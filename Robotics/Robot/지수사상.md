# 지수사상

> 상위: [[선형대수및기하학]]  
> 관련: [[리군론]], [[특수직교군]], [[특수유클리드군]]

리대수에서 리군으로의 근본적인 변환인 지수사상(Exponential Map)입니다. 로봇의 무한소 운동을 유한 운동으로 연결하는 핵심 수학적 도구입니다.

## 🎯 지수사상의 정의

### 기본 개념
```
exp: 𝔤 → G (리대수 → 리군)

무한소 생성자 X ∈ 𝔤에서 
리군 원소 exp(X) ∈ G로의 매핑

물리적 의미: 순간속도 → 유한운동
```

### 행렬 지수함수
```
exp(A) = I + A + A²/2! + A³/3! + ... = Σ(k=0 to ∞) Aᵏ/k!

수렴성: 모든 유한 차원 행렬에 대해 수렴
유일성: 유일한 해석적 연속
```

### 기본 성질
```
1. exp(0) = I (항등원)
2. exp(-A) = exp(A)⁻¹
3. det(exp(A)) = exp(tr(A))
4. d/dt exp(tA)|_{t=0} = A
```

## 🔄 SO(3)에서의 지수사상

### 로드리게스 공식
```
exp(ω̂) = I + sin(θ)/θ ω̂ + (1-cos(θ))/θ² ω̂²

여기서:
ω̂ ∈ so(3): 반대칭 행렬
θ = ||ω||: 회전각도
ω ∈ ℝ³: 축-각도 벡터
```

### 기하학적 해석
```
exp(ω̂): ω 축 주위로 θ만큼 회전
- ω: 회전축 방향
- θ = ||ω||: 회전각도  
- 오른손 법칙 적용
```

### 특수 경우들
```
θ = 0: exp(ω̂) = I (회전 없음)
θ = π: exp(ω̂) = 2ωω^T/||ω||² - I (180° 회전)
θ → 0: exp(ω̂) ≈ I + ω̂ (1차 근사)
θ → 0: exp(ω̂) ≈ I + ω̂ + ω̂²/2 (2차 근사)
```

### 유도 과정
```
ω̂² = -||ω||²I + ωω^T
ω̂³ = -||ω||²ω̂
ω̂⁴ = ||ω||⁴I - ||ω||²ωω^T

급수 전개와 삼각함수 항등식:
cos(θ) = 1 - θ²/2! + θ⁴/4! - ...
sin(θ) = θ - θ³/3! + θ⁵/5! - ...
```

## 🎯 SE(3)에서의 지수사상

### 완전 공식
```
exp(ξ̂) = [exp(ω̂)  Vv]
         [0       1 ]

ξ̂ = [ω̂ v] ∈ se(3)
    [0  0]

V: 좌측 자코비안 (Left Jacobian)
```

### 좌측 자코비안
```
V = I + (1-cos(θ))/θ² ω̂ + (θ-sin(θ))/θ³ ω̂²

θ = ||ω||인 경우
```

### 특수 경우들
```
순수 평행이동 (ω = 0):
exp(ξ̂) = [I v]
         [0 1]

순수 회전 (v = 0):
exp(ξ̂) = [exp(ω̂) 0]
         [0       1]

작은 운동 (θ → 0):
V ≈ I + ω̂/2 + ω̂²/12
exp(ξ̂) ≈ I + ξ̂ + ξ̂²/2
```

## 🧮 계산 방법

### 직접 계산 (작은 각도)
```
θ < 0.1 rad인 경우:
sin(θ)/θ ≈ 1 - θ²/6 + θ⁴/120
(1-cos(θ))/θ² ≈ 1/2 - θ²/24 + θ⁴/720

더 높은 정확도를 위한 테일러 전개 사용
```

### 수치적 방법
```
1. 행렬 지수함수 라이브러리 사용
2. 스케일링과 제곱 방법
3. 파데 근사 (Padé Approximation)
4. 케일리 변환 (작은 각도)
```

### 효율적 구현
```
로드리게스 공식 직접 구현:
- 삼각함수 1회 계산
- 행렬 곱셈 최소화
- 특이점 (θ = 0) 처리
```

## 🤖 로봇공학 응용

### 1. 관절 공간 적분
```
일정한 관절속도 q̇에서:
q(t) = q₀ + q̇t (선형 적분)

스크류 운동 모델:
T(t) = T₀ exp(ξ̂t) (지수 적분)
더 정확한 강체 운동 표현
```

### 2. 속도 명령 적분
```
로봇 제어기에서:
트위스트 명령 ξ_cmd
시간 간격 Δt
포즈 업데이트: T_new = T_old exp(ξ_cmd Δt)
```

### 3. 경로 계획
```
직선 경로 (스크류 운동):
T(s) = T_start exp(s ξ̂)
s ∈ [0,1]: 경로 매개변수
ξ̂ = log(T_start⁻¹ T_end): 경로 트위스트
```

### 4. 오차 보정
```
포즈 오차: T_error = T_target T_current⁻¹
오차 트위스트: ξ_error = log(T_error)
제어 입력: u = Kξ_error
```

## 📊 로그 사상 (역변환)

### SO(3)에서의 로그 사상
```
log: SO(3) → so(3)
ω̂ = log(R)

θ = arccos((tr(R) - 1)/2)
if θ ≠ 0, π:
    ω̂ = θ/(2sin(θ)) (R - R^T)
```

### 특이점 처리
```
θ = 0: ω̂ = 0 (회전 없음)
θ = π: 특별한 공식 필요
    가장 큰 대각성분을 가진 축 찾기
    √((R_ii + 1)/2) 계산
```

### SE(3)에서의 로그 사상
```
log: SE(3) → se(3)
ξ̂ = log(T)

복잡한 공식이지만 역변환 가능
수치적으로 안정한 구현 필요
```

## 🎯 미분과 자코비안

### 지수의 미분
```
d/dt exp(f(t)X) = exp(f(t)X) · f'(t)X (교환가능한 경우)

일반적으로:
d/dt exp(X(t)) = exp(X(t)) dexp⁻¹_{X(t)}(Ẋ(t))
```

### 오른쪽 자코비안
```
Jr = d/dε exp(X + εδX)|_{ε=0}
SO(3): Jr = I - (1-cos(θ))/θ² ω̂ + (θ-sin(θ))/θ³ ω̂²
```

### 왼쪽 자코비안
```
Jl = d/dε exp(εδX + X)|_{ε=0}
SE(3)에서 V 행렬과 관련
```

## 🔧 실용적 고려사항

### 1. 수치적 안정성
```
θ ≈ 0 근처에서:
- 0/0 형태의 불정형
- 테일러 전개로 근사
- 임계값 설정 (예: 1e-8)

θ ≈ π 근처에서:
- 로그 사상의 특이점
- 다른 표현법 사용 고려
```

### 2. 주기성 처리
```
SO(3): θ ∈ (-π, π]로 정규화
SE(3): 회전 부분만 정규화
연속성 유지가 중요
```

### 3. 계산 효율성
```
미리 계산된 테이블 사용
근사식의 계산 범위 설정
특수 경우의 분기 처리
```

## 🚀 고급 주제

### 1. 베이커-캠벨-하우스도르프 공식
```
exp(X)exp(Y) = exp(Z)
Z = X + Y + ½[X,Y] + (1/12)([X,[X,Y]] + [Y,[Y,X]]) + ...

비교환 리군에서 중요
근사 계산에 활용
```

### 2. 아드조인트와의 관계
```
Ad_{exp(X)} = exp(ad_X)
지수 사상과 아드조인트 표현의 관계
```

### 3. 측지선과 최단 경로
```
T(t) = T₀ exp(tξ̂): 리만 측지선
SE(3)에서 두 점을 연결하는 최단 경로
경로 계획의 이론적 기초
```

## 🔧 구현 예제

### MATLAB
```matlab
function R = so3_exp(omega)
    theta = norm(omega);
    
    if theta < 1e-8
        % 작은 각도 근사
        R = eye(3) + skew(omega);
    else
        % 로드리게스 공식
        omega_hat = skew(omega);
        R = eye(3) + sin(theta)/theta * omega_hat + ...
            (1-cos(theta))/theta^2 * omega_hat^2;
    end
end

function omega = so3_log(R)
    theta = acos((trace(R) - 1)/2);
    
    if abs(theta) < 1e-8
        omega = [0; 0; 0];
    elseif abs(theta - pi) < 1e-8
        % θ = π 특이점 처리
        [~, idx] = max(diag(R));
        v = sqrt((R(idx,idx) + 1)/2);
        omega = theta * sign(R(idx,:)) * v;
    else
        omega_hat = theta/(2*sin(theta)) * (R - R');
        omega = [omega_hat(3,2); omega_hat(1,3); omega_hat(2,1)];
    end
end
```

### Python
```python
import numpy as np

def rodrigues(omega):
    """로드리게스 공식으로 so(3) → SO(3)"""
    theta = np.linalg.norm(omega)
    
    if theta < 1e-8:
        return np.eye(3) + skew(omega)
    
    omega_hat = skew(omega)
    return (np.eye(3) + 
            np.sin(theta)/theta * omega_hat + 
            (1-np.cos(theta))/theta**2 * omega_hat @ omega_hat)

def se3_exp(xi):
    """se(3) → SE(3) 지수 사상"""
    rho = xi[:3]
    omega = xi[3:]
    theta = np.linalg.norm(omega)
    
    R = rodrigues(omega)
    
    if theta < 1e-8:
        V = np.eye(3)
    else:
        omega_hat = skew(omega)
        V = (np.eye(3) + 
             (1-np.cos(theta))/theta**2 * omega_hat +
             (theta-np.sin(theta))/theta**3 * omega_hat @ omega_hat)
    
    T = np.eye(4)
    T[:3, :3] = R
    T[:3, 3] = V @ rho
    return T

def matrix_exp_series(X, terms=20):
    """급수 전개로 행렬 지수함수 계산"""
    result = np.eye(X.shape[0])
    X_power = np.eye(X.shape[0])
    factorial = 1
    
    for k in range(1, terms+1):
        factorial *= k
        X_power = X_power @ X
        result += X_power / factorial
    
    return result
```

## 🎯 학습 전략

1. **수학적 기초** (3-4주)
   - 행렬 지수함수의 정의와 성질
   - 로드리게스 공식 유도

2. **로봇 응용** (3-4주)
   - 운동학과 동역학에서의 활용
   - 경로 계획과 제어

3. **수치 구현** (2-3주)
   - 안정적인 계산 방법
   - 특이점 처리

4. **고급 주제** (선택, 3-4주)
   - BCH 공식과 고차 근사
   - 리만 기하학과의 연결

---
*참고: Modern Robotics (Lynch & Park), Matrix Computations (Golub & Van Loan), Lie Groups and Lie Algebras for Robotics (Selig)*