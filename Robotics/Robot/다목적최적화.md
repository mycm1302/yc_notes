# 다목적최적화

> 상위: [[최적화설계]]

여러 개의 상충하는 목적함수를 동시에 최적화하는 설계 방법입니다. 실제 공학 문제는 대부분 여러 목표를 동시에 만족해야 하므로 매우 중요한 기법입니다.

## 🎯 기본 개념

### 왜 다목적최적화인가?

**실제 설계 상황:**
- 자동차: 연비 ↑ vs 성능 ↑ vs 안전성 ↑ vs 비용 ↓
- 로봇: 정밀도 ↑ vs 속도 ↑ vs 에너지효율 ↑ vs 무게 ↓
- 건물: 비용 ↓ vs 내구성 ↑ vs 에너지효율 ↑ vs 미관 ↑

**단일 목적 최적화의 한계:**
```
예시: 자동차 엔진 설계
- 연비만 최적화 → 출력 부족
- 출력만 최적화 → 연비 나쁨
- 실제 필요: 적절한 균형점
```

### 다목적 문제의 특성

**상충관계 (Trade-off):**
- 한 목표 개선 시 다른 목표 악화
- 완벽한 해는 존재하지 않음
- **파레토 최적해 집합** 존재

**수학적 정의:**
```
최소화: F(x) = [f₁(x), f₂(x), ..., fₘ(x)]ᵀ
제약조건: gⱼ(x) ≤ 0, j = 1,...,p
         hₖ(x) = 0, k = 1,...,q
         x ∈ X
```

여기서:
- m: 목적함수 개수 (≥2)
- F(x): 목적함수 벡터
- x: 설계변수 벡터

---

## 📊 파레토 최적성 이론

### 지배관계 (Dominance)

**정의:** 해 x₁이 해 x₂를 지배한다 (x₁ ≺ x₂)
⟺ 모든 목적함수에서 x₁ ≥ x₂이고, 적어도 하나에서 x₁ > x₂

**예시: 2목적 최소화 문제**
```
해 A: f₁=3, f₂=5
해 B: f₁=4, f₂=6  → A가 B를 지배 (A ≺ B)
해 C: f₁=2, f₂=7  → A와 C는 비지배 관계
```

### 파레토 최적해

**파레토 최적해:** 다른 해에 의해 지배되지 않는 해

**파레토 프론티어:** 모든 파레토 최적해들이 목적함수 공간에서 형성하는 경계

**시각적 이해 (2목적 문제):**
```
f₂ ↑
 │  ○ ← 지배되는 해
 │    ● ← 파레토 최적해
 │     ●
 │      ●
 │       ● ← 파레토 프론티어
 │        ●
 └──────────→ f₁
```

### 이상해와 나디르해

**이상해 (Ideal Point):** 각 목적함수의 개별 최적값
```
z* = [f₁*, f₂*, ..., fₘ*]ᵀ
여기서 fᵢ* = min fᵢ(x)
```

**나디르해 (Nadir Point):** 파레토 프론티어에서 각 목적함수의 최악값
- 실제로는 계산이 어려움
- 근사적으로 추정

---

## 🔧 해법 기법

### 1. 스칼라화 방법 (Scalarization)

#### 가중합 방법 (Weighted Sum)

**수식:**
```
최소화: ∑ wᵢ fᵢ(x)
제약조건: ∑ wᵢ = 1, wᵢ ≥ 0
```

**장점:**
- 구현 간단
- 기존 단일목적 알고리즘 사용 가능

**단점:**
- 가중치 설정 어려움
- 비볼록 구간의 해 찾지 못함
- 가중치와 선호도 관계 불명확

**실습 예제:**
```matlab
% 2목적 문제: f1 최소화, f2 최소화
w1 = 0.3; w2 = 0.7;
objective = w1*f1 + w2*f2;

% 가중치 변화에 따른 해 추적
weights = [0.1:0.1:0.9];
for i = 1:length(weights)
    w1 = weights(i); w2 = 1 - w1;
    % 최적화 실행
    % 결과 저장
end
```

#### ε-제약 방법 (ε-Constraint)

**수식:**
```
최소화: f₁(x)
제약조건: fᵢ(x) ≤ εᵢ, i = 2,...,m
          원래 제약조건
```

**장점:**
- 비볼록 영역의 해도 찾을 수 있음
- ε 값이 직관적

**단점:**
- ε 값 설정 어려움
- 실행불가능한 문제 발생 가능

**구현 예시:**
```matlab
% f1 최소화, f2 ≤ ε2로 제약
epsilon_values = [10, 15, 20, 25, 30];
pareto_solutions = [];

for eps = epsilon_values
    % 제약조건: f2(x) <= eps 추가
    % 최적화 실행
    if feasible
        pareto_solutions = [pareto_solutions; solution];
    end
end
```

#### 목표계획법 (Goal Programming)

**아이디어:** 각 목적함수에 목표값 설정, 편차 최소화

**수식:**
```
최소화: ∑ wᵢ⁺ dᵢ⁺ + ∑ wᵢ⁻ dᵢ⁻
제약조건: fᵢ(x) + dᵢ⁻ - dᵢ⁺ = gᵢ
          dᵢ⁺, dᵢ⁻ ≥ 0
```

여기서:
- gᵢ: i번째 목적함수의 목표값
- dᵢ⁺, dᵢ⁻: 양의/음의 편차
- wᵢ⁺, wᵢ⁻: 편차 가중치

### 2. 진화 알고리즘 (Evolutionary Algorithms)

#### NSGA-II (Non-dominated Sorting Genetic Algorithm II)

**핵심 아이디어:**
1. **비지배 정렬**: 해를 지배 레벨별로 분류
2. **밀집도 거리**: 같은 레벨 내에서 다양성 확보
3. **엘리트 보존**: 우수한 해 유지

**알고리즘 단계:**

**1단계: 비지배 정렬**
```
F₁ = {모든 비지배해}  ← 1차 프론트
F₂ = {F₁ 제거 후 비지배해}  ← 2차 프론트
⋮
```

**2단계: 밀집도 거리 계산**
```
거리 = ∑ |fᵢ(해k+1) - fᵢ(해k-1)| / (fᵢmax - fᵢmin)
```

**3단계: 선택**
- 낮은 프론트 우선
- 같은 프론트 내에서 높은 밀집도 거리 우선

**구현 골격:**
```matlab
function pareto_front = nsga2(pop_size, generations)
    % 초기 개체군 생성
    population = initialize_population(pop_size);
    
    for gen = 1:generations
        % 자식 생성 (교배, 돌연변이)
        offspring = generate_offspring(population);
        
        % 부모+자식 결합
        combined = [population; offspring];
        
        % 비지배 정렬
        fronts = non_dominated_sort(combined);
        
        % 다음 세대 선택
        population = select_population(fronts, pop_size);
    end
    
    pareto_front = fronts{1};  % 1차 프론트
end
```

#### SPEA2 (Strength Pareto Evolutionary Algorithm)

**특징:**
- **강도(Strength) 계산**: 각 해가 지배하는 해의 수
- **적합도(Fitness)**: 강도와 밀도 정보 결합
- **아카이브**: 우수한 해 별도 보관

**강도 계산:**
```
S(i) = |{j | i ≺ j}|  ← i가 지배하는 해의 수
R(i) = ∑ S(j)  ← i를 지배하는 해들의 강도 합
```

#### MOEA/D (Multi-Objective EA based on Decomposition)

**핵심 아이디어:** 다목적 문제를 여러 단일목적 문제로 분해

**분해 방법:**
1. **Tchebycheff 방법:**
   ```
   최소화: max{λᵢ|fᵢ(x) - zᵢ*|}
   ```

2. **가중합 방법:**
   ```
   최소화: ∑ λᵢfᵢ(x)
   ```

3. **PBI (Penalty-based Boundary Intersection):**
   ```
   최소화: d₁ + θd₂
   ```

---

## 🛠️ 의사결정 지원 기법

### TOPSIS (Technique for Order Preference by Similarity to Ideal Solution)

**단계:**
1. **정규화**: 목적함수 값을 0-1로 스케일링
2. **가중치 적용**: 중요도 반영
3. **이상해/반이상해 계산**
4. **거리 계산**: 각 해와 이상해/반이상해 간 거리
5. **순위 결정**: 상대적 근접도 계산

**수식:**
```
상대적 근접도 = d⁻/(d⁺ + d⁻)
여기서 d⁺: 이상해와의 거리, d⁻: 반이상해와의 거리
```

**구현 예시:**
```matlab
function ranking = topsis(solutions, weights, ideal, anti_ideal)
    % 1. 정규화
    normalized = normalize_matrix(solutions);
    
    % 2. 가중치 적용
    weighted = normalized .* weights;
    
    % 3. 거리 계산
    d_positive = sqrt(sum((weighted - ideal).^2, 2));
    d_negative = sqrt(sum((weighted - anti_ideal).^2, 2));
    
    % 4. 상대적 근접도
    closeness = d_negative ./ (d_positive + d_negative);
    
    % 5. 순위 결정
    [~, ranking] = sort(closeness, 'descend');
end
```

### AHP (Analytic Hierarchy Process)

**계층적 구조:**
```
최종 목표
├── 기준 1
│   ├── 대안 A
│   ├── 대안 B
│   └── 대안 C
├── 기준 2
└── 기준 3
```

**쌍비교 행렬:**
```
     A    B    C
A [  1   3   5  ]  ← A가 B보다 3배, C보다 5배 중요
B [ 1/3  1   2  ]
C [ 1/5 1/2  1  ]
```

**일관성 검증:**
- CI (Consistency Index) = (λmax - n)/(n-1)
- CR (Consistency Ratio) = CI/RI
- CR < 0.1이면 일관성 확보

---

## 📈 실제 응용 사례

### 사례 1: 자동차 차체 설계

**목적함수:**
1. 질량 최소화 (경량화)
2. 충돌 안전성 최대화
3. 진동 특성 최적화 (NVH)
4. 제조 비용 최소화

**제약조건:**
- 강성 요구사항
- 제조 가능성
- 법규 준수

**해법:**
- NSGA-II로 파레토 해집합 생성
- TOPSIS로 최종 설계안 선택

**결과 분석:**
```
Trade-off 관계:
- 질량 ↓ ⟺ 안전성 ↓
- 질량 ↓ ⟺ 비용 ↑ (고강도강 사용)
- 안전성 ↑ ⟺ 비용 ↑
```

### 사례 2: 로봇 매니퓰레이터 설계

**목적함수:**
1. 작업공간 최대화
2. 조작성 최대화 (컨디션 넘버 최소화)
3. 질량 최소화
4. 에너지 효율 최대화

**설계변수:**
- 링크 길이
- 질량 분포
- 액추에이터 사양

**특징:**
- 고차원 설계공간 (10+ 변수)
- 복잡한 제약조건 (특이점 회피)
- 동적 성능 고려

### 사례 3: 건물 에너지 시스템

**목적함수:**
1. 초기 투자비 최소화
2. 운영비 최소화  
3. CO₂ 배출 최소화
4. 에너지 자립도 최대화

**기술 옵션:**
- 태양광 패널
- 지열 히트펌프
- 축열 시스템
- 단열재

**특징:**
- 장기간 성능 평가 (20-30년)
- 불확실성 (에너지 가격, 기후)
- 이산적 선택 (장비 종류)

---

## 💻 소프트웨어 구현

### MATLAB 구현

**기본 NSGA-II 구현:**
```matlab
% 주요 함수들
function fronts = non_dominated_sort(population)
% 비지배 정렬 구현

function distances = crowding_distance(front, objectives)
% 밀집도 거리 계산

function new_pop = tournament_selection(population, tournament_size)
% 토너먼트 선택

function offspring = genetic_operators(parents, pc, pm)
% 교배 및 돌연변이
```

**사용 예제:**
```matlab
% 문제 정의
problem.nvars = 2;  % 변수 개수
problem.nobjs = 2;  % 목적함수 개수
problem.bounds = [-5, 5; -5, 5];  % 변수 범위
problem.evaluate = @zdt1_function;  % 평가 함수

% 알고리즘 실행
options.popsize = 100;
options.generations = 500;
result = nsga2(problem, options);

% 결과 시각화
plot(result.pareto_front(:,1), result.pareto_front(:,2), 'ro');
xlabel('f1'); ylabel('f2'); title('Pareto Front');
```

### Python 구현 (DEAP 라이브러리)

```python
import numpy as np
from deap import algorithms, base, creator, tools

# 문제 정의
creator.create("FitnessMin", base.Fitness, weights=(-1.0, -1.0))
creator.create("Individual", list, fitness=creator.FitnessMin)

# 도구 설정
toolbox = base.Toolbox()
toolbox.register("attr_float", np.random.random)
toolbox.register("individual", tools.initRepeat, creator.Individual, 
                toolbox.attr_float, n=2)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)

# 평가 함수
def evaluate(individual):
    x, y = individual
    f1 = x**2 + y**2
    f2 = (x-1)**2 + y**2
    return f1, f2

toolbox.register("evaluate", evaluate)
toolbox.register("mate", tools.cxBlend, alpha=0.5)
toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=0.2, indpb=0.1)
toolbox.register("select", tools.selNSGA2)

# NSGA-II 실행
population = toolbox.population(n=100)
algorithms.eaMuPlusLambda(population, toolbox, mu=100, lambda_=100, 
                         cxpb=0.9, mutpb=0.1, ngen=250)
```

---

## 🎓 학습 가이드

### 초급 과정 (2-3개월)

**1단계: 이론 기초**
- 파레토 최적성 개념 이해
- 지배관계와 비지배해 개념
- 간단한 2목적 문제 손계산

**실습 1: 수학적 예제**
```
f1(x) = x²
f2(x) = (x-2)²
x ∈ [0, 2]

해석적으로 파레토 프론티어 구하기
```

**2단계: 기본 알고리즘**
- 가중합 방법 구현
- ε-제약 방법 구현
- 결과 시각화

**실습 2: MATLAB 구현**
```matlab
% 2목적 함수 최적화
function [f1, f2] = objectives(x)
    f1 = x(1)^2 + x(2)^2;
    f2 = (x(1)-1)^2 + (x(2)-1)^2;
end

% 가중합 방법으로 파레토 해 생성
weights = 0:0.1:1;
pareto_set = [];
for w = weights
    % fmincon 사용하여 최적화
    % 결과 저장
end
```

### 중급 과정 (4-6개월)

**3단계: 진화 알고리즘**
- NSGA-II 원리 이해
- 비지배 정렬 알고리즘 구현
- 밀집도 거리 계산

**실습 3: NSGA-II 구현**
- 표준 테스트 함수 (ZDT, DTLZ) 사용
- 성능 지표 계산 (IGD, HV)
- 매개변수 튜닝

**4단계: 의사결정**
- TOPSIS 방법 학습
- AHP 구현
- 실제 문제 적용

### 고급 과정 (6개월+)

**5단계: 고급 주제**
- 다목적 위상최적화
- 다목적 강건설계
- 실시간 다목적 최적화

**6단계: 실무 프로젝트**
- 실제 공학 문제 해결
- 소프트웨어 개발
- 연구 논문 작성

---

## 🔧 성능 평가 지표

### 수렴성 지표

**IGD (Inverted Generational Distance):**
```
IGD = (1/|P*|) ∑ min d(v, u)
```
여기서 P*: 참 파레토 프론티어, u: 얻은 해

**HV (Hypervolume):**
```
HV = 레베스크 측도(∪ [f₁(xᵢ), r₁] × ... × [fₘ(xᵢ), rₘ])
```
여기서 r: 참조점

### 다양성 지표

**Spacing:**
```
SP = √(1/(n-1) ∑(d̄ - dᵢ)²)
```
여기서 dᵢ: i번째 해와 가장 가까운 해와의 거리

**Spread:**
```
Δ = (df + dl + ∑|dᵢ - d̄|)/(df + dl + (n-1)d̄)
```

---

**참고문헌:**
- Deb, K. (2001). *Multi-Objective Optimization using Evolutionary Algorithms*. Wiley.
- Miettinen, K. (1999). *Nonlinear Multiobjective Optimization*. Kluwer Academic Publishers.
- Coello, C.A., Lamont, G.B. & Van Veldhuizen, D.A. (2007). *Evolutionary Algorithms for Solving Multi-Objective Problems*. Springer.
- Deb, K. et al. (2002). A fast and elitist multiobjective genetic algorithm: NSGA-II. *IEEE Trans. Evolutionary Computation*, 6(2), 182-197.