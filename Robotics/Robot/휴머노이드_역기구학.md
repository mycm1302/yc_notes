# 역기구학 (Inverse Kinematics)

> 상위: [[휴머노이드 연구기술]]

## 정의

역기구학(Inverse Kinematics, IK)은 로봇의 엔드 이펙터(말단 장치)의 원하는 위치와 방향을 입력으로 하여, 각 관절이 어떤 각도로 움직여야 하는지를 계산하는 기법입니다.

## 수학적 정의

### 순기구학과의 관계
```
순기구학 (FK): q → x
x = f(q)

역기구학 (IK): x → q  
q = f⁻¹(x)

여기서:
- q: 관절 각도 벡터 (n차원)
- x: 엔드 이펙터 위치/방향 (m차원)
- f: 순기구학 함수
```

### 문제의 복잡성
- **비선형**: f(q)가 삼각함수의 복합함수
- **다중해**: 하나의 x에 대해 여러 q 존재 가능
- **해가 없음**: 작업공간 밖의 목표점
- **특이점**: 자코비안 행렬식이 0인 지점

## 해법 분류

### 1. 해석적 방법 (Analytical Methods)

#### 기하학적 접근
```python
# 2링크 로봇팔 예시
def inverse_kinematics_2link(x, y, L1, L2):
    """
    2링크 로봇팔의 해석적 역기구학
    """
    # 목표점까지의 거리
    r = np.sqrt(x**2 + y**2)
    
    # 코사인 법칙 적용
    cos_theta2 = (r**2 - L1**2 - L2**2) / (2 * L1 * L2)
    
    # 해가 존재하는지 확인
    if abs(cos_theta2) > 1:
        return None  # 해가 없음
    
    # 두 가지 해 (elbow up/down)
    theta2_1 = np.arccos(cos_theta2)
    theta2_2 = -np.arccos(cos_theta2)
    
    # theta1 계산
    alpha = np.arctan2(y, x)
    beta = np.arccos((L1**2 + r**2 - L2**2) / (2 * L1 * r))
    
    theta1_1 = alpha - beta
    theta1_2 = alpha + beta
    
    return [(theta1_1, theta2_1), (theta1_2, theta2_2)]
```

#### 대수적 접근
- **연립방정식**: 순기구학 방정식을 q에 대해 해결
- **치환법**: 삼각함수 치환으로 다항식 변환
- **결과식**: 여러 변수를 하나씩 소거

#### 장단점
- **장점**: 정확한 해, 빠른 계산, 모든 해 탐색 가능
- **단점**: 복잡한 로봇에 적용 어려움, 6 DOF 이상에서 매우 복잡

### 2. 수치적 방법 (Numerical Methods)

#### 뉴턴-랩슨 방법
```python
def newton_raphson_ik(target_pose, initial_guess, max_iterations=50):
    """
    뉴턴-랩슨 방법을 이용한 역기구학
    """
    q = initial_guess.copy()
    
    for i in range(max_iterations):
        # 현재 자세에서의 순기구학
        current_pose = forward_kinematics(q)
        
        # 오차 계산
        error = target_pose - current_pose
        
        # 수렴 검사
        if np.linalg.norm(error) < tolerance:
            return q, True
        
        # 자코비안 계산
        J = compute_jacobian(q)
        
        # 관절 각도 업데이트
        try:
            delta_q = np.linalg.solve(J, error)
            q += alpha * delta_q  # alpha: 스텝 크기
        except np.linalg.LinAlgError:
            return q, False  # 특이점에서 실패
    
    return q, False  # 수렴 실패
```

#### 경사하강법
```python
def gradient_descent_ik(target_pose, initial_guess):
    """
    경사하강법을 이용한 역기구학
    """
    q = initial_guess.copy()
    learning_rate = 0.01
    
    for iteration in range(max_iterations):
        # 오차 함수: E = 0.5 * ||f(q) - x_target||²
        current_pose = forward_kinematics(q)
        error = target_pose - current_pose
        
        if np.linalg.norm(error) < tolerance:
            return q, True
        
        # 그래디언트 계산: ∇E = J^T * error
        J = compute_jacobian(q)
        gradient = J.T @ error
        
        # 관절 각도 업데이트
        q += learning_rate * gradient
    
    return q, False
```

#### 의사역행렬 (Pseudoinverse)
```python
def pseudoinverse_ik(target_pose, current_q):
    """
    의사역행렬을 이용한 역기구학 (한 스텝)
    """
    # 자코비안 계산
    J = compute_jacobian(current_q)
    
    # 의사역행렬 계산
    if J.shape[0] == J.shape[1]:  # 정사각 행렬
        try:
            J_inv = np.linalg.inv(J)
        except np.linalg.LinAlgError:
            # 특이점에서 감쇠 최소제곱법
            lambda_reg = 0.01
            J_inv = J.T @ np.linalg.inv(J @ J.T + lambda_reg * np.eye(J.shape[0]))
    else:  # 직사각 행렬
        J_inv = np.linalg.pinv(J)
    
    # 현재 위치와 목표 위치의 차이
    current_pose = forward_kinematics(current_q)
    error = target_pose - current_pose
    
    # 관절 각도 변화량
    delta_q = J_inv @ error
    
    return current_q + delta_q
```

### 3. 최적화 기반 방법

#### 목적함수 정의
```python
def ik_objective_function(q, target_pose, weights):
    """
    역기구학을 위한 목적함수
    """
    # 주 목적: 위치/방향 오차 최소화
    current_pose = forward_kinematics(q)
    pose_error = np.linalg.norm(target_pose - current_pose)
    
    # 부차 목적들
    joint_limit_penalty = compute_joint_limit_penalty(q)
    smoothness_penalty = compute_smoothness_penalty(q)
    singularity_penalty = compute_singularity_penalty(q)
    
    total_cost = (weights['pose'] * pose_error +
                  weights['limits'] * joint_limit_penalty +
                  weights['smooth'] * smoothness_penalty +
                  weights['singular'] * singularity_penalty)
    
    return total_cost
```

#### 제약 최적화
```python
from scipy.optimize import minimize

def constrained_ik(target_pose, initial_guess):
    """
    제약 조건이 있는 역기구학 최적화
    """
    # 목적함수
    def objective(q):
        current_pose = forward_kinematics(q)
        return np.linalg.norm(target_pose - current_pose)**2
    
    # 관절 한계 제약
    bounds = [(q_min[i], q_max[i]) for i in range(len(initial_guess))]
    
    # 충돌 회피 제약
    def collision_constraint(q):
        return minimum_distance_to_obstacle(q) - safety_margin
    
    constraints = [{'type': 'ineq', 'fun': collision_constraint}]
    
    # 최적화 실행
    result = minimize(objective, initial_guess, 
                     bounds=bounds, constraints=constraints,
                     method='SLSQP')
    
    return result.x, result.success
```

## 특수 상황 처리

### 1. 중복 자유도 (Redundancy)

#### 문제 정의
- **정의**: 태스크 차원보다 관절 수가 많은 경우
- **예시**: 7-DOF 팔로 6-DOF 위치/방향 제어
- **결과**: 무한개의 해 존재

#### 해결 방법

##### Null Space 투영
```python
def redundant_ik_nullspace(target_pose, current_q, secondary_objective):
    """
    널 공간을 이용한 중복 자유도 역기구학
    """
    J = compute_jacobian(current_q)
    
    # 주 태스크: 위치/방향 제어
    current_pose = forward_kinematics(current_q)
    error = target_pose - current_pose
    J_pinv = np.linalg.pinv(J)
    
    # 주 태스크 해
    dq_primary = J_pinv @ error
    
    # 널 공간 투영자
    N = np.eye(len(current_q)) - J_pinv @ J
    
    # 부차 태스크 (예: 관절 중점 유지)
    dq_secondary = secondary_objective_gradient(current_q)
    
    # 최종 해
    dq_total = dq_primary + N @ dq_secondary
    
    return current_q + dq_total
```

##### 가중 의사역행렬
```python
def weighted_pseudoinverse_ik(target_pose, current_q, W):
    """
    가중 의사역행렬을 이용한 역기구학
    """
    J = compute_jacobian(current_q)
    
    # 가중 의사역행렬
    J_weighted_pinv = np.linalg.inv(W) @ J.T @ np.linalg.inv(J @ np.linalg.inv(W) @ J.T)
    
    current_pose = forward_kinematics(current_q)
    error = target_pose - current_pose
    
    delta_q = J_weighted_pinv @ error
    
    return current_q + delta_q
```

### 2. 특이점 (Singularity) 처리

#### 특이점 감지
```python
def detect_singularity(q, threshold=1e-3):
    """
    특이점 감지
    """
    J = compute_jacobian(q)
    
    # 조건수 확인
    condition_number = np.linalg.cond(J)
    
    # 행렬식 확인 (정사각 행렬인 경우)
    if J.shape[0] == J.shape[1]:
        det_J = np.linalg.det(J)
        return abs(det_J) < threshold
    
    # 특이값 확인
    singular_values = np.linalg.svd(J, compute_uv=False)
    min_singular_value = np.min(singular_values)
    
    return min_singular_value < threshold
```

#### 감쇠 최소제곱법 (Damped Least Squares)
```python
def damped_least_squares_ik(target_pose, current_q, lambda_damping=0.01):
    """
    감쇠 최소제곱법을 이용한 특이점 회피
    """
    J = compute_jacobian(current_q)
    
    # 감쇠된 의사역행렬
    J_damped_pinv = J.T @ np.linalg.inv(J @ J.T + lambda_damping**2 * np.eye(J.shape[0]))
    
    current_pose = forward_kinematics(current_q)
    error = target_pose - current_pose
    
    delta_q = J_damped_pinv @ error
    
    return current_q + delta_q
```

#### 특이점 회피
```python
def singularity_avoidance_ik(target_pose, current_q):
    """
    특이점 회피를 포함한 역기구학
    """
    J = compute_jacobian(current_q)
    
    # 특이점 근접도 계산
    manipulability = np.sqrt(np.linalg.det(J @ J.T))
    
    if manipulability < singularity_threshold:
        # 특이점 회피 방향 계산
        avoidance_direction = compute_avoidance_direction(current_q)
        
        # 주 태스크와 회피 태스크 결합
        current_pose = forward_kinematics(current_q)
        error = target_pose - current_pose
        
        # 가중 결합
        weight_task = 1.0
        weight_avoidance = 1.0 - manipulability / singularity_threshold
        
        combined_objective = (weight_task * J.T @ error +
                             weight_avoidance * avoidance_direction)
        
        return current_q + alpha * combined_objective
    else:
        # 일반적인 역기구학
        return pseudoinverse_ik(target_pose, current_q)
```

### 3. 작업공간 제한

#### 도달 가능성 검사
```python
def check_reachability(target_pose, robot_params):
    """
    목표 위치가 작업공간 내에 있는지 확인
    """
    # 단순한 구형 작업공간 검사
    max_reach = sum(robot_params['link_lengths'])
    distance_to_target = np.linalg.norm(target_pose[:3])
    
    if distance_to_target > max_reach:
        return False, "Target too far"
    
    # 최소 도달 거리 검사
    min_reach = abs(robot_params['link_lengths'][0] - 
                   sum(robot_params['link_lengths'][1:]))
    
    if distance_to_target < min_reach:
        return False, "Target too close"
    
    # 각도 제한 검사
    # ... 추가 검사
    
    return True, "Reachable"
```

#### 최근접점 투영
```python
def project_to_workspace(target_pose, robot_params):
    """
    작업공간 밖의 목표를 작업공간 경계로 투영
    """
    max_reach = sum(robot_params['link_lengths'])
    distance = np.linalg.norm(target_pose[:3])
    
    if distance > max_reach:
        # 최대 도달 거리로 투영
        direction = target_pose[:3] / distance
        projected_position = direction * max_reach
        
        # 방향은 유지
        projected_pose = target_pose.copy()
        projected_pose[:3] = projected_position
        
        return projected_pose
    
    return target_pose
```

## 실시간 역기구학

### 1. 점진적 해법

#### 속도 기반 IK
```python
def velocity_based_ik(target_velocity, current_q, dt):
    """
    속도 기반 실시간 역기구학
    """
    J = compute_jacobian(current_q)
    J_pinv = np.linalg.pinv(J)
    
    # 관절 속도 계산
    joint_velocity = J_pinv @ target_velocity
    
    # 관절 위치 업데이트
    new_q = current_q + joint_velocity * dt
    
    # 관절 한계 적용
    new_q = np.clip(new_q, joint_limits_min, joint_limits_max)
    
    return new_q
```

#### 궤적 추종
```python
def trajectory_following_ik(trajectory, initial_q, dt):
    """
    궤적 추종을 위한 연속적 역기구학
    """
    q_trajectory = [initial_q]
    current_q = initial_q.copy()
    
    for i in range(1, len(trajectory)):
        target_pose = trajectory[i]
        
        # 한 스텝 역기구학
        next_q = one_step_ik(target_pose, current_q, dt)
        
        # 부드러운 변화를 위한 필터링
        max_joint_velocity = 1.0  # rad/s
        max_change = max_joint_velocity * dt
        
        delta_q = next_q - current_q
        delta_q = np.clip(delta_q, -max_change, max_change)
        
        current_q = current_q + delta_q
        q_trajectory.append(current_q.copy())
    
    return q_trajectory
```

### 2. 실시간 최적화

#### Model Predictive Control
```python
def mpc_based_ik(trajectory_segment, current_q, horizon=10):
    """
    MPC를 이용한 예측적 역기구학
    """
    def objective(q_sequence):
        cost = 0
        q = current_q.copy()
        
        for i, target_pose in enumerate(trajectory_segment[:horizon]):
            # 위치 오차
            current_pose = forward_kinematics(q)
            pose_error = np.linalg.norm(target_pose - current_pose)
            cost += pose_error**2
            
            # 관절 변화 평활화
            if i > 0:
                smoothness = np.linalg.norm(q - q_prev)**2
                cost += 0.1 * smoothness
            
            q_prev = q.copy()
            if i < len(q_sequence) - 1:
                q = q_sequence[i+1]
        
        return cost
    
    # 초기 추정: 선형 보간
    q_init = generate_initial_trajectory(current_q, trajectory_segment, horizon)
    
    # 최적화
    result = minimize(objective, q_init.flatten(), method='L-BFGS-B')
    
    return result.x.reshape(-1, len(current_q))
```

## 휴머노이드 특수 고려사항

### 1. 전신 역기구학

#### 계층적 접근
```python
def whole_body_ik(tasks, current_q, priorities):
    """
    우선순위 기반 전신 역기구학
    """
    q = current_q.copy()
    
    # 우선순위 순으로 태스크 처리
    for priority_level in sorted(priorities.keys()):
        task_indices = priorities[priority_level]
        
        # 현재 우선순위 태스크들
        current_tasks = [tasks[i] for i in task_indices]
        
        # 복합 자코비안 구성
        J_combined = []
        error_combined = []
        
        for task in current_tasks:
            J_task = compute_task_jacobian(q, task)
            error_task = compute_task_error(q, task)
            
            J_combined.append(J_task)
            error_combined.append(error_task)
        
        J_combined = np.vstack(J_combined)
        error_combined = np.concatenate(error_combined)
        
        # 이전 우선순위 태스크의 널 공간에서 해결
        if priority_level > 0:
            N = compute_null_space_projector(q, higher_priority_tasks)
            J_projected = J_combined @ N
            delta_q = np.linalg.pinv(J_projected) @ error_combined
            delta_q = N @ delta_q
        else:
            delta_q = np.linalg.pinv(J_combined) @ error_combined
        
        q += delta_q
    
    return q
```

### 2. 균형 제약 통합

#### ZMP 제약이 있는 IK
```python
def balance_constrained_ik(upper_body_target, current_q):
    """
    균형 제약을 고려한 상체 역기구학
    """
    def objective_with_balance(q):
        # 상체 위치 오차
        upper_pose = compute_upper_body_pose(q)
        pose_error = np.linalg.norm(upper_body_target - upper_pose)
        
        # ZMP 위치 계산
        zmp = compute_zmp(q)
        support_polygon = get_support_polygon(q)
        
        # ZMP 제약 위반 패널티
        zmp_penalty = compute_zmp_penalty(zmp, support_polygon)
        
        return pose_error**2 + 100 * zmp_penalty
    
    # 관절 한계 제약
    bounds = [(q_min[i], q_max[i]) for i in range(len(current_q))]
    
    result = minimize(objective_with_balance, current_q, bounds=bounds)
    return result.x
```

## 성능 평가

### 평가 지표
- **정확도**: 목표 위치와 실제 위치의 오차
- **반복성**: 같은 목표에 대한 해의 일관성
- **수렴성**: 해로 수렴하는 속도와 안정성
- **계산 시간**: 실시간 응용을 위한 처리 속도

### 벤치마크 테스트
```python
def evaluate_ik_performance(ik_solver, test_cases):
    """
    역기구학 솔버 성능 평가
    """
    results = {
        'position_errors': [],
        'orientation_errors': [],
        'computation_times': [],
        'success_rates': []
    }
    
    for target_pose in test_cases:
        start_time = time.time()
        
        # 역기구학 해결
        solution, success = ik_solver(target_pose)
        
        computation_time = time.time() - start_time
        results['computation_times'].append(computation_time)
        
        if success:
            # 정확도 검사
            achieved_pose = forward_kinematics(solution)
            pos_error = np.linalg.norm(target_pose[:3] - achieved_pose[:3])
            ori_error = compute_orientation_error(target_pose[3:], achieved_pose[3:])
            
            results['position_errors'].append(pos_error)
            results['orientation_errors'].append(ori_error)
            results['success_rates'].append(1)
        else:
            results['success_rates'].append(0)
    
    # 통계 계산
    stats = {
        'avg_pos_error': np.mean(results['position_errors']),
        'avg_ori_error': np.mean(results['orientation_errors']),
        'avg_computation_time': np.mean(results['computation_times']),
        'success_rate': np.mean(results['success_rates'])
    }
    
    return stats
```

## 고급 주제

### 1. 학습 기반 역기구학

#### 신경망 접근법
```python
import torch
import torch.nn as nn

class NeuralIK(nn.Module):
    def __init__(self, input_dim=6, output_dim=7, hidden_dims=[128, 128]):
        super().__init__()
        
        layers = []
        prev_dim = input_dim
        
        for hidden_dim in hidden_dims:
            layers.extend([
                nn.Linear(prev_dim, hidden_dim),
                nn.ReLU(),
                nn.Dropout(0.1)
            ])
            prev_dim = hidden_dim
        
        layers.append(nn.Linear(prev_dim, output_dim))
        self.network = nn.Sequential(*layers)
    
    def forward(self, target_pose):
        return self.network(target_pose)

def train_neural_ik(model, dataset, epochs=1000):
    """
    신경망 역기구학 모델 훈련
    """
    optimizer = torch.optim.Adam(model.parameters(), lr=0.001)
    criterion = nn.MSELoss()
    
    for epoch in range(epochs):
        total_loss = 0
        
        for target_pose, true_joints in dataset:
            optimizer.zero_grad()
            
            predicted_joints = model(target_pose)
            
            # 순기구학으로 검증
            predicted_pose = forward_kinematics_torch(predicted_joints)
            pose_loss = criterion(predicted_pose, target_pose)
            
            # 관절 제한 손실
            joint_limit_loss = compute_joint_limit_loss(predicted_joints)
            
            total_loss = pose_loss + 0.1 * joint_limit_loss
            total_loss.backward()
            optimizer.step()
            
            total_loss += total_loss.item()
        
        if epoch % 100 == 0:
            print(f"Epoch {epoch}, Loss: {total_loss/len(dataset)}")
```

### 2. 확률적 역기구학

#### 베이지안 접근법
```python
def bayesian_ik(target_pose, prior_distribution, noise_model):
    """
    베이지안 추론을 이용한 확률적 역기구학
    """
    # 사전 분포에서 샘플링
    samples = []
    likelihoods = []
    
    for _ in range(num_samples):
        q_sample = prior_distribution.sample()
        
        # 순기구학 계산
        predicted_pose = forward_kinematics(q_sample)
        
        # 우도 계산
        likelihood = noise_model.likelihood(predicted_pose, target_pose)
        
        samples.append(q_sample)
        likelihoods.append(likelihood)
    
    # 가중 평균으로 최종 해 계산
    weights = np.array(likelihoods)
    weights /= np.sum(weights)
    
    solution = np.average(samples, axis=0, weights=weights)
    uncertainty = np.var(samples, axis=0)
    
    return solution, uncertainty
```

## 연결 문서

### 관련 기술
- **상위**: [[휴머노이드 연구기술]]
- **기구학**: [[순기구학]], [[자코비안분석]]
- **최적화**: [[비선형최적화]], [[제약최적화]]

### 수학적 기반
- **선형대수**: [[의사역행렬]], [[특이값분해]]
- **미적분**: [[자코비안]], [[기울기방법]]
- **최적화**: [[뉴턴방법]], [[경사하강법]]

### 응용 분야
- **휴머노이드**: [[전신제어기법]], [[다중태스크제어]]
- **로봇팔**: [[매니퓰레이터]], [[궤적계획]]
- **제어**: [[실시간제어]], [[MPC]]

## 태그

#역기구학 #순기구학 #자코비안 #로봇기구학 #최적화 #특이점 #중복자유도 #전신제어 #실시간제어