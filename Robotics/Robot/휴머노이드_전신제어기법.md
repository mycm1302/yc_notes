# 전신 제어 기법 (Whole-body Control)

> 상위: [[휴머노이드 연구기술]]

## 정의

전신 제어 기법(Whole-body Control)은 휴머노이드 로봇의 모든 관절을 통합적으로 제어하여 여러 태스크를 동시에 수행하면서도 물리적 제약과 안정성을 보장하는 고급 제어 방법입니다.

## 기본 개념

### 다중 태스크 제어 문제
```
주어진 조건:
- n개의 관절 (q ∈ ℝⁿ)
- m개의 태스크 (각각 차원 kᵢ)
- 물리적 제약조건

목표:
모든 태스크를 동시에 만족하면서
물리적 실현 가능성 보장
```

### 수학적 표현
```
태스크 i의 목적: ẋᵢ = Jᵢ(q) × q̇ = ẋᵢᵈ

전체 문제:
minimize: Σᵢ wᵢ ||Jᵢ(q)q̇ - ẋᵢᵈ||²

subject to: 
- 관절 한계: qₘᵢₙ ≤ q ≤ qₘₐₓ
- 속도 한계: q̇ₘᵢₙ ≤ q̇ ≤ q̇ₘₐₓ  
- 동역학 제약: M(q)q̈ + C(q,q̇) + G(q) = τ
- 접촉 제약: 발이 지면에 고정
- 안정성 제약: ZMP ∈ Support Polygon
```

## 계층적 제어 (Hierarchical Control)

### 1. 우선순위 기반 제어

#### 기본 원리
```python
def hierarchical_whole_body_control(tasks, current_q, current_q_dot):
    """
    계층적 우선순위 기반 전신 제어
    """
    q_dot_command = np.zeros(len(current_q))
    N = np.eye(len(current_q))  # 널 공간 투영자
    
    # 우선순위 순서로 태스크 처리
    for priority_level in sorted(set(task.priority for task in tasks)):
        level_tasks = [task for task in tasks if task.priority == priority_level]
        
        # 현재 우선순위 레벨의 복합 자코비안 구성
        J_level = []
        error_level = []
        
        for task in level_tasks:
            J_task = compute_task_jacobian(current_q, task)
            error_task = compute_task_error(current_q, current_q_dot, task)
            
            J_level.append(J_task)
            error_level.append(error_task)
        
        if J_level:
            J_combined = np.vstack(J_level)
            error_combined = np.concatenate(error_level)
            
            # 널 공간으로 투영된 자코비안
            J_projected = J_combined @ N
            
            # 태스크 해결 (의사역행렬 사용)
            if np.linalg.matrix_rank(J_projected) > 0:
                J_proj_pinv = np.linalg.pinv(J_projected)
                q_dot_task = J_proj_pinv @ error_combined
                
                # 전체 해에 추가
                q_dot_command += N @ q_dot_task
                
                # 널 공간 업데이트 (현재 레벨 제거)
                N = N @ (np.eye(len(current_q)) - J_proj_pinv @ J_projected)
    
    return q_dot_command

def compute_task_jacobian(q, task):
    """
    태스크별 자코비안 계산
    """
    if task.type == 'end_effector_position':
        return compute_position_jacobian(q, task.end_effector_chain)
    
    elif task.type == 'end_effector_orientation':
        return compute_orientation_jacobian(q, task.end_effector_chain)
    
    elif task.type == 'center_of_mass':
        return compute_com_jacobian(q)
    
    elif task.type == 'joint_posture':
        return np.eye(len(q))[task.joint_indices, :]
    
    elif task.type == 'momentum':
        return compute_momentum_jacobian(q)
    
    else:
        raise ValueError(f"Unknown task type: {task.type}")

def compute_task_error(q, q_dot, task):
    """
    태스크 오차 계산
    """
    if task.type == 'end_effector_position':
        current_pos = forward_kinematics_position(q, task.end_effector_chain)
        desired_pos = task.desired_position
        desired_vel = task.desired_velocity
        
        # PD 제어 형태의 오차
        pos_error = desired_pos - current_pos
        vel_error = desired_vel - compute_current_ee_velocity(q, q_dot, task)
        
        return task.kp * pos_error + task.kd * vel_error
    
    elif task.type == 'center_of_mass':
        current_com = compute_center_of_mass(q)
        desired_com = task.desired_com
        
        com_error = desired_com - current_com
        return task.kp * com_error
    
    # 다른 태스크 타입들...
    
    return np.zeros(task.dimension)
```

#### 엄격한 계층 구조
```python
class StrictHierarchicalController:
    def __init__(self, robot_model):
        self.robot = robot_model
        self.task_hierarchy = {}
        
    def add_task(self, task, priority_level):
        """태스크를 특정 우선순위 레벨에 추가"""
        if priority_level not in self.task_hierarchy:
            self.task_hierarchy[priority_level] = []
        self.task_hierarchy[priority_level].append(task)
    
    def compute_control(self, current_state):
        """엄격한 계층적 제어 계산"""
        q, q_dot = current_state
        q_dot_cmd = np.zeros(len(q))
        
        # 누적 널 공간 투영자
        N_accumulated = np.eye(len(q))
        
        for priority in sorted(self.task_hierarchy.keys()):
            tasks_at_level = self.task_hierarchy[priority]
            
            # 현재 레벨의 모든 태스크 결합
            J_level, error_level = self.combine_tasks_at_level(
                tasks_at_level, q, q_dot
            )
            
            if J_level.size > 0:
                # 상위 우선순위의 널 공간에서 해결
                J_constrained = J_level @ N_accumulated
                
                # 최소 노름 해
                if np.linalg.matrix_rank(J_constrained) > 0:
                    J_pinv = np.linalg.pinv(J_constrained)
                    q_dot_level = J_pinv @ error_level
                    
                    # 실제 관절 속도 추가
                    q_dot_cmd += N_accumulated @ q_dot_level
                    
                    # 널 공간 업데이트
                    N_level = np.eye(len(q)) - J_pinv @ J_constrained
                    N_accumulated = N_accumulated @ N_level
        
        return q_dot_cmd
    
    def combine_tasks_at_level(self, tasks, q, q_dot):
        """같은 우선순위 레벨의 태스크들 결합"""
        jacobians = []
        errors = []
        
        for task in tasks:
            J = compute_task_jacobian(q, task)
            e = compute_task_error(q, q_dot, task)
            
            # 가중치 적용
            if hasattr(task, 'weight_matrix'):
                W = task.weight_matrix
                J_weighted = W @ J
                e_weighted = W @ e
            else:
                J_weighted = J
                e_weighted = e
            
            jacobians.append(J_weighted)
            errors.append(e_weighted)
        
        if jacobians:
            return np.vstack(jacobians), np.concatenate(errors)
        else:
            return np.array([]), np.array([])
```

### 2. 소프트 우선순위 제어

#### 가중 최소제곱법
```python
def weighted_least_squares_control(tasks, current_q, current_q_dot):
    """
    가중 최소제곱법을 이용한 소프트 우선순위 제어
    """
    # 모든 태스크의 자코비안과 오차 수집
    all_jacobians = []
    all_errors = []
    all_weights = []
    
    for task in tasks:
        J = compute_task_jacobian(current_q, task)
        e = compute_task_error(current_q, current_q_dot, task)
        
        # 우선순위를 가중치로 변환
        priority_weight = 10 ** (task.priority)
        task_weight = priority_weight * task.weight
        
        # 가중치 행렬 구성
        W = np.sqrt(task_weight) * np.eye(len(e))
        
        all_jacobians.append(W @ J)
        all_errors.append(W @ e)
    
    # 전체 시스템 구성
    J_total = np.vstack(all_jacobians)
    e_total = np.concatenate(all_errors)
    
    # 가중 최소제곱 해
    q_dot_cmd = np.linalg.pinv(J_total) @ e_total
    
    return q_dot_cmd

def adaptive_weighted_control(tasks, current_q, current_q_dot, performance_history):
    """
    성능 기반 적응적 가중치 조정
    """
    # 각 태스크의 최근 성능 분석
    for task in tasks:
        recent_errors = performance_history[task.name][-10:]  # 최근 10개
        
        if len(recent_errors) > 0:
            avg_error = np.mean(recent_errors)
            error_trend = np.polyfit(range(len(recent_errors)), recent_errors, 1)[0]
            
            # 성능이 나빠지면 가중치 증가
            if error_trend > 0 or avg_error > task.acceptable_error:
                task.weight = min(task.weight * 1.1, task.max_weight)
            else:
                task.weight = max(task.weight * 0.99, task.min_weight)
    
    return weighted_least_squares_control(tasks, current_q, current_q_dot)
```

## 제약 조건 통합

### 1. 동역학 제약

#### 동역학 일관성 보장
```python
def dynamics_consistent_control(tasks, current_state, contact_forces):
    """
    동역학적으로 일관된 전신 제어
    """
    q, q_dot = current_state
    
    # 로봇 동역학 행렬
    M = compute_mass_matrix(q)
    C = compute_coriolis_matrix(q, q_dot)
    G = compute_gravity_vector(q)
    
    # 접촉 자코비안 (발-지면 접촉)
    J_contact = compute_contact_jacobian(q)
    
    def dynamics_constraint(q_ddot, tau, f_contact):
        """동역학 방정식 제약"""
        lhs = M @ q_ddot + C @ q_dot + G
        rhs = tau + J_contact.T @ f_contact
        return lhs - rhs
    
    def contact_constraint(q_ddot):
        """접촉 제약 (발이 지면에서 미끄러지지 않음)"""
        contact_acceleration = J_contact @ q_ddot + J_contact_dot @ q_dot
        return contact_acceleration  # = 0 for fixed contact
    
    # 통합 최적화 문제
    def integrated_objective(decision_vars):
        """통합 목적함수"""
        q_ddot, tau, f_contact = unpack_decision_vars(decision_vars)
        
        cost = 0
        
        # 태스크 추적 오차
        for task in tasks:
            J_task = compute_task_jacobian(q, task)
            J_task_dot = compute_task_jacobian_derivative(q, q_dot, task)
            
            desired_acceleration = compute_desired_task_acceleration(task)
            actual_acceleration = J_task @ q_ddot + J_task_dot @ q_dot
            
            error = desired_acceleration - actual_acceleration
            cost += task.weight * np.sum(error**2)
        
        # 제어 입력 최소화
        cost += control_weight * np.sum(tau**2)
        
        # 접촉력 최소화
        cost += contact_weight * np.sum(f_contact**2)
        
        return cost
    
    def integrated_constraints(decision_vars):
        """통합 제약조건"""
        q_ddot, tau, f_contact = unpack_decision_vars(decision_vars)
        
        constraints = []
        
        # 동역학 제약
        dynamics_eq = dynamics_constraint(q_ddot, tau, f_contact)
        constraints.extend(dynamics_eq)
        
        # 접촉 제약
        contact_eq = contact_constraint(q_ddot)
        constraints.extend(contact_eq)
        
        # 관절 토크 한계
        torque_limits = check_torque_limits(tau)
        constraints.extend(torque_limits)
        
        # 접촉력 제약 (마찰 원뿔)
        friction_constraints = check_friction_cone(f_contact)
        constraints.extend(friction_constraints)
        
        return np.array(constraints)
    
    # 2차 계획법으로 해결
    result = solve_qp(
        objective=integrated_objective,
        constraints=integrated_constraints,
        bounds=get_variable_bounds()
    )
    
    q_ddot_opt, tau_opt, f_contact_opt = unpack_decision_vars(result.x)
    
    return {
        'joint_acceleration': q_ddot_opt,
        'joint_torques': tau_opt,
        'contact_forces': f_contact_opt
    }
```

### 2. 접촉 제약

#### 마찰 제약 처리
```python
def handle_friction_constraints(contact_forces, contact_points):
    """
    마찰 원뿔 제약 처리
    """
    constraints = []
    
    for i, (force, point) in enumerate(zip(contact_forces, contact_points)):
        fx, fy, fz = force[:3]  # 힘 성분
        mx, my, mz = force[3:] if len(force) > 3 else [0, 0, 0]  # 모멘트 성분
        
        # 법선력이 양수여야 함 (지면에서 떨어지지 않음)
        constraints.append(fz)  # fz >= 0
        
        # 마찰 원뿔 제약
        mu = point.friction_coefficient
        
        # 선형화된 마찰 원뿔 (4면 피라미드)
        constraints.extend([
            mu * fz - fx,   # fx <= mu * fz
            mu * fz + fx,   # fx >= -mu * fz  
            mu * fz - fy,   # fy <= mu * fz
            mu * fz + fy    # fy >= -mu * fz
        ])
        
        # 중심압력점 제약 (발바닥 내부)
        if fz > 1e-6:  # 접촉이 있을 때만
            cop_x = -my / fz
            cop_y = mx / fz
            
            # 발바닥 경계 내부
            foot_bounds = point.support_polygon
            for edge in foot_bounds:
                # ax + by + c <= 0 형태의 선형 부등식
                a, b, c = edge.coefficients
                constraints.append(a * cop_x + b * cop_y + c)
    
    return constraints

def unilateral_contact_control(tasks, current_state, potential_contacts):
    """
    단방향 접촉을 고려한 제어
    """
    q, q_dot = current_state
    
    # 각 접촉 상태에 대한 최적해 계산
    contact_combinations = generate_contact_combinations(potential_contacts)
    best_solution = None
    best_cost = float('inf')
    
    for contact_set in contact_combinations:
        try:
            # 현재 접촉 세트에 대한 제어 계산
            solution = compute_control_with_contacts(tasks, current_state, contact_set)
            
            # 해의 유효성 검증
            if verify_contact_solution(solution, contact_set):
                cost = evaluate_solution_cost(solution, tasks)
                
                if cost < best_cost:
                    best_cost = cost
                    best_solution = solution
        
        except OptimizationError:
            continue  # 이 접촉 조합은 실현 불가능
    
    return best_solution

def verify_contact_solution(solution, contact_set):
    """
    접촉 해의 물리적 일관성 확인
    """
    contact_forces = solution['contact_forces']
    
    for i, contact in enumerate(contact_set):
        force = contact_forces[i]
        
        # 법선력 확인
        normal_force = force[2]  # z 성분
        if normal_force < -1e-6:  # 음의 법선력 (비물리적)
            return False
        
        # 마찰 제약 확인
        tangential_force = np.linalg.norm(force[:2])
        mu = contact.friction_coefficient
        
        if tangential_force > mu * normal_force + 1e-6:
            return False  # 마찰 제약 위반
    
    return True
```

### 3. 안정성 제약

#### ZMP 기반 안정성
```python
def stability_constrained_control(tasks, current_state, support_polygon):
    """
    ZMP 안정성 제약을 포함한 전신 제어
    """
    q, q_dot = current_state
    
    def zmp_constraint(q_ddot):
        """ZMP 제약 조건"""
        # ZMP 계산
        zmp = compute_zmp_from_acceleration(q, q_dot, q_ddot)
        
        # 지지 다각형 내부 확인
        constraints = []
        for edge in support_polygon.edges:
            # 각 변에 대한 선형 부등식
            a, b, c = edge.normal_form  # ax + by + c <= 0
            distance_to_edge = a * zmp[0] + b * zmp[1] + c
            constraints.append(-distance_to_edge)  # 내부이면 음수
        
        return constraints
    
    def enhanced_objective(decision_vars):
        """안정성을 고려한 목적함수"""
        q_ddot = decision_vars
        
        # 기본 태스크 비용
        base_cost = compute_task_tracking_cost(tasks, q, q_dot, q_ddot)
        
        # 안정성 마진 보상
        zmp = compute_zmp_from_acceleration(q, q_dot, q_ddot)
        stability_margin = compute_stability_margin(zmp, support_polygon)
        stability_reward = stability_weight * stability_margin
        
        return base_cost - stability_reward
    
    # 제약 조건 통합
    def all_constraints(q_ddot):
        constraints = []
        
        # ZMP 안정성
        zmp_cons = zmp_constraint(q_ddot)
        constraints.extend(zmp_cons)
        
        # 관절 가속도 한계
        accel_limits = check_acceleration_limits(q_ddot)
        constraints.extend(accel_limits)
        
        # 동역학 실현 가능성
        required_torques = compute_required_torques(q, q_dot, q_ddot)
        torque_limits = check_torque_limits(required_torques)
        constraints.extend(torque_limits)
        
        return np.array(constraints)
    
    # 최적화 실행
    result = minimize(
        enhanced_objective,
        initial_guess_q_ddot,
        constraints={'type': 'ineq', 'fun': all_constraints},
        method='SLSQP'
    )
    
    return result.x

def compute_stability_margin(zmp, support_polygon):
    """
    안정성 마진 계산 (ZMP와 지지 경계의 최단 거리)
    """
    min_distance = float('inf')
    
    for edge in support_polygon.edges:
        distance = point_to_line_distance(zmp, edge)
        min_distance = min(min_distance, distance)
    
    return min_distance

def adaptive_stability_control(tasks, current_state, disturbance_estimate):
    """
    외란 추정에 기반한 적응적 안정성 제어
    """
    # 현재 외란 수준에 따라 안정성 마진 조정
    base_margin = 0.02  # 2cm 기본 마진
    disturbance_magnitude = np.linalg.norm(disturbance_estimate)
    
    # 외란이 클수록 더 큰 안정성 마진 요구
    adaptive_margin = base_margin + 0.5 * disturbance_magnitude
    
    # 지지 다각형을 마진만큼 축소
    contracted_polygon = contract_polygon(support_polygon, adaptive_margin)
    
    # 축소된 지지 영역으로 제어
    return stability_constrained_control(tasks, current_state, contracted_polygon)
```

## 실시간 구현

### 1. 계산 효율성

#### 효율적 자코비안 계산
```python
class EfficientWholeBodyController:
    def __init__(self, robot_model):
        self.robot = robot_model
        self.cached_jacobians = {}
        self.last_q = None
        self.jacobian_update_threshold = 0.01  # rad
        
    def get_task_jacobian(self, q, task):
        """캐시된 자코비안 사용"""
        # 설정 변화 확인
        if (self.last_q is None or 
            np.linalg.norm(q - self.last_q) > self.jacobian_update_threshold):
            
            # 모든 자코비안 재계산
            self.update_all_jacobians(q)
            self.last_q = q.copy()
        
        return self.cached_jacobians[task.name]
    
    def update_all_jacobians(self, q):
        """모든 태스크 자코비안을 한 번에 계산"""
        # 순기구학 한 번만 계산
        T_matrices = self.robot.forward_kinematics_all(q)
        
        # 각 태스크 자코비안 계산 (중간 결과 재사용)
        for task_name, task in self.tasks.items():
            if task.type == 'end_effector':
                J = self.compute_ee_jacobian_from_transforms(T_matrices, task.chain)
            elif task.type == 'com':
                J = self.compute_com_jacobian_from_transforms(T_matrices)
            # ... 다른 태스크 유형들
            
            self.cached_jacobians[task_name] = J
    
    def parallel_task_computation(self, q, q_dot, tasks):
        """태스크 계산 병렬 처리"""
        import concurrent.futures
        
        def compute_single_task(task):
            J = self.get_task_jacobian(q, task)
            error = compute_task_error(q, q_dot, task)
            return task.name, J, error
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
            futures = [executor.submit(compute_single_task, task) for task in tasks]
            
            results = {}
            for future in concurrent.futures.as_completed(futures):
                name, J, error = future.result()
                results[name] = {'jacobian': J, 'error': error}
        
        return results

def sparse_jacobian_computation(robot_model, task, changed_joints):
    """변경된 관절만 고려한 스파스 자코비안 계산"""
    full_jacobian = np.zeros((task.dimension, robot_model.n_joints))
    
    # 변경된 관절과 그 이후 관절들만 계산
    for joint_idx in range(min(changed_joints), robot_model.n_joints):
        if joint_idx in changed_joints or any(j < joint_idx for j in changed_joints):
            # 이 관절의 영향을 받는 자코비안 열 계산
            jacobian_column = compute_jacobian_column(robot_model, task, joint_idx)
            full_jacobian[:, joint_idx] = jacobian_column
    
    return full_jacobian
```

### 2. 실시간 최적화

#### QP 기반 실시간 해법
```python
import cvxpy as cp

class RealTimeQPController:
    def __init__(self, robot_model, max_solve_time=0.01):
        self.robot = robot_model
        self.max_solve_time = max_solve_time
        
        # CVXPY 변수 사전 정의 (컴파일 시간 절약)
        self.q_dot = cp.Variable(robot_model.n_joints)
        self.setup_qp_structure()
    
    def setup_qp_structure(self):
        """QP 문제 구조 사전 정의"""
        self.constraints = []
        self.objectives = []
        
        # 관절 속도 한계 (항상 적용)
        self.constraints.extend([
            self.q_dot >= self.robot.q_dot_min,
            self.q_dot <= self.robot.q_dot_max
        ])
    
    def solve_real_time(self, tasks, current_state):
        """실시간 QP 해결"""
        q, q_dot_current = current_state
        
        # 동적으로 목적함수와 제약 업데이트
        objective_terms = []
        dynamic_constraints = []
        
        for task in tasks:
            J = compute_task_jacobian(q, task)
            error = compute_task_error(q, q_dot_current, task)
            
            # 최소제곱 목적함수 항
            task_objective = cp.sum_squares(J @ self.q_dot - error)
            objective_terms.append(task.weight * task_objective)
            
            # 태스크별 제약 (있는 경우)
            if hasattr(task, 'constraint'):
                constraint_value = task.constraint(J, self.q_dot, error)
                dynamic_constraints.append(constraint_value)
        
        # 전체 목적함수
        total_objective = cp.Minimize(sum(objective_terms))
        
        # 전체 제약
        all_constraints = self.constraints + dynamic_constraints
        
        # QP 문제 정의 및 해결
        problem = cp.Problem(total_objective, all_constraints)
        
        try:
            problem.solve(solver=cp.OSQP, max_iter=1000, 
                         time_limit=self.max_solve_time, verbose=False)
            
            if problem.status == cp.OPTIMAL:
                return self.q_dot.value
            else:
                # 대안 해법 (단순한 가중 의사역행렬)
                return self.fallback_solution(tasks, current_state)
                
        except Exception:
            return self.fallback_solution(tasks, current_state)
    
    def fallback_solution(self, tasks, current_state):
        """최적화 실패 시 대안 해법"""
        print("QP solver failed, using fallback solution")
        return weighted_least_squares_control(tasks, *current_state)

def warm_start_qp(previous_solution, current_problem):
    """이전 해를 이용한 따뜻한 시작"""
    if previous_solution is not None:
        # 이전 해를 현재 문제에 맞게 조정
        adjusted_solution = adapt_solution_to_current_problem(
            previous_solution, current_problem
        )
        current_problem.set_initial_value(adjusted_solution)
    
    return current_problem
```

## 고급 기법

### 1. 모델 예측 전신 제어

#### MPC 기반 전신 제어
```python
class WholBodyMPC:
    def __init__(self, robot_model, prediction_horizon=10):
        self.robot = robot_model
        self.N = prediction_horizon
        self.dt = 0.01
        
    def solve_mpc(self, current_state, task_references, constraints):
        """전신 MPC 최적화"""
        q0, q_dot0 = current_state
        
        # 결정 변수: [q_dot_0, q_dot_1, ..., q_dot_{N-1}]
        decision_vars = cp.Variable((self.N, self.robot.n_joints))
        
        # 상태 예측
        q_predicted = [q0]
        q_dot_predicted = [q_dot0]
        
        for k in range(self.N):
            q_next = q_predicted[-1] + decision_vars[k] * self.dt
            q_dot_next = decision_vars[k]
            
            q_predicted.append(q_next)
            q_dot_predicted.append(q_dot_next)
        
        # 목적함수
        objective_terms = []
        
        for k in range(self.N):
            # 각 시간 스텝에서의 태스크 비용
            for task in task_references:
                if k < len(task.reference_trajectory):
                    J_k = compute_task_jacobian(q_predicted[k], task)
                    ref_k = task.reference_trajectory[k]
                    actual_k = J_k @ decision_vars[k]
                    
                    tracking_cost = cp.sum_squares(actual_k - ref_k)
                    objective_terms.append(task.weight * tracking_cost)
            
            # 제어 평활화
            if k > 0:
                smoothness_cost = cp.sum_squares(decision_vars[k] - decision_vars[k-1])
                objective_terms.append(self.smoothness_weight * smoothness_cost)
        
        # 제약 조건
        mpc_constraints = []
        
        for k in range(self.N):
            # 관절 속도 한계
            mpc_constraints.extend([
                decision_vars[k] >= self.robot.q_dot_min,
                decision_vars[k] <= self.robot.q_dot_max
            ])
            
            # 관절 위치 한계
            mpc_constraints.append(
                q_predicted[k+1] >= self.robot.q_min
            )
            mpc_constraints.append(
                q_predicted[k+1] <= self.robot.q_max
            )
            
            # 태스크별 제약
            for constraint in constraints:
                constraint_value = constraint.evaluate(
                    q_predicted[k], decision_vars[k], k
                )
                mpc_constraints.append(constraint_value)
        
        # MPC 문제 해결
        objective = cp.Minimize(sum(objective_terms))
        problem = cp.Problem(objective, mpc_constraints)
        
        problem.solve(solver=cp.OSQP, verbose=False)
        
        if problem.status == cp.OPTIMAL:
            # 첫 번째 제어 입력 반환
            return decision_vars[0].value
        else:
            raise OptimizationError("MPC optimization failed")
```

### 2. 학습 기반 전신 제어

#### 강화학습 통합 제어
```python
import torch
import torch.nn as nn

class LearnedWholeBodyController(nn.Module):
    def __init__(self, state_dim, action_dim, task_dim):
        super().__init__()
        
        # 상태 인코더
        self.state_encoder = nn.Sequential(
            nn.Linear(state_dim, 256),
            nn.ReLU(),
            nn.Linear(256, 128)
        )
        
        # 태스크 인코더
        self.task_encoder = nn.Sequential(
            nn.Linear(task_dim, 128),
            nn.ReLU(),
            nn.Linear(128, 64)
        )
        
        # 통합 네트워크
        self.control_network = nn.Sequential(
            nn.Linear(128 + 64, 256),
            nn.ReLU(),
            nn.Linear(256, 128),
            nn.ReLU(),
            nn.Linear(128, action_dim)
        )
        
    def forward(self, state, task_specification):
        """학습된 전신 제어 정책"""
        state_features = self.state_encoder(state)
        task_features = self.task_encoder(task_specification)
        
        combined_features = torch.cat([state_features, task_features], dim=-1)
        control_output = self.control_network(combined_features)
        
        return control_output

def hybrid_learning_control(learned_controller, analytical_controller, 
                          current_state, tasks, confidence_threshold=0.8):
    """
    학습 기반과 해석적 제어의 하이브리드
    """
    # 학습된 제어기로 초기 해 생성
    state_tensor = torch.FloatTensor(current_state)
    task_tensor = encode_tasks_to_tensor(tasks)
    
    with torch.no_grad():
        learned_output = learned_controller(state_tensor, task_tensor)
        learned_control = learned_output.numpy()
    
    # 학습된 해의 신뢰도 평가
    confidence = evaluate_control_confidence(learned_control, current_state, tasks)
    
    if confidence > confidence_threshold:
        # 높은 신뢰도: 학습된 제어 사용
        return learned_control
    else:
        # 낮은 신뢰도: 해석적 제어기 사용 (또는 혼합)
        analytical_control = analytical_controller.compute_control(current_state, tasks)
        
        # 신뢰도에 따른 가중 평균
        alpha = confidence / confidence_threshold
        hybrid_control = alpha * learned_control + (1 - alpha) * analytical_control
        
        return hybrid_control

def evaluate_control_confidence(control_command, state, tasks):
    """
    제어 명령의 신뢰도 평가
    """
    # 예상 성능 평가
    predicted_performance = simulate_control_performance(control_command, state, tasks)
    
    # 물리적 실현 가능성 확인
    feasibility_score = check_physical_feasibility(control_command, state)
    
    # 안전성 평가
    safety_score = evaluate_safety_margin(control_command, state)
    
    # 종합 신뢰도
    confidence = (predicted_performance * feasibility_score * safety_score) ** (1/3)
    
    return confidence
```

### 3. 분산 전신 제어

#### 분산 최적화 방법
```python
class DistributedWholeBodyController:
    def __init__(self, robot_model, body_segments):
        self.robot = robot_model
        self.segments = body_segments  # {'upper_body': joints, 'lower_body': joints}
        self.coupling_constraints = []
        
    def admm_whole_body_control(self, tasks, current_state, max_iterations=10):
        """
        ADMM을 이용한 분산 전신 제어
        """
        # 태스크를 세그먼트별로 분할
        segment_tasks = self.distribute_tasks_to_segments(tasks)
        
        # ADMM 변수 초기화
        local_solutions = {}
        dual_variables = {}
        penalty_parameter = 1.0
        
        for seg_name in self.segments:
            local_solutions[seg_name] = np.zeros(len(self.segments[seg_name]))
            dual_variables[seg_name] = np.zeros(len(self.segments[seg_name]))
        
        # ADMM 반복
        for iteration in range(max_iterations):
            # 1단계: 각 세그먼트별 지역 최적화
            for seg_name, seg_joints in self.segments.items():
                seg_tasks = segment_tasks[seg_name]
                seg_state = extract_segment_state(current_state, seg_joints)
                
                local_solutions[seg_name] = self.solve_segment_subproblem(
                    seg_tasks, seg_state, dual_variables[seg_name], penalty_parameter
                )
            
            # 2단계: 전역 일관성 강제 (coupling constraints)
            global_solution = self.enforce_global_consistency(local_solutions)
            
            # 3단계: 듀얼 변수 업데이트
            for seg_name in self.segments:
                constraint_violation = local_solutions[seg_name] - global_solution[seg_name]
                dual_variables[seg_name] += penalty_parameter * constraint_violation
            
            # 수렴 확인
            if self.check_admm_convergence(local_solutions, global_solution):
                break
        
        # 전역 해 구성
        full_solution = self.combine_segment_solutions(global_solution)
        return full_solution
    
    def solve_segment_subproblem(self, seg_tasks, seg_state, dual_vars, rho):
        """
        세그먼트별 부문제 해결
        """
        def segment_objective(q_dot_seg):
            cost = 0
            
            # 세그먼트 태스크 비용
            for task in seg_tasks:
                J_seg = compute_segment_jacobian(seg_state, task)
                error = compute_task_error(seg_state, task)
                
                tracking_cost = np.sum((J_seg @ q_dot_seg - error)**2)
                cost += task.weight * tracking_cost
            
            # ADMM 항 (듀얼 변수와 페널티)
            admm_cost = dual_vars.T @ q_dot_seg + (rho/2) * np.sum(q_dot_seg**2)
            cost += admm_cost
            
            return cost
        
        # 세그먼트 제약
        segment_constraints = self.get_segment_constraints(seg_state)
        
        # 최적화 실행
        result = minimize(
            segment_objective,
            np.zeros(len(seg_state[0])),
            constraints=segment_constraints
        )
        
        return result.x
```

## 성능 평가

### 평가 지표
```python
def evaluate_whole_body_performance(controller, test_scenarios):
    """
    전신 제어 성능 종합 평가
    """
    results = {}
    
    for scenario_name, scenario in test_scenarios.items():
        scenario_results = {
            'task_tracking_errors': [],
            'constraint_violations': [],
            'energy_consumption': 0,
            'computation_times': [],
            'stability_margins': []
        }
        
        state = scenario['initial_state']
        tasks = scenario['tasks']
        
        for time_step in range(scenario['duration']):
            start_time = time.time()
            
            # 제어 계산
            control_command = controller.compute_control(state, tasks)
            
            computation_time = time.time() - start_time
            scenario_results['computation_times'].append(computation_time)
            
            # 상태 업데이트 (시뮬레이션)
            state = simulate_robot_step(state, control_command, scenario['dt'])
            
            # 성능 지표 계산
            task_errors = evaluate_task_tracking_errors(state, tasks)
            constraint_viols = evaluate_constraint_violations(state, control_command)
            stability_margin = compute_stability_margin(state)
            energy = compute_energy_consumption(control_command)
            
            scenario_results['task_tracking_errors'].append(task_errors)
            scenario_results['constraint_violations'].append(constraint_viols)
            scenario_results['stability_margins'].append(stability_margin)
            scenario_results['energy_consumption'] += energy
        
        # 통계 계산
        results[scenario_name] = {
            'avg_task_error': np.mean(scenario_results['task_tracking_errors']),
            'max_constraint_violation': np.max(scenario_results['constraint_violations']),
            'total_energy': scenario_results['energy_consumption'],
            'avg_computation_time': np.mean(scenario_results['computation_times']),
            'min_stability_margin': np.min(scenario_results['stability_margins'])
        }
    
    return results

def benchmark_against_baselines(controller, baseline_controllers, test_suite):
    """
    기준 제어기들과의 성능 비교
    """
    all_controllers = {'proposed': controller}
    all_controllers.update(baseline_controllers)
    
    comparison_results = {}
    
    for controller_name, ctrl in all_controllers.items():
        print(f"Evaluating {controller_name}...")
        results = evaluate_whole_body_performance(ctrl, test_suite)
        comparison_results[controller_name] = results
    
    # 성능 지표별 순위 계산
    performance_ranking = compute_performance_ranking(comparison_results)
    
    return comparison_results, performance_ranking
```

## 연결 문서

### 관련 기술
- **상위**: [[휴머노이드 연구기술]]
- **기구학**: [[역기구학]], [[자코비안]]
- **제어**: [[ZMP]], [[궤적최적화]]

### 수학적 기반
- **최적화**: [[2차계획법]], [[제약최적화]], [[다목적최적화]]
- **제어이론**: [[MPC]], [[계층적제어]], [[강건제어]]
- **선형대수**: [[의사역행렬]], [[널공간]], [[특이값분해]]

### 응용 분야
- **휴머노이드**: [[동적동작계획]], [[균형제어]]
- **로봇제어**: [[다중태스크제어]], [[실시간제어]]
- **최적화**: [[분산최적화]], [[ADMM]]

## 태그

#전신제어 #다중태스크 #계층적제어 #제약최적화 #실시간제어 #QP #MPC #휴머노이드 #안정성제어 #동역학제어