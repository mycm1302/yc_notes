# 로봇핸드 (Robot Hands)

## 📖 주요 참고문헌
> **핵심 연구 기관**: MIT CSAIL, Stanford, CMU Robotics Institute
> **주요 연구자**: Antonio Bicchi, Peter Allen, Matei Ciocarlie
> **참고서적**: *Robotics: Modelling, Planning and Control* (Siciliano), *Dexterous Manipulation* (Murray)

## 🎯 정의 및 특징

**로봇핸드**는 인간의 손과 유사한 기능을 수행하도록 설계된 다지 조작 장치로, 물체의 파지(grasping)와 정교한 조작(manipulation)을 담당합니다.

### 🖐️ 구조적 분류
```
손가락 수에 따른 분류:
- 2지 그리퍼: 평행/각도 그리퍼
- 3지 핸드: 삼각 파지 전문
- 4지 핸드: 엄지 + 3지 구조
- 5지 핸드: 인간 손 완전 모방

자유도에 따른 분류:
- 저자유도: 3-8 DOF
- 중자유도: 9-16 DOF  
- 고자유도: 17-25 DOF
- 초고자유도: 26+ DOF
```

### ⚡ 주요 기능
- **파지 (Grasping)**: 물체를 안전하게 잡기
- **조작 (Manipulation)**: 손안에서 물체 재배치
- **탐지 (Exploration)**: 촉각을 통한 물체 인식
- **도구 사용**: 다양한 도구 조작

### 🎯 설계 목표
- **다목적성**: 다양한 물체 처리 가능
- **정교성**: 정밀한 움직임 제어
- **안전성**: 물체 손상 방지
- **내구성**: 반복 사용 가능

## 🔧 기구학 및 동역학

### 1. 손가락 기구학

#### 순기구학 (Forward Kinematics)
```python
def finger_forward_kinematics(joint_angles):
    """손가락 순기구학 계산"""
    
    # 3관절 손가락 (MCP, PIP, DIP)
    theta1, theta2, theta3 = joint_angles
    
    # DH 파라미터 기반 변환
    T01 = dh_transform(L1, 0, 0, theta1)
    T12 = dh_transform(L2, 0, 0, theta2) 
    T23 = dh_transform(L3, 0, 0, theta3)
    
    # 누적 변환
    T02 = T01 @ T12
    T03 = T02 @ T23
    
    # 지골 위치
    proximal_pos = T01[:3, 3]
    middle_pos = T02[:3, 3]
    distal_pos = T03[:3, 3]
    
    return proximal_pos, middle_pos, distal_pos
```

#### 역기구학 (Inverse Kinematics)
```python
def finger_inverse_kinematics(target_position, link_lengths):
    """손가락 역기구학 해석적 해"""
    
    L1, L2, L3 = link_lengths
    x, y = target_position[:2]
    
    # 3-DOF 평면 조작기 역기구학
    # 2차 해 존재 (elbow up/down)
    
    # 코사인 법칙으로 세 번째 관절각
    c3 = (x**2 + y**2 - L1**2 - L2**2) / (2*L1*L2)
    
    if abs(c3) > 1:
        return None  # 도달 불가능
    
    theta3 = np.arccos(c3)  # elbow up 해
    
    # 첫 번째, 두 번째 관절각
    s3 = np.sin(theta3)
    theta2 = np.arctan2(y, x) - np.arctan2(L2*s3, L1 + L2*c3)
    theta1 = theta2 - theta3
    
    return [theta1, theta2, theta3]
```

### 2. 다지 핸드 기구학

#### 전체 핸드 자코비안
```python
def hand_jacobian(joint_config, finger_config):
    """전체 핸드의 자코비안 행렬"""
    
    jacobians = []
    
    for i, finger in enumerate(finger_config):
        # 각 손가락의 자코비안
        J_finger = compute_finger_jacobian(
            joint_config[finger.joint_indices])
        
        # 손바닥 좌표계로 변환
        T_palm_finger = finger.transform_to_palm()
        J_transformed = transform_jacobian(J_finger, T_palm_finger)
        
        jacobians.append(J_transformed)
    
    # 전체 자코비안 결합
    J_hand = np.block(jacobians)
    
    return J_hand
```

### 3. 접촉 역학

#### 접촉 모델
```python
class ContactModel:
    """접촉점 역학 모델"""
    
    def __init__(self, friction_coeff, contact_stiffness):
        self.mu = friction_coeff
        self.k_contact = contact_stiffness
    
    def contact_force(self, normal_penetration, tangential_slip):
        """접촉력 계산"""
        
        # 법선력 (페널티 방법)
        if normal_penetration > 0:
            F_normal = self.k_contact * normal_penetration
        else:
            F_normal = 0
        
        # 마찰력 (쿨롱 마찰)
        F_friction_max = self.mu * F_normal
        F_friction_desired = self.k_contact * tangential_slip
        
        if np.linalg.norm(F_friction_desired) <= F_friction_max:
            F_friction = F_friction_desired  # 스틱
        else:
            F_friction = F_friction_max * \
                        F_friction_desired / np.linalg.norm(F_friction_desired)  # 슬립
        
        return F_normal, F_friction
```

#### 파지 행렬 (Grasp Matrix)
```python
def grasp_matrix(contact_points, contact_normals):
    """파지 행렬 계산"""
    
    G = []
    
    for i, (point, normal) in enumerate(zip(contact_points, contact_normals)):
        # 접촉점에서의 wrench 매핑
        # F = [fx, fy, fz], M = r × F
        
        # 힘 부분
        force_part = np.eye(3)
        
        # 모멘트 부분 (외적 행렬)
        moment_part = skew_symmetric(point)
        
        # 6×3 매핑 행렬
        G_i = np.vstack([force_part, moment_part])
        G.append(G_i)
    
    # 전체 파지 행렬 (6×3n)
    G_total = np.hstack(G)
    
    return G_total
```

## 🎯 파지 계획 (Grasp Planning)

### 1. 파지 분류

#### 정밀 파지 (Precision Grasp)
```
특징:
- 손가락 끝으로 물체 조작
- 높은 정밀도, 낮은 힘
- 작은 물체에 적합
- 복잡한 조작 가능

대표적 파지:
- 핀치 그립 (2지)
- 삼각 그립 (3지)
- 펜 그립 (3지)
```

#### 파워 파지 (Power Grasp)
```
특징:
- 손바닥과 손가락으로 전체 감쌈
- 낮은 정밀도, 높은 힘
- 큰 물체에 적합
- 안정된 파지력

대표적 파지:
- 원통형 그립
- 구형 그립
- 갈고리 그립
```

### 2. 파지 품질 지표

#### 파지 견고성 (Grasp Robustness)
```python
def grasp_quality_measure(contact_points, contact_forces, object_weight):
    """파지 품질 평가"""
    
    # 힘 폐쇄 여부 (Force Closure)
    G = grasp_matrix(contact_points)
    force_closure = check_force_closure(G)
    
    # 최소 고유값 척도
    W = G @ G.T  # 파지 gram 행렬
    eigenvals = np.linalg.eigvals(W)
    quality_eigenvalue = np.min(eigenvals)
    
    # 조작성 척도
    manipulability = np.sqrt(np.linalg.det(W))
    
    # 안전 여유도
    min_force = np.min(np.abs(contact_forces))
    safety_margin = min_force / object_weight
    
    return {
        'force_closure': force_closure,
        'quality_eigenvalue': quality_eigenvalue,
        'manipulability': manipulability,
        'safety_margin': safety_margin
    }
```

#### 저항 타원체 (Resistance Ellipsoid)
```python
def resistance_ellipsoid(grasp_matrix):
    """파지의 저항 타원체 계산"""
    
    # 파지 gram 행렬
    W = grasp_matrix @ grasp_matrix.T
    
    # 특이값 분해
    U, S, Vt = np.linalg.svd(W)
    
    # 타원체 주축 방향
    principal_directions = U
    
    # 타원체 반지름 (저항 능력)
    resistance_radii = np.sqrt(S)
    
    return principal_directions, resistance_radii
```

### 3. 파지 계획 알고리즘

#### 샘플링 기반 계획
```python
class GraspPlanner:
    """샘플링 기반 파지 계획기"""
    
    def __init__(self, hand_model, object_model):
        self.hand = hand_model
        self.object = object_model
    
    def sample_grasps(self, num_samples):
        """파지 후보 샘플링"""
        
        grasp_candidates = []
        
        for i in range(num_samples):
            # 물체 표면에서 랜덤 접근 방향
            approach_direction = self.sample_approach_direction()
            
            # 접촉점 선택
            contact_points = self.select_contact_points(approach_direction)
            
            # 손가락 배치 계산
            finger_config = self.compute_finger_configuration(contact_points)
            
            # 충돌 검사
            if self.collision_free(finger_config):
                # 파지 품질 평가
                quality = self.evaluate_grasp_quality(
                    contact_points, finger_config)
                
                grasp_candidates.append({
                    'configuration': finger_config,
                    'quality': quality,
                    'contacts': contact_points
                })
        
        # 품질 순으로 정렬
        grasp_candidates.sort(key=lambda x: x['quality'], reverse=True)
        
        return grasp_candidates
```

#### 해석적 파지 계획
```python
def analytical_grasp_planning(object_geometry, hand_parameters):
    """해석적 파지 계획 (간단한 형태 물체)"""
    
    if object_geometry.type == 'cylinder':
        # 원통형 물체 파워 그립
        cylinder_radius = object_geometry.radius
        cylinder_height = object_geometry.height
        
        # 최적 접촉점 계산
        contact_angles = np.linspace(0, 2*np.pi, hand_parameters.num_fingers, 
                                   endpoint=False)
        
        contact_points = []
        for angle in contact_angles:
            x = cylinder_radius * np.cos(angle)
            y = cylinder_radius * np.sin(angle)
            z = cylinder_height / 2
            contact_points.append([x, y, z])
        
        return contact_points
    
    elif object_geometry.type == 'sphere':
        # 구형 물체 구형 그립
        sphere_radius = object_geometry.radius
        
        # 정사면체 접촉점 (4지 핸드)
        tetrahedron_vertices = [
            [1, 1, 1], [1, -1, -1], [-1, 1, -1], [-1, -1, 1]
        ]
        
        contact_points = []
        for vertex in tetrahedron_vertices:
            normalized = np.array(vertex) / np.linalg.norm(vertex)
            contact_point = sphere_radius * normalized
            contact_points.append(contact_point)
        
        return contact_points
```

## 🔄 손안 조작 (In-Hand Manipulation)

### 1. 조작 원시 동작 (Manipulation Primitives)

#### 롤링 (Rolling)
```python
def rolling_manipulation(object_state, target_rotation):
    """롤링을 통한 물체 회전"""
    
    # 현재 접촉점들
    current_contacts = object_state.contact_points
    
    # 목표 회전에 필요한 롤링 거리
    rolling_distance = target_rotation * object_state.radius
    
    finger_trajectories = []
    
    for i, contact in enumerate(current_contacts):
        # 접촉점의 롤링 궤적
        tangent_direction = compute_tangent_direction(contact, target_rotation)
        
        # 손가락 궤적 생성
        trajectory = generate_rolling_trajectory(
            contact, tangent_direction, rolling_distance)
        
        finger_trajectories.append(trajectory)
    
    return finger_trajectories
```

#### 슬라이딩 (Sliding)
```python
def sliding_manipulation(current_grasp, target_position):
    """슬라이딩을 통한 물체 위치 변경"""
    
    # 슬라이딩 방향 계산
    slide_direction = target_position - current_grasp.object_center
    slide_distance = np.linalg.norm(slide_direction)
    slide_direction = slide_direction / slide_distance
    
    # 각 손가락의 슬라이딩 궤적
    finger_motions = []
    
    for finger in current_grasp.fingers:
        # 마찰 원뿔 내에서 슬라이딩 방향 결정
        friction_cone_limit = np.arctan(finger.friction_coefficient)
        
        # 허용 가능한 슬라이딩 방향인지 확인
        if angle_with_normal(slide_direction, finger.contact_normal) < friction_cone_limit:
            motion = generate_sliding_motion(finger, slide_direction, slide_distance)
            finger_motions.append(motion)
        else:
            # 리그래스핑 필요
            return None
    
    return finger_motions
```

#### 피벗팅 (Pivoting)
```python
def pivoting_manipulation(pivot_contact, target_orientation):
    """피벗팅을 통한 물체 방향 변경"""
    
    # 피벗 축 설정
    pivot_axis = pivot_contact.normal
    
    # 목표 회전각 계산
    rotation_angle = compute_rotation_angle(
        current_orientation, target_orientation, pivot_axis)
    
    # 피벗팅 중 접촉 관리
    pivoting_plan = []
    
    # 1단계: 피벗 접촉점 고정
    fix_pivot_contact = {
        'finger': pivot_contact.finger_id,
        'action': 'maintain_contact',
        'force': pivot_contact.required_force
    }
    
    # 2단계: 다른 손가락들 재배치
    for finger_id in range(num_fingers):
        if finger_id != pivot_contact.finger_id:
            new_contact = compute_new_contact_after_rotation(
                finger_id, rotation_angle, pivot_axis)
            
            pivoting_plan.append({
                'finger': finger_id,
                'action': 'move_to_contact',
                'target': new_contact
            })
    
    return pivoting_plan
```

### 2. 동적 조작

#### 던지기-받기 (Throw-Catch)
```python
def dynamic_throw_catch(object_properties, target_position):
    """동적 던지기-받기 조작"""
    
    # 던지기 궤적 계산
    throw_trajectory = compute_ballistic_trajectory(
        current_position, target_position, object_properties.mass)
    
    # 던지기 동작
    release_velocity = throw_trajectory.initial_velocity
    release_timing = throw_trajectory.release_time
    
    throw_motion = generate_throw_motion(release_velocity, release_timing)
    
    # 받기 동작
    catch_position = throw_trajectory.landing_position
    catch_timing = throw_trajectory.flight_time
    
    catch_motion = generate_catch_motion(catch_position, catch_timing)
    
    return {
        'throw_phase': throw_motion,
        'flight_time': catch_timing,
        'catch_phase': catch_motion
    }
```

## 🎯 센서 시스템

### 1. 촉각 센서

#### 정전용량 촉각 센서
```python
class CapacitiveTactileSensor:
    """정전용량 기반 촉각 센서"""
    
    def __init__(self, sensor_array_size):
        self.array_size = sensor_array_size
        self.baseline_capacitance = self.calibrate_baseline()
    
    def measure_pressure_distribution(self):
        """압력 분포 측정"""
        
        current_capacitance = self.read_capacitance_array()
        pressure_distribution = []
        
        for i in range(self.array_size[0]):
            pressure_row = []
            for j in range(self.array_size[1]):
                # 정전용량 변화 → 압력 변환
                delta_C = (current_capacitance[i][j] - 
                          self.baseline_capacitance[i][j])
                
                pressure = self.capacitance_to_pressure(delta_C)
                pressure_row.append(pressure)
            
            pressure_distribution.append(pressure_row)
        
        return np.array(pressure_distribution)
    
    def detect_contact_features(self, pressure_distribution):
        """접촉 특성 추출"""
        
        # 접촉 영역 검출
        contact_threshold = 0.1  # N/cm²
        contact_mask = pressure_distribution > contact_threshold
        
        # 접촉 중심 계산
        contact_center = self.compute_center_of_pressure(
            pressure_distribution, contact_mask)
        
        # 접촉 면적
        contact_area = np.sum(contact_mask) * self.sensor_resolution
        
        # 총 접촉력
        total_force = np.sum(pressure_distribution) * self.sensor_resolution
        
        return {
            'center': contact_center,
            'area': contact_area,
            'total_force': total_force,
            'distribution': pressure_distribution
        }
```

#### 광학 촉각 센서
```python
class OpticalTactileSensor:
    """광학 기반 촉각 센서 (GelSight 방식)"""
    
    def __init__(self):
        self.camera = TactileCamera()
        self.reference_image = self.capture_reference()
    
    def measure_surface_deformation(self):
        """표면 변형 측정"""
        
        current_image = self.camera.capture()
        
        # 이미지 차분으로 변형 검출
        deformation_field = self.compute_optical_flow(
            self.reference_image, current_image)
        
        # 변형 → 응력 변환
        stress_field = self.deformation_to_stress(deformation_field)
        
        # 3차원 접촉 형태 복원
        contact_geometry = self.reconstruct_3d_contact(stress_field)
        
        return {
            'deformation': deformation_field,
            'stress': stress_field,
            'geometry': contact_geometry
        }
    
    def detect_texture_features(self, contact_image):
        """접촉 표면의 질감 특성 검출"""
        
        # 텍스처 분석
        texture_features = self.analyze_texture(contact_image)
        
        # 표면 거칠기 추정
        roughness = self.estimate_surface_roughness(texture_features)
        
        # 재료 분류
        material_type = self.classify_material(texture_features)
        
        return {
            'roughness': roughness,
            'material': material_type,
            'features': texture_features
        }
```

### 2. 근접 센서

#### 용량성 근접 센서
```python
def capacitive_proximity_sensing(sensor_positions, object_position):
    """용량성 근접 센서를 이용한 물체 위치 추정"""
    
    capacitance_readings = []
    
    for sensor_pos in sensor_positions:
        # 거리에 따른 정전용량 변화
        distance = np.linalg.norm(object_position - sensor_pos)
        
        # 근사 모델: C ∝ 1/d
        if distance > 0:
            capacitance = baseline_capacitance / distance
        else:
            capacitance = max_capacitance
        
        capacitance_readings.append(capacitance)
    
    # 삼각측량으로 위치 추정
    estimated_position = triangulate_position(
        sensor_positions, capacitance_readings)
    
    return estimated_position
```

### 3. 시각 센서

#### 손끝 카메라
```python
class FingertipCamera:
    """손끝 장착 마이크로 카메라"""
    
    def __init__(self, camera_resolution):
        self.resolution = camera_resolution
        self.calibration_matrix = self.load_calibration()
    
    def visual_servoing_grasp(self, target_object):
        """시각 피드백 기반 파지"""
        
        while not self.grasp_complete():
            # 현재 이미지 획득
            current_image = self.capture_image()
            
            # 물체 위치 검출
            object_position = self.detect_object_position(current_image)
            
            # 목표 파지 위치와의 오차
            position_error = target_object.grasp_point - object_position
            
            # 시각 제어 법칙
            finger_velocity = self.visual_control_law(position_error)
            
            # 손가락 움직임 명령
            self.move_finger(finger_velocity)
        
        return self.execute_grasp()
```

## 🔄 제어 아키텍처

### 1. 계층적 제어
```python
class HierarchicalHandController:
    """계층적 로봇핸드 제어기"""
    
    def __init__(self):
        self.task_planner = TaskPlanner()
        self.motion_planner = MotionPlanner()
        self.low_level_controller = LowLevelController()
    
    def execute_manipulation_task(self, task_description):
        """조작 작업 실행"""
        
        # 상위 계층: 작업 계획
        subtasks = self.task_planner.decompose_task(task_description)
        
        for subtask in subtasks:
            # 중간 계층: 움직임 계획
            motion_plan = self.motion_planner.plan_motion(subtask)
            
            # 하위 계층: 궤적 추적
            for trajectory_segment in motion_plan.segments:
                self.low_level_controller.track_trajectory(trajectory_segment)
        
        return "Task completed"
```

### 2. 적응 제어
```python
class AdaptiveGraspController:
    """적응형 파지 제어기"""
    
    def __init__(self):
        self.object_model = ObjectModel()
        self.contact_model = ContactModel()
        self.adaptation_rate = 0.1
    
    def adaptive_grasp_control(self, tactile_feedback):
        """촉각 피드백 기반 적응 제어"""
        
        # 물체 특성 추정
        estimated_properties = self.estimate_object_properties(tactile_feedback)
        
        # 모델 업데이트
        self.object_model.update(estimated_properties, self.adaptation_rate)
        
        # 최적 파지력 재계산
        optimal_forces = self.compute_optimal_grasp_forces(
            self.object_model.current_estimate())
        
        # 제어 게인 적응
        adapted_gains = self.adapt_control_gains(estimated_properties)
        
        # 제어 입력 생성
        control_input = self.generate_control_input(
            optimal_forces, adapted_gains)
        
        return control_input
```

### 3. 학습 기반 제어
```python
class DexterousManipulationRL:
    """강화학습 기반 정교 조작"""
    
    def __init__(self, state_dim, action_dim):
        self.policy_network = self.build_policy_network(state_dim, action_dim)
        self.value_network = self.build_value_network(state_dim)
        self.replay_buffer = ReplayBuffer()
    
    def train_manipulation_skill(self, episodes):
        """조작 기술 학습"""
        
        for episode in range(episodes):
            state = self.reset_environment()
            episode_reward = 0
            
            while not self.is_terminal(state):
                # 행동 선택
                action = self.select_action(state)
                
                # 환경과 상호작용
                next_state, reward, done = self.step(action)
                
                # 경험 저장
                self.replay_buffer.add(state, action, reward, next_state, done)
                
                # 네트워크 업데이트
                if len(self.replay_buffer) > batch_size:
                    self.update_networks()
                
                state = next_state
                episode_reward += reward
            
            print(f"Episode {episode}: Reward = {episode_reward}")
```

## 🏭 응용 분야 및 성능

### 1. 산업 응용
- **정밀 조립**: 전자부품, 시계 조립
- **품질 검사**: 촉각 기반 결함 검출
- **포장**: 다양한 형태 물체 포장
- **도구 조작**: 드라이버, 렌치 등 도구 사용

### 2. 서비스 응용  
- **가사 보조**: 설거지, 청소, 요리
- **개인 돌봄**: 노약자 보조, 의료 지원
- **교육**: 실험 보조, 시연
- **엔터테인먼트**: 악기 연주, 게임

### 3. 성능 지표
```
기계적 성능:
- 파지력: 1-1000N
- 위치 정확도: ±0.1-1.0mm
- 반복 정확도: ±0.05-0.5mm
- 동작 속도: 0.1-5.0 m/s

센서 성능:
- 촉각 해상도: 1-10mm
- 압력 범위: 0.1-100N/cm²
- 응답 시간: 1-100ms
- 온도 범위: -20~+80°C
```

---

#로봇핸드 #RobotHands #정교조작 #파지계획 #촉각센서 #손안조작