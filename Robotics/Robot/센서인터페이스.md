# 센서인터페이스

> 상위: [[전자회로설계]]

로봇 센서 신호를 마이크로컨트롤러에 연결하는 인터페이스 회로 설계입니다.

## 📡 주요 센서 인터페이스

### 엔코더 인터페이스
- **앱솔루트 엔코더**: 디지털 출력 (5V 로직)
- Pull-up 저항 필요 (4.7kΩ)
- 노이즈 필터링: RC 필터 (100Ω + 100nF)
- **용도**: 로프 각도 측정 모듈

### IMU 센서 인터페이스
- **MPU-9250**: I2C 통신 (주소: 0x68)
- 전원: 3.3V, 저노이즈 LDO 필수
- 디커플링: 100nF + 10μF
- **용도**: 가속도 센서 활용 IMU 모듈

### 로드셀 인터페이스
- **계측증폭기**: INA128 (이득 설정 저항 Rg)
- 24bit ADC: HX711 또는 AD7730
- 브리지 여자 전압: 5V 안정화
- **용도**: 힘센서 장력측정, FT센서 반력측정

## 🔌 회로 설계 원칙

### 전원 공급
```
센서별 전원 요구사항:
- 엔코더: 5V, 50-200mA
- IMU: 3.3V, 1-10mA
- 로드셀: 5-12V, 10-50mA
```

### 신호 조절
- **전압 분배기**: 5V → 3.3V 레벨 변환
- **버퍼 앰프**: 임피던스 매칭
- **LPF 필터**: 고주파 노이즈 제거

### 보호 회로
- ESD 보호: TVS 다이오드
- 과전압 보호: 제너 다이오드
- 역전압 보호: 쇼트키 다이오드

## ⚡ ESP32 연결 예시

### I2C 센서 연결
```cpp
// 멀티 센서 I2C 버스 설정
Wire.begin(21, 22);  // SDA=21, SCL=22
Wire.setClock(400000);  // 400kHz

센서 주소 할당:
- IMU (MPU9250): 0x68
- 압력센서: 0x77
- 온도센서: 0x48
```

### ADC 연결 (로드셀)
```cpp
// ESP32 ADC 설정 (12bit)
adc1_config_width(ADC_WIDTH_BIT_12);
adc1_config_channel_atten(ADC1_CHANNEL_0, ADC_ATTEN_DB_11);

// 멀티 샘플링으로 노이즈 감소
int samples = 16;
float avg = adcAverage(samples);
```

## 📐 PCB 레이아웃

### 배치 원칙
- 민감한 센서는 노이즈 소스에서 멀리
- 그라운드 플레인 충분히 확보
- 신호 라인 최대한 짧게
- 전원 디커플링 센서 근처 배치

### EMI 대책
```
노이즈 대책:
- 100nF 세라믹 커패시터 (고주파)
- 10μF 전해 커패시터 (저주파)
- 페라이트 비드 (EMI 억제)
- 차폐 케이스 (외부 간섭)
```

---

## 🔗 연결 문서
- 상위: [[전자회로설계]]
- 이론: [[환경인식]], [[상태추정]]
- 관련: [[신호조절]], [[센서시스템]]
- 응용: [[마이크로컨트롤러]]
## 🌐 최신 센서 트렌드와 인터페이스

### ToF (Time-of-Flight) 센서
```cpp
// VL53L0X 레이저 거리 센서
#include <VL53L0X.h>

VL53L0X sensor;

void setupToF() {
    sensor.init();
    sensor.setTimeout(500);
    sensor.startContinuous();
}

uint16_t readDistance() {
    return sensor.readRangeContinuousMillimeters();
}
```

### 다축 힘토크 센서 인터페이스
```cpp
// 6축 힘토크센서 (Fx, Fy, Fz, Mx, My, Mz)
// 6개 스트레인게이지 브리지 동시 측정

struct ForceData {
    float fx, fy, fz;  // 힘 [N]
    float mx, my, mz;  // 토크 [Nm]
};

ForceData readForceTorque() {
    ForceData ft;
    
    // 6채널 동시 ADC 읽기
    for(int i = 0; i < 6; i++) {
        selectMuxChannel(i);
        delayMicroseconds(100);
        rawADC[i] = ads1115.readADC_SingleEnded(0);
    }
    
    // 캘리브레이션 매트릭스 적용
    applyCalibraitonMatrix(&ft, rawADC);
    
    return ft;
}
```

### MEMS 관성센서 고급 활용
```cpp
// ICM-20948 9축 센서 (가속도+자이로+지자기)
// DMP (Digital Motion Processor) 활용

void setupICM20948() {
    icm.begin();
    icm.enableDMP(true);
    icm.setDMPODRrate(DMP_ODR_Reg_Quat9, 0);  // 쿼터니언 출력
}

void readQuaternion() {
    icm_20948_DMP_data_t data;
    icm.readDMPdataFromFIFO(&data);
    
    if(data.header & DMP_header_bitmap_Quat9) {
        float q0 = data.Quat9.Data.Q1 / 1073741824.0;
        float q1 = data.Quat9.Data.Q2 / 1073741824.0;
        float q2 = data.Quat9.Data.Q3 / 1073741824.0;
        float q3 = data.Quat9.Data.Q4 / 1073741824.0;
        
        // 쿼터니언 → 오일러각 변환
        convertToEuler(q0, q1, q2, q3);
    }
}
```

## 🔬 고급 신호 처리 기법

### 센서 융합 알고리즘
```cpp
// 확장 칼만 필터 기반 센서 융합
class SensorFusion {
private:
    Matrix<4,4> P;  // 오차 공분산
    Matrix<4,1> x;  // 상태벡터 [roll, pitch, yaw, bias]
    
public:
    void predict(float gyro_x, float gyro_y, float gyro_z, float dt) {
        // 예측 단계
        x(0) += (gyro_x - x(3)) * dt;  // roll
        x(1) += gyro_y * dt;           // pitch  
        x(2) += gyro_z * dt;           // yaw
        // x(3) = bias (불변)
        
        // 공분산 예측
        updateCovariancePredict(dt);
    }
    
    void update(float accel_roll, float accel_pitch, float mag_yaw) {
        // 측정값과 예측값 비교
        Matrix<3,1> z_measured = {accel_roll, accel_pitch, mag_yaw};
        Matrix<3,1> z_predicted = {x(0), x(1), x(2)};
        
        // 칼만 이득 계산 및 상태 업데이트
        updateState(z_measured, z_predicted);
    }
};
```

### 적응형 필터링
```cpp
// 센서 노이즈에 따른 적응형 가중치
class AdaptiveFilter {
private:
    float noise_threshold = 0.1;
    float trust_factor = 1.0;
    
public:
    float filterSensorData(float new_value, float old_value) {
        float diff = abs(new_value - old_value);
        
        if(diff > noise_threshold) {
            trust_factor *= 0.9;  // 신뢰도 감소
        } else {
            trust_factor = min(1.0, trust_factor + 0.01);  // 신뢰도 회복
        }
        
        float alpha = 0.1 * trust_factor;
        return alpha * new_value + (1-alpha) * old_value;
    }
};
```

## 🔧 산업용 센서 인터페이스

### 4-20mA 전류루프 인터페이스
```cpp
// 산업용 압력/온도 센서 (4-20mA 출력)
// 250Ω 정밀저항으로 전압 변환

float read4to20mA() {
    float voltage = analogRead(A0) * 5.0 / 1023.0;
    float current = voltage / 250.0;  // 250Ω 저항값
    
    // 4-20mA → 0-100% 스케일링
    float percentage = (current - 0.004) / 0.016 * 100.0;
    return constrain(percentage, 0, 100);
}

// 센서 고장 진단
bool diagnoseSensor() {
    float current = readCurrent();
    
    if(current < 0.0035) return false;      // 단선 오류
    if(current > 0.022) return false;       // 과전류 오류
    if(abs(current - 0.004) < 0.0005) {    // 하한값 고정
        return false;  // 센서 오류 가능성
    }
    
    return true;  // 정상
}
```

### RS-485 센서 네트워크
```cpp
// Modbus RTU 프로토콜로 다중 센서 통신
#include <ModbusMaster.h>

ModbusMaster node;

void setupRS485Network() {
    Serial1.begin(9600);  // RS-485 시리얼
    node.begin(1, Serial1);  // 슬레이브 ID=1
}

float readRemotePressure(uint8_t slave_id) {
    node.begin(slave_id, Serial1);
    
    uint8_t result = node.readHoldingRegisters(0x0001, 1);
    if(result == node.ku8MBSuccess) {
        uint16_t raw = node.getResponseBuffer(0);
        return raw * 0.01;  // 스케일 팩터 적용
    }
    
    return -1;  // 통신 오류
}
```

## 🛡️ 센서 보호 및 진단

### ESD 보호 강화
```
고급 ESD 보호 회로:
1차: TVS 다이오드 (PESD5V0S1BA)
2차: 폴리스위치 (PPTC)
3차: 페라이트 비드 + RC 필터

민감한 센서 (로드셀, 압력센서):
- 차폐 케이블 필수
- 절연 앰프 사용 (ISO124)
- 옵토커플러 절연
```

### 센서 자가진단 시스템
```cpp
class SensorDiagnostics {
private:
    struct SensorStatus {
        bool is_connected;
        float last_value;
        uint32_t last_update;
        uint16_t error_count;
    };
    
    SensorStatus sensors[MAX_SENSORS];
    
public:
    void checkSensorHealth(int sensor_id, float value) {
        SensorStatus* s = &sensors[sensor_id];
        
        // 연결 상태 확인
        if(abs(value - s->last_value) < 0.001 && 
           millis() - s->last_update > 1000) {
            s->error_count++;
            if(s->error_count > 10) {
                s->is_connected = false;
                Serial.printf("센서 %d 응답 없음\n", sensor_id);
            }
        } else {
            s->error_count = 0;
            s->is_connected = true;
        }
        
        s->last_value = value;
        s->last_update = millis();
    }
    
    void printDiagnostics() {
        for(int i = 0; i < MAX_SENSORS; i++) {
            if(!sensors[i].is_connected) {
                Serial.printf("센서 %d: 오류 상태\n", i);
            }
        }
    }
};
```