# ì„¼ì„œì¸í„°í˜ì´ìŠ¤

> ìƒìœ„: [[ì „ìíšŒë¡œì„¤ê³„]]

ë¡œë´‡ ì„¼ì„œ ì‹ í˜¸ë¥¼ ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì— ì—°ê²°í•˜ëŠ” ì¸í„°í˜ì´ìŠ¤ íšŒë¡œ ì„¤ê³„ì…ë‹ˆë‹¤.

## ğŸ“¡ ì£¼ìš” ì„¼ì„œ ì¸í„°í˜ì´ìŠ¤

### ì—”ì½”ë” ì¸í„°í˜ì´ìŠ¤
- **ì•±ì†”ë£¨íŠ¸ ì—”ì½”ë”**: ë””ì§€í„¸ ì¶œë ¥ (5V ë¡œì§)
- Pull-up ì €í•­ í•„ìš” (4.7kÎ©)
- ë…¸ì´ì¦ˆ í•„í„°ë§: RC í•„í„° (100Î© + 100nF)
- **ìš©ë„**: ë¡œí”„ ê°ë„ ì¸¡ì • ëª¨ë“ˆ

### IMU ì„¼ì„œ ì¸í„°í˜ì´ìŠ¤
- **MPU-9250**: I2C í†µì‹  (ì£¼ì†Œ: 0x68)
- ì „ì›: 3.3V, ì €ë…¸ì´ì¦ˆ LDO í•„ìˆ˜
- ë””ì»¤í”Œë§: 100nF + 10Î¼F
- **ìš©ë„**: ê°€ì†ë„ ì„¼ì„œ í™œìš© IMU ëª¨ë“ˆ

### ë¡œë“œì…€ ì¸í„°í˜ì´ìŠ¤
- **ê³„ì¸¡ì¦í­ê¸°**: INA128 (ì´ë“ ì„¤ì • ì €í•­ Rg)
- 24bit ADC: HX711 ë˜ëŠ” AD7730
- ë¸Œë¦¬ì§€ ì—¬ì ì „ì••: 5V ì•ˆì •í™”
- **ìš©ë„**: í˜ì„¼ì„œ ì¥ë ¥ì¸¡ì •, FTì„¼ì„œ ë°˜ë ¥ì¸¡ì •

## ğŸ”Œ íšŒë¡œ ì„¤ê³„ ì›ì¹™

### ì „ì› ê³µê¸‰
```
ì„¼ì„œë³„ ì „ì› ìš”êµ¬ì‚¬í•­:
- ì—”ì½”ë”: 5V, 50-200mA
- IMU: 3.3V, 1-10mA
- ë¡œë“œì…€: 5-12V, 10-50mA
```

### ì‹ í˜¸ ì¡°ì ˆ
- **ì „ì•• ë¶„ë°°ê¸°**: 5V â†’ 3.3V ë ˆë²¨ ë³€í™˜
- **ë²„í¼ ì•°í”„**: ì„í”¼ë˜ìŠ¤ ë§¤ì¹­
- **LPF í•„í„°**: ê³ ì£¼íŒŒ ë…¸ì´ì¦ˆ ì œê±°

### ë³´í˜¸ íšŒë¡œ
- ESD ë³´í˜¸: TVS ë‹¤ì´ì˜¤ë“œ
- ê³¼ì „ì•• ë³´í˜¸: ì œë„ˆ ë‹¤ì´ì˜¤ë“œ
- ì—­ì „ì•• ë³´í˜¸: ì‡¼íŠ¸í‚¤ ë‹¤ì´ì˜¤ë“œ

## âš¡ ESP32 ì—°ê²° ì˜ˆì‹œ

### I2C ì„¼ì„œ ì—°ê²°
```cpp
// ë©€í‹° ì„¼ì„œ I2C ë²„ìŠ¤ ì„¤ì •
Wire.begin(21, 22);  // SDA=21, SCL=22
Wire.setClock(400000);  // 400kHz

ì„¼ì„œ ì£¼ì†Œ í• ë‹¹:
- IMU (MPU9250): 0x68
- ì••ë ¥ì„¼ì„œ: 0x77
- ì˜¨ë„ì„¼ì„œ: 0x48
```

### ADC ì—°ê²° (ë¡œë“œì…€)
```cpp
// ESP32 ADC ì„¤ì • (12bit)
adc1_config_width(ADC_WIDTH_BIT_12);
adc1_config_channel_atten(ADC1_CHANNEL_0, ADC_ATTEN_DB_11);

// ë©€í‹° ìƒ˜í”Œë§ìœ¼ë¡œ ë…¸ì´ì¦ˆ ê°ì†Œ
int samples = 16;
float avg = adcAverage(samples);
```

## ğŸ“ PCB ë ˆì´ì•„ì›ƒ

### ë°°ì¹˜ ì›ì¹™
- ë¯¼ê°í•œ ì„¼ì„œëŠ” ë…¸ì´ì¦ˆ ì†ŒìŠ¤ì—ì„œ ë©€ë¦¬
- ê·¸ë¼ìš´ë“œ í”Œë ˆì¸ ì¶©ë¶„íˆ í™•ë³´
- ì‹ í˜¸ ë¼ì¸ ìµœëŒ€í•œ ì§§ê²Œ
- ì „ì› ë””ì»¤í”Œë§ ì„¼ì„œ ê·¼ì²˜ ë°°ì¹˜

### EMI ëŒ€ì±…
```
ë…¸ì´ì¦ˆ ëŒ€ì±…:
- 100nF ì„¸ë¼ë¯¹ ì»¤íŒ¨ì‹œí„° (ê³ ì£¼íŒŒ)
- 10Î¼F ì „í•´ ì»¤íŒ¨ì‹œí„° (ì €ì£¼íŒŒ)
- í˜ë¼ì´íŠ¸ ë¹„ë“œ (EMI ì–µì œ)
- ì°¨í ì¼€ì´ìŠ¤ (ì™¸ë¶€ ê°„ì„­)
```

---

## ğŸ”— ì—°ê²° ë¬¸ì„œ
- ìƒìœ„: [[ì „ìíšŒë¡œì„¤ê³„]]
- ì´ë¡ : [[í™˜ê²½ì¸ì‹]], [[ìƒíƒœì¶”ì •]]
- ê´€ë ¨: [[ì‹ í˜¸ì¡°ì ˆ]], [[ì„¼ì„œì‹œìŠ¤í…œ]]
- ì‘ìš©: [[ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬]]
## ğŸŒ ìµœì‹  ì„¼ì„œ íŠ¸ë Œë“œì™€ ì¸í„°í˜ì´ìŠ¤

### ToF (Time-of-Flight) ì„¼ì„œ
```cpp
// VL53L0X ë ˆì´ì € ê±°ë¦¬ ì„¼ì„œ
#include <VL53L0X.h>

VL53L0X sensor;

void setupToF() {
    sensor.init();
    sensor.setTimeout(500);
    sensor.startContinuous();
}

uint16_t readDistance() {
    return sensor.readRangeContinuousMillimeters();
}
```

### ë‹¤ì¶• í˜í† í¬ ì„¼ì„œ ì¸í„°í˜ì´ìŠ¤
```cpp
// 6ì¶• í˜í† í¬ì„¼ì„œ (Fx, Fy, Fz, Mx, My, Mz)
// 6ê°œ ìŠ¤íŠ¸ë ˆì¸ê²Œì´ì§€ ë¸Œë¦¬ì§€ ë™ì‹œ ì¸¡ì •

struct ForceData {
    float fx, fy, fz;  // í˜ [N]
    float mx, my, mz;  // í† í¬ [Nm]
};

ForceData readForceTorque() {
    ForceData ft;
    
    // 6ì±„ë„ ë™ì‹œ ADC ì½ê¸°
    for(int i = 0; i < 6; i++) {
        selectMuxChannel(i);
        delayMicroseconds(100);
        rawADC[i] = ads1115.readADC_SingleEnded(0);
    }
    
    // ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ë§¤íŠ¸ë¦­ìŠ¤ ì ìš©
    applyCalibraitonMatrix(&ft, rawADC);
    
    return ft;
}
```

### MEMS ê´€ì„±ì„¼ì„œ ê³ ê¸‰ í™œìš©
```cpp
// ICM-20948 9ì¶• ì„¼ì„œ (ê°€ì†ë„+ìì´ë¡œ+ì§€ìê¸°)
// DMP (Digital Motion Processor) í™œìš©

void setupICM20948() {
    icm.begin();
    icm.enableDMP(true);
    icm.setDMPODRrate(DMP_ODR_Reg_Quat9, 0);  // ì¿¼í„°ë‹ˆì–¸ ì¶œë ¥
}

void readQuaternion() {
    icm_20948_DMP_data_t data;
    icm.readDMPdataFromFIFO(&data);
    
    if(data.header & DMP_header_bitmap_Quat9) {
        float q0 = data.Quat9.Data.Q1 / 1073741824.0;
        float q1 = data.Quat9.Data.Q2 / 1073741824.0;
        float q2 = data.Quat9.Data.Q3 / 1073741824.0;
        float q3 = data.Quat9.Data.Q4 / 1073741824.0;
        
        // ì¿¼í„°ë‹ˆì–¸ â†’ ì˜¤ì¼ëŸ¬ê° ë³€í™˜
        convertToEuler(q0, q1, q2, q3);
    }
}
```

## ğŸ”¬ ê³ ê¸‰ ì‹ í˜¸ ì²˜ë¦¬ ê¸°ë²•

### ì„¼ì„œ ìœµí•© ì•Œê³ ë¦¬ì¦˜
```cpp
// í™•ì¥ ì¹¼ë§Œ í•„í„° ê¸°ë°˜ ì„¼ì„œ ìœµí•©
class SensorFusion {
private:
    Matrix<4,4> P;  // ì˜¤ì°¨ ê³µë¶„ì‚°
    Matrix<4,1> x;  // ìƒíƒœë²¡í„° [roll, pitch, yaw, bias]
    
public:
    void predict(float gyro_x, float gyro_y, float gyro_z, float dt) {
        // ì˜ˆì¸¡ ë‹¨ê³„
        x(0) += (gyro_x - x(3)) * dt;  // roll
        x(1) += gyro_y * dt;           // pitch  
        x(2) += gyro_z * dt;           // yaw
        // x(3) = bias (ë¶ˆë³€)
        
        // ê³µë¶„ì‚° ì˜ˆì¸¡
        updateCovariancePredict(dt);
    }
    
    void update(float accel_roll, float accel_pitch, float mag_yaw) {
        // ì¸¡ì •ê°’ê³¼ ì˜ˆì¸¡ê°’ ë¹„êµ
        Matrix<3,1> z_measured = {accel_roll, accel_pitch, mag_yaw};
        Matrix<3,1> z_predicted = {x(0), x(1), x(2)};
        
        // ì¹¼ë§Œ ì´ë“ ê³„ì‚° ë° ìƒíƒœ ì—…ë°ì´íŠ¸
        updateState(z_measured, z_predicted);
    }
};
```

### ì ì‘í˜• í•„í„°ë§
```cpp
// ì„¼ì„œ ë…¸ì´ì¦ˆì— ë”°ë¥¸ ì ì‘í˜• ê°€ì¤‘ì¹˜
class AdaptiveFilter {
private:
    float noise_threshold = 0.1;
    float trust_factor = 1.0;
    
public:
    float filterSensorData(float new_value, float old_value) {
        float diff = abs(new_value - old_value);
        
        if(diff > noise_threshold) {
            trust_factor *= 0.9;  // ì‹ ë¢°ë„ ê°ì†Œ
        } else {
            trust_factor = min(1.0, trust_factor + 0.01);  // ì‹ ë¢°ë„ íšŒë³µ
        }
        
        float alpha = 0.1 * trust_factor;
        return alpha * new_value + (1-alpha) * old_value;
    }
};
```

## ğŸ”§ ì‚°ì—…ìš© ì„¼ì„œ ì¸í„°í˜ì´ìŠ¤

### 4-20mA ì „ë¥˜ë£¨í”„ ì¸í„°í˜ì´ìŠ¤
```cpp
// ì‚°ì—…ìš© ì••ë ¥/ì˜¨ë„ ì„¼ì„œ (4-20mA ì¶œë ¥)
// 250Î© ì •ë°€ì €í•­ìœ¼ë¡œ ì „ì•• ë³€í™˜

float read4to20mA() {
    float voltage = analogRead(A0) * 5.0 / 1023.0;
    float current = voltage / 250.0;  // 250Î© ì €í•­ê°’
    
    // 4-20mA â†’ 0-100% ìŠ¤ì¼€ì¼ë§
    float percentage = (current - 0.004) / 0.016 * 100.0;
    return constrain(percentage, 0, 100);
}

// ì„¼ì„œ ê³ ì¥ ì§„ë‹¨
bool diagnoseSensor() {
    float current = readCurrent();
    
    if(current < 0.0035) return false;      // ë‹¨ì„  ì˜¤ë¥˜
    if(current > 0.022) return false;       // ê³¼ì „ë¥˜ ì˜¤ë¥˜
    if(abs(current - 0.004) < 0.0005) {    // í•˜í•œê°’ ê³ ì •
        return false;  // ì„¼ì„œ ì˜¤ë¥˜ ê°€ëŠ¥ì„±
    }
    
    return true;  // ì •ìƒ
}
```

### RS-485 ì„¼ì„œ ë„¤íŠ¸ì›Œí¬
```cpp
// Modbus RTU í”„ë¡œí† ì½œë¡œ ë‹¤ì¤‘ ì„¼ì„œ í†µì‹ 
#include <ModbusMaster.h>

ModbusMaster node;

void setupRS485Network() {
    Serial1.begin(9600);  // RS-485 ì‹œë¦¬ì–¼
    node.begin(1, Serial1);  // ìŠ¬ë ˆì´ë¸Œ ID=1
}

float readRemotePressure(uint8_t slave_id) {
    node.begin(slave_id, Serial1);
    
    uint8_t result = node.readHoldingRegisters(0x0001, 1);
    if(result == node.ku8MBSuccess) {
        uint16_t raw = node.getResponseBuffer(0);
        return raw * 0.01;  // ìŠ¤ì¼€ì¼ íŒ©í„° ì ìš©
    }
    
    return -1;  // í†µì‹  ì˜¤ë¥˜
}
```

## ğŸ›¡ï¸ ì„¼ì„œ ë³´í˜¸ ë° ì§„ë‹¨

### ESD ë³´í˜¸ ê°•í™”
```
ê³ ê¸‰ ESD ë³´í˜¸ íšŒë¡œ:
1ì°¨: TVS ë‹¤ì´ì˜¤ë“œ (PESD5V0S1BA)
2ì°¨: í´ë¦¬ìŠ¤ìœ„ì¹˜ (PPTC)
3ì°¨: í˜ë¼ì´íŠ¸ ë¹„ë“œ + RC í•„í„°

ë¯¼ê°í•œ ì„¼ì„œ (ë¡œë“œì…€, ì••ë ¥ì„¼ì„œ):
- ì°¨í ì¼€ì´ë¸” í•„ìˆ˜
- ì ˆì—° ì•°í”„ ì‚¬ìš© (ISO124)
- ì˜µí† ì»¤í”ŒëŸ¬ ì ˆì—°
```

### ì„¼ì„œ ìê°€ì§„ë‹¨ ì‹œìŠ¤í…œ
```cpp
class SensorDiagnostics {
private:
    struct SensorStatus {
        bool is_connected;
        float last_value;
        uint32_t last_update;
        uint16_t error_count;
    };
    
    SensorStatus sensors[MAX_SENSORS];
    
public:
    void checkSensorHealth(int sensor_id, float value) {
        SensorStatus* s = &sensors[sensor_id];
        
        // ì—°ê²° ìƒíƒœ í™•ì¸
        if(abs(value - s->last_value) < 0.001 && 
           millis() - s->last_update > 1000) {
            s->error_count++;
            if(s->error_count > 10) {
                s->is_connected = false;
                Serial.printf("ì„¼ì„œ %d ì‘ë‹µ ì—†ìŒ\n", sensor_id);
            }
        } else {
            s->error_count = 0;
            s->is_connected = true;
        }
        
        s->last_value = value;
        s->last_update = millis();
    }
    
    void printDiagnostics() {
        for(int i = 0; i < MAX_SENSORS; i++) {
            if(!sensors[i].is_connected) {
                Serial.printf("ì„¼ì„œ %d: ì˜¤ë¥˜ ìƒíƒœ\n", i);
            }
        }
    }
};
```