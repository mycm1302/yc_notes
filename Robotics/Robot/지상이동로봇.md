# 지상이동로봇 (Terrestrial Mobile Robots)

## 📖 주요 참고문헌
> **핵심 교과서**: *Introduction to Autonomous Mobile Robots* by Roland Siegwart, Illah R. Nourbakhsh, Davide Scaramuzza (MIT Press)
> **보조 교과서**: *Probabilistic Robotics* by Sebastian Thrun, Wolfram Burgard, Dieter Fox
> **참고서적**: *Principles of Robot Motion* by Howie Choset, *Mobile Robotics* by Alonzo Kelly

## 🎯 정의 및 특징

**지상이동로봇**은 바퀴, 궤도, 또는 기타 이동 메커니즘을 사용하여 지면에서 이동하는 로봇으로, 자율 내비게이션과 다양한 임무 수행이 가능한 시스템입니다.

### 🚗 구조적 분류

#### 바퀴 구동 방식
```
차동 구동 (Differential Drive):
- 2개 독립 구동바퀴 + 캐스터/볼 바퀴
- 간단한 제어, 제자리 회전 가능
- 실내 로봇에 널리 사용

아커만 조향 (Ackermann Steering):
- 전륜 조향 + 후륜 구동
- 자동차와 동일한 방식
- 고속 주행에 적합

전방향 구동 (Omnidirectional):
- 메카넘 휠 또는 옴니 휠
- 모든 방향 즉시 이동 가능
- 좁은 공간에서 유리

궤도 구동 (Tracked):
- 무한궤도 사용
- 높은 견인력과 지형 적응성
- 험지, 군사용에 적합
```

### ⚡ 장점
- **효율적 이동**: 평지에서 높은 에너지 효율
- **높은 속도**: 빠른 이동 속도 달성 가능
- **정확한 제어**: 예측 가능한 운동학
- **안정성**: 정적 안정성 확보

### ⚠️ 제약 사항
- **지형 제약**: 계단, 장애물 통과 어려움
- **견인력 의존**: 미끄러운 표면에서 성능 저하
- **기동성 제한**: 일부 구동 방식의 운동 제약
- **접지압**: 연약지반에서 매몰 위험

## 🔧 이동 로봇 기구학

### 1. 차동 구동 로봇

#### 운동학 모델
```python
class DifferentialDriveRobot:
    """차동 구동 로봇 기구학"""
    
    def __init__(self, wheel_radius, wheel_base):
        self.r = wheel_radius      # 바퀴 반지름
        self.L = wheel_base        # 바퀴 간격
    
    def forward_kinematics(self, wheel_velocities):
        """순기구학: 바퀴 속도 → 로봇 속도"""
        
        v_left, v_right = wheel_velocities
        
        # 로봇 중심점의 선속도
        v = self.r * (v_right + v_left) / 2
        
        # 로봇의 각속도
        omega = self.r * (v_right - v_left) / self.L
        
        return v, omega
    
    def inverse_kinematics(self, robot_velocity):
        """역기구학: 로봇 속도 → 바퀴 속도"""
        
        v, omega = robot_velocity
        
        # 좌측 바퀴 속도
        v_left = (v - omega * self.L / 2) / self.r
        
        # 우측 바퀴 속도  
        v_right = (v + omega * self.L / 2) / self.r
        
        return v_left, v_right
    
    def pose_update(self, pose, velocities, dt):
        """포즈 업데이트 (적분)"""
        
        x, y, theta = pose
        v, omega = velocities
        
        # 오일러 적분
        x_new = x + v * np.cos(theta) * dt
        y_new = y + v * np.sin(theta) * dt
        theta_new = theta + omega * dt
        
        # 각도 정규화
        theta_new = self.normalize_angle(theta_new)
        
        return np.array([x_new, y_new, theta_new])
    
    def motion_model(self, pose, controls, dt):
        """운동 모델 (노이즈 포함)"""
        
        # 제어 입력에 노이즈 추가
        v_cmd, omega_cmd = controls
        
        # 운동 노이즈 매개변수
        alpha1, alpha2, alpha3, alpha4 = 0.1, 0.1, 0.1, 0.1
        
        v_actual = v_cmd + np.random.normal(0, alpha1 * abs(v_cmd) + alpha2 * abs(omega_cmd))
        omega_actual = omega_cmd + np.random.normal(0, alpha3 * abs(v_cmd) + alpha4 * abs(omega_cmd))
        
        # 포즈 업데이트
        new_pose = self.pose_update(pose, (v_actual, omega_actual), dt)
        
        return new_pose
```

### 2. 아커만 조향 로봇

#### 아커만 기하학
```python
class AckermannSteeringRobot:
    """아커만 조향 로봇 기구학"""
    
    def __init__(self, wheelbase, track_width):
        self.L = wheelbase         # 축간거리
        self.W = track_width       # 윤거
    
    def ackermann_angles(self, steering_angle, side='inner'):
        """아커만 조향각 계산"""
        
        if side == 'inner':
            # 내측 바퀴 조향각
            delta_inner = np.arctan(self.L / (self.L / np.tan(steering_angle) - self.W/2))
            return delta_inner
        else:
            # 외측 바퀴 조향각
            delta_outer = np.arctan(self.L / (self.L / np.tan(steering_angle) + self.W/2))
            return delta_outer
    
    def turning_radius(self, steering_angle):
        """회전 반지름"""
        
        if abs(steering_angle) < 1e-6:
            return float('inf')  # 직진
        
        R = self.L / np.tan(steering_angle)
        return abs(R)
    
    def bicycle_model(self, pose, controls, dt):
        """자전거 모델 (단순화된 아커만 모델)"""
        
        x, y, theta = pose
        v, delta = controls  # 속도, 조향각
        
        # 운동 방정식
        x_dot = v * np.cos(theta)
        y_dot = v * np.sin(theta)
        theta_dot = v * np.tan(delta) / self.L
        
        # 적분
        x_new = x + x_dot * dt
        y_new = y + y_dot * dt
        theta_new = theta + theta_dot * dt
        
        return np.array([x_new, y_new, theta_new])
```

### 3. 전방향 이동 로봇

#### 메카넘 휠
```python
class MecanumWheelRobot:
    """메카넘 휠 로봇 기구학"""
    
    def __init__(self, wheel_radius, robot_geometry):
        self.r = wheel_radius
        self.lx = robot_geometry['length'] / 2    # 전후 바퀴 간격의 절반
        self.ly = robot_geometry['width'] / 2     # 좌우 바퀴 간격의 절반
    
    def forward_kinematics(self, wheel_speeds):
        """순기구학: 바퀴 속도 → 로봇 속도"""
        
        w1, w2, w3, w4 = wheel_speeds  # 전좌, 전우, 후좌, 후우
        
        # 기구학 행렬
        # [vx]   r  [ 1  1  1  1] [w1]
        # [vy] = - [1 -1 -1  1] [w2]
        # [wz]   4  [1 -1  1 -1] [w3]
        #           [           ] [w4]
        
        vx = self.r / 4 * (w1 + w2 + w3 + w4)
        vy = self.r / 4 * (w1 - w2 - w3 + w4)
        wz = self.r / (4 * (self.lx + self.ly)) * (w1 - w2 + w3 - w4)
        
        return np.array([vx, vy, wz])
    
    def inverse_kinematics(self, robot_velocity):
        """역기구학: 로봇 속도 → 바퀴 속도"""
        
        vx, vy, wz = robot_velocity
        
        # 역 기구학 행렬
        w1 = (vx + vy + wz * (self.lx + self.ly)) / self.r
        w2 = (vx - vy - wz * (self.lx + self.ly)) / self.r
        w3 = (vx - vy + wz * (self.lx + self.ly)) / self.r
        w4 = (vx + vy - wz * (self.lx + self.ly)) / self.r
        
        return np.array([w1, w2, w3, w4])
    
    def holonomic_motion(self, pose, velocity_command, dt):
        """홀로노믹 운동"""
        
        x, y, theta = pose
        vx_body, vy_body, wz = velocity_command
        
        # 몸체 좌표계 속도를 전역 좌표계로 변환
        vx_global = vx_body * np.cos(theta) - vy_body * np.sin(theta)
        vy_global = vx_body * np.sin(theta) + vy_body * np.cos(theta)
        
        # 포즈 업데이트
        x_new = x + vx_global * dt
        y_new = y + vy_global * dt
        theta_new = theta + wz * dt
        
        return np.array([x_new, y_new, theta_new])
```

## 🗺️ 지역화 및 매핑 (SLAM)

### 1. 확률적 지역화

#### 몬테카를로 지역화 (MCL)
```python
class MonteCarloLocalization:
    """몬테카를로 지역화 (파티클 필터)"""
    
    def __init__(self, num_particles, map_data, motion_model, sensor_model):
        self.num_particles = num_particles
        self.map = map_data
        self.motion_model = motion_model
        self.sensor_model = sensor_model
        
        # 파티클 초기화
        self.particles = self.initialize_particles()
        self.weights = np.ones(num_particles) / num_particles
    
    def predict(self, control_input, dt):
        """예측 단계 (운동 모델)"""
        
        for i in range(self.num_particles):
            # 각 파티클에 운동 모델 적용 (노이즈 포함)
            self.particles[i] = self.motion_model.sample(
                self.particles[i], control_input, dt)
    
    def update(self, sensor_measurement):
        """업데이트 단계 (센서 모델)"""
        
        for i in range(self.num_particles):
            # 각 파티클에서 예상되는 센서 측정값
            expected_measurement = self.sensor_model.expected_measurement(
                self.particles[i], self.map)
            
            # 실제 측정값과의 유사도 계산
            self.weights[i] = self.sensor_model.likelihood(
                sensor_measurement, expected_measurement)
        
        # 가중치 정규화
        self.weights /= np.sum(self.weights)
    
    def resample(self):
        """리샘플링 (중요도 재샘플링)"""
        
        # 유효 샘플 크기 계산
        n_eff = 1.0 / np.sum(self.weights**2)
        
        if n_eff < self.num_particles / 2:  # 리샘플링 임계값
            # 체계적 리샘플링
            indices = self.systematic_resampling(self.weights)
            self.particles = self.particles[indices]
            self.weights = np.ones(self.num_particles) / self.num_particles
    
    def estimate_pose(self):
        """포즈 추정 (가중 평균)"""
        
        # 가중 평균으로 포즈 추정
        mean_pose = np.average(self.particles, weights=self.weights, axis=0)
        
        # 공분산 계산
        cov = np.cov(self.particles.T, aweights=self.weights)
        
        return mean_pose, cov
```

#### 확장 칼만 필터 지역화 (EKF)
```python
class EKFLocalization:
    """확장 칼만 필터 지역화"""
    
    def __init__(self, initial_state, initial_covariance):
        self.state = initial_state      # [x, y, theta]
        self.covariance = initial_covariance
    
    def predict(self, control_input, dt):
        """예측 단계"""
        
        # 운동 모델
        self.state = self.motion_model(self.state, control_input, dt)
        
        # 야코비안 계산
        F = self.motion_jacobian(self.state, control_input, dt)
        
        # 공분산 예측
        Q = self.process_noise_covariance(control_input, dt)
        self.covariance = F @ self.covariance @ F.T + Q
    
    def update(self, landmark_observations):
        """업데이트 단계"""
        
        for observation in landmark_observations:
            landmark_id, range_bearing = observation
            
            # 예상 관측값
            expected_obs = self.observation_model(self.state, landmark_id)
            
            # 혁신 (innovation)
            innovation = range_bearing - expected_obs
            innovation[1] = self.normalize_angle(innovation[1])  # 각도 정규화
            
            # 관측 야코비안
            H = self.observation_jacobian(self.state, landmark_id)
            
            # 칼만 게인
            R = self.measurement_noise_covariance()
            S = H @ self.covariance @ H.T + R
            K = self.covariance @ H.T @ np.linalg.inv(S)
            
            # 상태 업데이트
            self.state = self.state + K @ innovation
            
            # 공분산 업데이트
            I = np.eye(len(self.state))
            self.covariance = (I - K @ H) @ self.covariance
    
    def observation_model(self, pose, landmark_id):
        """관측 모델: 포즈 → 예상 관측값"""
        
        x, y, theta = pose
        lx, ly = self.get_landmark_position(landmark_id)
        
        # 거리
        dx = lx - x
        dy = ly - y
        range_pred = np.sqrt(dx**2 + dy**2)
        
        # 방위각
        bearing_pred = np.arctan2(dy, dx) - theta
        bearing_pred = self.normalize_angle(bearing_pred)
        
        return np.array([range_pred, bearing_pred])
```

### 2. SLAM (동시 지역화 및 매핑)

#### FastSLAM
```python
class FastSLAM:
    """FastSLAM 알고리즘"""
    
    def __init__(self, num_particles):
        self.num_particles = num_particles
        self.particles = []
        
        # 각 파티클은 로봇 궤적과 랜드마크 EKF들을 가짐
        for i in range(num_particles):
            particle = {
                'trajectory': [],
                'weight': 1.0 / num_particles,
                'landmark_ekfs': {}  # 랜드마크별 EKF
            }
            self.particles.append(particle)
    
    def process_control(self, control_input, dt):
        """제어 입력 처리"""
        
        for particle in self.particles:
            # 운동 모델로 새로운 포즈 샘플링
            if len(particle['trajectory']) > 0:
                current_pose = particle['trajectory'][-1]
            else:
                current_pose = np.array([0, 0, 0])  # 초기 포즈
            
            new_pose = self.sample_motion_model(current_pose, control_input, dt)
            particle['trajectory'].append(new_pose)
    
    def process_measurement(self, observations):
        """센서 측정값 처리"""
        
        for i, particle in enumerate(self.particles):
            current_pose = particle['trajectory'][-1]
            log_weight = 0
            
            for obs in observations:
                landmark_id, measurement = obs
                
                if landmark_id not in particle['landmark_ekfs']:
                    # 새로운 랜드마크 초기화
                    particle['landmark_ekfs'][landmark_id] = self.initialize_landmark_ekf(
                        current_pose, measurement)
                else:
                    # 기존 랜드마크 업데이트
                    ekf = particle['landmark_ekfs'][landmark_id]
                    likelihood = self.update_landmark_ekf(ekf, current_pose, measurement)
                    log_weight += np.log(likelihood)
            
            # 파티클 가중치 업데이트
            particle['weight'] *= np.exp(log_weight)
        
        # 가중치 정규화
        total_weight = sum(p['weight'] for p in self.particles)
        for particle in self.particles:
            particle['weight'] /= total_weight
        
        # 리샘플링
        self.resample_particles()
    
    def initialize_landmark_ekf(self, robot_pose, measurement):
        """새 랜드마크 EKF 초기화"""
        
        x, y, theta = robot_pose
        range_meas, bearing_meas = measurement
        
        # 랜드마크 위치 초기 추정
        lx = x + range_meas * np.cos(theta + bearing_meas)
        ly = y + range_meas * np.sin(theta + bearing_meas)
        
        # EKF 상태 및 공분산 초기화
        landmark_state = np.array([lx, ly])
        landmark_cov = np.eye(2) * 10.0  # 큰 불확실성
        
        return {'state': landmark_state, 'covariance': landmark_cov}
```

#### 그래프 기반 SLAM
```python
class GraphSLAM:
    """그래프 기반 SLAM"""
    
    def __init__(self):
        self.poses = {}           # 포즈 노드들
        self.landmarks = {}       # 랜드마크 노드들
        self.pose_edges = []      # 포즈간 제약
        self.observation_edges = [] # 관측 제약
    
    def add_pose_node(self, pose_id, initial_pose):
        """포즈 노드 추가"""
        self.poses[pose_id] = initial_pose
    
    def add_landmark_node(self, landmark_id, initial_position):
        """랜드마크 노드 추가"""
        self.landmarks[landmark_id] = initial_position
    
    def add_pose_constraint(self, pose1_id, pose2_id, relative_pose, information_matrix):
        """포즈간 제약 추가 (오도메트리)"""
        constraint = {
            'pose1': pose1_id,
            'pose2': pose2_id,
            'measurement': relative_pose,
            'information': information_matrix
        }
        self.pose_edges.append(constraint)
    
    def add_observation_constraint(self, pose_id, landmark_id, observation, information_matrix):
        """관측 제약 추가"""
        constraint = {
            'pose': pose_id,
            'landmark': landmark_id,
            'measurement': observation,
            'information': information_matrix
        }
        self.observation_edges.append(constraint)
    
    def optimize(self, max_iterations=100):
        """비선형 최적화 (가우스-뉴튼)"""
        
        for iteration in range(max_iterations):
            # 헤시안 행렬과 b 벡터 구성
            H, b = self.linearize_and_solve()
            
            # 시스템 해결: H * dx = -b
            dx = self.solve_linear_system(H, -b)
            
            # 상태 업데이트
            self.update_state(dx)
            
            # 수렴 확인
            if np.linalg.norm(dx) < 1e-6:
                break
    
    def linearize_and_solve(self):
        """선형화 및 정보 행렬 구성"""
        
        # 상태 벡터 차원 계산
        state_dim = len(self.poses) * 3 + len(self.landmarks) * 2
        
        H = np.zeros((state_dim, state_dim))
        b = np.zeros(state_dim)
        
        # 포즈 제약 처리
        for edge in self.pose_edges:
            error, jacobian = self.compute_pose_error_and_jacobian(edge)
            
            # 정보 행렬 업데이트
            H += jacobian.T @ edge['information'] @ jacobian
            b += jacobian.T @ edge['information'] @ error
        
        # 관측 제약 처리
        for edge in self.observation_edges:
            error, jacobian = self.compute_observation_error_and_jacobian(edge)
            
            # 정보 행렬 업데이트
            H += jacobian.T @ edge['information'] @ jacobian
            b += jacobian.T @ edge['information'] @ error
        
        return H, b
```

## 🎯 경로 계획 및 내비게이션

### 1. 전역 경로 계획

#### Dijkstra 알고리즘
```python
class GlobalPathPlanner:
    """전역 경로 계획기"""
    
    def __init__(self, occupancy_grid, resolution):
        self.grid = occupancy_grid
        self.resolution = resolution
        self.height, self.width = occupancy_grid.shape
    
    def dijkstra(self, start, goal):
        """Dijkstra 경로 계획"""
        
        # 거리 맵 초기화
        distances = np.full((self.height, self.width), np.inf)
        visited = np.zeros((self.height, self.width), dtype=bool)
        previous = {}
        
        # 시작점 설정
        start_idx = self.world_to_grid(start)
        distances[start_idx] = 0
        
        # 우선순위 큐
        pq = [(0, start_idx)]
        
        while pq:
            current_dist, current = heapq.heappop(pq)
            
            if visited[current]:
                continue
            
            visited[current] = True
            
            # 목표점 도달 확인
            goal_idx = self.world_to_grid(goal)
            if current == goal_idx:
                return self.reconstruct_path(previous, current)
            
            # 이웃 탐색
            for neighbor in self.get_neighbors(current):
                if self.is_valid_cell(neighbor) and not visited[neighbor]:
                    # 이동 비용 계산
                    move_cost = self.get_move_cost(current, neighbor)
                    new_dist = current_dist + move_cost
                    
                    if new_dist < distances[neighbor]:
                        distances[neighbor] = new_dist
                        previous[neighbor] = current
                        heapq.heappush(pq, (new_dist, neighbor))
        
        return None  # 경로 없음
    
    def get_move_cost(self, from_cell, to_cell):
        """이동 비용 계산"""
        
        # 장애물 확인
        if self.grid[to_cell] > 0.5:  # 점유 확률 50% 이상
            return np.inf
        
        # 대각선 이동 비용 (√2), 직선 이동 비용 (1)
        dx = abs(to_cell[0] - from_cell[0])
        dy = abs(to_cell[1] - from_cell[1])
        
        if dx + dy == 1:
            return 1.0  # 직선 이동
        else:
            return 1.414  # 대각선 이동
```

#### A* 알고리즘 개선
```python
class AStarPlanner:
    """A* 경로 계획기 (개선된 버전)"""
    
    def __init__(self, occupancy_grid, resolution):
        self.grid = occupancy_grid
        self.resolution = resolution
        self.height, self.width = occupancy_grid.shape
    
    def a_star_with_smoothing(self, start, goal):
        """부드러운 경로를 위한 개선된 A*"""
        
        # 표준 A* 실행
        raw_path = self.a_star(start, goal)
        
        if raw_path is None:
            return None
        
        # 경로 스무딩
        smooth_path = self.smooth_path(raw_path)
        
        return smooth_path
    
    def smooth_path(self, path):
        """경로 스무딩 (더글라스-포이커 알고리즘)"""
        
        if len(path) <= 2:
            return path
        
        smoothed = [path[0]]  # 시작점
        
        i = 0
        while i < len(path) - 1:
            # 직선으로 연결 가능한 가장 먼 점 찾기
            max_j = i + 1
            
            for j in range(i + 2, len(path)):
                if self.line_of_sight(path[i], path[j]):
                    max_j = j
                else:
                    break
            
            smoothed.append(path[max_j])
            i = max_j
        
        return smoothed
    
    def line_of_sight(self, point1, point2):
        """두 점 사이 가시선 확인 (브레젠햄 알고리즘)"""
        
        x1, y1 = self.world_to_grid(point1)
        x2, y2 = self.world_to_grid(point2)
        
        # 브레젠햄 직선 알고리즘
        points = self.bresenham_line(x1, y1, x2, y2)
        
        # 모든 점이 자유공간인지 확인
        for x, y in points:
            if not self.is_free_cell((x, y)):
                return False
        
        return True
```

### 2. 지역 경로 계획

#### Dynamic Window Approach (DWA)
```python
class DynamicWindowApproach:
    """동적 윈도우 접근법"""
    
    def __init__(self, robot_params, dwa_params):
        self.max_vel = robot_params['max_velocity']
        self.max_acc = robot_params['max_acceleration']
        self.max_omega = robot_params['max_angular_velocity']
        self.max_alpha = robot_params['max_angular_acceleration']
        
        self.dt = dwa_params['time_step']
        self.predict_time = dwa_params['predict_time']
        self.alpha = dwa_params['heading_weight']
        self.beta = dwa_params['distance_weight']
        self.gamma = dwa_params['velocity_weight']
    
    def plan(self, current_state, goal, obstacles):
        """DWA 경로 계획"""
        
        x, y, theta, v, omega = current_state
        
        # 동적 윈도우 계산
        dw = self.calculate_dynamic_window(v, omega)
        
        # 최적 제어 입력 찾기
        best_v, best_omega = self.optimize_trajectory(
            current_state, goal, obstacles, dw)
        
        return best_v, best_omega
    
    def calculate_dynamic_window(self, current_v, current_omega):
        """동적 윈도우 계산"""
        
        # 속도 제약
        v_min = max(0, current_v - self.max_acc * self.dt)
        v_max = min(self.max_vel, current_v + self.max_acc * self.dt)
        
        # 각속도 제약
        omega_min = max(-self.max_omega, current_omega - self.max_alpha * self.dt)
        omega_max = min(self.max_omega, current_omega + self.max_alpha * self.dt)
        
        return [v_min, v_max, omega_min, omega_max]
    
    def optimize_trajectory(self, state, goal, obstacles, dw):
        """궤적 최적화"""
        
        best_score = -np.inf
        best_v, best_omega = 0, 0
        
        # 속도 공간 샘플링
        v_samples = np.linspace(dw[0], dw[1], 20)
        omega_samples = np.linspace(dw[2], dw[3], 40)
        
        for v in v_samples:
            for omega in omega_samples:
                # 궤적 시뮬레이션
                trajectory = self.simulate_trajectory(state, v, omega)
                
                # 충돌 확인
                if self.check_collision(trajectory, obstacles):
                    continue
                
                # 비용 함수 계산
                heading_cost = self.heading_cost(trajectory, goal)
                distance_cost = self.distance_cost(trajectory, obstacles)
                velocity_cost = self.velocity_cost(v)
                
                total_cost = (self.alpha * heading_cost + 
                             self.beta * distance_cost + 
                             self.gamma * velocity_cost)
                
                if total_cost > best_score:
                    best_score = total_cost
                    best_v, best_omega = v, omega
        
        return best_v, best_omega
    
    def simulate_trajectory(self, initial_state, v, omega):
        """궤적 시뮬레이션"""
        
        trajectory = []
        x, y, theta = initial_state[:3]
        
        for t in np.arange(0, self.predict_time, self.dt):
            trajectory.append([x, y, theta])
            
            # 운동학 업데이트
            x += v * np.cos(theta) * self.dt
            y += v * np.sin(theta) * self.dt
            theta += omega * self.dt
        
        return np.array(trajectory)
```

## 🎯 센서 시스템

### 1. LiDAR 기반 지각

#### 2D LiDAR 처리
```python
class LiDAR2D:
    """2D LiDAR 센서 처리"""
    
    def __init__(self, max_range, angular_resolution, noise_std):
        self.max_range = max_range
        self.angular_res = angular_resolution
        self.noise_std = noise_std
        self.num_beams = int(2 * np.pi / angular_resolution)
    
    def scan_simulation(self, robot_pose, environment):
        """LiDAR 스캔 시뮬레이션"""
        
        x, y, theta = robot_pose
        ranges = []
        
        for i in range(self.num_beams):
            beam_angle = theta + i * self.angular_res
            
            # 광선 추적
            range_measurement = self.ray_casting(
                [x, y], beam_angle, environment)
            
            # 노이즈 추가
            noisy_range = range_measurement + np.random.normal(0, self.noise_std)
            noisy_range = np.clip(noisy_range, 0, self.max_range)
            
            ranges.append(noisy_range)
        
        return np.array(ranges)
    
    def extract_features(self, scan_data):
        """특징점 추출"""
        
        # 1. 선분 추출 (Split-and-Merge)
        lines = self.extract_lines(scan_data)
        
        # 2. 코너 추출
        corners = self.extract_corners(scan_data)
        
        # 3. 원형 특징 추출
        circles = self.extract_circles(scan_data)
        
        return {
            'lines': lines,
            'corners': corners,
            'circles': circles
        }
    
    def extract_lines(self, scan_data):
        """직선 특징 추출 (RANSAC)"""
        
        # 극좌표를 직교좌표로 변환
        points = self.polar_to_cartesian(scan_data)
        
        lines = []
        remaining_points = points.copy()
        
        while len(remaining_points) > 10:  # 최소 점 개수
            # RANSAC으로 직선 찾기
            line, inliers = self.ransac_line_fitting(remaining_points)
            
            if len(inliers) < 5:  # 충분한 지지점이 없으면 종료
                break
            
            lines.append(line)
            remaining_points = np.delete(remaining_points, inliers, axis=0)
        
        return lines
    
    def ransac_line_fitting(self, points, iterations=100, threshold=0.1):
        """RANSAC 직선 피팅"""
        
        best_line = None
        best_inliers = []
        
        for _ in range(iterations):
            # 2개 점 랜덤 선택
            sample_indices = np.random.choice(len(points), 2, replace=False)
            p1, p2 = points[sample_indices]
            
            # 직선 방정식: ax + by + c = 0
            a = p2[1] - p1[1]
            b = p1[0] - p2[0]
            c = p2[0] * p1[1] - p1[0] * p2[1]
            
            # 정규화
            norm = np.sqrt(a**2 + b**2)
            if norm < 1e-6:
                continue
            a, b, c = a/norm, b/norm, c/norm
            
            # 인라이어 찾기
            distances = np.abs(a * points[:, 0] + b * points[:, 1] + c)
            inliers = np.where(distances < threshold)[0]
            
            if len(inliers) > len(best_inliers):
                best_line = [a, b, c]
                best_inliers = inliers
        
        return best_line, best_inliers
```

### 2. 비전 시스템

#### 옵티컬 플로우
```python
class OpticalFlow:
    """옵티컬 플로우 기반 운동 추정"""
    
    def __init__(self, camera_params):
        self.focal_length = camera_params['focal_length']
        self.principal_point = camera_params['principal_point']
        self.feature_detector = cv2.goodFeaturesToTrack
    
    def estimate_motion(self, prev_frame, curr_frame):
        """두 프레임간 운동 추정"""
        
        # 특징점 검출
        prev_features = self.feature_detector(
            prev_frame, maxCorners=100, qualityLevel=0.01, minDistance=10)
        
        # 루카스-카나데 추적
        curr_features, status, error = cv2.calcOpticalFlowPyrLK(
            prev_frame, curr_frame, prev_features, None)
        
        # 좋은 특징점만 선택
        good_prev = prev_features[status == 1]
        good_curr = curr_features[status == 1]
        
        # Essential Matrix 계산
        E, mask = cv2.findEssentialMat(
            good_prev, good_curr, self.focal_length, self.principal_point)
        
        # 회전과 평행이동 복원
        _, R, t, _ = cv2.recoverPose(E, good_prev, good_curr)
        
        return R, t
    
    def visual_odometry(self, frame_sequence):
        """비주얼 오도메트리"""
        
        trajectory = []
        current_pose = np.eye(4)  # 초기 포즈
        
        for i in range(1, len(frame_sequence)):
            prev_frame = frame_sequence[i-1]
            curr_frame = frame_sequence[i]
            
            # 상대 운동 추정
            R_rel, t_rel = self.estimate_motion(prev_frame, curr_frame)
            
            # 4x4 변환 행렬 구성
            T_rel = np.eye(4)
            T_rel[:3, :3] = R_rel
            T_rel[:3, 3] = t_rel.flatten()
            
            # 절대 포즈 업데이트
            current_pose = current_pose @ T_rel
            
            # 위치 추출
            position = current_pose[:3, 3]
            trajectory.append(position)
        
        return np.array(trajectory)
```

### 3. 다중 센서 융합

#### 확장 칼만 필터 센서 융합
```python
class MultiSensorFusion:
    """다중 센서 융합 (EKF)"""
    
    def __init__(self, initial_state):
        # 상태: [x, y, theta, vx, vy, vtheta]
        self.state = initial_state
        self.covariance = np.eye(6) * 0.1
        
        # 센서 모델들
        self.gps_model = GPSModel()
        self.imu_model = IMUModel()
        self.lidar_model = LiDARModel()
        self.encoder_model = EncoderModel()
    
    def predict(self, dt):
        """예측 단계 (운동 모델)"""
        
        x, y, theta, vx, vy, vtheta = self.state
        
        # 상태 전이 (등속도 모델)
        F = np.array([
            [1, 0, 0, dt, 0, 0],
            [0, 1, 0, 0, dt, 0],
            [0, 0, 1, 0, 0, dt],
            [0, 0, 0, 1, 0, 0],
            [0, 0, 0, 0, 1, 0],
            [0, 0, 0, 0, 0, 1]
        ])
        
        self.state = F @ self.state
        
        # 프로세스 노이즈
        Q = np.diag([0.01, 0.01, 0.01, 0.1, 0.1, 0.1]) * dt
        
        self.covariance = F @ self.covariance @ F.T + Q
    
    def update_gps(self, gps_measurement):
        """GPS 측정값 업데이트"""
        
        # 관측 행렬 (위치만 관측)
        H = np.zeros((2, 6))
        H[0, 0] = 1  # x
        H[1, 1] = 1  # y
        
        # 관측 잔차
        innovation = gps_measurement - H @ self.state
        
        # 칼만 업데이트
        self.kalman_update(H, innovation, self.gps_model.noise_covariance())
    
    def update_imu(self, imu_measurement):
        """IMU 측정값 업데이트"""
        
        # 관측 행렬 (각속도와 가속도)
        H = np.zeros((3, 6))
        H[0, 2] = 1  # theta
        H[1, 3] = 1  # vx
        H[2, 4] = 1  # vy
        
        innovation = imu_measurement - H @ self.state
        
        self.kalman_update(H, innovation, self.imu_model.noise_covariance())
    
    def kalman_update(self, H, innovation, R):
        """칼만 필터 업데이트 공통 함수"""
        
        # 혁신 공분산
        S = H @ self.covariance @ H.T + R
        
        # 칼만 게인
        K = self.covariance @ H.T @ np.linalg.inv(S)
        
        # 상태 업데이트
        self.state = self.state + K @ innovation
        
        # 공분산 업데이트
        I = np.eye(len(self.state))
        self.covariance = (I - K @ H) @ self.covariance
```

## 🔄 제어 시스템

### 1. 궤적 추종 제어

#### 순수 추종 (Pure Pursuit)
```python
class PurePursuitController:
    """순수 추종 제어기"""
    
    def __init__(self, lookahead_distance, wheelbase):
        self.lookahead_dist = lookahead_distance
        self.wheelbase = wheelbase
    
    def compute_control(self, current_pose, reference_path):
        """제어 입력 계산"""
        
        # 추종점 찾기
        lookahead_point = self.find_lookahead_point(current_pose, reference_path)
        
        if lookahead_point is None:
            return 0, 0  # 정지
        
        # 현재 위치에서 추종점으로의 벡터
        x, y, theta = current_pose
        target_x, target_y = lookahead_point
        
        # 로컬 좌표계로 변환
        dx = target_x - x
        dy = target_y - y
        
        local_x = dx * np.cos(theta) + dy * np.sin(theta)
        local_y = -dx * np.sin(theta) + dy * np.cos(theta)
        
        # 곡률 계산
        curvature = 2 * local_y / (self.lookahead_dist**2)
        
        # 조향각 계산 (아커만 모델)
        steering_angle = np.arctan(curvature * self.wheelbase)
        
        # 속도는 곡률에 반비례
        target_velocity = self.velocity_profile(curvature)
        
        return target_velocity, steering_angle
    
    def find_lookahead_point(self, current_pose, path):
        """추종점 찾기"""
        
        x, y, _ = current_pose
        
        for i in range(len(path) - 1):
            p1 = path[i]
            p2 = path[i + 1]
            
            # 선분과 추종원의 교점 계산
            intersection = self.line_circle_intersection(
                p1, p2, [x, y], self.lookahead_dist)
            
            if intersection is not None:
                return intersection
        
        # 교점이 없으면 경로의 마지막 점
        return path[-1] if len(path) > 0 else None
    
    def velocity_profile(self, curvature):
        """곡률에 따른 속도 프로파일"""
        
        max_velocity = 2.0  # m/s
        min_velocity = 0.5  # m/s
        
        # 곡률이 클수록 속도 감소
        velocity = max_velocity / (1 + abs(curvature) * 5)
        velocity = max(velocity, min_velocity)
        
        return velocity
```

#### 모델 예측 제어 (MPC)
```python
class MPCController:
    """모델 예측 제어기"""
    
    def __init__(self, horizon, dt, Q, R):
        self.N = horizon        # 예측 구간
        self.dt = dt           # 시간 간격
        self.Q = Q             # 상태 가중치
        self.R = R             # 제어 가중치
    
    def solve_mpc(self, current_state, reference_trajectory):
        """MPC 최적화 문제 해결"""
        
        # 결정 변수: [x0, x1, ..., xN, u0, u1, ..., u(N-1)]
        nx = len(current_state)  # 상태 차원
        nu = 2                   # 제어 차원 (v, omega)
        
        # 변수 개수
        n_vars = (self.N + 1) * nx + self.N * nu
        
        # 초기 추정값
        x0 = np.zeros(n_vars)
        x0[:nx] = current_state
        
        # 제약 조건
        constraints = self.setup_constraints(current_state)
        
        # 비용 함수
        def cost_function(x):
            return self.compute_cost(x, reference_trajectory)
        
        # 최적화 해결
        result = minimize(cost_function, x0, constraints=constraints, 
                         method='SLSQP')
        
        # 첫 번째 제어 입력 추출
        u_start_idx = (self.N + 1) * nx
        optimal_control = result.x[u_start_idx:u_start_idx + nu]
        
        return optimal_control
    
    def compute_cost(self, decision_vars, reference):
        """비용 함수 계산"""
        
        nx = len(reference[0])
        nu = 2
        
        cost = 0
        
        # 상태 비용
        for k in range(self.N + 1):
            state_idx = k * nx
            state = decision_vars[state_idx:state_idx + nx]
            ref_state = reference[min(k, len(reference) - 1)]
            
            state_error = state - ref_state
            cost += state_error.T @ self.Q @ state_error
        
        # 제어 비용
        u_start_idx = (self.N + 1) * nx
        for k in range(self.N):
            control_idx = u_start_idx + k * nu
            control = decision_vars[control_idx:control_idx + nu]
            
            cost += control.T @ self.R @ control
        
        return cost
    
    def setup_constraints(self, initial_state):
        """제약 조건 설정"""
        
        constraints = []
        
        # 초기 조건 제약
        def initial_constraint(x):
            return x[:len(initial_state)] - initial_state
        
        constraints.append({'type': 'eq', 'fun': initial_constraint})
        
        # 동역학 제약
        for k in range(self.N):
            def dynamics_constraint(x, k=k):
                return self.dynamics_constraint_k(x, k)
            
            constraints.append({'type': 'eq', 'fun': dynamics_constraint})
        
        return constraints
```

## 🏭 응용 분야 및 성능

### 1. 실내 응용
```
서비스 로봇:
- 청소 로봇 (룸바, 로보락)
- 안내 로봇 (공항, 병원)
- 배송 로봇 (호텔, 사무실)
- 순찰 로봇 (보안)

물류 로봇:
- 창고 자동화 (AGV, AMR)
- 피킹 로봇
- 팔레타이징 로봇
- 재고 관리 로봇
```

### 2. 실외 응용
```
자율주행:
- 승용차 자율주행
- 상용차 자율주행
- 셔틀 서비스
- 배송 차량

농업:
- 자율 트랙터
- 농약 살포 로봇
- 수확 로봇
- 모니터링 로봇

건설/광업:
- 자율 덤프트럭
- 굴삭기 자동화
- 측량 로봇
- 안전 감시 로봇
```

### 3. 성능 지표
```
이동 성능:
- 최대 속도: 0.5-80 km/h
- 가속도: 0.5-5.0 m/s²
- 회전 반지름: 0-∞ (구동 방식별)
- 등판 능력: 5-30°

정밀도:
- 위치 정확도: ±1-50 cm
- 각도 정확도: ±1-5°
- 반복 정확도: ±0.5-10 cm
- 경로 추종 오차: ±5-50 cm

자율성:
- 연속 운행 시간: 8-24시간
- 충전/연료 보급: 자동/수동
- 장애물 회피: 정적/동적
- 날씨 대응: 실내/실외
```

### 4. 주요 기술 동향
```
센서 융합:
- LiDAR + 카메라 + 레이더
- AI 기반 환경 인식
- 엣지 컴퓨팅 적용

통신 기술:
- 5G/6G 연결성
- V2X 통신
- 클라우드 로보틱스
- 디지털 트윈

자율성 향상:
- 레벨 4/5 자율주행
- 무감독 학습
- 전이 학습
- 연합 학습
```

---

#지상이동로봇 #MobileRobots #자율주행 #SLAM #경로계획 #센서융합 #차동구동 #아커만조향