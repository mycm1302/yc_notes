# ì§€ìƒì´ë™ë¡œë´‡ (Terrestrial Mobile Robots)

## ğŸ“– ì£¼ìš” ì°¸ê³ ë¬¸í—Œ
> **í•µì‹¬ êµê³¼ì„œ**: *Introduction to Autonomous Mobile Robots* by Roland Siegwart, Illah R. Nourbakhsh, Davide Scaramuzza (MIT Press)
> **ë³´ì¡° êµê³¼ì„œ**: *Probabilistic Robotics* by Sebastian Thrun, Wolfram Burgard, Dieter Fox
> **ì°¸ê³ ì„œì **: *Principles of Robot Motion* by Howie Choset, *Mobile Robotics* by Alonzo Kelly

## ğŸ¯ ì •ì˜ ë° íŠ¹ì§•

**ì§€ìƒì´ë™ë¡œë´‡**ì€ ë°”í€´, ê¶¤ë„, ë˜ëŠ” ê¸°íƒ€ ì´ë™ ë©”ì»¤ë‹ˆì¦˜ì„ ì‚¬ìš©í•˜ì—¬ ì§€ë©´ì—ì„œ ì´ë™í•˜ëŠ” ë¡œë´‡ìœ¼ë¡œ, ììœ¨ ë‚´ë¹„ê²Œì´ì…˜ê³¼ ë‹¤ì–‘í•œ ì„ë¬´ ìˆ˜í–‰ì´ ê°€ëŠ¥í•œ ì‹œìŠ¤í…œì…ë‹ˆë‹¤.

### ğŸš— êµ¬ì¡°ì  ë¶„ë¥˜

#### ë°”í€´ êµ¬ë™ ë°©ì‹
```
ì°¨ë™ êµ¬ë™ (Differential Drive):
- 2ê°œ ë…ë¦½ êµ¬ë™ë°”í€´ + ìºìŠ¤í„°/ë³¼ ë°”í€´
- ê°„ë‹¨í•œ ì œì–´, ì œìë¦¬ íšŒì „ ê°€ëŠ¥
- ì‹¤ë‚´ ë¡œë´‡ì— ë„ë¦¬ ì‚¬ìš©

ì•„ì»¤ë§Œ ì¡°í–¥ (Ackermann Steering):
- ì „ë¥œ ì¡°í–¥ + í›„ë¥œ êµ¬ë™
- ìë™ì°¨ì™€ ë™ì¼í•œ ë°©ì‹
- ê³ ì† ì£¼í–‰ì— ì í•©

ì „ë°©í–¥ êµ¬ë™ (Omnidirectional):
- ë©”ì¹´ë„˜ íœ  ë˜ëŠ” ì˜´ë‹ˆ íœ 
- ëª¨ë“  ë°©í–¥ ì¦‰ì‹œ ì´ë™ ê°€ëŠ¥
- ì¢ì€ ê³µê°„ì—ì„œ ìœ ë¦¬

ê¶¤ë„ êµ¬ë™ (Tracked):
- ë¬´í•œê¶¤ë„ ì‚¬ìš©
- ë†’ì€ ê²¬ì¸ë ¥ê³¼ ì§€í˜• ì ì‘ì„±
- í—˜ì§€, êµ°ì‚¬ìš©ì— ì í•©
```

### âš¡ ì¥ì 
- **íš¨ìœ¨ì  ì´ë™**: í‰ì§€ì—ì„œ ë†’ì€ ì—ë„ˆì§€ íš¨ìœ¨
- **ë†’ì€ ì†ë„**: ë¹ ë¥¸ ì´ë™ ì†ë„ ë‹¬ì„± ê°€ëŠ¥
- **ì •í™•í•œ ì œì–´**: ì˜ˆì¸¡ ê°€ëŠ¥í•œ ìš´ë™í•™
- **ì•ˆì •ì„±**: ì •ì  ì•ˆì •ì„± í™•ë³´

### âš ï¸ ì œì•½ ì‚¬í•­
- **ì§€í˜• ì œì•½**: ê³„ë‹¨, ì¥ì• ë¬¼ í†µê³¼ ì–´ë ¤ì›€
- **ê²¬ì¸ë ¥ ì˜ì¡´**: ë¯¸ë„ëŸ¬ìš´ í‘œë©´ì—ì„œ ì„±ëŠ¥ ì €í•˜
- **ê¸°ë™ì„± ì œí•œ**: ì¼ë¶€ êµ¬ë™ ë°©ì‹ì˜ ìš´ë™ ì œì•½
- **ì ‘ì§€ì••**: ì—°ì•½ì§€ë°˜ì—ì„œ ë§¤ëª° ìœ„í—˜

## ğŸ”§ ì´ë™ ë¡œë´‡ ê¸°êµ¬í•™

### 1. ì°¨ë™ êµ¬ë™ ë¡œë´‡

#### ìš´ë™í•™ ëª¨ë¸
```python
class DifferentialDriveRobot:
    """ì°¨ë™ êµ¬ë™ ë¡œë´‡ ê¸°êµ¬í•™"""
    
    def __init__(self, wheel_radius, wheel_base):
        self.r = wheel_radius      # ë°”í€´ ë°˜ì§€ë¦„
        self.L = wheel_base        # ë°”í€´ ê°„ê²©
    
    def forward_kinematics(self, wheel_velocities):
        """ìˆœê¸°êµ¬í•™: ë°”í€´ ì†ë„ â†’ ë¡œë´‡ ì†ë„"""
        
        v_left, v_right = wheel_velocities
        
        # ë¡œë´‡ ì¤‘ì‹¬ì ì˜ ì„ ì†ë„
        v = self.r * (v_right + v_left) / 2
        
        # ë¡œë´‡ì˜ ê°ì†ë„
        omega = self.r * (v_right - v_left) / self.L
        
        return v, omega
    
    def inverse_kinematics(self, robot_velocity):
        """ì—­ê¸°êµ¬í•™: ë¡œë´‡ ì†ë„ â†’ ë°”í€´ ì†ë„"""
        
        v, omega = robot_velocity
        
        # ì¢Œì¸¡ ë°”í€´ ì†ë„
        v_left = (v - omega * self.L / 2) / self.r
        
        # ìš°ì¸¡ ë°”í€´ ì†ë„  
        v_right = (v + omega * self.L / 2) / self.r
        
        return v_left, v_right
    
    def pose_update(self, pose, velocities, dt):
        """í¬ì¦ˆ ì—…ë°ì´íŠ¸ (ì ë¶„)"""
        
        x, y, theta = pose
        v, omega = velocities
        
        # ì˜¤ì¼ëŸ¬ ì ë¶„
        x_new = x + v * np.cos(theta) * dt
        y_new = y + v * np.sin(theta) * dt
        theta_new = theta + omega * dt
        
        # ê°ë„ ì •ê·œí™”
        theta_new = self.normalize_angle(theta_new)
        
        return np.array([x_new, y_new, theta_new])
    
    def motion_model(self, pose, controls, dt):
        """ìš´ë™ ëª¨ë¸ (ë…¸ì´ì¦ˆ í¬í•¨)"""
        
        # ì œì–´ ì…ë ¥ì— ë…¸ì´ì¦ˆ ì¶”ê°€
        v_cmd, omega_cmd = controls
        
        # ìš´ë™ ë…¸ì´ì¦ˆ ë§¤ê°œë³€ìˆ˜
        alpha1, alpha2, alpha3, alpha4 = 0.1, 0.1, 0.1, 0.1
        
        v_actual = v_cmd + np.random.normal(0, alpha1 * abs(v_cmd) + alpha2 * abs(omega_cmd))
        omega_actual = omega_cmd + np.random.normal(0, alpha3 * abs(v_cmd) + alpha4 * abs(omega_cmd))
        
        # í¬ì¦ˆ ì—…ë°ì´íŠ¸
        new_pose = self.pose_update(pose, (v_actual, omega_actual), dt)
        
        return new_pose
```

### 2. ì•„ì»¤ë§Œ ì¡°í–¥ ë¡œë´‡

#### ì•„ì»¤ë§Œ ê¸°í•˜í•™
```python
class AckermannSteeringRobot:
    """ì•„ì»¤ë§Œ ì¡°í–¥ ë¡œë´‡ ê¸°êµ¬í•™"""
    
    def __init__(self, wheelbase, track_width):
        self.L = wheelbase         # ì¶•ê°„ê±°ë¦¬
        self.W = track_width       # ìœ¤ê±°
    
    def ackermann_angles(self, steering_angle, side='inner'):
        """ì•„ì»¤ë§Œ ì¡°í–¥ê° ê³„ì‚°"""
        
        if side == 'inner':
            # ë‚´ì¸¡ ë°”í€´ ì¡°í–¥ê°
            delta_inner = np.arctan(self.L / (self.L / np.tan(steering_angle) - self.W/2))
            return delta_inner
        else:
            # ì™¸ì¸¡ ë°”í€´ ì¡°í–¥ê°
            delta_outer = np.arctan(self.L / (self.L / np.tan(steering_angle) + self.W/2))
            return delta_outer
    
    def turning_radius(self, steering_angle):
        """íšŒì „ ë°˜ì§€ë¦„"""
        
        if abs(steering_angle) < 1e-6:
            return float('inf')  # ì§ì§„
        
        R = self.L / np.tan(steering_angle)
        return abs(R)
    
    def bicycle_model(self, pose, controls, dt):
        """ìì „ê±° ëª¨ë¸ (ë‹¨ìˆœí™”ëœ ì•„ì»¤ë§Œ ëª¨ë¸)"""
        
        x, y, theta = pose
        v, delta = controls  # ì†ë„, ì¡°í–¥ê°
        
        # ìš´ë™ ë°©ì •ì‹
        x_dot = v * np.cos(theta)
        y_dot = v * np.sin(theta)
        theta_dot = v * np.tan(delta) / self.L
        
        # ì ë¶„
        x_new = x + x_dot * dt
        y_new = y + y_dot * dt
        theta_new = theta + theta_dot * dt
        
        return np.array([x_new, y_new, theta_new])
```

### 3. ì „ë°©í–¥ ì´ë™ ë¡œë´‡

#### ë©”ì¹´ë„˜ íœ 
```python
class MecanumWheelRobot:
    """ë©”ì¹´ë„˜ íœ  ë¡œë´‡ ê¸°êµ¬í•™"""
    
    def __init__(self, wheel_radius, robot_geometry):
        self.r = wheel_radius
        self.lx = robot_geometry['length'] / 2    # ì „í›„ ë°”í€´ ê°„ê²©ì˜ ì ˆë°˜
        self.ly = robot_geometry['width'] / 2     # ì¢Œìš° ë°”í€´ ê°„ê²©ì˜ ì ˆë°˜
    
    def forward_kinematics(self, wheel_speeds):
        """ìˆœê¸°êµ¬í•™: ë°”í€´ ì†ë„ â†’ ë¡œë´‡ ì†ë„"""
        
        w1, w2, w3, w4 = wheel_speeds  # ì „ì¢Œ, ì „ìš°, í›„ì¢Œ, í›„ìš°
        
        # ê¸°êµ¬í•™ í–‰ë ¬
        # [vx]   r  [ 1  1  1  1] [w1]
        # [vy] = - [1 -1 -1  1] [w2]
        # [wz]   4  [1 -1  1 -1] [w3]
        #           [           ] [w4]
        
        vx = self.r / 4 * (w1 + w2 + w3 + w4)
        vy = self.r / 4 * (w1 - w2 - w3 + w4)
        wz = self.r / (4 * (self.lx + self.ly)) * (w1 - w2 + w3 - w4)
        
        return np.array([vx, vy, wz])
    
    def inverse_kinematics(self, robot_velocity):
        """ì—­ê¸°êµ¬í•™: ë¡œë´‡ ì†ë„ â†’ ë°”í€´ ì†ë„"""
        
        vx, vy, wz = robot_velocity
        
        # ì—­ ê¸°êµ¬í•™ í–‰ë ¬
        w1 = (vx + vy + wz * (self.lx + self.ly)) / self.r
        w2 = (vx - vy - wz * (self.lx + self.ly)) / self.r
        w3 = (vx - vy + wz * (self.lx + self.ly)) / self.r
        w4 = (vx + vy - wz * (self.lx + self.ly)) / self.r
        
        return np.array([w1, w2, w3, w4])
    
    def holonomic_motion(self, pose, velocity_command, dt):
        """í™€ë¡œë…¸ë¯¹ ìš´ë™"""
        
        x, y, theta = pose
        vx_body, vy_body, wz = velocity_command
        
        # ëª¸ì²´ ì¢Œí‘œê³„ ì†ë„ë¥¼ ì „ì—­ ì¢Œí‘œê³„ë¡œ ë³€í™˜
        vx_global = vx_body * np.cos(theta) - vy_body * np.sin(theta)
        vy_global = vx_body * np.sin(theta) + vy_body * np.cos(theta)
        
        # í¬ì¦ˆ ì—…ë°ì´íŠ¸
        x_new = x + vx_global * dt
        y_new = y + vy_global * dt
        theta_new = theta + wz * dt
        
        return np.array([x_new, y_new, theta_new])
```

## ğŸ—ºï¸ ì§€ì—­í™” ë° ë§¤í•‘ (SLAM)

### 1. í™•ë¥ ì  ì§€ì—­í™”

#### ëª¬í…Œì¹´ë¥¼ë¡œ ì§€ì—­í™” (MCL)
```python
class MonteCarloLocalization:
    """ëª¬í…Œì¹´ë¥¼ë¡œ ì§€ì—­í™” (íŒŒí‹°í´ í•„í„°)"""
    
    def __init__(self, num_particles, map_data, motion_model, sensor_model):
        self.num_particles = num_particles
        self.map = map_data
        self.motion_model = motion_model
        self.sensor_model = sensor_model
        
        # íŒŒí‹°í´ ì´ˆê¸°í™”
        self.particles = self.initialize_particles()
        self.weights = np.ones(num_particles) / num_particles
    
    def predict(self, control_input, dt):
        """ì˜ˆì¸¡ ë‹¨ê³„ (ìš´ë™ ëª¨ë¸)"""
        
        for i in range(self.num_particles):
            # ê° íŒŒí‹°í´ì— ìš´ë™ ëª¨ë¸ ì ìš© (ë…¸ì´ì¦ˆ í¬í•¨)
            self.particles[i] = self.motion_model.sample(
                self.particles[i], control_input, dt)
    
    def update(self, sensor_measurement):
        """ì—…ë°ì´íŠ¸ ë‹¨ê³„ (ì„¼ì„œ ëª¨ë¸)"""
        
        for i in range(self.num_particles):
            # ê° íŒŒí‹°í´ì—ì„œ ì˜ˆìƒë˜ëŠ” ì„¼ì„œ ì¸¡ì •ê°’
            expected_measurement = self.sensor_model.expected_measurement(
                self.particles[i], self.map)
            
            # ì‹¤ì œ ì¸¡ì •ê°’ê³¼ì˜ ìœ ì‚¬ë„ ê³„ì‚°
            self.weights[i] = self.sensor_model.likelihood(
                sensor_measurement, expected_measurement)
        
        # ê°€ì¤‘ì¹˜ ì •ê·œí™”
        self.weights /= np.sum(self.weights)
    
    def resample(self):
        """ë¦¬ìƒ˜í”Œë§ (ì¤‘ìš”ë„ ì¬ìƒ˜í”Œë§)"""
        
        # ìœ íš¨ ìƒ˜í”Œ í¬ê¸° ê³„ì‚°
        n_eff = 1.0 / np.sum(self.weights**2)
        
        if n_eff < self.num_particles / 2:  # ë¦¬ìƒ˜í”Œë§ ì„ê³„ê°’
            # ì²´ê³„ì  ë¦¬ìƒ˜í”Œë§
            indices = self.systematic_resampling(self.weights)
            self.particles = self.particles[indices]
            self.weights = np.ones(self.num_particles) / self.num_particles
    
    def estimate_pose(self):
        """í¬ì¦ˆ ì¶”ì • (ê°€ì¤‘ í‰ê· )"""
        
        # ê°€ì¤‘ í‰ê· ìœ¼ë¡œ í¬ì¦ˆ ì¶”ì •
        mean_pose = np.average(self.particles, weights=self.weights, axis=0)
        
        # ê³µë¶„ì‚° ê³„ì‚°
        cov = np.cov(self.particles.T, aweights=self.weights)
        
        return mean_pose, cov
```

#### í™•ì¥ ì¹¼ë§Œ í•„í„° ì§€ì—­í™” (EKF)
```python
class EKFLocalization:
    """í™•ì¥ ì¹¼ë§Œ í•„í„° ì§€ì—­í™”"""
    
    def __init__(self, initial_state, initial_covariance):
        self.state = initial_state      # [x, y, theta]
        self.covariance = initial_covariance
    
    def predict(self, control_input, dt):
        """ì˜ˆì¸¡ ë‹¨ê³„"""
        
        # ìš´ë™ ëª¨ë¸
        self.state = self.motion_model(self.state, control_input, dt)
        
        # ì•¼ì½”ë¹„ì•ˆ ê³„ì‚°
        F = self.motion_jacobian(self.state, control_input, dt)
        
        # ê³µë¶„ì‚° ì˜ˆì¸¡
        Q = self.process_noise_covariance(control_input, dt)
        self.covariance = F @ self.covariance @ F.T + Q
    
    def update(self, landmark_observations):
        """ì—…ë°ì´íŠ¸ ë‹¨ê³„"""
        
        for observation in landmark_observations:
            landmark_id, range_bearing = observation
            
            # ì˜ˆìƒ ê´€ì¸¡ê°’
            expected_obs = self.observation_model(self.state, landmark_id)
            
            # í˜ì‹  (innovation)
            innovation = range_bearing - expected_obs
            innovation[1] = self.normalize_angle(innovation[1])  # ê°ë„ ì •ê·œí™”
            
            # ê´€ì¸¡ ì•¼ì½”ë¹„ì•ˆ
            H = self.observation_jacobian(self.state, landmark_id)
            
            # ì¹¼ë§Œ ê²Œì¸
            R = self.measurement_noise_covariance()
            S = H @ self.covariance @ H.T + R
            K = self.covariance @ H.T @ np.linalg.inv(S)
            
            # ìƒíƒœ ì—…ë°ì´íŠ¸
            self.state = self.state + K @ innovation
            
            # ê³µë¶„ì‚° ì—…ë°ì´íŠ¸
            I = np.eye(len(self.state))
            self.covariance = (I - K @ H) @ self.covariance
    
    def observation_model(self, pose, landmark_id):
        """ê´€ì¸¡ ëª¨ë¸: í¬ì¦ˆ â†’ ì˜ˆìƒ ê´€ì¸¡ê°’"""
        
        x, y, theta = pose
        lx, ly = self.get_landmark_position(landmark_id)
        
        # ê±°ë¦¬
        dx = lx - x
        dy = ly - y
        range_pred = np.sqrt(dx**2 + dy**2)
        
        # ë°©ìœ„ê°
        bearing_pred = np.arctan2(dy, dx) - theta
        bearing_pred = self.normalize_angle(bearing_pred)
        
        return np.array([range_pred, bearing_pred])
```

### 2. SLAM (ë™ì‹œ ì§€ì—­í™” ë° ë§¤í•‘)

#### FastSLAM
```python
class FastSLAM:
    """FastSLAM ì•Œê³ ë¦¬ì¦˜"""
    
    def __init__(self, num_particles):
        self.num_particles = num_particles
        self.particles = []
        
        # ê° íŒŒí‹°í´ì€ ë¡œë´‡ ê¶¤ì ê³¼ ëœë“œë§ˆí¬ EKFë“¤ì„ ê°€ì§
        for i in range(num_particles):
            particle = {
                'trajectory': [],
                'weight': 1.0 / num_particles,
                'landmark_ekfs': {}  # ëœë“œë§ˆí¬ë³„ EKF
            }
            self.particles.append(particle)
    
    def process_control(self, control_input, dt):
        """ì œì–´ ì…ë ¥ ì²˜ë¦¬"""
        
        for particle in self.particles:
            # ìš´ë™ ëª¨ë¸ë¡œ ìƒˆë¡œìš´ í¬ì¦ˆ ìƒ˜í”Œë§
            if len(particle['trajectory']) > 0:
                current_pose = particle['trajectory'][-1]
            else:
                current_pose = np.array([0, 0, 0])  # ì´ˆê¸° í¬ì¦ˆ
            
            new_pose = self.sample_motion_model(current_pose, control_input, dt)
            particle['trajectory'].append(new_pose)
    
    def process_measurement(self, observations):
        """ì„¼ì„œ ì¸¡ì •ê°’ ì²˜ë¦¬"""
        
        for i, particle in enumerate(self.particles):
            current_pose = particle['trajectory'][-1]
            log_weight = 0
            
            for obs in observations:
                landmark_id, measurement = obs
                
                if landmark_id not in particle['landmark_ekfs']:
                    # ìƒˆë¡œìš´ ëœë“œë§ˆí¬ ì´ˆê¸°í™”
                    particle['landmark_ekfs'][landmark_id] = self.initialize_landmark_ekf(
                        current_pose, measurement)
                else:
                    # ê¸°ì¡´ ëœë“œë§ˆí¬ ì—…ë°ì´íŠ¸
                    ekf = particle['landmark_ekfs'][landmark_id]
                    likelihood = self.update_landmark_ekf(ekf, current_pose, measurement)
                    log_weight += np.log(likelihood)
            
            # íŒŒí‹°í´ ê°€ì¤‘ì¹˜ ì—…ë°ì´íŠ¸
            particle['weight'] *= np.exp(log_weight)
        
        # ê°€ì¤‘ì¹˜ ì •ê·œí™”
        total_weight = sum(p['weight'] for p in self.particles)
        for particle in self.particles:
            particle['weight'] /= total_weight
        
        # ë¦¬ìƒ˜í”Œë§
        self.resample_particles()
    
    def initialize_landmark_ekf(self, robot_pose, measurement):
        """ìƒˆ ëœë“œë§ˆí¬ EKF ì´ˆê¸°í™”"""
        
        x, y, theta = robot_pose
        range_meas, bearing_meas = measurement
        
        # ëœë“œë§ˆí¬ ìœ„ì¹˜ ì´ˆê¸° ì¶”ì •
        lx = x + range_meas * np.cos(theta + bearing_meas)
        ly = y + range_meas * np.sin(theta + bearing_meas)
        
        # EKF ìƒíƒœ ë° ê³µë¶„ì‚° ì´ˆê¸°í™”
        landmark_state = np.array([lx, ly])
        landmark_cov = np.eye(2) * 10.0  # í° ë¶ˆí™•ì‹¤ì„±
        
        return {'state': landmark_state, 'covariance': landmark_cov}
```

#### ê·¸ë˜í”„ ê¸°ë°˜ SLAM
```python
class GraphSLAM:
    """ê·¸ë˜í”„ ê¸°ë°˜ SLAM"""
    
    def __init__(self):
        self.poses = {}           # í¬ì¦ˆ ë…¸ë“œë“¤
        self.landmarks = {}       # ëœë“œë§ˆí¬ ë…¸ë“œë“¤
        self.pose_edges = []      # í¬ì¦ˆê°„ ì œì•½
        self.observation_edges = [] # ê´€ì¸¡ ì œì•½
    
    def add_pose_node(self, pose_id, initial_pose):
        """í¬ì¦ˆ ë…¸ë“œ ì¶”ê°€"""
        self.poses[pose_id] = initial_pose
    
    def add_landmark_node(self, landmark_id, initial_position):
        """ëœë“œë§ˆí¬ ë…¸ë“œ ì¶”ê°€"""
        self.landmarks[landmark_id] = initial_position
    
    def add_pose_constraint(self, pose1_id, pose2_id, relative_pose, information_matrix):
        """í¬ì¦ˆê°„ ì œì•½ ì¶”ê°€ (ì˜¤ë„ë©”íŠ¸ë¦¬)"""
        constraint = {
            'pose1': pose1_id,
            'pose2': pose2_id,
            'measurement': relative_pose,
            'information': information_matrix
        }
        self.pose_edges.append(constraint)
    
    def add_observation_constraint(self, pose_id, landmark_id, observation, information_matrix):
        """ê´€ì¸¡ ì œì•½ ì¶”ê°€"""
        constraint = {
            'pose': pose_id,
            'landmark': landmark_id,
            'measurement': observation,
            'information': information_matrix
        }
        self.observation_edges.append(constraint)
    
    def optimize(self, max_iterations=100):
        """ë¹„ì„ í˜• ìµœì í™” (ê°€ìš°ìŠ¤-ë‰´íŠ¼)"""
        
        for iteration in range(max_iterations):
            # í—¤ì‹œì•ˆ í–‰ë ¬ê³¼ b ë²¡í„° êµ¬ì„±
            H, b = self.linearize_and_solve()
            
            # ì‹œìŠ¤í…œ í•´ê²°: H * dx = -b
            dx = self.solve_linear_system(H, -b)
            
            # ìƒíƒœ ì—…ë°ì´íŠ¸
            self.update_state(dx)
            
            # ìˆ˜ë ´ í™•ì¸
            if np.linalg.norm(dx) < 1e-6:
                break
    
    def linearize_and_solve(self):
        """ì„ í˜•í™” ë° ì •ë³´ í–‰ë ¬ êµ¬ì„±"""
        
        # ìƒíƒœ ë²¡í„° ì°¨ì› ê³„ì‚°
        state_dim = len(self.poses) * 3 + len(self.landmarks) * 2
        
        H = np.zeros((state_dim, state_dim))
        b = np.zeros(state_dim)
        
        # í¬ì¦ˆ ì œì•½ ì²˜ë¦¬
        for edge in self.pose_edges:
            error, jacobian = self.compute_pose_error_and_jacobian(edge)
            
            # ì •ë³´ í–‰ë ¬ ì—…ë°ì´íŠ¸
            H += jacobian.T @ edge['information'] @ jacobian
            b += jacobian.T @ edge['information'] @ error
        
        # ê´€ì¸¡ ì œì•½ ì²˜ë¦¬
        for edge in self.observation_edges:
            error, jacobian = self.compute_observation_error_and_jacobian(edge)
            
            # ì •ë³´ í–‰ë ¬ ì—…ë°ì´íŠ¸
            H += jacobian.T @ edge['information'] @ jacobian
            b += jacobian.T @ edge['information'] @ error
        
        return H, b
```

## ğŸ¯ ê²½ë¡œ ê³„íš ë° ë‚´ë¹„ê²Œì´ì…˜

### 1. ì „ì—­ ê²½ë¡œ ê³„íš

#### Dijkstra ì•Œê³ ë¦¬ì¦˜
```python
class GlobalPathPlanner:
    """ì „ì—­ ê²½ë¡œ ê³„íšê¸°"""
    
    def __init__(self, occupancy_grid, resolution):
        self.grid = occupancy_grid
        self.resolution = resolution
        self.height, self.width = occupancy_grid.shape
    
    def dijkstra(self, start, goal):
        """Dijkstra ê²½ë¡œ ê³„íš"""
        
        # ê±°ë¦¬ ë§µ ì´ˆê¸°í™”
        distances = np.full((self.height, self.width), np.inf)
        visited = np.zeros((self.height, self.width), dtype=bool)
        previous = {}
        
        # ì‹œì‘ì  ì„¤ì •
        start_idx = self.world_to_grid(start)
        distances[start_idx] = 0
        
        # ìš°ì„ ìˆœìœ„ í
        pq = [(0, start_idx)]
        
        while pq:
            current_dist, current = heapq.heappop(pq)
            
            if visited[current]:
                continue
            
            visited[current] = True
            
            # ëª©í‘œì  ë„ë‹¬ í™•ì¸
            goal_idx = self.world_to_grid(goal)
            if current == goal_idx:
                return self.reconstruct_path(previous, current)
            
            # ì´ì›ƒ íƒìƒ‰
            for neighbor in self.get_neighbors(current):
                if self.is_valid_cell(neighbor) and not visited[neighbor]:
                    # ì´ë™ ë¹„ìš© ê³„ì‚°
                    move_cost = self.get_move_cost(current, neighbor)
                    new_dist = current_dist + move_cost
                    
                    if new_dist < distances[neighbor]:
                        distances[neighbor] = new_dist
                        previous[neighbor] = current
                        heapq.heappush(pq, (new_dist, neighbor))
        
        return None  # ê²½ë¡œ ì—†ìŒ
    
    def get_move_cost(self, from_cell, to_cell):
        """ì´ë™ ë¹„ìš© ê³„ì‚°"""
        
        # ì¥ì• ë¬¼ í™•ì¸
        if self.grid[to_cell] > 0.5:  # ì ìœ  í™•ë¥  50% ì´ìƒ
            return np.inf
        
        # ëŒ€ê°ì„  ì´ë™ ë¹„ìš© (âˆš2), ì§ì„  ì´ë™ ë¹„ìš© (1)
        dx = abs(to_cell[0] - from_cell[0])
        dy = abs(to_cell[1] - from_cell[1])
        
        if dx + dy == 1:
            return 1.0  # ì§ì„  ì´ë™
        else:
            return 1.414  # ëŒ€ê°ì„  ì´ë™
```

#### A* ì•Œê³ ë¦¬ì¦˜ ê°œì„ 
```python
class AStarPlanner:
    """A* ê²½ë¡œ ê³„íšê¸° (ê°œì„ ëœ ë²„ì „)"""
    
    def __init__(self, occupancy_grid, resolution):
        self.grid = occupancy_grid
        self.resolution = resolution
        self.height, self.width = occupancy_grid.shape
    
    def a_star_with_smoothing(self, start, goal):
        """ë¶€ë“œëŸ¬ìš´ ê²½ë¡œë¥¼ ìœ„í•œ ê°œì„ ëœ A*"""
        
        # í‘œì¤€ A* ì‹¤í–‰
        raw_path = self.a_star(start, goal)
        
        if raw_path is None:
            return None
        
        # ê²½ë¡œ ìŠ¤ë¬´ë”©
        smooth_path = self.smooth_path(raw_path)
        
        return smooth_path
    
    def smooth_path(self, path):
        """ê²½ë¡œ ìŠ¤ë¬´ë”© (ë”ê¸€ë¼ìŠ¤-í¬ì´ì»¤ ì•Œê³ ë¦¬ì¦˜)"""
        
        if len(path) <= 2:
            return path
        
        smoothed = [path[0]]  # ì‹œì‘ì 
        
        i = 0
        while i < len(path) - 1:
            # ì§ì„ ìœ¼ë¡œ ì—°ê²° ê°€ëŠ¥í•œ ê°€ì¥ ë¨¼ ì  ì°¾ê¸°
            max_j = i + 1
            
            for j in range(i + 2, len(path)):
                if self.line_of_sight(path[i], path[j]):
                    max_j = j
                else:
                    break
            
            smoothed.append(path[max_j])
            i = max_j
        
        return smoothed
    
    def line_of_sight(self, point1, point2):
        """ë‘ ì  ì‚¬ì´ ê°€ì‹œì„  í™•ì¸ (ë¸Œë ˆì  í–„ ì•Œê³ ë¦¬ì¦˜)"""
        
        x1, y1 = self.world_to_grid(point1)
        x2, y2 = self.world_to_grid(point2)
        
        # ë¸Œë ˆì  í–„ ì§ì„  ì•Œê³ ë¦¬ì¦˜
        points = self.bresenham_line(x1, y1, x2, y2)
        
        # ëª¨ë“  ì ì´ ììœ ê³µê°„ì¸ì§€ í™•ì¸
        for x, y in points:
            if not self.is_free_cell((x, y)):
                return False
        
        return True
```

### 2. ì§€ì—­ ê²½ë¡œ ê³„íš

#### Dynamic Window Approach (DWA)
```python
class DynamicWindowApproach:
    """ë™ì  ìœˆë„ìš° ì ‘ê·¼ë²•"""
    
    def __init__(self, robot_params, dwa_params):
        self.max_vel = robot_params['max_velocity']
        self.max_acc = robot_params['max_acceleration']
        self.max_omega = robot_params['max_angular_velocity']
        self.max_alpha = robot_params['max_angular_acceleration']
        
        self.dt = dwa_params['time_step']
        self.predict_time = dwa_params['predict_time']
        self.alpha = dwa_params['heading_weight']
        self.beta = dwa_params['distance_weight']
        self.gamma = dwa_params['velocity_weight']
    
    def plan(self, current_state, goal, obstacles):
        """DWA ê²½ë¡œ ê³„íš"""
        
        x, y, theta, v, omega = current_state
        
        # ë™ì  ìœˆë„ìš° ê³„ì‚°
        dw = self.calculate_dynamic_window(v, omega)
        
        # ìµœì  ì œì–´ ì…ë ¥ ì°¾ê¸°
        best_v, best_omega = self.optimize_trajectory(
            current_state, goal, obstacles, dw)
        
        return best_v, best_omega
    
    def calculate_dynamic_window(self, current_v, current_omega):
        """ë™ì  ìœˆë„ìš° ê³„ì‚°"""
        
        # ì†ë„ ì œì•½
        v_min = max(0, current_v - self.max_acc * self.dt)
        v_max = min(self.max_vel, current_v + self.max_acc * self.dt)
        
        # ê°ì†ë„ ì œì•½
        omega_min = max(-self.max_omega, current_omega - self.max_alpha * self.dt)
        omega_max = min(self.max_omega, current_omega + self.max_alpha * self.dt)
        
        return [v_min, v_max, omega_min, omega_max]
    
    def optimize_trajectory(self, state, goal, obstacles, dw):
        """ê¶¤ì  ìµœì í™”"""
        
        best_score = -np.inf
        best_v, best_omega = 0, 0
        
        # ì†ë„ ê³µê°„ ìƒ˜í”Œë§
        v_samples = np.linspace(dw[0], dw[1], 20)
        omega_samples = np.linspace(dw[2], dw[3], 40)
        
        for v in v_samples:
            for omega in omega_samples:
                # ê¶¤ì  ì‹œë®¬ë ˆì´ì…˜
                trajectory = self.simulate_trajectory(state, v, omega)
                
                # ì¶©ëŒ í™•ì¸
                if self.check_collision(trajectory, obstacles):
                    continue
                
                # ë¹„ìš© í•¨ìˆ˜ ê³„ì‚°
                heading_cost = self.heading_cost(trajectory, goal)
                distance_cost = self.distance_cost(trajectory, obstacles)
                velocity_cost = self.velocity_cost(v)
                
                total_cost = (self.alpha * heading_cost + 
                             self.beta * distance_cost + 
                             self.gamma * velocity_cost)
                
                if total_cost > best_score:
                    best_score = total_cost
                    best_v, best_omega = v, omega
        
        return best_v, best_omega
    
    def simulate_trajectory(self, initial_state, v, omega):
        """ê¶¤ì  ì‹œë®¬ë ˆì´ì…˜"""
        
        trajectory = []
        x, y, theta = initial_state[:3]
        
        for t in np.arange(0, self.predict_time, self.dt):
            trajectory.append([x, y, theta])
            
            # ìš´ë™í•™ ì—…ë°ì´íŠ¸
            x += v * np.cos(theta) * self.dt
            y += v * np.sin(theta) * self.dt
            theta += omega * self.dt
        
        return np.array(trajectory)
```

## ğŸ¯ ì„¼ì„œ ì‹œìŠ¤í…œ

### 1. LiDAR ê¸°ë°˜ ì§€ê°

#### 2D LiDAR ì²˜ë¦¬
```python
class LiDAR2D:
    """2D LiDAR ì„¼ì„œ ì²˜ë¦¬"""
    
    def __init__(self, max_range, angular_resolution, noise_std):
        self.max_range = max_range
        self.angular_res = angular_resolution
        self.noise_std = noise_std
        self.num_beams = int(2 * np.pi / angular_resolution)
    
    def scan_simulation(self, robot_pose, environment):
        """LiDAR ìŠ¤ìº” ì‹œë®¬ë ˆì´ì…˜"""
        
        x, y, theta = robot_pose
        ranges = []
        
        for i in range(self.num_beams):
            beam_angle = theta + i * self.angular_res
            
            # ê´‘ì„  ì¶”ì 
            range_measurement = self.ray_casting(
                [x, y], beam_angle, environment)
            
            # ë…¸ì´ì¦ˆ ì¶”ê°€
            noisy_range = range_measurement + np.random.normal(0, self.noise_std)
            noisy_range = np.clip(noisy_range, 0, self.max_range)
            
            ranges.append(noisy_range)
        
        return np.array(ranges)
    
    def extract_features(self, scan_data):
        """íŠ¹ì§•ì  ì¶”ì¶œ"""
        
        # 1. ì„ ë¶„ ì¶”ì¶œ (Split-and-Merge)
        lines = self.extract_lines(scan_data)
        
        # 2. ì½”ë„ˆ ì¶”ì¶œ
        corners = self.extract_corners(scan_data)
        
        # 3. ì›í˜• íŠ¹ì§• ì¶”ì¶œ
        circles = self.extract_circles(scan_data)
        
        return {
            'lines': lines,
            'corners': corners,
            'circles': circles
        }
    
    def extract_lines(self, scan_data):
        """ì§ì„  íŠ¹ì§• ì¶”ì¶œ (RANSAC)"""
        
        # ê·¹ì¢Œí‘œë¥¼ ì§êµì¢Œí‘œë¡œ ë³€í™˜
        points = self.polar_to_cartesian(scan_data)
        
        lines = []
        remaining_points = points.copy()
        
        while len(remaining_points) > 10:  # ìµœì†Œ ì  ê°œìˆ˜
            # RANSACìœ¼ë¡œ ì§ì„  ì°¾ê¸°
            line, inliers = self.ransac_line_fitting(remaining_points)
            
            if len(inliers) < 5:  # ì¶©ë¶„í•œ ì§€ì§€ì ì´ ì—†ìœ¼ë©´ ì¢…ë£Œ
                break
            
            lines.append(line)
            remaining_points = np.delete(remaining_points, inliers, axis=0)
        
        return lines
    
    def ransac_line_fitting(self, points, iterations=100, threshold=0.1):
        """RANSAC ì§ì„  í”¼íŒ…"""
        
        best_line = None
        best_inliers = []
        
        for _ in range(iterations):
            # 2ê°œ ì  ëœë¤ ì„ íƒ
            sample_indices = np.random.choice(len(points), 2, replace=False)
            p1, p2 = points[sample_indices]
            
            # ì§ì„  ë°©ì •ì‹: ax + by + c = 0
            a = p2[1] - p1[1]
            b = p1[0] - p2[0]
            c = p2[0] * p1[1] - p1[0] * p2[1]
            
            # ì •ê·œí™”
            norm = np.sqrt(a**2 + b**2)
            if norm < 1e-6:
                continue
            a, b, c = a/norm, b/norm, c/norm
            
            # ì¸ë¼ì´ì–´ ì°¾ê¸°
            distances = np.abs(a * points[:, 0] + b * points[:, 1] + c)
            inliers = np.where(distances < threshold)[0]
            
            if len(inliers) > len(best_inliers):
                best_line = [a, b, c]
                best_inliers = inliers
        
        return best_line, best_inliers
```

### 2. ë¹„ì „ ì‹œìŠ¤í…œ

#### ì˜µí‹°ì»¬ í”Œë¡œìš°
```python
class OpticalFlow:
    """ì˜µí‹°ì»¬ í”Œë¡œìš° ê¸°ë°˜ ìš´ë™ ì¶”ì •"""
    
    def __init__(self, camera_params):
        self.focal_length = camera_params['focal_length']
        self.principal_point = camera_params['principal_point']
        self.feature_detector = cv2.goodFeaturesToTrack
    
    def estimate_motion(self, prev_frame, curr_frame):
        """ë‘ í”„ë ˆì„ê°„ ìš´ë™ ì¶”ì •"""
        
        # íŠ¹ì§•ì  ê²€ì¶œ
        prev_features = self.feature_detector(
            prev_frame, maxCorners=100, qualityLevel=0.01, minDistance=10)
        
        # ë£¨ì¹´ìŠ¤-ì¹´ë‚˜ë° ì¶”ì 
        curr_features, status, error = cv2.calcOpticalFlowPyrLK(
            prev_frame, curr_frame, prev_features, None)
        
        # ì¢‹ì€ íŠ¹ì§•ì ë§Œ ì„ íƒ
        good_prev = prev_features[status == 1]
        good_curr = curr_features[status == 1]
        
        # Essential Matrix ê³„ì‚°
        E, mask = cv2.findEssentialMat(
            good_prev, good_curr, self.focal_length, self.principal_point)
        
        # íšŒì „ê³¼ í‰í–‰ì´ë™ ë³µì›
        _, R, t, _ = cv2.recoverPose(E, good_prev, good_curr)
        
        return R, t
    
    def visual_odometry(self, frame_sequence):
        """ë¹„ì£¼ì–¼ ì˜¤ë„ë©”íŠ¸ë¦¬"""
        
        trajectory = []
        current_pose = np.eye(4)  # ì´ˆê¸° í¬ì¦ˆ
        
        for i in range(1, len(frame_sequence)):
            prev_frame = frame_sequence[i-1]
            curr_frame = frame_sequence[i]
            
            # ìƒëŒ€ ìš´ë™ ì¶”ì •
            R_rel, t_rel = self.estimate_motion(prev_frame, curr_frame)
            
            # 4x4 ë³€í™˜ í–‰ë ¬ êµ¬ì„±
            T_rel = np.eye(4)
            T_rel[:3, :3] = R_rel
            T_rel[:3, 3] = t_rel.flatten()
            
            # ì ˆëŒ€ í¬ì¦ˆ ì—…ë°ì´íŠ¸
            current_pose = current_pose @ T_rel
            
            # ìœ„ì¹˜ ì¶”ì¶œ
            position = current_pose[:3, 3]
            trajectory.append(position)
        
        return np.array(trajectory)
```

### 3. ë‹¤ì¤‘ ì„¼ì„œ ìœµí•©

#### í™•ì¥ ì¹¼ë§Œ í•„í„° ì„¼ì„œ ìœµí•©
```python
class MultiSensorFusion:
    """ë‹¤ì¤‘ ì„¼ì„œ ìœµí•© (EKF)"""
    
    def __init__(self, initial_state):
        # ìƒíƒœ: [x, y, theta, vx, vy, vtheta]
        self.state = initial_state
        self.covariance = np.eye(6) * 0.1
        
        # ì„¼ì„œ ëª¨ë¸ë“¤
        self.gps_model = GPSModel()
        self.imu_model = IMUModel()
        self.lidar_model = LiDARModel()
        self.encoder_model = EncoderModel()
    
    def predict(self, dt):
        """ì˜ˆì¸¡ ë‹¨ê³„ (ìš´ë™ ëª¨ë¸)"""
        
        x, y, theta, vx, vy, vtheta = self.state
        
        # ìƒíƒœ ì „ì´ (ë“±ì†ë„ ëª¨ë¸)
        F = np.array([
            [1, 0, 0, dt, 0, 0],
            [0, 1, 0, 0, dt, 0],
            [0, 0, 1, 0, 0, dt],
            [0, 0, 0, 1, 0, 0],
            [0, 0, 0, 0, 1, 0],
            [0, 0, 0, 0, 0, 1]
        ])
        
        self.state = F @ self.state
        
        # í”„ë¡œì„¸ìŠ¤ ë…¸ì´ì¦ˆ
        Q = np.diag([0.01, 0.01, 0.01, 0.1, 0.1, 0.1]) * dt
        
        self.covariance = F @ self.covariance @ F.T + Q
    
    def update_gps(self, gps_measurement):
        """GPS ì¸¡ì •ê°’ ì—…ë°ì´íŠ¸"""
        
        # ê´€ì¸¡ í–‰ë ¬ (ìœ„ì¹˜ë§Œ ê´€ì¸¡)
        H = np.zeros((2, 6))
        H[0, 0] = 1  # x
        H[1, 1] = 1  # y
        
        # ê´€ì¸¡ ì”ì°¨
        innovation = gps_measurement - H @ self.state
        
        # ì¹¼ë§Œ ì—…ë°ì´íŠ¸
        self.kalman_update(H, innovation, self.gps_model.noise_covariance())
    
    def update_imu(self, imu_measurement):
        """IMU ì¸¡ì •ê°’ ì—…ë°ì´íŠ¸"""
        
        # ê´€ì¸¡ í–‰ë ¬ (ê°ì†ë„ì™€ ê°€ì†ë„)
        H = np.zeros((3, 6))
        H[0, 2] = 1  # theta
        H[1, 3] = 1  # vx
        H[2, 4] = 1  # vy
        
        innovation = imu_measurement - H @ self.state
        
        self.kalman_update(H, innovation, self.imu_model.noise_covariance())
    
    def kalman_update(self, H, innovation, R):
        """ì¹¼ë§Œ í•„í„° ì—…ë°ì´íŠ¸ ê³µí†µ í•¨ìˆ˜"""
        
        # í˜ì‹  ê³µë¶„ì‚°
        S = H @ self.covariance @ H.T + R
        
        # ì¹¼ë§Œ ê²Œì¸
        K = self.covariance @ H.T @ np.linalg.inv(S)
        
        # ìƒíƒœ ì—…ë°ì´íŠ¸
        self.state = self.state + K @ innovation
        
        # ê³µë¶„ì‚° ì—…ë°ì´íŠ¸
        I = np.eye(len(self.state))
        self.covariance = (I - K @ H) @ self.covariance
```

## ğŸ”„ ì œì–´ ì‹œìŠ¤í…œ

### 1. ê¶¤ì  ì¶”ì¢… ì œì–´

#### ìˆœìˆ˜ ì¶”ì¢… (Pure Pursuit)
```python
class PurePursuitController:
    """ìˆœìˆ˜ ì¶”ì¢… ì œì–´ê¸°"""
    
    def __init__(self, lookahead_distance, wheelbase):
        self.lookahead_dist = lookahead_distance
        self.wheelbase = wheelbase
    
    def compute_control(self, current_pose, reference_path):
        """ì œì–´ ì…ë ¥ ê³„ì‚°"""
        
        # ì¶”ì¢…ì  ì°¾ê¸°
        lookahead_point = self.find_lookahead_point(current_pose, reference_path)
        
        if lookahead_point is None:
            return 0, 0  # ì •ì§€
        
        # í˜„ì¬ ìœ„ì¹˜ì—ì„œ ì¶”ì¢…ì ìœ¼ë¡œì˜ ë²¡í„°
        x, y, theta = current_pose
        target_x, target_y = lookahead_point
        
        # ë¡œì»¬ ì¢Œí‘œê³„ë¡œ ë³€í™˜
        dx = target_x - x
        dy = target_y - y
        
        local_x = dx * np.cos(theta) + dy * np.sin(theta)
        local_y = -dx * np.sin(theta) + dy * np.cos(theta)
        
        # ê³¡ë¥  ê³„ì‚°
        curvature = 2 * local_y / (self.lookahead_dist**2)
        
        # ì¡°í–¥ê° ê³„ì‚° (ì•„ì»¤ë§Œ ëª¨ë¸)
        steering_angle = np.arctan(curvature * self.wheelbase)
        
        # ì†ë„ëŠ” ê³¡ë¥ ì— ë°˜ë¹„ë¡€
        target_velocity = self.velocity_profile(curvature)
        
        return target_velocity, steering_angle
    
    def find_lookahead_point(self, current_pose, path):
        """ì¶”ì¢…ì  ì°¾ê¸°"""
        
        x, y, _ = current_pose
        
        for i in range(len(path) - 1):
            p1 = path[i]
            p2 = path[i + 1]
            
            # ì„ ë¶„ê³¼ ì¶”ì¢…ì›ì˜ êµì  ê³„ì‚°
            intersection = self.line_circle_intersection(
                p1, p2, [x, y], self.lookahead_dist)
            
            if intersection is not None:
                return intersection
        
        # êµì ì´ ì—†ìœ¼ë©´ ê²½ë¡œì˜ ë§ˆì§€ë§‰ ì 
        return path[-1] if len(path) > 0 else None
    
    def velocity_profile(self, curvature):
        """ê³¡ë¥ ì— ë”°ë¥¸ ì†ë„ í”„ë¡œíŒŒì¼"""
        
        max_velocity = 2.0  # m/s
        min_velocity = 0.5  # m/s
        
        # ê³¡ë¥ ì´ í´ìˆ˜ë¡ ì†ë„ ê°ì†Œ
        velocity = max_velocity / (1 + abs(curvature) * 5)
        velocity = max(velocity, min_velocity)
        
        return velocity
```

#### ëª¨ë¸ ì˜ˆì¸¡ ì œì–´ (MPC)
```python
class MPCController:
    """ëª¨ë¸ ì˜ˆì¸¡ ì œì–´ê¸°"""
    
    def __init__(self, horizon, dt, Q, R):
        self.N = horizon        # ì˜ˆì¸¡ êµ¬ê°„
        self.dt = dt           # ì‹œê°„ ê°„ê²©
        self.Q = Q             # ìƒíƒœ ê°€ì¤‘ì¹˜
        self.R = R             # ì œì–´ ê°€ì¤‘ì¹˜
    
    def solve_mpc(self, current_state, reference_trajectory):
        """MPC ìµœì í™” ë¬¸ì œ í•´ê²°"""
        
        # ê²°ì • ë³€ìˆ˜: [x0, x1, ..., xN, u0, u1, ..., u(N-1)]
        nx = len(current_state)  # ìƒíƒœ ì°¨ì›
        nu = 2                   # ì œì–´ ì°¨ì› (v, omega)
        
        # ë³€ìˆ˜ ê°œìˆ˜
        n_vars = (self.N + 1) * nx + self.N * nu
        
        # ì´ˆê¸° ì¶”ì •ê°’
        x0 = np.zeros(n_vars)
        x0[:nx] = current_state
        
        # ì œì•½ ì¡°ê±´
        constraints = self.setup_constraints(current_state)
        
        # ë¹„ìš© í•¨ìˆ˜
        def cost_function(x):
            return self.compute_cost(x, reference_trajectory)
        
        # ìµœì í™” í•´ê²°
        result = minimize(cost_function, x0, constraints=constraints, 
                         method='SLSQP')
        
        # ì²« ë²ˆì§¸ ì œì–´ ì…ë ¥ ì¶”ì¶œ
        u_start_idx = (self.N + 1) * nx
        optimal_control = result.x[u_start_idx:u_start_idx + nu]
        
        return optimal_control
    
    def compute_cost(self, decision_vars, reference):
        """ë¹„ìš© í•¨ìˆ˜ ê³„ì‚°"""
        
        nx = len(reference[0])
        nu = 2
        
        cost = 0
        
        # ìƒíƒœ ë¹„ìš©
        for k in range(self.N + 1):
            state_idx = k * nx
            state = decision_vars[state_idx:state_idx + nx]
            ref_state = reference[min(k, len(reference) - 1)]
            
            state_error = state - ref_state
            cost += state_error.T @ self.Q @ state_error
        
        # ì œì–´ ë¹„ìš©
        u_start_idx = (self.N + 1) * nx
        for k in range(self.N):
            control_idx = u_start_idx + k * nu
            control = decision_vars[control_idx:control_idx + nu]
            
            cost += control.T @ self.R @ control
        
        return cost
    
    def setup_constraints(self, initial_state):
        """ì œì•½ ì¡°ê±´ ì„¤ì •"""
        
        constraints = []
        
        # ì´ˆê¸° ì¡°ê±´ ì œì•½
        def initial_constraint(x):
            return x[:len(initial_state)] - initial_state
        
        constraints.append({'type': 'eq', 'fun': initial_constraint})
        
        # ë™ì—­í•™ ì œì•½
        for k in range(self.N):
            def dynamics_constraint(x, k=k):
                return self.dynamics_constraint_k(x, k)
            
            constraints.append({'type': 'eq', 'fun': dynamics_constraint})
        
        return constraints
```

## ğŸ­ ì‘ìš© ë¶„ì•¼ ë° ì„±ëŠ¥

### 1. ì‹¤ë‚´ ì‘ìš©
```
ì„œë¹„ìŠ¤ ë¡œë´‡:
- ì²­ì†Œ ë¡œë´‡ (ë£¸ë°”, ë¡œë³´ë½)
- ì•ˆë‚´ ë¡œë´‡ (ê³µí•­, ë³‘ì›)
- ë°°ì†¡ ë¡œë´‡ (í˜¸í…”, ì‚¬ë¬´ì‹¤)
- ìˆœì°° ë¡œë´‡ (ë³´ì•ˆ)

ë¬¼ë¥˜ ë¡œë´‡:
- ì°½ê³  ìë™í™” (AGV, AMR)
- í”¼í‚¹ ë¡œë´‡
- íŒ”ë ˆíƒ€ì´ì§• ë¡œë´‡
- ì¬ê³  ê´€ë¦¬ ë¡œë´‡
```

### 2. ì‹¤ì™¸ ì‘ìš©
```
ììœ¨ì£¼í–‰:
- ìŠ¹ìš©ì°¨ ììœ¨ì£¼í–‰
- ìƒìš©ì°¨ ììœ¨ì£¼í–‰
- ì…”í‹€ ì„œë¹„ìŠ¤
- ë°°ì†¡ ì°¨ëŸ‰

ë†ì—…:
- ììœ¨ íŠ¸ë™í„°
- ë†ì•½ ì‚´í¬ ë¡œë´‡
- ìˆ˜í™• ë¡œë´‡
- ëª¨ë‹ˆí„°ë§ ë¡œë´‡

ê±´ì„¤/ê´‘ì—…:
- ììœ¨ ë¤í”„íŠ¸ëŸ­
- êµ´ì‚­ê¸° ìë™í™”
- ì¸¡ëŸ‰ ë¡œë´‡
- ì•ˆì „ ê°ì‹œ ë¡œë´‡
```

### 3. ì„±ëŠ¥ ì§€í‘œ
```
ì´ë™ ì„±ëŠ¥:
- ìµœëŒ€ ì†ë„: 0.5-80 km/h
- ê°€ì†ë„: 0.5-5.0 m/sÂ²
- íšŒì „ ë°˜ì§€ë¦„: 0-âˆ (êµ¬ë™ ë°©ì‹ë³„)
- ë“±íŒ ëŠ¥ë ¥: 5-30Â°

ì •ë°€ë„:
- ìœ„ì¹˜ ì •í™•ë„: Â±1-50 cm
- ê°ë„ ì •í™•ë„: Â±1-5Â°
- ë°˜ë³µ ì •í™•ë„: Â±0.5-10 cm
- ê²½ë¡œ ì¶”ì¢… ì˜¤ì°¨: Â±5-50 cm

ììœ¨ì„±:
- ì—°ì† ìš´í–‰ ì‹œê°„: 8-24ì‹œê°„
- ì¶©ì „/ì—°ë£Œ ë³´ê¸‰: ìë™/ìˆ˜ë™
- ì¥ì• ë¬¼ íšŒí”¼: ì •ì /ë™ì 
- ë‚ ì”¨ ëŒ€ì‘: ì‹¤ë‚´/ì‹¤ì™¸
```

### 4. ì£¼ìš” ê¸°ìˆ  ë™í–¥
```
ì„¼ì„œ ìœµí•©:
- LiDAR + ì¹´ë©”ë¼ + ë ˆì´ë”
- AI ê¸°ë°˜ í™˜ê²½ ì¸ì‹
- ì—£ì§€ ì»´í“¨íŒ… ì ìš©

í†µì‹  ê¸°ìˆ :
- 5G/6G ì—°ê²°ì„±
- V2X í†µì‹ 
- í´ë¼ìš°ë“œ ë¡œë³´í‹±ìŠ¤
- ë””ì§€í„¸ íŠ¸ìœˆ

ììœ¨ì„± í–¥ìƒ:
- ë ˆë²¨ 4/5 ììœ¨ì£¼í–‰
- ë¬´ê°ë… í•™ìŠµ
- ì „ì´ í•™ìŠµ
- ì—°í•© í•™ìŠµ
```

---

#ì§€ìƒì´ë™ë¡œë´‡ #MobileRobots #ììœ¨ì£¼í–‰ #SLAM #ê²½ë¡œê³„íš #ì„¼ì„œìœµí•© #ì°¨ë™êµ¬ë™ #ì•„ì»¤ë§Œì¡°í–¥