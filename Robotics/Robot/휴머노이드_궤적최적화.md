# 궤적 최적화 (Trajectory Optimization)

> 상위: [[휴머노이드 연구기술]]

## 정의

궤적 최적화(Trajectory Optimization)는 로봇이 초기 상태에서 목표 상태까지 이동하는 과정에서 특정 성능 지표를 최적화하는 시간에 따른 상태와 제어 입력의 최적 궤적을 찾는 기법입니다.

## 수학적 정의

### 일반적 형태
```
minimize: J = ∫₀ᵀ L(x(t), u(t), t) dt + Φ(x(T))

subject to: ẋ(t) = f(x(t), u(t), t)
           x(0) = x₀
           x(T) = xf (또는 자유)
           g(x(t), u(t), t) ≤ 0
           h(x(t), u(t), t) = 0

여기서:
- x(t): 시간 t에서의 상태 벡터
- u(t): 시간 t에서의 제어 입력
- L(·): 순간 비용 함수
- Φ(·): 종료 비용 함수
- f(·): 시스템 동역학
- g(·), h(·): 부등식/등식 제약
```

### 이산화된 형태
```
minimize: J = Σₖ₌₀ᴺ⁻¹ L(xₖ, uₖ, k·Δt) + Φ(xₙ)

subject to: xₖ₊₁ = f_d(xₖ, uₖ, k·Δt)
           x₀ = x_initial
           xₙ ∈ X_final
           gₖ(xₖ, uₖ) ≤ 0, k = 0,1,...,N-1
           hₖ(xₖ, uₖ) = 0, k = 0,1,...,N-1
```

## 최적화 기법 분류

### 1. 직접 방법 (Direct Methods)

#### 단일 사격법 (Single Shooting)
```python
def single_shooting_optimization(initial_state, final_state, horizon, dynamics):
    """
    단일 사격법을 이용한 궤적 최적화
    """
    # 제어 입력만을 최적화 변수로 사용
    def objective(u_flat):
        u_sequence = u_flat.reshape((horizon, control_dim))
        
        # 시뮬레이션 실행
        states = [initial_state]
        cost = 0
        
        for k in range(horizon):
            # 다음 상태 계산
            x_next = dynamics(states[-1], u_sequence[k], k*dt)
            states.append(x_next)
            
            # 순간 비용 누적
            cost += stage_cost(states[-2], u_sequence[k], k*dt)
        
        # 종료 비용 추가
        cost += terminal_cost(states[-1], final_state)
        
        return cost
    
    # 제약 조건
    def constraints(u_flat):
        u_sequence = u_flat.reshape((horizon, control_dim))
        states = simulate_trajectory(initial_state, u_sequence, dynamics)
        
        constraints_violation = []
        
        for k in range(horizon + 1):
            # 상태 제약
            state_constraints = evaluate_state_constraints(states[k], k*dt)
            constraints_violation.extend(state_constraints)
            
            # 제어 제약 (마지막 스텝 제외)
            if k < horizon:
                control_constraints = evaluate_control_constraints(u_sequence[k], k*dt)
                constraints_violation.extend(control_constraints)
        
        return np.array(constraints_violation)
    
    # 최적화 실행
    initial_guess = np.zeros(horizon * control_dim)
    
    result = minimize(
        objective,
        initial_guess,
        method='SLSQP',
        constraints={'type': 'ineq', 'fun': lambda u: -constraints(u)},
        options={'maxiter': 1000}
    )
    
    return result
```

#### 다중 사격법 (Multiple Shooting)
```python
def multiple_shooting_optimization(initial_state, final_state, horizon, dynamics):
    """
    다중 사격법을 이용한 궤적 최적화
    """
    # 상태와 제어를 모두 최적화 변수로 사용
    def objective_and_constraints(z):
        states, controls = unpack_decision_variables(z, horizon)
        
        objective = 0
        defect_constraints = []
        
        for k in range(horizon):
            # 순간 비용
            objective += stage_cost(states[k], controls[k], k*dt)
            
            # 동역학 제약 (defect constraints)
            x_next_predicted = dynamics(states[k], controls[k], k*dt)
            defect = states[k+1] - x_next_predicted
            defect_constraints.extend(defect)
        
        # 종료 비용
        objective += terminal_cost(states[-1], final_state)
        
        return objective, np.array(defect_constraints)
    
    # 경계 조건 제약
    def boundary_constraints(z):
        states, controls = unpack_decision_variables(z, horizon)
        
        # 초기 조건
        initial_constraint = states[0] - initial_state
        
        # 종료 조건 (자유 종료인 경우 생략 가능)
        # final_constraint = states[-1] - final_state
        
        return initial_constraint  # np.concatenate([initial_constraint, final_constraint])
    
    # 초기 추정
    initial_guess = generate_initial_trajectory_guess(initial_state, final_state, horizon)
    
    # 최적화 실행
    result = minimize(
        lambda z: objective_and_constraints(z)[0],
        initial_guess,
        method='SLSQP',
        constraints=[
            {'type': 'eq', 'fun': lambda z: objective_and_constraints(z)[1]},  # 동역학 제약
            {'type': 'eq', 'fun': boundary_constraints}  # 경계 조건
        ]
    )
    
    return result
```

#### 콜로케이션 방법 (Collocation Methods)
```python
def collocation_optimization(initial_state, final_state, N_segments, dynamics):
    """
    콜로케이션 방법을 이용한 궤적 최적화
    """
    # 르장드르-가우스-로바토 점들 사용
    tau, weights = legendre_gauss_lobatto_points(degree=3)
    
    def setup_collocation_constraints():
        constraints = []
        
        for seg in range(N_segments):
            # 각 세그먼트의 시작과 끝
            t_start = seg * segment_duration
            t_end = (seg + 1) * segment_duration
            
            # 콜로케이션 점들에서의 동역학 제약
            for i, tau_i in enumerate(tau[1:-1]):  # 내부 점들만
                t_col = t_start + tau_i * segment_duration
                
                # 상태와 제어를 보간
                x_col = interpolate_state(seg, tau_i)
                u_col = interpolate_control(seg, tau_i)
                
                # 상태 도함수 계산 (라그랑주 보간 미분)
                x_dot_col = compute_state_derivative(seg, tau_i)
                
                # 동역학 제약
                f_col = dynamics(x_col, u_col, t_col)
                defect = x_dot_col - f_col
                
                constraints.extend(defect)
            
            # 세그먼트 연결 제약 (C0 연속성)
            if seg > 0:
                x_end_prev = get_segment_end_state(seg - 1)
                x_start_curr = get_segment_start_state(seg)
                continuity = x_start_curr - x_end_prev
                constraints.extend(continuity)
        
        return np.array(constraints)
    
    # 목적 함수 (가우스 적분)
    def objective(decision_vars):
        cost = 0
        
        for seg in range(N_segments):
            for i, (tau_i, w_i) in enumerate(zip(tau, weights)):
                t_col = seg * segment_duration + tau_i * segment_duration
                x_col = interpolate_state(seg, tau_i)
                u_col = interpolate_control(seg, tau_i)
                
                stage_cost_val = stage_cost(x_col, u_col, t_col)
                cost += w_i * segment_duration * stage_cost_val
        
        # 종료 비용
        final_state = get_final_state()
        cost += terminal_cost(final_state, final_state)
        
        return cost
    
    # 최적화 실행
    return minimize(
        objective,
        initial_guess,
        constraints={'type': 'eq', 'fun': setup_collocation_constraints}
    )
```

### 2. 간접 방법 (Indirect Methods)

#### 필요조건 기반 해법
```python
def indirect_optimization_pontryagin(initial_state, final_state, dynamics, hamiltonian):
    """
    폰트라긴 최소 원리를 이용한 간접 최적화
    """
    def two_point_bvp_residual(z):
        """
        2점 경계값 문제의 잔차
        """
        # z = [x(0), λ(0), T]
        N_states = len(initial_state)
        x0 = z[:N_states]
        lambda0 = z[N_states:2*N_states]
        T = z[-1]
        
        # 상태와 공상태 방정식 적분
        def augmented_dynamics(t, y):
            x = y[:N_states]
            lam = y[N_states:]
            
            # 최적 제어 계산 (해밀토니안 최소화)
            u_opt = compute_optimal_control(x, lam, t)
            
            # 상태 방정식
            x_dot = dynamics(x, u_opt, t)
            
            # 공상태 방정식 (해밀토니안의 상태에 대한 음의 편미분)
            lambda_dot = -compute_hamiltonian_state_gradient(x, lam, u_opt, t)
            
            return np.concatenate([x_dot, lambda_dot])
        
        # 적분 실행
        sol = solve_ivp(
            augmented_dynamics,
            [0, T],
            np.concatenate([x0, lambda0]),
            dense_output=True
        )
        
        # 종료 조건
        x_final = sol.y[:N_states, -1]
        lambda_final = sol.y[N_states:, -1]
        
        # 경계 조건 잔차
        residual = []
        
        # 초기 상태 조건
        residual.extend(x0 - initial_state)
        
        # 종료 상태 조건
        residual.extend(x_final - final_state)
        
        # 횡단 조건 (종료 시간이 자유인 경우)
        H_final = hamiltonian(x_final, lambda_final, 
                             compute_optimal_control(x_final, lambda_final, T), T)
        residual.append(H_final)  # H(T) = 0
        
        return np.array(residual)
    
    # 초기 추정
    initial_guess = np.concatenate([
        initial_state,
        np.ones_like(initial_state),  # 공상태 초기 추정
        [1.0]  # 종료 시간 추정
    ])
    
    # 뉴턴-랩슨으로 해결
    solution = fsolve(two_point_bvp_residual, initial_guess)
    
    return solution
```

### 3. 혼합 방법 (Hybrid Methods)

#### 직접-간접 방법
```python
def hybrid_direct_indirect_optimization(problem_setup):
    """
    직접 방법으로 초기해를 구한 후 간접 방법으로 정제
    """
    # 1단계: 직접 방법으로 대략적 해 구하기
    print("Phase 1: Direct method for initial solution...")
    direct_result = multiple_shooting_optimization(**problem_setup)
    
    # 2단계: 직접 방법 결과를 간접 방법의 초기 추정으로 사용
    print("Phase 2: Indirect method for refinement...")
    
    # 공상태 초기 추정 (KKT 조건으로부터)
    lambda_initial = estimate_costate_from_direct_solution(direct_result)
    
    # 간접 방법 실행
    indirect_result = indirect_optimization_pontryagin(
        initial_state=problem_setup['initial_state'],
        final_state=problem_setup['final_state'],
        dynamics=problem_setup['dynamics'],
        hamiltonian=problem_setup['hamiltonian']
    )
    
    return indirect_result

def estimate_costate_from_direct_solution(direct_solution):
    """
    직접 방법 해로부터 공상태 초기값 추정
    """
    # KKT 승수로부터 추정
    # 이는 문제에 따라 구체적 구현이 달라짐
    pass
```

## 휴머노이드 특수 응용

### 1. 보행 궤적 최적화

#### 주기적 보행 최적화
```python
def periodic_walking_optimization(step_length, step_time, robot_model):
    """
    주기적 보행을 위한 궤적 최적화
    """
    def objective(decision_vars):
        joint_trajectories, com_trajectory, foot_trajectories = unpack_variables(decision_vars)
        
        cost = 0
        
        # 에너지 최소화
        for k in range(N_knots-1):
            joint_velocities = (joint_trajectories[k+1] - joint_trajectories[k]) / dt
            joint_accelerations = compute_joint_accelerations(joint_trajectories, k)
            
            # 토크 계산
            torques = compute_inverse_dynamics(
                joint_trajectories[k], joint_velocities, joint_accelerations
            )
            
            # 에너지 비용
            cost += dt * np.sum(torques**2)
        
        # 부드러움 비용
        smoothness_cost = compute_trajectory_smoothness(joint_trajectories)
        cost += 10.0 * smoothness_cost
        
        # ZMP 안정성 비용
        zmp_cost = compute_zmp_stability_cost(joint_trajectories, com_trajectory)
        cost += 100.0 * zmp_cost
        
        return cost
    
    def constraints(decision_vars):
        joint_trajectories, com_trajectory, foot_trajectories = unpack_variables(decision_vars)
        
        violations = []
        
        for k in range(N_knots):
            # 기구학 일관성
            computed_com = compute_com_from_joints(joint_trajectories[k])
            com_error = com_trajectory[k] - computed_com
            violations.extend(com_error)
            
            # ZMP 제약
            zmp = compute_zmp(joint_trajectories[k])
            support_polygon = get_support_polygon(foot_trajectories, k)
            
            if not point_in_polygon(zmp, support_polygon):
                violations.append(distance_to_polygon(zmp, support_polygon))
            
            # 관절 한계
            joint_limit_violations = check_joint_limits(joint_trajectories[k])
            violations.extend(joint_limit_violations)
            
            # 충돌 회피
            collision_violations = check_self_collision(joint_trajectories[k])
            violations.extend(collision_violations)
        
        # 주기성 제약
        periodicity_error = joint_trajectories[-1] - joint_trajectories[0]
        violations.extend(periodicity_error)
        
        return np.array(violations)
    
    # 초기 추정 (키네마틱 보행 패턴)
    initial_guess = generate_kinematic_walking_pattern(
        step_length, step_time, robot_model
    )
    
    # 최적화 실행
    result = minimize(
        objective,
        initial_guess,
        method='SLSQP',
        constraints={'type': 'ineq', 'fun': lambda x: -constraints(x)},
        options={'maxiter': 500, 'ftol': 1e-6}
    )
    
    return result
```

#### 지형 적응 보행
```python
def terrain_adaptive_walking_optimization(terrain_map, robot_model):
    """
    지형에 적응하는 보행 궤적 최적화
    """
    def terrain_constraint(decision_vars, k):
        """
        지형 제약 조건
        """
        foot_positions = extract_foot_positions(decision_vars, k)
        violations = []
        
        for foot_pos in foot_positions:
            # 지면 높이 계산
            ground_height = terrain_map.get_height(foot_pos[:2])
            
            # 발이 지면 위에 있어야 함
            clearance = foot_pos[2] - ground_height
            if clearance < min_foot_clearance:
                violations.append(min_foot_clearance - clearance)
        
        return violations
    
    def stability_on_terrain(decision_vars):
        """
        불규칙 지형에서의 안정성 비용
        """
        cost = 0
        
        for k in range(N_knots):
            # 현재 지지 발의 위치
            support_feet = get_support_feet(decision_vars, k)
            
            # 각 지지 발에서의 지면 경사
            for foot in support_feet:
                foot_pos = foot['position']
                ground_normal = terrain_map.get_normal(foot_pos[:2])
                
                # 지면 경사에 따른 안정성 비용
                slope_angle = np.arccos(np.dot(ground_normal, [0, 0, 1]))
                cost += slope_penalty_weight * slope_angle**2
        
        return cost
    
    # 기본 최적화에 지형 제약 추가
    base_result = periodic_walking_optimization(step_length, step_time, robot_model)
    
    # 지형 제약을 포함한 재최적화
    enhanced_constraints = lambda x: np.concatenate([
        base_constraints(x),
        np.concatenate([terrain_constraint(x, k) for k in range(N_knots)])
    ])
    
    enhanced_objective = lambda x: (
        base_objective(x) + stability_on_terrain(x)
    )
    
    result = minimize(
        enhanced_objective,
        base_result.x,
        constraints={'type': 'ineq', 'fun': lambda x: -enhanced_constraints(x)}
    )
    
    return result
```

### 2. 전신 동작 최적화

#### 복합 태스크 최적화
```python
def whole_body_task_optimization(tasks, robot_model, time_horizon):
    """
    여러 태스크를 동시에 수행하는 전신 동작 최적화
    """
    def multi_task_objective(decision_vars):
        joint_trajectories = reshape_decision_vars(decision_vars)
        total_cost = 0
        
        for task in tasks:
            task_cost = 0
            
            for k in range(N_knots):
                # 태스크별 성능 평가
                if task.type == 'reaching':
                    end_effector_pos = compute_end_effector_position(
                        joint_trajectories[k], task.chain
                    )
                    error = np.linalg.norm(end_effector_pos - task.target_position[k])
                    task_cost += task.weight * error**2
                
                elif task.type == 'balance':
                    com_pos = compute_com_position(joint_trajectories[k])
                    zmp = compute_zmp(joint_trajectories[k])
                    
                    # ZMP가 지지 영역 내에 있는지 확인
                    support_polygon = task.support_polygon[k]
                    if not point_in_polygon(zmp, support_polygon):
                        dist = distance_to_polygon(zmp, support_polygon)
                        task_cost += task.weight * 1000 * dist**2
                
                elif task.type == 'posture':
                    posture_error = joint_trajectories[k] - task.reference_posture[k]
                    task_cost += task.weight * np.sum(posture_error**2)
            
            total_cost += task_cost
        
        # 부드러움 정규화
        smoothness_cost = 0
        for k in range(N_knots-1):
            joint_vel = (joint_trajectories[k+1] - joint_trajectories[k]) / dt
            smoothness_cost += np.sum(joint_vel**2)
        
        total_cost += smoothness_weight * smoothness_cost
        
        return total_cost
    
    def hierarchical_task_constraints(decision_vars):
        """
        계층적 태스크 제약
        """
        joint_trajectories = reshape_decision_vars(decision_vars)
        constraints = []
        
        # 우선순위별로 태스크 처리
        for priority_level in sorted(set(task.priority for task in tasks)):
            priority_tasks = [task for task in tasks if task.priority == priority_level]
            
            for k in range(N_knots):
                # 각 우선순위에서 태스크 제약
                for task in priority_tasks:
                    if task.type == 'equality':
                        constraint_value = evaluate_task_constraint(
                            joint_trajectories[k], task
                        )
                        constraints.extend(constraint_value)
        
        return np.array(constraints)
    
    # 최적화 실행
    initial_guess = generate_multi_task_initial_guess(tasks, robot_model)
    
    result = minimize(
        multi_task_objective,
        initial_guess,
        method='SLSQP',
        constraints={'type': 'eq', 'fun': hierarchical_task_constraints},
        options={'maxiter': 1000}
    )
    
    return result
```

### 3. 동적 동작 최적화

#### 점프/착지 최적화
```python
def jumping_trajectory_optimization(jump_height, jump_distance, robot_model):
    """
    점프 동작을 위한 궤적 최적화
    """
    def jumping_objective(decision_vars):
        phases = unpack_jumping_phases(decision_vars)  # 준비, 점프, 비행, 착지
        
        cost = 0
        
        # 각 페이즈별 비용
        for phase_name, phase_data in phases.items():
            if phase_name == 'preparation':
                # 준비 단계: 부드러운 움직임
                smoothness = compute_phase_smoothness(phase_data)
                cost += prep_weight * smoothness
                
            elif phase_name == 'takeoff':
                # 점프 단계: 파워 최적화
                power_cost = compute_takeoff_power(phase_data)
                cost += takeoff_weight * power_cost
                
            elif phase_name == 'flight':
                # 비행 단계: 자세 유지
                posture_cost = compute_flight_posture_cost(phase_data)
                cost += flight_weight * posture_cost
                
            elif phase_name == 'landing':
                # 착지 단계: 충격 최소화
                impact_cost = compute_landing_impact(phase_data)
                cost += landing_weight * impact_cost
        
        return cost
    
    def jumping_constraints(decision_vars):
        phases = unpack_jumping_phases(decision_vars)
        constraints = []
        
        # 점프 높이/거리 제약
        flight_trajectory = phases['flight']
        max_height = np.max(flight_trajectory['com_height'])
        horizontal_distance = flight_trajectory['com_position'][-1][0] - flight_trajectory['com_position'][0][0]
        
        constraints.append(max_height - jump_height)  # 최소 점프 높이
        constraints.append(horizontal_distance - jump_distance)  # 최소 점프 거리
        
        # 각 페이즈 연결 제약
        for i in range(len(phases) - 1):
            phase_continuity = check_phase_continuity(phases[i], phases[i+1])
            constraints.extend(phase_continuity)
        
        # 동역학 제약
        for phase_data in phases.values():
            dynamics_constraints = check_dynamics_consistency(phase_data)
            constraints.extend(dynamics_constraints)
        
        # 착지 안정성
        landing_stability = check_landing_stability(phases['landing'])
        constraints.extend(landing_stability)
        
        return np.array(constraints)
    
    # 초기 추정 (간단한 포물선 궤적 기반)
    initial_guess = generate_jumping_initial_guess(jump_height, jump_distance)
    
    # 최적화
    result = minimize(
        jumping_objective,
        initial_guess,
        method='SLSQP',
        constraints={'type': 'ineq', 'fun': lambda x: -jumping_constraints(x)}
    )
    
    return result
```

## 실시간 궤적 최적화

### 1. Model Predictive Control (MPC)

#### 순환 최적화
```python
class RealTimeMPC:
    def __init__(self, robot_model, prediction_horizon, control_horizon):
        self.robot = robot_model
        self.N_pred = prediction_horizon
        self.N_ctrl = control_horizon
        self.dt = 0.01
        
    def solve_mpc(self, current_state, reference_trajectory):
        """
        MPC 최적화 문제 해결
        """
        def mpc_objective(u_sequence):
            u_seq = u_sequence.reshape((self.N_ctrl, self.robot.n_controls))
            
            # 상태 예측
            predicted_states = self.predict_states(current_state, u_seq)
            
            cost = 0
            
            # 추적 오차 비용
            for k in range(self.N_pred):
                if k < len(reference_trajectory):
                    tracking_error = predicted_states[k] - reference_trajectory[k]
                    cost += np.sum(Q @ tracking_error**2)
                
                # 제어 비용
                if k < self.N_ctrl:
                    cost += np.sum(R @ u_seq[k]**2)
                
                # 제어 변화율 비용
                if k > 0 and k < self.N_ctrl:
                    du = u_seq[k] - u_seq[k-1]
                    cost += np.sum(Rd @ du**2)
            
            return cost
        
        def mpc_constraints(u_sequence):
            u_seq = u_sequence.reshape((self.N_ctrl, self.robot.n_controls))
            predicted_states = self.predict_states(current_state, u_seq)
            
            constraints = []
            
            for k in range(self.N_pred):
                # 상태 제약
                state_constraints = self.evaluate_state_constraints(predicted_states[k])
                constraints.extend(state_constraints)
                
                # 제어 제약
                if k < self.N_ctrl:
                    control_constraints = self.evaluate_control_constraints(u_seq[k])
                    constraints.extend(control_constraints)
            
            return np.array(constraints)
        
        # 따뜻한 시작 (이전 해 이용)
        initial_guess = self.get_warm_start_guess()
        
        # 실시간 최적화 (제한된 반복)
        result = minimize(
            mpc_objective,
            initial_guess,
            method='SQP',
            constraints={'type': 'ineq', 'fun': lambda u: -mpc_constraints(u)},
            options={'maxiter': 50}  # 실시간 제약
        )
        
        # 첫 번째 제어 입력 반환
        optimal_controls = result.x.reshape((self.N_ctrl, self.robot.n_controls))
        return optimal_controls[0]
    
    def predict_states(self, initial_state, control_sequence):
        """
        제어 시퀀스로부터 상태 예측
        """
        states = [initial_state]
        current_state = initial_state.copy()
        
        for k in range(self.N_pred):
            if k < len(control_sequence):
                u = control_sequence[k]
            else:
                u = np.zeros(self.robot.n_controls)  # 제어 구간 이후는 0
            
            next_state = self.robot.dynamics(current_state, u, self.dt)
            states.append(next_state)
            current_state = next_state
        
        return states[1:]  # 초기 상태 제외
```

### 2. 적응형 궤적 최적화

#### 온라인 재계획
```python
class AdaptiveTrajectoryPlanner:
    def __init__(self, robot_model):
        self.robot = robot_model
        self.current_plan = None
        self.replanning_threshold = 0.1
        
    def update_trajectory(self, current_state, current_target, disturbances):
        """
        상황 변화에 따른 궤적 온라인 업데이트
        """
        # 현재 계획과의 편차 확인
        if self.current_plan is not None:
            deviation = self.compute_plan_deviation(current_state)
            
            if deviation > self.replanning_threshold:
                print("Replanning triggered due to large deviation")
                return self.replan_trajectory(current_state, current_target)
        
        # 외란 감지 및 대응
        if self.detect_significant_disturbance(disturbances):
            print("Replanning triggered due to disturbance")
            return self.robust_replan(current_state, current_target, disturbances)
        
        # 목표 변경 대응
        if self.target_changed(current_target):
            print("Replanning triggered due to target change")
            return self.replan_trajectory(current_state, current_target)
        
        # 현재 계획 유지
        return self.get_current_plan_segment(current_state)
    
    def replan_trajectory(self, start_state, target_state):
        """
        빠른 재계획
        """
        # 간소화된 최적화 (실시간 제약)
        simplified_problem = self.create_simplified_problem(start_state, target_state)
        
        # 따뜻한 시작 사용
        if self.current_plan is not None:
            initial_guess = self.extract_warm_start(start_state)
        else:
            initial_guess = self.generate_quick_initial_guess(start_state, target_state)
        
        # 제한된 반복으로 최적화
        result = self.solve_with_time_limit(simplified_problem, initial_guess, time_limit=0.05)
        
        self.current_plan = result
        return result
    
    def robust_replan(self, current_state, target_state, disturbances):
        """
        외란을 고려한 강건한 재계획
        """
        # 외란 모델 업데이트
        disturbance_model = self.update_disturbance_model(disturbances)
        
        # 강건한 목적함수 (최악의 경우 고려)
        def robust_objective(decision_vars):
            nominal_cost = self.compute_nominal_cost(decision_vars)
            worst_case_cost = self.compute_worst_case_cost(decision_vars, disturbance_model)
            
            return nominal_cost + robustness_weight * worst_case_cost
        
        # 강건한 제약 (불확실성 마진 포함)
        def robust_constraints(decision_vars):
            nominal_constraints = self.compute_nominal_constraints(decision_vars)
            uncertainty_margins = self.compute_uncertainty_margins(decision_vars, disturbance_model)
            
            return nominal_constraints - uncertainty_margins
        
        # 강건한 최적화 실행
        result = minimize(
            robust_objective,
            self.get_warm_start_guess(),
            constraints={'type': 'ineq', 'fun': robust_constraints},
            options={'maxiter': 100}
        )
        
        return result
```

## 고급 최적화 기법

### 1. 다목적 최적화

#### 파레토 최적 해법
```python
def multi_objective_trajectory_optimization(objectives, weights=None):
    """
    다목적 궤적 최적화
    """
    if weights is None:
        # 파레토 프론트 탐색
        return compute_pareto_front(objectives)
    else:
        # 가중합 방법
        return weighted_sum_optimization(objectives, weights)

def compute_pareto_front(objectives):
    """
    파레토 최적 해 집합 계산
    """
    pareto_solutions = []
    
    # 다양한 가중치 조합으로 최적화
    for weight_combination in generate_weight_combinations(len(objectives)):
        def weighted_objective(decision_vars):
            costs = [obj(decision_vars) for obj in objectives]
            return sum(w * c for w, c in zip(weight_combination, costs))
        
        # 개별 최적화
        result = minimize(weighted_objective, initial_guess)
        
        if result.success:
            # 파레토 최적성 확인
            objective_values = [obj(result.x) for obj in objectives]
            
            if is_pareto_optimal(objective_values, pareto_solutions):
                pareto_solutions.append({
                    'solution': result.x,
                    'objectives': objective_values,
                    'weights': weight_combination
                })
    
    return pareto_solutions

def is_pareto_optimal(candidate, existing_solutions):
    """
    파레토 최적성 확인
    """
    for existing in existing_solutions:
        existing_obj = existing['objectives']
        
        # 지배 관계 확인
        if all(e <= c for e, c in zip(existing_obj, candidate)):
            if any(e < c for e, c in zip(existing_obj, candidate)):
                return False  # 기존 해가 후보를 지배
    
    return True
```

### 2. 확률적 최적화

#### 강건한 최적화
```python
def robust_trajectory_optimization(nominal_problem, uncertainty_model):
    """
    불확실성을 고려한 강건한 궤적 최적화
    """
    def robust_objective(decision_vars):
        # 몬테 카를로 샘플링으로 기댓값 계산
        costs = []
        
        for _ in range(n_samples):
            # 불확실성 샘플링
            uncertainty_sample = uncertainty_model.sample()
            
            # 샘플에 대한 비용 계산
            perturbed_cost = compute_cost_with_uncertainty(decision_vars, uncertainty_sample)
            costs.append(perturbed_cost)
        
        # 평균 + 분산 페널티 (mean-variance 최적화)
        mean_cost = np.mean(costs)
        var_cost = np.var(costs)
        
        return mean_cost + risk_aversion_parameter * var_cost
    
    def chance_constraints(decision_vars):
        """
        확률적 제약 (chance constraints)
        """
        violation_probabilities = []
        
        for constraint_func in constraint_functions:
            violations = 0
            
            for _ in range(n_samples):
                uncertainty_sample = uncertainty_model.sample()
                constraint_value = constraint_func(decision_vars, uncertainty_sample)
                
                if constraint_value > 0:  # 제약 위반
                    violations += 1
            
            violation_prob = violations / n_samples
            
            # 허용 위반 확률 이하여야 함
            violation_probabilities.append(violation_prob - allowable_violation_probability)
        
        return np.array(violation_probabilities)
    
    # 강건한 최적화 실행
    result = minimize(
        robust_objective,
        initial_guess,
        constraints={'type': 'ineq', 'fun': lambda x: -chance_constraints(x)}
    )
    
    return result
```

### 3. 계층적 최적화

#### 다단계 최적화
```python
def hierarchical_trajectory_optimization(task_hierarchy):
    """
    계층적 태스크 우선순위를 고려한 최적화
    """
    current_solution = initial_guess
    
    # 우선순위 순으로 최적화
    for priority_level in sorted(task_hierarchy.keys()):
        tasks_at_level = task_hierarchy[priority_level]
        
        print(f"Optimizing priority level {priority_level}")
        
        # 현재 우선순위 레벨의 목적함수
        def level_objective(decision_vars):
            cost = 0
            for task in tasks_at_level:
                task_cost = task.evaluate(decision_vars)
                cost += task.weight * task_cost
            return cost
        
        # 상위 우선순위 제약 유지
        def higher_priority_constraints(decision_vars):
            constraints = []
            
            for higher_level in range(priority_level):
                if higher_level in task_hierarchy:
                    for task in task_hierarchy[higher_level]:
                        # 상위 우선순위 성능 유지
                        task_performance = task.evaluate(decision_vars)
                        optimal_performance = task.evaluate(current_solution)
                        
                        # 성능 저하 방지
                        constraints.append(optimal_performance - task_performance)
            
            return np.array(constraints)
        
        # 현재 레벨 최적화
        result = minimize(
            level_objective,
            current_solution,
            constraints={'type': 'ineq', 'fun': higher_priority_constraints}
        )
        
        if result.success:
            current_solution = result.x
        else:
            print(f"Optimization failed at priority level {priority_level}")
            break
    
    return current_solution
```

## 성능 평가 및 검증

### 최적성 검증
```python
def verify_optimality(solution, problem_setup):
    """
    최적성 조건 검증
    """
    verification_results = {}
    
    # 1차 필요조건 (KKT 조건)
    grad_lagrangian = compute_lagrangian_gradient(solution, problem_setup)
    verification_results['gradient_norm'] = np.linalg.norm(grad_lagrangian)
    verification_results['first_order_satisfied'] = verification_results['gradient_norm'] < 1e-6
    
    # 제약 만족도
    constraint_violations = evaluate_constraints(solution, problem_setup)
    verification_results['max_constraint_violation'] = np.max(np.maximum(constraint_violations, 0))
    verification_results['constraints_satisfied'] = verification_results['max_constraint_violation'] < 1e-6
    
    # 2차 조건 (헤시안 양반정치)
    hessian = compute_lagrangian_hessian(solution, problem_setup)
    eigenvalues = np.linalg.eigvals(hessian)
    verification_results['min_eigenvalue'] = np.min(eigenvalues)
    verification_results['second_order_satisfied'] = verification_results['min_eigenvalue'] > -1e-6
    
    return verification_results

def benchmark_optimization_performance(algorithms, test_problems):
    """
    다양한 최적화 알고리즘 성능 비교
    """
    results = {}
    
    for alg_name, algorithm in algorithms.items():
        results[alg_name] = []
        
        for problem_name, problem in test_problems.items():
            start_time = time.time()
            
            try:
                solution = algorithm(problem)
                solve_time = time.time() - start_time
                
                # 성능 지표 계산
                objective_value = problem['objective'](solution.x)
                constraint_violation = np.max(np.maximum(
                    problem['constraints'](solution.x), 0
                ))
                
                result_entry = {
                    'problem': problem_name,
                    'success': solution.success,
                    'objective': objective_value,
                    'constraint_violation': constraint_violation,
                    'solve_time': solve_time,
                    'iterations': solution.nit if hasattr(solution, 'nit') else None
                }
                
            except Exception as e:
                result_entry = {
                    'problem': problem_name,
                    'success': False,
                    'error': str(e),
                    'solve_time': time.time() - start_time
                }
            
            results[alg_name].append(result_entry)
    
    return results
```

## 연결 문서

### 관련 기술
- **상위**: [[휴머노이드 연구기술]]
- **보행**: [[ZMP]], [[이족보행]]
- **제어**: [[전신제어기법]], [[MPC]]

### 수학적 기반
- **최적화**: [[비선형최적화]], [[제약최적화]], [[변분법]]
- **제어이론**: [[최적제어]], [[폰트라긴원리]]
- **수치해석**: [[수치적분]], [[경계값문제]]

### 응용 분야
- **휴머노이드**: [[보행패턴생성]], [[동적동작계획]]
- **로봇제어**: [[모션계획]], [[실시간제어]]
- **최적화**: [[MPC]], [[강건제어]]

## 태그

#궤적최적화 #최적제어 #보행최적화 #MPC #실시간최적화 #다목적최적화 #강건최적화 #전신동작 #동적동작