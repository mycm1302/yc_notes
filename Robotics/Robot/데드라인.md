# ë°ë“œë¼ì¸

> ìƒìœ„: [[ì‹¤ì‹œê°„ì œì–´]]

ì‹¤ì‹œê°„ ì‹œìŠ¤í…œì—ì„œ ì‘ì—…(task)ì´ ë°˜ë“œì‹œ ì™„ë£Œë˜ì–´ì•¼ í•˜ëŠ” ì‹œê°„ ì œì•½ì¡°ê±´ì…ë‹ˆë‹¤.

## â° ë°ë“œë¼ì¸ ì •ì˜

### ì ˆëŒ€ ë°ë“œë¼ì¸ (Absolute Deadline)
- **ì •ì˜**: ì‘ì—…ì´ ì™„ë£Œë˜ì–´ì•¼ í•˜ëŠ” ì ˆëŒ€ì ì¸ ì‹œê°„ì 
- **í‘œí˜„**: di = ri + Di (ë„ì°©ì‹œê°„ + ìƒëŒ€ë°ë“œë¼ì¸)
- **íŠ¹ì§•**: ì‹œìŠ¤í…œ íƒ€ì´ë¨¸ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•œ ê³ ì •ëœ ì‹œê°„ì 

### ìƒëŒ€ ë°ë“œë¼ì¸ (Relative Deadline)  
- **ì •ì˜**: ì‘ì—… ë„ì°© ì‹œì ë¶€í„° ì™„ë£Œê¹Œì§€ í—ˆìš©ë˜ëŠ” ì‹œê°„
- **í‘œí˜„**: Di = di - ri (ì ˆëŒ€ë°ë“œë¼ì¸ - ë„ì°©ì‹œê°„)
- **í™œìš©**: ì‘ì—… íŠ¹ì„± ì •ì˜ì™€ ìŠ¤ì¼€ì¤„ë§ ì•Œê³ ë¦¬ì¦˜ ì„¤ê³„

## ğŸ¯ ë°ë“œë¼ì¸ ë¶„ë¥˜

### í•˜ë“œ ë°ë“œë¼ì¸ (Hard Deadline)
```
íŠ¹ì§•:
- ë°ë“œë¼ì¸ ìœ„ë°˜ ì‹œ ì‹œìŠ¤í…œ ì™„ì „ ì‹¤íŒ¨
- ì¹˜ëª…ì  ê²°ê³¼ ì´ˆë˜ (ì•ˆì „, ì¬ì‚° í”¼í•´)
- 100% ë³´ì¥ í•„ìš”

ì‘ìš© ì‚¬ë¡€:
- ì›ìë¡œ ì œì–´ ì‹œìŠ¤í…œ
- ìë™ì°¨ ì—ì–´ë°± ì‹œìŠ¤í…œ  
- í•­ê³µê¸° ë¹„í–‰ ì œì–´
- ì˜ë£Œê¸°ê¸° ìƒëª…ìœ ì§€ì¥ì¹˜
```

### ì†Œí”„íŠ¸ ë°ë“œë¼ì¸ (Soft Deadline)
```
íŠ¹ì§•:
- ë°ë“œë¼ì¸ ìœ„ë°˜ ì‹œ ì„±ëŠ¥ ì €í•˜
- ì‹œìŠ¤í…œ ì§€ì† ìš´ì˜ ê°€ëŠ¥
- í†µê³„ì  ë³´ì¥ìœ¼ë¡œ ì¶©ë¶„

ì‘ìš© ì‚¬ë¡€:
- ë©€í‹°ë¯¸ë””ì–´ ìŠ¤íŠ¸ë¦¬ë°
- ì›¹ ì„œë²„ ì‘ë‹µ
- ê²Œì„ í”„ë ˆì„ ë Œë”ë§
- ìŒì„±/ì˜ìƒ ì²˜ë¦¬
```

### íŒ ë°ë“œë¼ì¸ (Firm Deadline)
```
íŠ¹ì§•:
- ë°ë“œë¼ì¸ í›„ ê²°ê³¼ ë¬´ì˜ë¯¸
- ëŠ¦ì€ ì™„ë£ŒëŠ” ìì› ë‚­ë¹„
- ë²„ë ¤ì§€ëŠ” ì‘ì—… ë°œìƒ

ì‘ìš© ì‚¬ë¡€:
- ì„¼ì„œ ë°ì´í„° ìƒ˜í”Œë§
- ì‹¤ì‹œê°„ ë¹„ë””ì˜¤ ì¸ì½”ë”©
- ë„¤íŠ¸ì›Œí¬ íŒ¨í‚· ì „ì†¡
```

## ğŸ“Š ë°ë“œë¼ì¸ ë¶„ì„

### ìŠ¤ì¼€ì¤„ë§ ê°€ëŠ¥ì„± ë¶„ì„
```cpp
// Rate Monotonic ë¶„ì„ (Liu & Layland)
bool isSchedulableRM(Task tasks[], int n) {
    float utilization = 0;
    
    // ì „ì²´ ì´ìš©ë¥  ê³„ì‚°
    for(int i = 0; i < n; i++) {
        utilization += (float)tasks[i].execution_time / tasks[i].period;
    }
    
    // Liu-Layland ì¶©ë¶„ì¡°ê±´
    float bound = n * (pow(2, 1.0/n) - 1);
    
    if(utilization <= bound) {
        return true;  // ìŠ¤ì¼€ì¤„ë§ ê°€ëŠ¥
    }
    
    // í•„ìš”ì¡°ê±´ ê²€ì‚¬  
    return utilization <= 1.0;
}

// EDF ë¶„ì„
bool isSchedulableEDF(Task tasks[], int n) {
    float utilization = 0;
    
    for(int i = 0; i < n; i++) {
        utilization += (float)tasks[i].execution_time / tasks[i].deadline;
    }
    
    return utilization <= 1.0;  // EDF ìµœì  ì¡°ê±´
}
```

### ì‘ë‹µì‹œê°„ ë¶„ì„ (Response Time Analysis)
```cpp
// ê³ ì •ìš°ì„ ìˆœìœ„ ì‹œìŠ¤í…œì—ì„œ ìµœì•…ì‘ë‹µì‹œê°„ ê³„ì‚°
int calculateWorstCaseResponseTime(Task task, Task higher_priority[], int hp_count) {
    int response_time = task.execution_time;
    int prev_response = 0;
    
    // ê³ ì •ì  ë°˜ë³µë²•
    while(response_time != prev_response) {
        prev_response = response_time;
        int interference = 0;
        
        // ë†’ì€ ìš°ì„ ìˆœìœ„ ì‘ì—…ë“¤ì˜ ê°„ì„­ ê³„ì‚°
        for(int i = 0; i < hp_count; i++) {
            interference += ceil((float)response_time / higher_priority[i].period) 
                          * higher_priority[i].execution_time;
        }
        
        response_time = task.execution_time + interference;
        
        // ìˆ˜ë ´í•˜ì§€ ì•Šìœ¼ë©´ ìŠ¤ì¼€ì¤„ë§ ë¶ˆê°€ëŠ¥
        if(response_time > task.deadline) {
            return -1;  // ë°ë“œë¼ì¸ ìœ„ë°˜
        }
    }
    
    return response_time;
}
```

## âš¡ ë°ë“œë¼ì¸ ê´€ë¦¬ ê¸°ë²•

### ë°ë“œë¼ì¸ ëª¨ë‹ˆí„°ë§
```cpp
class DeadlineMonitor {
private:
    struct TaskDeadline {
        int task_id;
        unsigned long absolute_deadline;
        bool completed;
    };
    
    TaskDeadline deadlines[MAX_TASKS];
    int deadline_count = 0;
    
public:
    void addDeadline(int task_id, unsigned long deadline) {
        if(deadline_count < MAX_TASKS) {
            deadlines[deadline_count] = {task_id, deadline, false};
            deadline_count++;
        }
    }
    
    void checkDeadlines() {
        unsigned long current_time = millis();
        
        for(int i = 0; i < deadline_count; i++) {
            if(!deadlines[i].completed && 
               current_time > deadlines[i].absolute_deadline) {
                
                handleDeadlineMiss(deadlines[i].task_id);
            }
        }
    }
    
    void markCompleted(int task_id) {
        for(int i = 0; i < deadline_count; i++) {
            if(deadlines[i].task_id == task_id) {
                deadlines[i].completed = true;
                break;
            }
        }
    }
};
```

### ë°ë“œë¼ì¸ ìœ„ë°˜ ì²˜ë¦¬
```cpp
// ë°ë“œë¼ì¸ ë¯¸ìŠ¤ í•¸ë“¤ë§ ì „ëµ
void handleDeadlineMiss(int task_id) {
    switch(getTaskCriticality(task_id)) {
        case HARD_REAL_TIME:
            // ì‹œìŠ¤í…œ ì•ˆì „ ëª¨ë“œë¡œ ì „í™˜
            enterSafeMode();
            logCriticalError(task_id);
            break;
            
        case SOFT_REAL_TIME:
            // ì„±ëŠ¥ ì €í•˜ í—ˆìš©, ê³„ì† ì‹¤í–‰
            adjustQualityOfService(task_id);
            logPerformanceWarning(task_id);
            break;
            
        case FIRM_REAL_TIME:
            // ì‘ì—… ì·¨ì†Œ, ë‹¤ìŒ ì¸ìŠ¤í„´ìŠ¤ ì¤€ë¹„
            cancelTask(task_id);
            prepareNextInstance(task_id);
            break;
    }
}

// ì ì‘ì  ë°ë“œë¼ì¸ ì¡°ì •
void adaptiveDeadlineAdjustment() {
    static int miss_count = 0;
    static unsigned long last_adjustment = 0;
    
    miss_count++;
    
    // ì¼ì • ê¸°ê°„ ë‚´ ë¯¸ìŠ¤ê°€ ë§ìœ¼ë©´ ë°ë“œë¼ì¸ ì™„í™”
    if(millis() - last_adjustment > 1000) {
        if(miss_count > MISS_THRESHOLD) {
            relaxDeadlines(0.1);  // 10% ì™„í™”
            logMessage("Deadlines relaxed due to frequent misses");
        }
        
        miss_count = 0;
        last_adjustment = millis();
    }
}
```

## ğŸ” ì‹¤ì¸¡ ë°ì´í„° ë¶„ì„

### ë°ë“œë¼ì¸ ì„±ëŠ¥ ì§€í‘œ
```cpp
class DeadlineMetrics {
private:
    int total_tasks = 0;
    int deadline_misses = 0;
    float worst_tardiness = 0;
    float avg_response_time = 0;
    
public:
    void recordTaskCompletion(unsigned long start_time, 
                            unsigned long end_time, 
                            unsigned long deadline) {
        
        total_tasks++;
        float response_time = end_time - start_time;
        
        // í‰ê·  ì‘ë‹µì‹œê°„ ì—…ë°ì´íŠ¸
        avg_response_time = (avg_response_time * (total_tasks - 1) + response_time) / total_tasks;
        
        // ë°ë“œë¼ì¸ ìœ„ë°˜ í™•ì¸
        if(end_time > deadline) {
            deadline_misses++;
            float tardiness = end_time - deadline;
            if(tardiness > worst_tardiness) {
                worst_tardiness = tardiness;
            }
        }
    }
    
    float getDeadlineMissRatio() {
        return (float)deadline_misses / total_tasks * 100.0;
    }
    
    void printStatistics() {
        Serial.printf("Total tasks: %d\n", total_tasks);
        Serial.printf("Deadline miss ratio: %.2f%%\n", getDeadlineMissRatio());
        Serial.printf("Worst tardiness: %.2f ms\n", worst_tardiness);
        Serial.printf("Average response time: %.2f ms\n", avg_response_time);
    }
};
```

---

## ğŸ”— ì—°ê²° ë¬¸ì„œ
- ìƒìœ„: [[ì‹¤ì‹œê°„ì œì–´]]
- ê´€ë ¨: [[ì§€í„°]], [[ë ˆì´í„´ì‹œ]], [[ì²˜ë¦¬ëŸ‰]]
- ìŠ¤ì¼€ì¤„ë§: [[ìš°ì„ ìˆœìœ„ìŠ¤ì¼€ì¤„ë§]], [[ì‹œë¶„í• ìŠ¤ì¼€ì¤„ë§]]
- êµ¬í˜„: [[ì¸í„°ëŸ½íŠ¸ì²˜ë¦¬]], [[ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬]]

## ğŸ“š ì°¸ê³ ë¬¸í—Œ
- [Liu & Layland (1973). "Scheduling Algorithms for Multiprogramming in a Hard Real-Time Environment"](https://en.wikipedia.org/wiki/Scheduling_analysis_real-time_systems)
- [Mok (2004). "Real Time Scheduling Theory: A Historical Perspective"](https://www.researchgate.net/publication/220414198_Real_Time_Scheduling_Theory_A_Historical_Perspective)
- [Chetto (2014). "Real-time Systems Scheduling: Fundamentals"](https://www.amazon.com/Real-time-Systems-Scheduling-Fundamentals-Telecommunications/dp/1848216653)
