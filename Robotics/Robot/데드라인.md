# 데드라인

> 상위: [[실시간제어]]

실시간 시스템에서 작업(task)이 반드시 완료되어야 하는 시간 제약조건입니다.

## ⏰ 데드라인 정의

### 절대 데드라인 (Absolute Deadline)
- **정의**: 작업이 완료되어야 하는 절대적인 시간점
- **표현**: di = ri + Di (도착시간 + 상대데드라인)
- **특징**: 시스템 타이머를 기준으로 한 고정된 시간점

### 상대 데드라인 (Relative Deadline)  
- **정의**: 작업 도착 시점부터 완료까지 허용되는 시간
- **표현**: Di = di - ri (절대데드라인 - 도착시간)
- **활용**: 작업 특성 정의와 스케줄링 알고리즘 설계

## 🎯 데드라인 분류

### 하드 데드라인 (Hard Deadline)
```
특징:
- 데드라인 위반 시 시스템 완전 실패
- 치명적 결과 초래 (안전, 재산 피해)
- 100% 보장 필요

응용 사례:
- 원자로 제어 시스템
- 자동차 에어백 시스템  
- 항공기 비행 제어
- 의료기기 생명유지장치
```

### 소프트 데드라인 (Soft Deadline)
```
특징:
- 데드라인 위반 시 성능 저하
- 시스템 지속 운영 가능
- 통계적 보장으로 충분

응용 사례:
- 멀티미디어 스트리밍
- 웹 서버 응답
- 게임 프레임 렌더링
- 음성/영상 처리
```

### 펌 데드라인 (Firm Deadline)
```
특징:
- 데드라인 후 결과 무의미
- 늦은 완료는 자원 낭비
- 버려지는 작업 발생

응용 사례:
- 센서 데이터 샘플링
- 실시간 비디오 인코딩
- 네트워크 패킷 전송
```

## 📊 데드라인 분석

### 스케줄링 가능성 분석
```cpp
// Rate Monotonic 분석 (Liu & Layland)
bool isSchedulableRM(Task tasks[], int n) {
    float utilization = 0;
    
    // 전체 이용률 계산
    for(int i = 0; i < n; i++) {
        utilization += (float)tasks[i].execution_time / tasks[i].period;
    }
    
    // Liu-Layland 충분조건
    float bound = n * (pow(2, 1.0/n) - 1);
    
    if(utilization <= bound) {
        return true;  // 스케줄링 가능
    }
    
    // 필요조건 검사  
    return utilization <= 1.0;
}

// EDF 분석
bool isSchedulableEDF(Task tasks[], int n) {
    float utilization = 0;
    
    for(int i = 0; i < n; i++) {
        utilization += (float)tasks[i].execution_time / tasks[i].deadline;
    }
    
    return utilization <= 1.0;  // EDF 최적 조건
}
```

### 응답시간 분석 (Response Time Analysis)
```cpp
// 고정우선순위 시스템에서 최악응답시간 계산
int calculateWorstCaseResponseTime(Task task, Task higher_priority[], int hp_count) {
    int response_time = task.execution_time;
    int prev_response = 0;
    
    // 고정점 반복법
    while(response_time != prev_response) {
        prev_response = response_time;
        int interference = 0;
        
        // 높은 우선순위 작업들의 간섭 계산
        for(int i = 0; i < hp_count; i++) {
            interference += ceil((float)response_time / higher_priority[i].period) 
                          * higher_priority[i].execution_time;
        }
        
        response_time = task.execution_time + interference;
        
        // 수렴하지 않으면 스케줄링 불가능
        if(response_time > task.deadline) {
            return -1;  // 데드라인 위반
        }
    }
    
    return response_time;
}
```

## ⚡ 데드라인 관리 기법

### 데드라인 모니터링
```cpp
class DeadlineMonitor {
private:
    struct TaskDeadline {
        int task_id;
        unsigned long absolute_deadline;
        bool completed;
    };
    
    TaskDeadline deadlines[MAX_TASKS];
    int deadline_count = 0;
    
public:
    void addDeadline(int task_id, unsigned long deadline) {
        if(deadline_count < MAX_TASKS) {
            deadlines[deadline_count] = {task_id, deadline, false};
            deadline_count++;
        }
    }
    
    void checkDeadlines() {
        unsigned long current_time = millis();
        
        for(int i = 0; i < deadline_count; i++) {
            if(!deadlines[i].completed && 
               current_time > deadlines[i].absolute_deadline) {
                
                handleDeadlineMiss(deadlines[i].task_id);
            }
        }
    }
    
    void markCompleted(int task_id) {
        for(int i = 0; i < deadline_count; i++) {
            if(deadlines[i].task_id == task_id) {
                deadlines[i].completed = true;
                break;
            }
        }
    }
};
```

### 데드라인 위반 처리
```cpp
// 데드라인 미스 핸들링 전략
void handleDeadlineMiss(int task_id) {
    switch(getTaskCriticality(task_id)) {
        case HARD_REAL_TIME:
            // 시스템 안전 모드로 전환
            enterSafeMode();
            logCriticalError(task_id);
            break;
            
        case SOFT_REAL_TIME:
            // 성능 저하 허용, 계속 실행
            adjustQualityOfService(task_id);
            logPerformanceWarning(task_id);
            break;
            
        case FIRM_REAL_TIME:
            // 작업 취소, 다음 인스턴스 준비
            cancelTask(task_id);
            prepareNextInstance(task_id);
            break;
    }
}

// 적응적 데드라인 조정
void adaptiveDeadlineAdjustment() {
    static int miss_count = 0;
    static unsigned long last_adjustment = 0;
    
    miss_count++;
    
    // 일정 기간 내 미스가 많으면 데드라인 완화
    if(millis() - last_adjustment > 1000) {
        if(miss_count > MISS_THRESHOLD) {
            relaxDeadlines(0.1);  // 10% 완화
            logMessage("Deadlines relaxed due to frequent misses");
        }
        
        miss_count = 0;
        last_adjustment = millis();
    }
}
```

## 🔍 실측 데이터 분석

### 데드라인 성능 지표
```cpp
class DeadlineMetrics {
private:
    int total_tasks = 0;
    int deadline_misses = 0;
    float worst_tardiness = 0;
    float avg_response_time = 0;
    
public:
    void recordTaskCompletion(unsigned long start_time, 
                            unsigned long end_time, 
                            unsigned long deadline) {
        
        total_tasks++;
        float response_time = end_time - start_time;
        
        // 평균 응답시간 업데이트
        avg_response_time = (avg_response_time * (total_tasks - 1) + response_time) / total_tasks;
        
        // 데드라인 위반 확인
        if(end_time > deadline) {
            deadline_misses++;
            float tardiness = end_time - deadline;
            if(tardiness > worst_tardiness) {
                worst_tardiness = tardiness;
            }
        }
    }
    
    float getDeadlineMissRatio() {
        return (float)deadline_misses / total_tasks * 100.0;
    }
    
    void printStatistics() {
        Serial.printf("Total tasks: %d\n", total_tasks);
        Serial.printf("Deadline miss ratio: %.2f%%\n", getDeadlineMissRatio());
        Serial.printf("Worst tardiness: %.2f ms\n", worst_tardiness);
        Serial.printf("Average response time: %.2f ms\n", avg_response_time);
    }
};
```

---

## 🔗 연결 문서
- 상위: [[실시간제어]]
- 관련: [[지터]], [[레이턴시]], [[처리량]]
- 스케줄링: [[우선순위스케줄링]], [[시분할스케줄링]]
- 구현: [[인터럽트처리]], [[마이크로컨트롤러]]

## 📚 참고문헌
- [Liu & Layland (1973). "Scheduling Algorithms for Multiprogramming in a Hard Real-Time Environment"](https://en.wikipedia.org/wiki/Scheduling_analysis_real-time_systems)
- [Mok (2004). "Real Time Scheduling Theory: A Historical Perspective"](https://www.researchgate.net/publication/220414198_Real_Time_Scheduling_Theory_A_Historical_Perspective)
- [Chetto (2014). "Real-time Systems Scheduling: Fundamentals"](https://www.amazon.com/Real-time-Systems-Scheduling-Fundamentals-Telecommunications/dp/1848216653)
