# 입출력시스템

> 상위: [[전자회로설계]]

마이크로컨트롤러와 외부 장치 간 인터페이스 설계와 구현 방법입니다.

## 📊 MCU별 통신 인터페이스 비교

### Arduino (ATmega328P)
```
UART: 1개 (Serial)
SPI: 1개 (Hardware SPI)
I2C: 1개 (Wire)
GPIO: 14개 디지털, 6개 아날로그
ADC: 10bit, 6채널
PWM: 6채널
인터럽트: 2개 외부 인터럽트 (PIN 2, 3)

특징: 간단한 구조, 초보자 친화적
용도: 프로토타이핑, 간단한 로봇
```

### ESP32
```
UART: 3개 (Serial, Serial1, Serial2)
SPI: 2개 (HSPI, VSPI)
I2C: 2개 (Wire, Wire1)
GPIO: 34개 (일부 입력 전용)
ADC: 12bit, 18채널 (2개 ADC)
DAC: 8bit, 2채널
PWM: LEDC 16채널
인터럽트: 모든 GPIO 핀
WiFi/Bluetooth: 내장
CAN: 1개 (외부 트랜시버 필요)
Touch: 10개 터치 센서

특징: 무선 통신 내장, 듀얼 코어
용도: IoT 로봇, 무선 제어 시스템
```
### STM32 (F4 시리즈)
```
UART/USART: 최대 6개
SPI: 최대 3개
I2C: 최대 3개
GPIO: 80+ 핀 (모델에 따라)
ADC: 12bit, 최대 24채널 (3개 ADC)
DAC: 12bit, 2채널
PWM: 다수 타이머 기반
인터럽트: 모든 GPIO 핀
CAN: 2개 (내장 트랜시버)
USB: OTG 지원
DMA: 고성능 데이터 전송
타이머: 14개 (고급 제어)

특징: 고성능, 실시간 처리
용도: 산업용 로봇, 정밀 제어
```

## 🔄 폴링 vs 인터럽트

### 폴링 (Polling) 방식
```cpp
// Arduino 폴링 예시
void loop() {
    if(digitalRead(SENSOR_PIN) == HIGH) {
        // 센서 감지시 처리
        processSensorData();
    }
    
    if(Serial.available() > 0) {
        // 시리얼 데이터 수신시 처리
        String data = Serial.readString();
    }
    
    delay(10);  // 10ms 주기
}

장점: 간단한 구현, 디버깅 용이
단점: CPU 자원 낭비, 반응속도 제한
```
### 인터럽트 (Interrupt) 방식
```cpp
// ESP32 인터럽트 예시
volatile bool sensorTriggered = false;
volatile long encoderCount = 0;

void IRAM_ATTR sensorISR() {
    sensorTriggered = true;
}

void IRAM_ATTR encoderISR() {
    encoderCount++;
}

void setup() {
    attachInterrupt(digitalPinToInterrupt(2), sensorISR, RISING);
    attachInterrupt(digitalPinToInterrupt(3), encoderISR, CHANGE);
}

void loop() {
    if(sensorTriggered) {
        sensorTriggered = false;
        processSensorEvent();
    }
    
    // 다른 작업 수행 가능
    doOtherTasks();
}

장점: 실시간 반응, 효율적 CPU 사용
단점: 복잡한 구현, 동기화 문제 가능
```

## 📡 MCU별 통신 구현

### Arduino 통신 예시
```cpp
// UART 통신
Serial.begin(9600);
Serial.println("Hello World");

// I2C 마스터
#include <Wire.h>
Wire.begin();
Wire.beginTransmission(0x68);
Wire.write(0x3B);
Wire.endTransmission();
Wire.requestFrom(0x68, 6);

// SPI 통신
#include <SPI.h>
SPI.begin();
SPI.transfer(0xAA);
```
### ESP32 통신 예시
```cpp
// 멀티 UART
Serial.begin(115200);    // USB 시리얼
Serial1.begin(9600, SERIAL_8N1, 16, 17);   // GPIO 16,17
Serial2.begin(115200, SERIAL_8N1, 32, 33); // GPIO 32,33

// 멀티 I2C
Wire.begin(21, 22);      // SDA=21, SCL=22
Wire1.begin(25, 26);     // SDA=25, SCL=26

// 멀티 SPI
SPI.begin(18, 19, 23, 5);    // SCK, MISO, MOSI, SS
HSPI.begin();

// CAN 버스
#include <CAN.h>
CAN.setPins(5, 35);  // TX, RX
CAN.begin(500E3);    // 500kbps

// WiFi
#include <WiFi.h>
WiFi.begin("SSID", "password");

// Bluetooth
#include "BluetoothSerial.h"
BluetoothSerial SerialBT;
SerialBT.begin("ESP32-Robot");
```
### STM32 통신 예시 (HAL 라이브러리)
```cpp
// UART 통신
HAL_UART_Transmit(&huart1, (uint8_t*)"Hello", 5, 1000);
HAL_UART_Receive_IT(&huart1, rxBuffer, 10);

// I2C 통신
HAL_I2C_Master_Transmit(&hi2c1, 0x68<<1, txData, 2, 1000);
HAL_I2C_Master_Receive(&hi2c1, 0x68<<1, rxData, 6, 1000);

// SPI 통신
HAL_SPI_Transmit(&hspi1, txData, 4, 1000);
HAL_SPI_Receive(&hspi1, rxData, 4, 1000);

// CAN 통신
CAN_TxHeaderTypeDef txHeader;
txHeader.StdId = 0x123;
txHeader.DLC = 8;
HAL_CAN_AddTxMessage(&hcan1, &txHeader, txData, &txMailbox);

// DMA 활용 (고속 데이터 전송)
HAL_UART_Transmit_DMA(&huart1, txBuffer, 1024);
HAL_ADC_Start_DMA(&hadc1, adcBuffer, 100);
```

## ⚡ 실무 활용 패턴

### 센서 데이터 수집 시스템
```cpp
// ESP32 멀티 센서 시스템
void setupSensors() {
    // I2C 센서들
    Wire.begin(21, 22);
    setupIMU();        // MPU9250
    setupPressure();   // BMP280
    
    // SPI 센서
    SPI.begin(18, 19, 23);
    setupHighSpeedSensor();
    
    // 아날로그 센서
    setupLoadCell();   // ADC 채널
    
    // 엔코더 (인터럽트)
    attachInterrupt(digitalPinToInterrupt(2), encoderISR, CHANGE);
}
```
### 모터 제어 시스템
```cpp
// STM32 고성능 모터 제어
void setupMotorControl() {
    // PWM 타이머 설정 (3상 BLDC)
    HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);  // U상
    HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);  // V상
    HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_3);  // W상
    
    // 엔코더 인터페이스
    HAL_TIM_Encoder_Start(&htim2, TIM_CHANNEL_ALL);
    
    // CAN 통신 (모터 드라이버 제어)
    HAL_CAN_Start(&hcan1);
    HAL_CAN_ActivateNotification(&hcan1, CAN_IT_RX_FIFO0_MSG_PENDING);
}

// ESP32 간단한 모터 제어
void setupSimpleMotor() {
    // PWM 채널 설정
    ledcSetup(0, 20000, 8);  // 20kHz, 8bit
    ledcAttachPin(12, 0);    // 모터 PWM
    
    // 방향 제어
    pinMode(13, OUTPUT);     // DIR1
    pinMode(14, OUTPUT);     // DIR2
}
```

### 통신 네트워크 구성
```cpp
// 로봇 시스템 통신 아키텍처
// 마스터 (ESP32) → 슬레이브들 (Arduino/STM32)

// ESP32 마스터
void setupRobotNetwork() {
    // 센서 모듈과 I2C 통신
    Wire.begin(21, 22);
    
    // 모터 컨트롤러와 CAN 통신
    CAN.setPins(5, 35);
    CAN.begin(500E3);
    
    // 상위 시스템과 WiFi 통신
    WiFi.begin("RobotNetwork", "password");
    
    // 사용자 인터페이스와 Bluetooth
    SerialBT.begin("Robot-Control");
}
```

## 🔧 선택 가이드

### 프로젝트별 MCU 선택
```
간단한 프로토타입: Arduino Uno
- 학습용, 간단한 센서 연결
- 제한적 통신 인터페이스로 충분

IoT 로봇: ESP32
- 무선 통신 필수
- 다양한 센서 인터페이스 필요
- 적당한 처리 성능

산업용/정밀 제어: STM32
- 실시간 처리 요구
- 다수의 통신 인터페이스
- 고성능 모터 제어
```

---

## 🔗 연결 문서
- 상위: [[전자회로설계]]
- 관련: [[통신인터페이스]], [[마이크로컨트롤러]]
- 응용: [[센서인터페이스]], [[모터드라이버]]