# ëª¨í„°ë“œë¼ì´ë²„

> ìƒìœ„: [[ì „ìíšŒë¡œì„¤ê³„]]

ë¡œë´‡ êµ¬ë™ì„ ìœ„í•œ ì§ë¥˜ ëª¨í„° ì œì–´ íšŒë¡œì™€ ë“œë¼ì´ë²„ ì„¤ê³„ì…ë‹ˆë‹¤.

## âš™ï¸ BLDC ëª¨í„° ì œì–´

### ë¸ŒëŸ¬ì‹œë¦¬ìŠ¤ ì˜êµ¬ìì„ ì§ë¥˜ ëª¨í„° íŠ¹ì§•
- **ê³ íš¨ìœ¨**: 90% ì´ìƒì˜ íš¨ìœ¨
- **ì •ë°€ ì œì–´**: í™€ ì„¼ì„œ ë˜ëŠ” ì—”ì½”ë” í”¼ë“œë°±
- **ê¸´ ìˆ˜ëª…**: ë¸ŒëŸ¬ì‹œ ë§ˆëª¨ ì—†ìŒ
- **ì €ì†ŒìŒ**: ê¸°ê³„ì  ì ‘ì´‰ ìµœì†Œí™”

### ëª¨í„° ì„ ì • ê¸°ì¤€
```
í† í¬ = ë¶€í•˜ ê´€ì„± Ã— ê°ê°€ì†ë„ + ë§ˆì°° í† í¬

í•„ìš” ìŠ¤í™ ì˜ˆì‹œ:
- ì •ê²© í† í¬: 0.5 Nm
- ìµœëŒ€ ì†ë„: 3000 RPM
- ì •ê²© ì „ì••: 24V  
- ì •ê²© ì „ë¥˜: 2A
```

## ğŸ”Œ 3ìƒ ì¸ë²„í„° íšŒë¡œ

### MOSFET ë¸Œë¦¬ì§€
```
DC+ â”€â”¬â”€ Q1 â”€â”¬â”€ Uìƒ
     â”œâ”€ Q3 â”€â”¼â”€ Vìƒ
     â””â”€ Q5 â”€â”¼â”€ Wìƒ
            â”‚
DC- â”€â”´â”€ Q2,Q4,Q6 â”€â”˜
```
### MOSFET ì„ ì •
```
ì£¼ìš” íŒŒë¼ë¯¸í„°:
- Rds(on): ì˜¨ ì €í•­ (ë‚®ì„ìˆ˜ë¡ íš¨ìœ¨ ì¢‹ìŒ)
- Id: ë“œë ˆì¸ ì „ë¥˜ (ëª¨í„° ì „ë¥˜ì˜ 1.5ë°° ì´ìƒ)
- Vds: ë‚´ì•• (ì „ì› ì „ì••ì˜ 2ë°° ì´ìƒ)

ì¶”ì²œ MOSFET:
- ì €ì „ë ¥: IRF530N, IRLZ44N
- ê³ ì „ë ¥: IRF3205, IRFP260N
```

## ğŸ“Š PWM ì œì–´

### ESP32 3ìƒ PWM ìƒì„±
```cpp
void setupMotorPWM() {
    // 20kHz PWM ì„¤ì •
    ledcSetup(0, 20000, 8);  // ì±„ë„0, 20kHz, 8bit
    ledcSetup(1, 20000, 8);  // ì±„ë„1
    ledcSetup(2, 20000, 8);  // ì±„ë„2
    
    // í•€ ì—°ê²°
    ledcAttachPin(12, 0);  // Uìƒ
    ledcAttachPin(13, 1);  // Vìƒ
    ledcAttachPin(14, 2);  // Wìƒ
}

void setMotorVoltage(float u, float v, float w) {
    ledcWrite(0, (int)(u * 255));
    ledcWrite(1, (int)(v * 255));  
    ledcWrite(2, (int)(w * 255));
}
```
### PID ì œì–´ê¸° êµ¬í˜„
```cpp
class PIDController {
private:
    float kp, ki, kd;
    float prev_error = 0;
    float integral = 0;
    
public:
    float update(float setpoint, float feedback, float dt) {
        float error = setpoint - feedback;
        float p_term = kp * error;
        integral += error * dt;
        float i_term = ki * integral;
        float derivative = (error - prev_error) / dt;
        float d_term = kd * derivative;
        prev_error = error;
        return p_term + i_term + d_term;
    }
};
```

## ğŸ›¡ï¸ ë³´í˜¸ ê¸°ëŠ¥

### ê³¼ì „ë¥˜ ë³´í˜¸
```cpp
// í™€ ì„¼ì„œ ê¸°ë°˜ ì „ë¥˜ ì¸¡ì • (ACS712)
float readMotorCurrent() {
    int adc_value = analogRead(CURRENT_SENSOR_PIN);
    float voltage = adc_value * 3.3 / 4095.0;
    float current = (voltage - 1.65) / 0.066;
    return current;
}

void checkOvercurrent() {
    if(readMotorCurrent() > MAX_CURRENT) {
        emergencyStop();
    }
}
```

### ë¹„ìƒ ì •ì§€
```cpp
void emergencyStop() {
    ledcWrite(0, 0);  // ëª¨ë“  PWM ì¶œë ¥ 0
    ledcWrite(1, 0);
    ledcWrite(2, 0);
    digitalWrite(BRAKE_PIN, HIGH);  // ë¸Œë ˆì´í¬ í™œì„±í™”
}
```

---

## ğŸ”— ì—°ê²° ë¬¸ì„œ
- ìƒìœ„: [[ì „ìíšŒë¡œì„¤ê³„]]
- ì´ë¡ : [[êµ¬ë™ê³„ëª¨ë¸ë§]] - ëª¨í„°/ê¸°ì–´/ë§ˆì°° ìƒì„¸ ëª¨ë¸ë§
- ê´€ë ¨: [[ì „ì›ì‹œìŠ¤í…œ]], [[PWMì‹ í˜¸ìƒì„±]]
- ì‘ìš©: [[ì§ë¥˜ëª¨í„°]], [[ì—”ì½”ë”]]
## ğŸš€ ê³ ê¸‰ ëª¨í„° ì œì–´ ê¸°ë²•

### ë²¡í„° ì œì–´ (Field Oriented Control)
```cpp
// FOC êµ¬í˜„ì„ ìœ„í•œ ì¢Œí‘œ ë³€í™˜
struct Vector2D {
    float d, q;  // d-q ì¢Œí‘œê³„
};

struct Vector3D {
    float a, b, c;  // 3ìƒ ì¢Œí‘œê³„
};

// Clarke ë³€í™˜ (3ìƒ â†’ 2ìƒ)
Vector2D clarke_transform(Vector3D abc) {
    Vector2D result;
    result.d = abc.a;
    result.q = (abc.b - abc.c) / sqrt(3.0);
    return result;
}

// Park ë³€í™˜ (ì •ì§€ì¢Œí‘œ â†’ íšŒì „ì¢Œí‘œ)
Vector2D park_transform(Vector2D dq_stat, float theta) {
    Vector2D result;
    float cos_theta = cos(theta);
    float sin_theta = sin(theta);
    
    result.d = dq_stat.d * cos_theta + dq_stat.q * sin_theta;
    result.q = -dq_stat.d * sin_theta + dq_stat.q * cos_theta;
    return result;
}

// FOC ì œì–´ ë£¨í”„
void foc_control_loop() {
    // ì „ë¥˜ ì¸¡ì • (3ìƒ)
    Vector3D i_abc = readMotorCurrents();
    
    // ì¢Œí‘œ ë³€í™˜
    Vector2D i_dq_stat = clarke_transform(i_abc);
    Vector2D i_dq_rot = park_transform(i_dq_stat, rotor_angle);
    
    // PI ì œì–´ê¸°
    float id_ref = 0;  // í† í¬ ìƒì„±ì— ê¸°ì—¬í•˜ì§€ ì•ŠëŠ” ì„±ë¶„
    float iq_ref = torque_command / kt;  // í† í¬ ëª…ë ¹
    
    float vd_ref = pi_controller_d.update(id_ref - i_dq_rot.d);
    float vq_ref = pi_controller_q.update(iq_ref - i_dq_rot.q);
    
    // ì—­ë³€í™˜í•˜ì—¬ 3ìƒ ì „ì•• ìƒì„±
    Vector2D v_dq_stat = inverse_park_transform({vd_ref, vq_ref}, rotor_angle);
    Vector3D v_abc = inverse_clarke_transform(v_dq_stat);
    
    // PWM ì¶œë ¥
    setPWM(v_abc.a, v_abc.b, v_abc.c);
}
```

### ì„¼ì„œë¦¬ìŠ¤ ì œì–´ (Sensorless Control)
```cpp
// ë°±-EMF ê¸°ë°˜ ì„¼ì„œë¦¬ìŠ¤ ì œì–´
class SensorlessControl {
private:
    float bemf_a, bemf_b, bemf_c;
    float estimated_angle = 0;
    float estimated_speed = 0;
    
public:
    void estimateRotorPosition() {
        // ìƒì „ì••ê³¼ ì „ë¥˜ë¡œë¶€í„° ë°±-EMF ê³„ì‚°
        bemf_a = v_phase_a - i_phase_a * R_phase - L_phase * di_dt_a;
        bemf_b = v_phase_b - i_phase_b * R_phase - L_phase * di_dt_b;
        bemf_c = v_phase_c - i_phase_c * R_phase - L_phase * di_dt_c;
        
        // ë°±-EMFë¡œë¶€í„° ìœ„ì¹˜ ì¶”ì • (ì•„í¬íƒ„ì  íŠ¸ ë°©ë²•)
        float bemf_alpha = bemf_a;
        float bemf_beta = (bemf_b - bemf_c) / sqrt(3.0);
        
        estimated_angle = atan2(bemf_beta, bemf_alpha);
        
        // ì†ë„ ì¶”ì • (ìœ„ì¹˜ ë¯¸ë¶„)
        static float prev_angle = 0;
        estimated_speed = (estimated_angle - prev_angle) / dt;
        prev_angle = estimated_angle;
    }
    
    float getRotorAngle() { return estimated_angle; }
    float getRotorSpeed() { return estimated_speed; }
};
```

### ì–´ëŒ‘í‹°ë¸Œ ì œì–´
```cpp
// ë¶€í•˜ ë³€í™”ì— ì ì‘í•˜ëŠ” ì œì–´ê¸°
class AdaptiveController {
private:
    float estimated_inertia = 0.01;  // ì¶”ì • ê´€ì„±
    float estimated_friction = 0.1;  // ì¶”ì • ë§ˆì°°
    
public:
    void updateParameters(float measured_torque, float measured_accel) {
        // ê´€ì„± ì¶”ì • (í† í¬ = ê´€ì„± Ã— ê°€ì†ë„ + ë§ˆì°° Ã— ì†ë„)
        if(abs(measured_accel) > 0.1) {
            estimated_inertia = estimated_inertia * 0.99 + 
                               (measured_torque / measured_accel) * 0.01;
        }
        
        // PID ê²Œì¸ ìë™ ì¡°ì •
        float kp = 10.0 / estimated_inertia;
        float ki = kp / 0.1;  // ì ë¶„ì‹œê°„ 100ms
        float kd = kp * 0.01; // ë¯¸ë¶„ì‹œê°„ 10ms
        
        pid_controller.setGains(kp, ki, kd);
    }
};
```

## âš¡ ì „ë ¥ì „ì ê³ ê¸‰ ê¸°ë²•

### SiC MOSFET í™œìš©
```cpp
// SiC MOSFET íŠ¹ì„±ì„ í™œìš©í•œ ê³ íš¨ìœ¨ ë“œë¼ì´ë²„
// ë” ë†’ì€ ìŠ¤ìœ„ì¹­ ì£¼íŒŒìˆ˜ ê°€ëŠ¥ (100kHz+)

void setupSiCDriver() {
    // ê²Œì´íŠ¸ ë“œë¼ì´ë²„: ë¹ ë¥¸ ìŠ¤ìœ„ì¹­ì„ ìœ„í•œ ê°•í•œ êµ¬ë™ë ¥
    // UCC27531: 4A í”¼í¬ ì „ë¥˜
    
    // ê³ ì£¼íŒŒ PWM ì„¤ì • (100kHz)
    ledcSetup(0, 100000, 10);  // 100kHz, 10bit í•´ìƒë„
    
    // ë°ë“œíƒ€ì„ ì„¤ì • (ë” ì§§ê²Œ ê°€ëŠ¥)
    deadtime_ns = 50;  // 50ns (Si MOSFET ëŒ€ë¹„ 1/4)
}

// ì˜¨ë„ ëª¨ë‹ˆí„°ë§ (SiCëŠ” ê³ ì˜¨ ë™ì‘ ê°€ëŠ¥)
float checkJunctionTemp() {
    // NTC ì¨ë¯¸ìŠ¤í„° ë˜ëŠ” ì˜¨ì¹© ì˜¨ë„ì„¼ì„œ
    float temp = readTemperatureSensor();
    
    if(temp > 150) {  // SiCëŠ” 150Â°Cê¹Œì§€ ë™ì‘ ê°€ëŠ¥
        reduceOperatingPower();
    }
    
    return temp;
}
```

### ë‹¤ìƒ ëª¨í„° ì œì–´ (5ìƒ, 6ìƒ)
```cpp
// 5ìƒ BLDC ëª¨í„° ì œì–´
// ë” ë¶€ë“œëŸ¬ìš´ í† í¬, ê³ ì¥ í—ˆìš©ì„±

void control5PhaseBLDC() {
    float phase_angles[5];
    
    // 5ìƒ 120ë„ ê°„ê²© ëŒ€ì‹  72ë„ ê°„ê²©
    for(int i = 0; i < 5; i++) {
        phase_angles[i] = rotor_angle + i * (2 * PI / 5);
    }
    
    // 5ìƒ PWM ìƒì„±
    for(int i = 0; i < 5; i++) {
        float duty = 0.5 + 0.5 * sin(phase_angles[i]);
        ledcWrite(i, duty * 1023);
    }
}

// ê³ ì¥ í—ˆìš© ì œì–´ (í•œ ìƒ ê³ ì¥ì‹œ)
void faultTolerantControl(int failed_phase) {
    // ë‚¨ì€ 4ìƒìœ¼ë¡œ ì œì–´ ê³„ì†
    for(int i = 0; i < 5; i++) {
        if(i == failed_phase) {
            ledcWrite(i, 0);  // ê³ ì¥ ìƒ ë¹„í™œì„±í™”
        } else {
            // ë³´ìƒëœ PWM ê³„ì‚°
            float compensated_duty = calculateCompensatedDuty(i);
            ledcWrite(i, compensated_duty);
        }
    }
}
```

## ğŸ”Š ëª¨í„° ì§„ë™/ì†ŒìŒ ì œì–´

### í† í¬ ë¦¬í”Œ ìµœì†Œí™”
```cpp
// ì „ë¥˜ ê³ ì¡°íŒŒ ì£¼ì…ì„ í†µí•œ í† í¬ ë¦¬í”Œ ê°ì†Œ
class TorqueRippleReduction {
private:
    float harmonic_amplitudes[6] = {0, 0, 0, 0, 0, 0};  // 6ì°¨ê¹Œì§€
    
public:
    void calculateHarmonics(float fundamental_current) {
        // ëª¨í„°ë³„ íŠ¹ì„±ì— ë”°ë¥¸ ê³ ì¡°íŒŒ ê³„ìˆ˜
        harmonic_amplitudes[0] = fundamental_current;
        harmonic_amplitudes[2] = -0.1 * fundamental_current;  // 3ì°¨ ê³ ì¡°íŒŒ
        harmonic_amplitudes[4] = 0.05 * fundamental_current;  // 5ì°¨ ê³ ì¡°íŒŒ
    }
    
    float generateCurrentReference(float electrical_angle) {
        float current_ref = 0;
        
        for(int n = 0; n < 6; n++) {
            current_ref += harmonic_amplitudes[n] * sin((n+1) * electrical_angle);
        }
        
        return current_ref;
    }
};
```

### ëŠ¥ë™ ì§„ë™ ì œì–´
```cpp
// ê°€ì†ë„ ì„¼ì„œ í”¼ë“œë°±ì„ ì´ìš©í•œ ì§„ë™ ì–µì œ
class VibraitonController {
private:
    float vibration_filter[10];  // ì§„ë™ ì´ë ¥
    int filter_index = 0;
    
public:
    float calculateAntiVibrationTorque(float measured_vibration) {
        // ì§„ë™ ì£¼íŒŒìˆ˜ ë¶„ì„
        addToBuffer(measured_vibration);
        float vibration_frequency = estimateFrequency();
        
        // ì—­ìƒ í† í¬ ìƒì„±
        float anti_torque = -0.1 * measured_vibration;
        anti_torque *= sin(2 * PI * vibration_frequency * millis() / 1000.0 + PI);
        
        return anti_torque;
    }
    
private:
    void addToBuffer(float value) {
        vibration_filter[filter_index] = value;
        filter_index = (filter_index + 1) % 10;
    }
};
```

## ğŸ§  AI ê¸°ë°˜ ëª¨í„° ì œì–´

### ë¨¸ì‹ ëŸ¬ë‹ íŒŒë¼ë¯¸í„° íŠœë‹
```cpp
// ê°•í™”í•™ìŠµì„ ì´ìš©í•œ PID ê²Œì¸ ìµœì í™”
class RLPIDTuner {
private:
    float gain_history[100][3];  // Kp, Ki, Kd ì´ë ¥
    float performance_history[100];  // ì„±ëŠ¥ ì§€í‘œ
    int experience_count = 0;
    
public:
    void learnFromPerformance(float kp, float ki, float kd, float performance) {
        if(experience_count < 100) {
            gain_history[experience_count][0] = kp;
            gain_history[experience_count][1] = ki;
            gain_history[experience_count][2] = kd;
            performance_history[experience_count] = performance;
            experience_count++;
        }
    }
    
    void suggestGains(float* kp, float* ki, float* kd) {
        // ë‹¨ìˆœ ê·¸ë¦¬ë”” ì„ íƒ (ê°€ì¥ ì¢‹ì€ ì„±ëŠ¥ì˜ ê²Œì¸ ì„ íƒ)
        int best_index = 0;
        float best_performance = performance_history[0];
        
        for(int i = 1; i < experience_count; i++) {
            if(performance_history[i] > best_performance) {
                best_performance = performance_history[i];
                best_index = i;
            }
        }
        
        *kp = gain_history[best_index][0];
        *ki = gain_history[best_index][1];
        *kd = gain_history[best_index][2];
    }
};
```

### ì˜ˆì¸¡ ì œì–´ (MPC)
```cpp
// ëª¨ë¸ ì˜ˆì¸¡ ì œì–´ë¥¼ ì´ìš©í•œ ìµœì  ì œì–´
class ModelPredictiveController {
private:
    static const int HORIZON = 10;  // ì˜ˆì¸¡ êµ¬ê°„
    float state_predictions[HORIZON][3];  // ìœ„ì¹˜, ì†ë„, ì „ë¥˜
    
public:
    float optimizeControl(float current_state[3], float reference) {
        float best_control = 0;
        float best_cost = INFINITY;
        
        // ì œì–´ ì…ë ¥ í›„ë³´ë“¤ í‰ê°€
        for(float u = -100; u <= 100; u += 5) {  // í† í¬ ëª…ë ¹ ë²”ìœ„
            float cost = evaluateControlSequence(current_state, u, reference);
            
            if(cost < best_cost) {
                best_cost = cost;
                best_control = u;
            }
        }
        
        return best_control;
    }
    
private:
    float evaluateControlSequence(float state[3], float control, float ref) {
        float cost = 0;
        float temp_state[3] = {state[0], state[1], state[2]};
        
        // ì˜ˆì¸¡ êµ¬ê°„ì— ëŒ€í•´ ë¹„ìš© ê³„ì‚°
        for(int k = 0; k < HORIZON; k++) {
            // ëª¨í„° ëª¨ë¸ë¡œ ë‹¤ìŒ ìƒíƒœ ì˜ˆì¸¡
            predictNextState(temp_state, control);
            
            // ë¹„ìš© í•¨ìˆ˜ (ì¶”ì  ì˜¤ì°¨ + ì œì–´ ë…¸ë ¥)
            float tracking_error = pow(temp_state[0] - ref, 2);
            float control_effort = pow(control, 2) * 0.01;
            cost += tracking_error + control_effort;
        }
        
        return cost;
    }
};
```