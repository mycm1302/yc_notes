# 모터드라이버

> 상위: [[전자회로설계]]

로봇 구동을 위한 직류 모터 제어 회로와 드라이버 설계입니다.

## ⚙️ BLDC 모터 제어

### 브러시리스 영구자석 직류 모터 특징
- **고효율**: 90% 이상의 효율
- **정밀 제어**: 홀 센서 또는 엔코더 피드백
- **긴 수명**: 브러시 마모 없음
- **저소음**: 기계적 접촉 최소화

### 모터 선정 기준
```
토크 = 부하 관성 × 각가속도 + 마찰 토크

필요 스펙 예시:
- 정격 토크: 0.5 Nm
- 최대 속도: 3000 RPM
- 정격 전압: 24V  
- 정격 전류: 2A
```

## 🔌 3상 인버터 회로

### MOSFET 브리지
```
DC+ ─┬─ Q1 ─┬─ U상
     ├─ Q3 ─┼─ V상
     └─ Q5 ─┼─ W상
            │
DC- ─┴─ Q2,Q4,Q6 ─┘
```
### MOSFET 선정
```
주요 파라미터:
- Rds(on): 온 저항 (낮을수록 효율 좋음)
- Id: 드레인 전류 (모터 전류의 1.5배 이상)
- Vds: 내압 (전원 전압의 2배 이상)

추천 MOSFET:
- 저전력: IRF530N, IRLZ44N
- 고전력: IRF3205, IRFP260N
```

## 📊 PWM 제어

### ESP32 3상 PWM 생성
```cpp
void setupMotorPWM() {
    // 20kHz PWM 설정
    ledcSetup(0, 20000, 8);  // 채널0, 20kHz, 8bit
    ledcSetup(1, 20000, 8);  // 채널1
    ledcSetup(2, 20000, 8);  // 채널2
    
    // 핀 연결
    ledcAttachPin(12, 0);  // U상
    ledcAttachPin(13, 1);  // V상
    ledcAttachPin(14, 2);  // W상
}

void setMotorVoltage(float u, float v, float w) {
    ledcWrite(0, (int)(u * 255));
    ledcWrite(1, (int)(v * 255));  
    ledcWrite(2, (int)(w * 255));
}
```
### PID 제어기 구현
```cpp
class PIDController {
private:
    float kp, ki, kd;
    float prev_error = 0;
    float integral = 0;
    
public:
    float update(float setpoint, float feedback, float dt) {
        float error = setpoint - feedback;
        float p_term = kp * error;
        integral += error * dt;
        float i_term = ki * integral;
        float derivative = (error - prev_error) / dt;
        float d_term = kd * derivative;
        prev_error = error;
        return p_term + i_term + d_term;
    }
};
```

## 🛡️ 보호 기능

### 과전류 보호
```cpp
// 홀 센서 기반 전류 측정 (ACS712)
float readMotorCurrent() {
    int adc_value = analogRead(CURRENT_SENSOR_PIN);
    float voltage = adc_value * 3.3 / 4095.0;
    float current = (voltage - 1.65) / 0.066;
    return current;
}

void checkOvercurrent() {
    if(readMotorCurrent() > MAX_CURRENT) {
        emergencyStop();
    }
}
```

### 비상 정지
```cpp
void emergencyStop() {
    ledcWrite(0, 0);  // 모든 PWM 출력 0
    ledcWrite(1, 0);
    ledcWrite(2, 0);
    digitalWrite(BRAKE_PIN, HIGH);  // 브레이크 활성화
}
```

---

## 🔗 연결 문서
- 상위: [[전자회로설계]]
- 이론: [[구동계모델링]] - 모터/기어/마찰 상세 모델링
- 관련: [[전원시스템]], [[PWM신호생성]]
- 응용: [[직류모터]], [[엔코더]]
## 🚀 고급 모터 제어 기법

### 벡터 제어 (Field Oriented Control)
```cpp
// FOC 구현을 위한 좌표 변환
struct Vector2D {
    float d, q;  // d-q 좌표계
};

struct Vector3D {
    float a, b, c;  // 3상 좌표계
};

// Clarke 변환 (3상 → 2상)
Vector2D clarke_transform(Vector3D abc) {
    Vector2D result;
    result.d = abc.a;
    result.q = (abc.b - abc.c) / sqrt(3.0);
    return result;
}

// Park 변환 (정지좌표 → 회전좌표)
Vector2D park_transform(Vector2D dq_stat, float theta) {
    Vector2D result;
    float cos_theta = cos(theta);
    float sin_theta = sin(theta);
    
    result.d = dq_stat.d * cos_theta + dq_stat.q * sin_theta;
    result.q = -dq_stat.d * sin_theta + dq_stat.q * cos_theta;
    return result;
}

// FOC 제어 루프
void foc_control_loop() {
    // 전류 측정 (3상)
    Vector3D i_abc = readMotorCurrents();
    
    // 좌표 변환
    Vector2D i_dq_stat = clarke_transform(i_abc);
    Vector2D i_dq_rot = park_transform(i_dq_stat, rotor_angle);
    
    // PI 제어기
    float id_ref = 0;  // 토크 생성에 기여하지 않는 성분
    float iq_ref = torque_command / kt;  // 토크 명령
    
    float vd_ref = pi_controller_d.update(id_ref - i_dq_rot.d);
    float vq_ref = pi_controller_q.update(iq_ref - i_dq_rot.q);
    
    // 역변환하여 3상 전압 생성
    Vector2D v_dq_stat = inverse_park_transform({vd_ref, vq_ref}, rotor_angle);
    Vector3D v_abc = inverse_clarke_transform(v_dq_stat);
    
    // PWM 출력
    setPWM(v_abc.a, v_abc.b, v_abc.c);
}
```

### 센서리스 제어 (Sensorless Control)
```cpp
// 백-EMF 기반 센서리스 제어
class SensorlessControl {
private:
    float bemf_a, bemf_b, bemf_c;
    float estimated_angle = 0;
    float estimated_speed = 0;
    
public:
    void estimateRotorPosition() {
        // 상전압과 전류로부터 백-EMF 계산
        bemf_a = v_phase_a - i_phase_a * R_phase - L_phase * di_dt_a;
        bemf_b = v_phase_b - i_phase_b * R_phase - L_phase * di_dt_b;
        bemf_c = v_phase_c - i_phase_c * R_phase - L_phase * di_dt_c;
        
        // 백-EMF로부터 위치 추정 (아크탄젠트 방법)
        float bemf_alpha = bemf_a;
        float bemf_beta = (bemf_b - bemf_c) / sqrt(3.0);
        
        estimated_angle = atan2(bemf_beta, bemf_alpha);
        
        // 속도 추정 (위치 미분)
        static float prev_angle = 0;
        estimated_speed = (estimated_angle - prev_angle) / dt;
        prev_angle = estimated_angle;
    }
    
    float getRotorAngle() { return estimated_angle; }
    float getRotorSpeed() { return estimated_speed; }
};
```

### 어댑티브 제어
```cpp
// 부하 변화에 적응하는 제어기
class AdaptiveController {
private:
    float estimated_inertia = 0.01;  // 추정 관성
    float estimated_friction = 0.1;  // 추정 마찰
    
public:
    void updateParameters(float measured_torque, float measured_accel) {
        // 관성 추정 (토크 = 관성 × 가속도 + 마찰 × 속도)
        if(abs(measured_accel) > 0.1) {
            estimated_inertia = estimated_inertia * 0.99 + 
                               (measured_torque / measured_accel) * 0.01;
        }
        
        // PID 게인 자동 조정
        float kp = 10.0 / estimated_inertia;
        float ki = kp / 0.1;  // 적분시간 100ms
        float kd = kp * 0.01; // 미분시간 10ms
        
        pid_controller.setGains(kp, ki, kd);
    }
};
```

## ⚡ 전력전자 고급 기법

### SiC MOSFET 활용
```cpp
// SiC MOSFET 특성을 활용한 고효율 드라이버
// 더 높은 스위칭 주파수 가능 (100kHz+)

void setupSiCDriver() {
    // 게이트 드라이버: 빠른 스위칭을 위한 강한 구동력
    // UCC27531: 4A 피크 전류
    
    // 고주파 PWM 설정 (100kHz)
    ledcSetup(0, 100000, 10);  // 100kHz, 10bit 해상도
    
    // 데드타임 설정 (더 짧게 가능)
    deadtime_ns = 50;  // 50ns (Si MOSFET 대비 1/4)
}

// 온도 모니터링 (SiC는 고온 동작 가능)
float checkJunctionTemp() {
    // NTC 써미스터 또는 온칩 온도센서
    float temp = readTemperatureSensor();
    
    if(temp > 150) {  // SiC는 150°C까지 동작 가능
        reduceOperatingPower();
    }
    
    return temp;
}
```

### 다상 모터 제어 (5상, 6상)
```cpp
// 5상 BLDC 모터 제어
// 더 부드러운 토크, 고장 허용성

void control5PhaseBLDC() {
    float phase_angles[5];
    
    // 5상 120도 간격 대신 72도 간격
    for(int i = 0; i < 5; i++) {
        phase_angles[i] = rotor_angle + i * (2 * PI / 5);
    }
    
    // 5상 PWM 생성
    for(int i = 0; i < 5; i++) {
        float duty = 0.5 + 0.5 * sin(phase_angles[i]);
        ledcWrite(i, duty * 1023);
    }
}

// 고장 허용 제어 (한 상 고장시)
void faultTolerantControl(int failed_phase) {
    // 남은 4상으로 제어 계속
    for(int i = 0; i < 5; i++) {
        if(i == failed_phase) {
            ledcWrite(i, 0);  // 고장 상 비활성화
        } else {
            // 보상된 PWM 계산
            float compensated_duty = calculateCompensatedDuty(i);
            ledcWrite(i, compensated_duty);
        }
    }
}
```

## 🔊 모터 진동/소음 제어

### 토크 리플 최소화
```cpp
// 전류 고조파 주입을 통한 토크 리플 감소
class TorqueRippleReduction {
private:
    float harmonic_amplitudes[6] = {0, 0, 0, 0, 0, 0};  // 6차까지
    
public:
    void calculateHarmonics(float fundamental_current) {
        // 모터별 특성에 따른 고조파 계수
        harmonic_amplitudes[0] = fundamental_current;
        harmonic_amplitudes[2] = -0.1 * fundamental_current;  // 3차 고조파
        harmonic_amplitudes[4] = 0.05 * fundamental_current;  // 5차 고조파
    }
    
    float generateCurrentReference(float electrical_angle) {
        float current_ref = 0;
        
        for(int n = 0; n < 6; n++) {
            current_ref += harmonic_amplitudes[n] * sin((n+1) * electrical_angle);
        }
        
        return current_ref;
    }
};
```

### 능동 진동 제어
```cpp
// 가속도 센서 피드백을 이용한 진동 억제
class VibraitonController {
private:
    float vibration_filter[10];  // 진동 이력
    int filter_index = 0;
    
public:
    float calculateAntiVibrationTorque(float measured_vibration) {
        // 진동 주파수 분석
        addToBuffer(measured_vibration);
        float vibration_frequency = estimateFrequency();
        
        // 역상 토크 생성
        float anti_torque = -0.1 * measured_vibration;
        anti_torque *= sin(2 * PI * vibration_frequency * millis() / 1000.0 + PI);
        
        return anti_torque;
    }
    
private:
    void addToBuffer(float value) {
        vibration_filter[filter_index] = value;
        filter_index = (filter_index + 1) % 10;
    }
};
```

## 🧠 AI 기반 모터 제어

### 머신러닝 파라미터 튜닝
```cpp
// 강화학습을 이용한 PID 게인 최적화
class RLPIDTuner {
private:
    float gain_history[100][3];  // Kp, Ki, Kd 이력
    float performance_history[100];  // 성능 지표
    int experience_count = 0;
    
public:
    void learnFromPerformance(float kp, float ki, float kd, float performance) {
        if(experience_count < 100) {
            gain_history[experience_count][0] = kp;
            gain_history[experience_count][1] = ki;
            gain_history[experience_count][2] = kd;
            performance_history[experience_count] = performance;
            experience_count++;
        }
    }
    
    void suggestGains(float* kp, float* ki, float* kd) {
        // 단순 그리디 선택 (가장 좋은 성능의 게인 선택)
        int best_index = 0;
        float best_performance = performance_history[0];
        
        for(int i = 1; i < experience_count; i++) {
            if(performance_history[i] > best_performance) {
                best_performance = performance_history[i];
                best_index = i;
            }
        }
        
        *kp = gain_history[best_index][0];
        *ki = gain_history[best_index][1];
        *kd = gain_history[best_index][2];
    }
};
```

### 예측 제어 (MPC)
```cpp
// 모델 예측 제어를 이용한 최적 제어
class ModelPredictiveController {
private:
    static const int HORIZON = 10;  // 예측 구간
    float state_predictions[HORIZON][3];  // 위치, 속도, 전류
    
public:
    float optimizeControl(float current_state[3], float reference) {
        float best_control = 0;
        float best_cost = INFINITY;
        
        // 제어 입력 후보들 평가
        for(float u = -100; u <= 100; u += 5) {  // 토크 명령 범위
            float cost = evaluateControlSequence(current_state, u, reference);
            
            if(cost < best_cost) {
                best_cost = cost;
                best_control = u;
            }
        }
        
        return best_control;
    }
    
private:
    float evaluateControlSequence(float state[3], float control, float ref) {
        float cost = 0;
        float temp_state[3] = {state[0], state[1], state[2]};
        
        // 예측 구간에 대해 비용 계산
        for(int k = 0; k < HORIZON; k++) {
            // 모터 모델로 다음 상태 예측
            predictNextState(temp_state, control);
            
            // 비용 함수 (추적 오차 + 제어 노력)
            float tracking_error = pow(temp_state[0] - ref, 2);
            float control_effort = pow(control, 2) * 0.01;
            cost += tracking_error + control_effort;
        }
        
        return cost;
    }
};
```