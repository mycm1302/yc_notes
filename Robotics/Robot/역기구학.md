# ì—­ê¸°êµ¬í•™

> ìƒìœ„: [[ìœ„ì¹˜ê¸°êµ¬í•™]]
>
> ë ˆí¼ëŸ°ìŠ¤:
> - **Modern Robotics** - Lynch & Park (2017) - Chapter 6
> - **Introduction to Robotics** - Craig (2005) - Chapter 4
> - **Wikipedia - Inverse kinematics** (2025ë…„ 1ì›”)
> - **Illinois CS - Inverse Kinematics** (University of Illinois)
> - **RoboDK - Inverse Kinematics in Robotics** (2021ë…„ 6ì›”)

ì›í•˜ëŠ” ë§ë‹¨íš¨ê³¼ê¸°ì˜ ìœ„ì¹˜ì™€ ìì„¸ë¡œë¶€í„° í•„ìš”í•œ ê´€ì ˆ ë³€ìˆ˜ë¥¼ ê³„ì‚°í•˜ëŠ” ê¸°êµ¬í•™ ë¬¸ì œì…ë‹ˆë‹¤.

## ğŸ¯ ê¸°ë³¸ ì •ì˜

### ì—­ê¸°êµ¬í•™ ë¬¸ì œ
ì‘ì—… ê³µê°„(task space)ì—ì„œ ê´€ì ˆ ê³µê°„(joint space)ìœ¼ë¡œì˜ ì—­ë³€í™˜:
```
Î¸ = fâ»Â¹(Tâ‚€â¿)
```

ì—¬ê¸°ì„œ:
- **Tâ‚€â¿**: ì›í•˜ëŠ” ë§ë‹¨íš¨ê³¼ê¸°ì˜ ë™ì°¨ë³€í™˜í–‰ë ¬
- **Î¸**: ê³„ì‚°í•´ì•¼ í•  ê´€ì ˆ ë³€ìˆ˜ ë²¡í„°
- **fâ»Â¹**: ìˆœê¸°êµ¬í•™ì˜ ì—­í•¨ìˆ˜

### ë¬¸ì œì˜ íŠ¹ì„±
- **ë‹¤ì¤‘í•´**: í•˜ë‚˜ì˜ ë§ë‹¨ ìì„¸ì— ëŒ€í•´ ì—¬ëŸ¬ ê´€ì ˆ ì„¤ì • ê°€ëŠ¥
- **í•´ê°€ ì—†ëŠ” ê²½ìš°**: ì‘ì—…ê³µê°„ ë°–ì˜ ìœ„ì¹˜
- **ë¬´í•œí•´**: ì—¬ìœ  ììœ ë„ê°€ ìˆëŠ” ê²½ìš°
- **ë³µì¡ì„±**: í•´ì„ì  í•´ê°€ ì—†ëŠ” ê²½ìš°ê°€ ë§ìŒ

---

## ğŸ” í•´ì„ì  ë°©ë²• (Analytical Methods)

### ê¸°í•˜í•™ì  ì ‘ê·¼ë²• (Geometric Approach)
ë¡œë´‡ì˜ ê¸°í•˜í•™ì  êµ¬ì¡°ë¥¼ ì´ìš©í•œ ì‚¼ê°ë²• í•´ë²•:

#### ê¸°ë³¸ ì›ë¦¬
- **ê¸°í•˜í•™ì  ì§ê´€**: ë¡œë´‡ ë§í¬ì™€ ê´€ì ˆì˜ ë¬¼ë¦¬ì  ê´€ê³„ í™œìš©
- **ì‚¼ê°ë²• ì ìš©**: ì‚¬ì¸, ì½”ì‚¬ì¸ ë²•ì¹™ì„ ì´ìš©í•œ ê°ë„ ê³„ì‚°
- **ì°¨ì› ì¶•ì†Œ**: 3ì°¨ì› ë¬¸ì œë¥¼ 2ì°¨ì› í‰ë©´ ë¬¸ì œë¡œ ë¶„í•´

#### 2ë§í¬ í‰ë©´ ë§¤ë‹ˆí“°ë ˆì´í„° ì˜ˆì œ
ëª©í‘œ ìœ„ì¹˜ (x, y)ì— ëŒ€í•œ ê´€ì ˆê° ê³„ì‚°:

```
# ê¸°í•˜í•™ì  ê´€ê³„ì‹
r = âˆš(xÂ² + yÂ²)  # ëª©í‘œì ê¹Œì§€ì˜ ê±°ë¦¬
cos(Î¸â‚‚) = (rÂ² - Lâ‚Â² - Lâ‚‚Â²)/(2Lâ‚Lâ‚‚)

# ë‘ ê°€ì§€ í•´ (íŒ”ê¿ˆì¹˜ ìœ„/ì•„ë˜)
Î¸â‚‚ = Â±arccos((rÂ² - Lâ‚Â² - Lâ‚‚Â²)/(2Lâ‚Lâ‚‚))

# ì²« ë²ˆì§¸ ê´€ì ˆê°
Î± = atan2(y, x)
Î² = atan2(Lâ‚‚sin(Î¸â‚‚), Lâ‚ + Lâ‚‚cos(Î¸â‚‚))
Î¸â‚ = Î± - Î²  (íŒ”ê¿ˆì¹˜ ì•„ë˜) ë˜ëŠ” Î¸â‚ = Î± + Î²  (íŒ”ê¿ˆì¹˜ ìœ„)
```

### ëŒ€ìˆ˜ì  ì ‘ê·¼ë²• (Algebraic Approach)
ìˆœê¸°êµ¬í•™ ë°©ì •ì‹ì„ ì§ì ‘ ì—­ì‚°í•˜ëŠ” ë°©ë²•:

#### ê¸°ë³¸ ê³¼ì •
1. **ë³€í™˜í–‰ë ¬ ì„¤ì •**: ëª©í‘œ ë³€í™˜í–‰ë ¬ T_desired ì •ì˜
2. **ë°©ì •ì‹ ìœ ë„**: T_desired = Tâ‚€â¿(Î¸â‚, Î¸â‚‚, ..., Î¸â‚™)
3. **ì„±ë¶„ ë¶„ì„**: í–‰ë ¬ ì„±ë¶„ë³„ ë°©ì •ì‹ ì¶”ì¶œ
4. **í•´ ê³„ì‚°**: ì—°ë¦½ë°©ì •ì‹ í•´ë²•

#### êµ¬í˜„ ì˜ˆì œ
```python
def algebraic_ik_2link(target_T, L1, L2):
    """2ë§í¬ ë¡œë´‡ì˜ ëŒ€ìˆ˜ì  ì—­ê¸°êµ¬í•™"""
    # ëª©í‘œ ìœ„ì¹˜ ì¶”ì¶œ
    x = target_T[0, 3]
    y = target_T[1, 3]
    
    # ë°©í–¥ê° ì¶”ì¶œ (2ë§í¬ í‰ë©´ ë¡œë´‡)
    phi = np.arctan2(target_T[1, 0], target_T[0, 0])
    
    # ì†ëª© ìœ„ì¹˜ ê³„ì‚° (ë§ë‹¨ì—ì„œ ì—­ì¶”ì )
    wx = x - L2 * np.cos(phi)
    wy = y - L2 * np.sin(phi)
    
    # 2ë§í¬ ìœ„ì¹˜ ë¬¸ì œë¡œ ì¶•ì†Œ
    r = np.sqrt(wx**2 + wy**2)
    cos_theta2 = (r**2 - L1**2 - L2**2) / (2*L1*L2)
    
    # í•´ ì¡´ì¬ í™•ì¸
    if abs(cos_theta2) > 1:
        return None  # í•´ê°€ ì—†ìŒ
    
    # ë‘ ê°€ì§€ í•´ ê³„ì‚°
    theta2_1 = np.arccos(cos_theta2)
    theta2_2 = -theta2_1
    
    solutions = []
    for theta2 in [theta2_1, theta2_2]:
        theta1 = np.arctan2(wy, wx) - np.arctan2(L2*np.sin(theta2), 
                                                 L1 + L2*np.cos(theta2))
        solutions.append([theta1, theta2])
    
    return solutions
```

---

## ğŸ”¢ ìˆ˜ì¹˜ì  ë°©ë²• (Numerical Methods)

### Newton-Raphson ë°©ë²•
ì•¼ì½”ë¹„ì•ˆ í–‰ë ¬ì„ ì´ìš©í•œ ë°˜ë³µì  í•´ë²•:

#### ê¸°ë³¸ ì•Œê³ ë¦¬ì¦˜
```
1. ì´ˆê¸° ì¶”ì •ê°’ Î¸â‚€ ì„¤ì •
2. ë°˜ë³µ:
   - í˜„ì¬ ë§ë‹¨ ìì„¸ ê³„ì‚°: T_current = FK(Î¸áµ¢)
   - ì˜¤ì°¨ ê³„ì‚°: e = T_desired - T_current
   - ì•¼ì½”ë¹„ì•ˆ ê³„ì‚°: J = âˆ‚FK/âˆ‚Î¸|Î¸áµ¢
   - ê´€ì ˆ ì—…ë°ì´íŠ¸: Î¸áµ¢â‚Šâ‚ = Î¸áµ¢ + Jâºe
3. ìˆ˜ë ´ ì¡°ê±´ í™•ì¸: ||e|| < Îµ
```

#### ì•¼ì½”ë¹„ì•ˆ ì˜ì‚¬ì—­í–‰ë ¬ (Pseudoinverse)
íŠ¹ì´ì ê³¼ ì—¬ìœ  ììœ ë„ ì²˜ë¦¬:
```
Jâº = (Jáµ€J)â»Â¹Jáµ€  (ê³¼ê²°ì •ê³„, m > n)
Jâº = Jáµ€(JJáµ€)â»Â¹  (ë¶€ì¡±ê²°ì •ê³„, m < n)
```

### êµ¬í˜„ ì˜ˆì œ
```python
def numerical_ik_jacobian(robot, target_pose, max_iter=100, tol=1e-6):
    """ì•¼ì½”ë¹„ì•ˆ ê¸°ë°˜ ìˆ˜ì¹˜ ì—­ê¸°êµ¬í•™"""
    theta = robot.q  # í˜„ì¬ ê´€ì ˆê°
    
    for i in range(max_iter):
        # ìˆœê¸°êµ¬í•™ ê³„ì‚°
        current_T = robot.fkine(theta)
        
        # ìì„¸ ì˜¤ì°¨ ê³„ì‚° (ìœ„ì¹˜ + ë°©í–¥)
        pos_error = target_pose[:3, 3] - current_T[:3, 3]
        rot_error = rotation_error(target_pose[:3, :3], current_T[:3, :3])
        error = np.concatenate([pos_error, rot_error])
        
        # ìˆ˜ë ´ í™•ì¸
        if np.linalg.norm(error) < tol:
            return theta, True
        
        # ì•¼ì½”ë¹„ì•ˆ ê³„ì‚°
        J = robot.jacob0(theta)  # ê¸°ì¤€ ì¢Œí‘œê³„ ì•¼ì½”ë¹„ì•ˆ
        
        # ì˜ì‚¬ì—­í–‰ë ¬ë¡œ ê´€ì ˆê° ì—…ë°ì´íŠ¸
        J_pinv = np.linalg.pinv(J)
        delta_theta = J_pinv @ error
        
        # ìŠ¤í… í¬ê¸° ì¡°ì • (ë°œì‚° ë°©ì§€)
        step_size = min(1.0, 0.1 / np.linalg.norm(delta_theta))
        theta += step_size * delta_theta
    
    return theta, False  # ìˆ˜ë ´ ì‹¤íŒ¨

def rotation_error(R_desired, R_current):
    """íšŒì „ ì˜¤ì°¨ë¥¼ ê°ì†ë„ ë²¡í„°ë¡œ ë³€í™˜"""
    R_error = R_desired @ R_current.T
    # ì¶•-ê° í‘œí˜„ìœ¼ë¡œ ë³€í™˜
    angle = np.arccos((np.trace(R_error) - 1) / 2)
    if abs(angle) < 1e-6:
        return np.zeros(3)
    
    axis = np.array([R_error[2,1] - R_error[1,2],
                     R_error[0,2] - R_error[2,0], 
                     R_error[1,0] - R_error[0,1]]) / (2 * np.sin(angle))
    return angle * axis
```

---

## ğŸ”§ ê¸°êµ¬í•™ì  ë¶„ë¦¬ (Kinematic Decoupling)

### 6ììœ ë„ ë¡œë´‡ì˜ ë¶„ë¦¬ ì „ëµ
êµ¬í˜• ì†ëª©ì„ ê°€ì§„ 6ì¶• ë¡œë´‡ì˜ ì²´ê³„ì  í•´ë²•:

#### ìœ„ì¹˜ ë¬¸ì œ (Position Problem)
ì²˜ìŒ 3ê°œ ê´€ì ˆë¡œ ì†ëª© ì¤‘ì‹¬ ìœ„ì¹˜ ê²°ì •:
```
# ì†ëª© ì¤‘ì‹¬ ìœ„ì¹˜ ê³„ì‚°
w_center = target_pos - dâ‚† * target_orientation[:, 2]

# 3ììœ ë„ ìœ„ì¹˜ ë¬¸ì œë¡œ ì¶•ì†Œ
Î¸â‚, Î¸â‚‚, Î¸â‚ƒ = solve_position_ik(w_center)
```

#### ìì„¸ ë¬¸ì œ (Orientation Problem)  
ë§ˆì§€ë§‰ 3ê°œ ê´€ì ˆë¡œ ë§ë‹¨ ìì„¸ ê²°ì •:
```python
def solve_wrist_orientation(R_target, theta123):
    """êµ¬í˜• ì†ëª©ì˜ ìì„¸ ì—­ê¸°êµ¬í•™"""
    # ì²˜ìŒ 3ê°œ ê´€ì ˆë¡œ ì¸í•œ íšŒì „ ê³„ì‚°
    R_03 = forward_kinematics_03(theta123)
    
    # ì†ëª©ì—ì„œì˜ ìƒëŒ€ íšŒì „ ê³„ì‚°
    R_36 = R_03.T @ R_target
    
    # ZYZ ì˜¤ì¼ëŸ¬ê°ìœ¼ë¡œ ë¶„í•´
    theta5 = np.arccos(R_36[2, 2])
    
    if abs(np.sin(theta5)) > 1e-6:  # íŠ¹ì´ì  íšŒí”¼
        theta4 = np.arctan2(R_36[1, 2], R_36[0, 2])
        theta6 = np.arctan2(R_36[2, 1], -R_36[2, 0])
    else:  # íŠ¹ì´ì ì—ì„œì˜ ì²˜ë¦¬
        theta4 = 0  # ì„ì˜ë¡œ ì„¤ì •
        if theta5 > 0:  # theta5 = 0
            theta6 = np.arctan2(R_36[1, 0], R_36[0, 0])
        else:  # theta5 = Ï€
            theta6 = np.arctan2(-R_36[1, 0], R_36[0, 0])
    
    return theta4, theta5, theta6
```

---

## âš ï¸ íŠ¹ì´ì ê³¼ ë‹¤ì¤‘í•´ ë¬¸ì œ

### íŠ¹ì´ì  (Singularities)
ì•¼ì½”ë¹„ì•ˆ í–‰ë ¬ì´ íŠ¹ì´ì ì—ì„œ ë°œìƒí•˜ëŠ” ë¬¸ì œ:

#### íŠ¹ì´ì ì˜ ì¢…ë¥˜
1. **ê²½ê³„ íŠ¹ì´ì **: ì‘ì—…ê³µê°„ ê²½ê³„ì—ì„œ ë°œìƒ
2. **ë‚´ë¶€ íŠ¹ì´ì **: ì‘ì—…ê³µê°„ ë‚´ë¶€ì—ì„œ ë°œìƒ  
3. **ì†ëª© íŠ¹ì´ì **: êµ¬í˜• ì†ëª©ì—ì„œ ì¶•ì´ ì¼ì¹˜í•  ë•Œ

#### íŠ¹ì´ì  ì²˜ë¦¬ ë°©ë²•
```python
def damped_least_squares(J, damping=0.01):
    """ê°ì‡  ìµœì†Œì œê³±ë²•ìœ¼ë¡œ íŠ¹ì´ì  íšŒí”¼"""
    m, n = J.shape
    if m >= n:
        return J.T @ np.linalg.inv(J @ J.T + damping**2 * np.eye(m))
    else:
        return np.linalg.inv(J.T @ J + damping**2 * np.eye(n)) @ J.T

def singular_value_filtering(J, threshold=1e-6):
    """íŠ¹ì´ê°’ í•„í„°ë§ìœ¼ë¡œ ìˆ˜ì¹˜ì  ì•ˆì •ì„± í–¥ìƒ"""
    U, s, Vt = np.linalg.svd(J)
    s_filtered = np.where(s > threshold, 1/s, 0)
    return Vt.T @ np.diag(s_filtered) @ U.T
```

### ë‹¤ì¤‘í•´ ì„ íƒ ì „ëµ
ì—¬ëŸ¬ í•´ ì¤‘ ìµœì í•´ ì„ íƒ:

#### ì„ íƒ ê¸°ì¤€
1. **ê´€ì ˆ í•œê³„ íšŒí”¼**: ê´€ì ˆ ê°€ë™ë²”ìœ„ ë‚´ì˜ í•´ ìš°ì„ 
2. **í˜„ì¬ ìì„¸ì™€ì˜ ê·¼ì ‘ì„±**: ìµœì†Œ ê´€ì ˆ ë³€í™”ëŸ‰
3. **íŠ¹ì´ì  íšŒí”¼**: ì¡°ì‘ì„± ì§€ìˆ˜ ê³ ë ¤
4. **ì¶©ëŒ íšŒí”¼**: ìì²´ ì¶©ëŒ ë° í™˜ê²½ ì¶©ëŒ íšŒí”¼

```python
def select_best_solution(solutions, current_theta, joint_limits):
    """ìµœì  í•´ ì„ íƒ"""
    best_score = float('inf')
    best_solution = None
    
    for sol in solutions:
        # ê´€ì ˆ í•œê³„ í™•ì¸
        if not check_joint_limits(sol, joint_limits):
            continue
            
        # í˜„ì¬ ìì„¸ì™€ì˜ ê±°ë¦¬
        distance = np.linalg.norm(sol - current_theta)
        
        # ì¡°ì‘ì„± ì§€ìˆ˜ (íŠ¹ì´ì  íšŒí”¼)
        manipulability = calculate_manipulability(sol)
        
        # ì¢…í•© ì ìˆ˜ (ë‚®ì„ìˆ˜ë¡ ì¢‹ìŒ)
        score = distance + 1.0 / (manipulability + 1e-6)
        
        if score < best_score:
            best_score = score
            best_solution = sol
    
    return best_solution
```

---

## ğŸ”„ ê³ ê¸‰ ìˆ˜ì¹˜ ë°©ë²•

### Cyclic Coordinate Descent (CCD)
ê´€ì ˆì„ ìˆœì°¨ì ìœ¼ë¡œ ìµœì í™”í•˜ëŠ” ë°©ë²•:

```python
def ccd_inverse_kinematics(robot, target_pos, max_iter=100):
    """ìˆœí™˜ ì¢Œí‘œ í•˜ê°•ë²•"""
    theta = robot.q.copy()
    n_joints = len(theta)
    
    for iteration in range(max_iter):
        for i in range(n_joints-1, -1, -1):  # ëì—ì„œë¶€í„°
            # í˜„ì¬ ë§ë‹¨ ìœ„ì¹˜
            current_T = robot.fkine(theta)
            current_pos = current_T[:3, 3]
            
            # ië²ˆì§¸ ê´€ì ˆ ìœ„ì¹˜
            joint_T = robot.fkine(theta, end=i)
            joint_pos = joint_T[:3, 3]
            
            # ë²¡í„° ê³„ì‚°
            v1 = current_pos - joint_pos
            v2 = target_pos - joint_pos
            
            # íšŒì „ ê°ë„ ê³„ì‚°
            if np.linalg.norm(v1) > 1e-6 and np.linalg.norm(v2) > 1e-6:
                v1_norm = v1 / np.linalg.norm(v1)
                v2_norm = v2 / np.linalg.norm(v2)
                
                cos_angle = np.clip(np.dot(v1_norm, v2_norm), -1, 1)
                angle = np.arccos(cos_angle)
                
                # íšŒì „ ë°©í–¥ ê²°ì •
                axis = joint_T[:3, 2]  # zì¶•
                cross = np.cross(v1_norm, v2_norm)
                if np.dot(cross, axis) < 0:
                    angle = -angle
                
                theta[i] += angle
        
        # ìˆ˜ë ´ í™•ì¸
        current_T = robot.fkine(theta)
        error = np.linalg.norm(target_pos - current_T[:3, 3])
        if error < 1e-6:
            break
    
    return theta
```

### FABRIK (Forward And Backward Reaching IK)
ì „ì§„ ë° í›„ì§„ ë„ë‹¬ ì•Œê³ ë¦¬ì¦˜:

```python
def fabrik_2d(joints, target, tolerance=1e-6, max_iter=100):
    """2D FABRIK ì•Œê³ ë¦¬ì¦˜"""
    n = len(joints)
    distances = [np.linalg.norm(joints[i+1] - joints[i]) 
                for i in range(n-1)]
    
    for _ in range(max_iter):
        # í›„ì§„ íŒ¨ìŠ¤ (ëª©í‘œì—ì„œ ì‹œì‘)
        joints[-1] = target
        for i in range(n-2, -1, -1):
            direction = (joints[i] - joints[i+1])
            direction = direction / np.linalg.norm(direction)
            joints[i] = joints[i+1] + distances[i] * direction
        
        # ì „ì§„ íŒ¨ìŠ¤ (ê¸°ì¤€ì ì—ì„œ ì‹œì‘)
        joints[0] = np.array([0, 0])  # ê³ ì •ëœ ê¸°ì¤€ì 
        for i in range(n-1):
            direction = (joints[i+1] - joints[i])
            direction = direction / np.linalg.norm(direction)
            joints[i+1] = joints[i] + distances[i] * direction
        
        # ìˆ˜ë ´ í™•ì¸
        if np.linalg.norm(joints[-1] - target) < tolerance:
            break
    
    return joints
```

---

## ğŸ’¡ ì¥ë‹¨ì  ë¹„êµ

### í•´ì„ì  ë°©ë²•
#### ì¥ì 
- **ê³ ì† ê³„ì‚°**: ì§ì ‘ ê³µì‹ìœ¼ë¡œ ì¦‰ì‹œ ê³„ì‚°
- **ëª¨ë“  í•´ ì œê³µ**: ê°€ëŠ¥í•œ ëª¨ë“  í•´ í™•ì¸ ê°€ëŠ¥
- **ìˆ˜ì¹˜ ì˜¤ì°¨ ì—†ìŒ**: ì •í™•í•œ í•´
- **ì˜ˆì¸¡ ê°€ëŠ¥**: í•­ìƒ ë™ì¼í•œ ê²°ê³¼

#### ë‹¨ì 
- **ë³µì¡í•œ ìœ ë„**: ë¡œë´‡ë³„ ê°œë³„ ìœ ë„ í•„ìš”
- **ì œí•œì  ì ìš©**: íŠ¹ë³„í•œ êµ¬ì¡°ì˜ ë¡œë´‡ë§Œ ê°€ëŠ¥
- **í™•ì¥ì„± ë¶€ì¡±**: ì—¬ìœ  ììœ ë„ ì²˜ë¦¬ ì–´ë ¤ì›€

### ìˆ˜ì¹˜ì  ë°©ë²•
#### ì¥ì 
- **ì¼ë°˜ì„±**: ëª¨ë“  ë¡œë´‡ êµ¬ì¡°ì— ì ìš© ê°€ëŠ¥
- **ì—¬ìœ  ììœ ë„ ì²˜ë¦¬**: ìµœì í™” ê¸°ì¤€ ì¶”ê°€ ê°€ëŠ¥
- **ì œì•½ ì¡°ê±´**: ê´€ì ˆ í•œê³„, ì¶©ëŒ íšŒí”¼ ë“± ê³ ë ¤
- **í™•ì¥ì„±**: ë³µì¡í•œ ë¡œë´‡ë„ ì²˜ë¦¬ ê°€ëŠ¥

#### ë‹¨ì 
- **ê³„ì‚° ë¹„ìš©**: ë°˜ë³µ ê³„ì‚°ìœ¼ë¡œ ì¸í•œ ì§€ì—°
- **ì´ˆê¸°ê°’ ì˜ì¡´**: ìˆ˜ë ´ì„±ì´ ì´ˆê¸° ì¶”ì •ê°’ì— ì¢Œìš°
- **ì§€ì—­ ìµœì í•´**: ì „ì—­ ìµœì í•´ ë³´ì¥ ì•ˆë¨
- **íŠ¹ì´ì  ë¬¸ì œ**: ìˆ˜ì¹˜ì  ë¶ˆì•ˆì •ì„±

---

## ğŸ¯ ì‹¤ìš©ì  êµ¬í˜„ íŒ

### ì´ˆê¸°ê°’ ì„ íƒ ì „ëµ
```python
def generate_initial_guesses(robot, target_pose, n_attempts=10):
    """ë‹¤ì–‘í•œ ì´ˆê¸°ê°’ ìƒì„±"""
    guesses = []
    
    # 1. í˜„ì¬ ê´€ì ˆê°
    guesses.append(robot.q.copy())
    
    # 2. ì˜ì  ìì„¸
    guesses.append(np.zeros(robot.n))
    
    # 3. ëœë¤ ìì„¸ (ê´€ì ˆ í•œê³„ ë‚´)
    for _ in range(n_attempts - 2):
        random_q = np.random.uniform(robot.qlim[0], robot.qlim[1])
        guesses.append(random_q)
    
    return guesses
```

### ê°•ê±´í•œ ì—­ê¸°êµ¬í•™ ì†”ë²„
```python
def robust_inverse_kinematics(robot, target_pose):
    """ì—¬ëŸ¬ ë°©ë²•ì„ ì¡°í•©í•œ ê°•ê±´í•œ ì—­ê¸°êµ¬í•™"""
    
    # 1. í•´ì„ì  í•´ê°€ ìˆëŠ” ê²½ìš° ìš°ì„  ì‹œë„
    if hasattr(robot, 'analytical_ik'):
        analytical_solutions = robot.analytical_ik(target_pose)
        if analytical_solutions:
            return select_best_solution(analytical_solutions, robot.q)
    
    # 2. ìˆ˜ì¹˜ì  ë°©ë²•ë“¤ ì‹œë„
    methods = [
        lambda: numerical_ik_jacobian(robot, target_pose),
        lambda: ccd_inverse_kinematics(robot, target_pose[:3, 3]),
        lambda: fabrik_ik(robot, target_pose)
    ]
    
    for method in methods:
        try:
            solution, success = method()
            if success:
                return solution
        except:
            continue
    
    # 3. ëª¨ë“  ë°©ë²• ì‹¤íŒ¨ ì‹œ ê·¼ì‚¬í•´ ë°˜í™˜
    return numerical_ik_jacobian(robot, target_pose, max_iter=1000)
```

---

## ğŸ”— ì—°ê²° ë¶„ì•¼
- ìƒìœ„: [[ìœ„ì¹˜ê¸°êµ¬í•™]]
- ê¸°ì´ˆ: [[ìˆœê¸°êµ¬í•™]], [[ì•¼ì½”ë¹„ì•ˆë¶„ì„]]
- ì‘ìš©: [[ê¶¤ì ê³„íš]], [[ë¡œë´‡ì œì–´ê¸°ë²•]]
- ë„êµ¬: [[ìˆ˜ì¹˜í•´ì„]], [[ìµœì í™”ì´ë¡ ]]

---

## ğŸ“š ì°¸ê³ ë¬¸í—Œ
1. Lynch, K.M. & Park, F.C. (2017). *Modern Robotics: Mechanics, Planning, and Control*. Cambridge University Press. Chapter 6
2. Craig, J.J. (2005). *Introduction to Robotics: Mechanics and Control* (3rd ed.). Pearson. Chapter 4
3. Wikipedia Contributors. (2025). "Inverse kinematics." *Wikipedia*. Retrieved January 2025
4. University of Illinois. "Chapter 6. Inverse kinematics." *Robotic Systems*
5. RoboDK. (2021). "Inverse Kinematics in Robotics: What You Need to Know." Blog Post
6. Aristidou, A. & Lasenby, J. (2011). "FABRIK: A fast, iterative solver for the Inverse Kinematics problem." *Graphical Models*, 73(5), 243-260