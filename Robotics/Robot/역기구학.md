# 역기구학

> 상위: [[위치기구학]]
>
> 레퍼런스:
> - **Modern Robotics** - Lynch & Park (2017) - Chapter 6
> - **Introduction to Robotics** - Craig (2005) - Chapter 4
> - **Wikipedia - Inverse kinematics** (2025년 1월)
> - **Illinois CS - Inverse Kinematics** (University of Illinois)
> - **RoboDK - Inverse Kinematics in Robotics** (2021년 6월)

원하는 말단효과기의 위치와 자세로부터 필요한 관절 변수를 계산하는 기구학 문제입니다.

## 🎯 기본 정의

### 역기구학 문제
작업 공간(task space)에서 관절 공간(joint space)으로의 역변환:
```
θ = f⁻¹(T₀ⁿ)
```

여기서:
- **T₀ⁿ**: 원하는 말단효과기의 동차변환행렬
- **θ**: 계산해야 할 관절 변수 벡터
- **f⁻¹**: 순기구학의 역함수

### 문제의 특성
- **다중해**: 하나의 말단 자세에 대해 여러 관절 설정 가능
- **해가 없는 경우**: 작업공간 밖의 위치
- **무한해**: 여유 자유도가 있는 경우
- **복잡성**: 해석적 해가 없는 경우가 많음

---

## 🔍 해석적 방법 (Analytical Methods)

### 기하학적 접근법 (Geometric Approach)
로봇의 기하학적 구조를 이용한 삼각법 해법:

#### 기본 원리
- **기하학적 직관**: 로봇 링크와 관절의 물리적 관계 활용
- **삼각법 적용**: 사인, 코사인 법칙을 이용한 각도 계산
- **차원 축소**: 3차원 문제를 2차원 평면 문제로 분해

#### 2링크 평면 매니퓰레이터 예제
목표 위치 (x, y)에 대한 관절각 계산:

```
# 기하학적 관계식
r = √(x² + y²)  # 목표점까지의 거리
cos(θ₂) = (r² - L₁² - L₂²)/(2L₁L₂)

# 두 가지 해 (팔꿈치 위/아래)
θ₂ = ±arccos((r² - L₁² - L₂²)/(2L₁L₂))

# 첫 번째 관절각
α = atan2(y, x)
β = atan2(L₂sin(θ₂), L₁ + L₂cos(θ₂))
θ₁ = α - β  (팔꿈치 아래) 또는 θ₁ = α + β  (팔꿈치 위)
```

### 대수적 접근법 (Algebraic Approach)
순기구학 방정식을 직접 역산하는 방법:

#### 기본 과정
1. **변환행렬 설정**: 목표 변환행렬 T_desired 정의
2. **방정식 유도**: T_desired = T₀ⁿ(θ₁, θ₂, ..., θₙ)
3. **성분 분석**: 행렬 성분별 방정식 추출
4. **해 계산**: 연립방정식 해법

#### 구현 예제
```python
def algebraic_ik_2link(target_T, L1, L2):
    """2링크 로봇의 대수적 역기구학"""
    # 목표 위치 추출
    x = target_T[0, 3]
    y = target_T[1, 3]
    
    # 방향각 추출 (2링크 평면 로봇)
    phi = np.arctan2(target_T[1, 0], target_T[0, 0])
    
    # 손목 위치 계산 (말단에서 역추적)
    wx = x - L2 * np.cos(phi)
    wy = y - L2 * np.sin(phi)
    
    # 2링크 위치 문제로 축소
    r = np.sqrt(wx**2 + wy**2)
    cos_theta2 = (r**2 - L1**2 - L2**2) / (2*L1*L2)
    
    # 해 존재 확인
    if abs(cos_theta2) > 1:
        return None  # 해가 없음
    
    # 두 가지 해 계산
    theta2_1 = np.arccos(cos_theta2)
    theta2_2 = -theta2_1
    
    solutions = []
    for theta2 in [theta2_1, theta2_2]:
        theta1 = np.arctan2(wy, wx) - np.arctan2(L2*np.sin(theta2), 
                                                 L1 + L2*np.cos(theta2))
        solutions.append([theta1, theta2])
    
    return solutions
```

---

## 🔢 수치적 방법 (Numerical Methods)

### Newton-Raphson 방법
야코비안 행렬을 이용한 반복적 해법:

#### 기본 알고리즘
```
1. 초기 추정값 θ₀ 설정
2. 반복:
   - 현재 말단 자세 계산: T_current = FK(θᵢ)
   - 오차 계산: e = T_desired - T_current
   - 야코비안 계산: J = ∂FK/∂θ|θᵢ
   - 관절 업데이트: θᵢ₊₁ = θᵢ + J⁺e
3. 수렴 조건 확인: ||e|| < ε
```

#### 야코비안 의사역행렬 (Pseudoinverse)
특이점과 여유 자유도 처리:
```
J⁺ = (JᵀJ)⁻¹Jᵀ  (과결정계, m > n)
J⁺ = Jᵀ(JJᵀ)⁻¹  (부족결정계, m < n)
```

### 구현 예제
```python
def numerical_ik_jacobian(robot, target_pose, max_iter=100, tol=1e-6):
    """야코비안 기반 수치 역기구학"""
    theta = robot.q  # 현재 관절각
    
    for i in range(max_iter):
        # 순기구학 계산
        current_T = robot.fkine(theta)
        
        # 자세 오차 계산 (위치 + 방향)
        pos_error = target_pose[:3, 3] - current_T[:3, 3]
        rot_error = rotation_error(target_pose[:3, :3], current_T[:3, :3])
        error = np.concatenate([pos_error, rot_error])
        
        # 수렴 확인
        if np.linalg.norm(error) < tol:
            return theta, True
        
        # 야코비안 계산
        J = robot.jacob0(theta)  # 기준 좌표계 야코비안
        
        # 의사역행렬로 관절각 업데이트
        J_pinv = np.linalg.pinv(J)
        delta_theta = J_pinv @ error
        
        # 스텝 크기 조정 (발산 방지)
        step_size = min(1.0, 0.1 / np.linalg.norm(delta_theta))
        theta += step_size * delta_theta
    
    return theta, False  # 수렴 실패

def rotation_error(R_desired, R_current):
    """회전 오차를 각속도 벡터로 변환"""
    R_error = R_desired @ R_current.T
    # 축-각 표현으로 변환
    angle = np.arccos((np.trace(R_error) - 1) / 2)
    if abs(angle) < 1e-6:
        return np.zeros(3)
    
    axis = np.array([R_error[2,1] - R_error[1,2],
                     R_error[0,2] - R_error[2,0], 
                     R_error[1,0] - R_error[0,1]]) / (2 * np.sin(angle))
    return angle * axis
```

---

## 🔧 기구학적 분리 (Kinematic Decoupling)

### 6자유도 로봇의 분리 전략
구형 손목을 가진 6축 로봇의 체계적 해법:

#### 위치 문제 (Position Problem)
처음 3개 관절로 손목 중심 위치 결정:
```
# 손목 중심 위치 계산
w_center = target_pos - d₆ * target_orientation[:, 2]

# 3자유도 위치 문제로 축소
θ₁, θ₂, θ₃ = solve_position_ik(w_center)
```

#### 자세 문제 (Orientation Problem)  
마지막 3개 관절로 말단 자세 결정:
```python
def solve_wrist_orientation(R_target, theta123):
    """구형 손목의 자세 역기구학"""
    # 처음 3개 관절로 인한 회전 계산
    R_03 = forward_kinematics_03(theta123)
    
    # 손목에서의 상대 회전 계산
    R_36 = R_03.T @ R_target
    
    # ZYZ 오일러각으로 분해
    theta5 = np.arccos(R_36[2, 2])
    
    if abs(np.sin(theta5)) > 1e-6:  # 특이점 회피
        theta4 = np.arctan2(R_36[1, 2], R_36[0, 2])
        theta6 = np.arctan2(R_36[2, 1], -R_36[2, 0])
    else:  # 특이점에서의 처리
        theta4 = 0  # 임의로 설정
        if theta5 > 0:  # theta5 = 0
            theta6 = np.arctan2(R_36[1, 0], R_36[0, 0])
        else:  # theta5 = π
            theta6 = np.arctan2(-R_36[1, 0], R_36[0, 0])
    
    return theta4, theta5, theta6
```

---

## ⚠️ 특이점과 다중해 문제

### 특이점 (Singularities)
야코비안 행렬이 특이점에서 발생하는 문제:

#### 특이점의 종류
1. **경계 특이점**: 작업공간 경계에서 발생
2. **내부 특이점**: 작업공간 내부에서 발생  
3. **손목 특이점**: 구형 손목에서 축이 일치할 때

#### 특이점 처리 방법
```python
def damped_least_squares(J, damping=0.01):
    """감쇠 최소제곱법으로 특이점 회피"""
    m, n = J.shape
    if m >= n:
        return J.T @ np.linalg.inv(J @ J.T + damping**2 * np.eye(m))
    else:
        return np.linalg.inv(J.T @ J + damping**2 * np.eye(n)) @ J.T

def singular_value_filtering(J, threshold=1e-6):
    """특이값 필터링으로 수치적 안정성 향상"""
    U, s, Vt = np.linalg.svd(J)
    s_filtered = np.where(s > threshold, 1/s, 0)
    return Vt.T @ np.diag(s_filtered) @ U.T
```

### 다중해 선택 전략
여러 해 중 최적해 선택:

#### 선택 기준
1. **관절 한계 회피**: 관절 가동범위 내의 해 우선
2. **현재 자세와의 근접성**: 최소 관절 변화량
3. **특이점 회피**: 조작성 지수 고려
4. **충돌 회피**: 자체 충돌 및 환경 충돌 회피

```python
def select_best_solution(solutions, current_theta, joint_limits):
    """최적 해 선택"""
    best_score = float('inf')
    best_solution = None
    
    for sol in solutions:
        # 관절 한계 확인
        if not check_joint_limits(sol, joint_limits):
            continue
            
        # 현재 자세와의 거리
        distance = np.linalg.norm(sol - current_theta)
        
        # 조작성 지수 (특이점 회피)
        manipulability = calculate_manipulability(sol)
        
        # 종합 점수 (낮을수록 좋음)
        score = distance + 1.0 / (manipulability + 1e-6)
        
        if score < best_score:
            best_score = score
            best_solution = sol
    
    return best_solution
```

---

## 🔄 고급 수치 방법

### Cyclic Coordinate Descent (CCD)
관절을 순차적으로 최적화하는 방법:

```python
def ccd_inverse_kinematics(robot, target_pos, max_iter=100):
    """순환 좌표 하강법"""
    theta = robot.q.copy()
    n_joints = len(theta)
    
    for iteration in range(max_iter):
        for i in range(n_joints-1, -1, -1):  # 끝에서부터
            # 현재 말단 위치
            current_T = robot.fkine(theta)
            current_pos = current_T[:3, 3]
            
            # i번째 관절 위치
            joint_T = robot.fkine(theta, end=i)
            joint_pos = joint_T[:3, 3]
            
            # 벡터 계산
            v1 = current_pos - joint_pos
            v2 = target_pos - joint_pos
            
            # 회전 각도 계산
            if np.linalg.norm(v1) > 1e-6 and np.linalg.norm(v2) > 1e-6:
                v1_norm = v1 / np.linalg.norm(v1)
                v2_norm = v2 / np.linalg.norm(v2)
                
                cos_angle = np.clip(np.dot(v1_norm, v2_norm), -1, 1)
                angle = np.arccos(cos_angle)
                
                # 회전 방향 결정
                axis = joint_T[:3, 2]  # z축
                cross = np.cross(v1_norm, v2_norm)
                if np.dot(cross, axis) < 0:
                    angle = -angle
                
                theta[i] += angle
        
        # 수렴 확인
        current_T = robot.fkine(theta)
        error = np.linalg.norm(target_pos - current_T[:3, 3])
        if error < 1e-6:
            break
    
    return theta
```

### FABRIK (Forward And Backward Reaching IK)
전진 및 후진 도달 알고리즘:

```python
def fabrik_2d(joints, target, tolerance=1e-6, max_iter=100):
    """2D FABRIK 알고리즘"""
    n = len(joints)
    distances = [np.linalg.norm(joints[i+1] - joints[i]) 
                for i in range(n-1)]
    
    for _ in range(max_iter):
        # 후진 패스 (목표에서 시작)
        joints[-1] = target
        for i in range(n-2, -1, -1):
            direction = (joints[i] - joints[i+1])
            direction = direction / np.linalg.norm(direction)
            joints[i] = joints[i+1] + distances[i] * direction
        
        # 전진 패스 (기준점에서 시작)
        joints[0] = np.array([0, 0])  # 고정된 기준점
        for i in range(n-1):
            direction = (joints[i+1] - joints[i])
            direction = direction / np.linalg.norm(direction)
            joints[i+1] = joints[i] + distances[i] * direction
        
        # 수렴 확인
        if np.linalg.norm(joints[-1] - target) < tolerance:
            break
    
    return joints
```

---

## 💡 장단점 비교

### 해석적 방법
#### 장점
- **고속 계산**: 직접 공식으로 즉시 계산
- **모든 해 제공**: 가능한 모든 해 확인 가능
- **수치 오차 없음**: 정확한 해
- **예측 가능**: 항상 동일한 결과

#### 단점
- **복잡한 유도**: 로봇별 개별 유도 필요
- **제한적 적용**: 특별한 구조의 로봇만 가능
- **확장성 부족**: 여유 자유도 처리 어려움

### 수치적 방법
#### 장점
- **일반성**: 모든 로봇 구조에 적용 가능
- **여유 자유도 처리**: 최적화 기준 추가 가능
- **제약 조건**: 관절 한계, 충돌 회피 등 고려
- **확장성**: 복잡한 로봇도 처리 가능

#### 단점
- **계산 비용**: 반복 계산으로 인한 지연
- **초기값 의존**: 수렴성이 초기 추정값에 좌우
- **지역 최적해**: 전역 최적해 보장 안됨
- **특이점 문제**: 수치적 불안정성

---

## 🎯 실용적 구현 팁

### 초기값 선택 전략
```python
def generate_initial_guesses(robot, target_pose, n_attempts=10):
    """다양한 초기값 생성"""
    guesses = []
    
    # 1. 현재 관절각
    guesses.append(robot.q.copy())
    
    # 2. 영점 자세
    guesses.append(np.zeros(robot.n))
    
    # 3. 랜덤 자세 (관절 한계 내)
    for _ in range(n_attempts - 2):
        random_q = np.random.uniform(robot.qlim[0], robot.qlim[1])
        guesses.append(random_q)
    
    return guesses
```

### 강건한 역기구학 솔버
```python
def robust_inverse_kinematics(robot, target_pose):
    """여러 방법을 조합한 강건한 역기구학"""
    
    # 1. 해석적 해가 있는 경우 우선 시도
    if hasattr(robot, 'analytical_ik'):
        analytical_solutions = robot.analytical_ik(target_pose)
        if analytical_solutions:
            return select_best_solution(analytical_solutions, robot.q)
    
    # 2. 수치적 방법들 시도
    methods = [
        lambda: numerical_ik_jacobian(robot, target_pose),
        lambda: ccd_inverse_kinematics(robot, target_pose[:3, 3]),
        lambda: fabrik_ik(robot, target_pose)
    ]
    
    for method in methods:
        try:
            solution, success = method()
            if success:
                return solution
        except:
            continue
    
    # 3. 모든 방법 실패 시 근사해 반환
    return numerical_ik_jacobian(robot, target_pose, max_iter=1000)
```

---

## 🔗 연결 분야
- 상위: [[위치기구학]]
- 기초: [[순기구학]], [[야코비안분석]]
- 응용: [[궤적계획]], [[로봇제어기법]]
- 도구: [[수치해석]], [[최적화이론]]

---

## 📚 참고문헌
1. Lynch, K.M. & Park, F.C. (2017). *Modern Robotics: Mechanics, Planning, and Control*. Cambridge University Press. Chapter 6
2. Craig, J.J. (2005). *Introduction to Robotics: Mechanics and Control* (3rd ed.). Pearson. Chapter 4
3. Wikipedia Contributors. (2025). "Inverse kinematics." *Wikipedia*. Retrieved January 2025
4. University of Illinois. "Chapter 6. Inverse kinematics." *Robotic Systems*
5. RoboDK. (2021). "Inverse Kinematics in Robotics: What You Need to Know." Blog Post
6. Aristidou, A. & Lasenby, J. (2011). "FABRIK: A fast, iterative solver for the Inverse Kinematics problem." *Graphical Models*, 73(5), 243-260