# 레이턴시

> 상위: [[실시간제어]]

실시간 시스템에서 입력 이벤트부터 해당 출력 응답까지의 지연 시간으로, 시스템 응답성의 핵심 지표입니다.

## ⏱️ 레이턴시 정의와 분류

### 인터럽트 레이턴시 (Interrupt Latency)
```
정의: 하드웨어 인터럽트 발생부터 ISR 첫 명령어 실행까지의 시간

구성 요소:
1. 하드웨어 감지 시간 (1-2 사이클)
2. 인터럽트 컨트롤러 처리 (2-5 사이클)  
3. 컨텍스트 저장 (10-50 사이클)
4. ISR 진입 (1-3 사이클)

총 레이턴시 = 14-60 사이클 (일반적)
```

### 태스크 스위칭 레이턴시 (Task Switching Latency)
```
정의: 스케줄러가 다른 태스크로 전환하는데 걸리는 시간

포함 요소:
- 현재 태스크 컨텍스트 저장
- 스케줄러 실행 시간
- 새 태스크 컨텍스트 복원
- 캐시/TLB 미스 페널티

ARM Cortex-M: 12-16 사이클
ARM Cortex-A: 100-500 사이클  
x86: 500-2000 사이클
```

### 시스템 응답 레이턴시 (System Response Latency)
```
정의: 외부 이벤트부터 실제 제어 출력까지의 전체 지연

End-to-End 레이턴시 = 
  센서 응답시간 + 
  ADC 변환시간 + 
  인터럽트 레이턴시 + 
  제어 알고리즘 실행시간 + 
  PWM 출력 지연
```

## 🔍 레이턴시 측정 기법

### 하드웨어 기반 측정
```cpp
// GPIO 토글을 이용한 인터럽트 레이턴시 측정
class LatencyMeasurement {
private:
    volatile unsigned long interrupt_start_time;
    volatile unsigned long handler_entry_time;
    
public:
    void setupMeasurement() {
        // 측정용 GPIO 핀 설정
        pinMode(TRIGGER_PIN, OUTPUT);
        pinMode(MEASURE_PIN, OUTPUT);
        
        // 외부 인터럽트 설정
        attachInterrupt(digitalPinToInterrupt(INTERRUPT_PIN), 
                       measureISR, RISING);
    }
    
    void triggerInterrupt() {
        // 트리거 신호 생성과 동시에 시간 기록
        digitalWrite(TRIGGER_PIN, HIGH);
        interrupt_start_time = micros();
        digitalWrite(TRIGGER_PIN, LOW);
    }
    
    // 인터럽트 서비스 루틴
    static void measureISR() {
        // ISR 진입 즉시 GPIO 토글 (오실로스코프 측정용)
        digitalWrite(MEASURE_PIN, HIGH);
        
        // 소프트웨어 타이밍 기록
        handler_entry_time = micros();
        
        // 실제 ISR 작업 수행
        performCriticalTask();
        
        digitalWrite(MEASURE_PIN, LOW);
    }
    
    void printLatencyStats() {
        unsigned long latency = handler_entry_time - interrupt_start_time;
        Serial.printf("Interrupt latency: %lu μs\n", latency);
    }
};
```

### 소프트웨어 프로파일링
```cpp
// 시스템 호출 레이턴시 측정
class SystemCallProfiler {
private:
    struct CallProfile {
        const char* call_name;
        unsigned long min_time;
        unsigned long max_time;
        unsigned long total_time;
        int call_count;
    };
    
    CallProfile profiles[20];
    int profile_count = 0;
    
public:
    int registerCall(const char* name) {
        if(profile_count < 20) {
            profiles[profile_count] = {name, ULONG_MAX, 0, 0, 0};
            return profile_count++;
        }
        return -1;
    }
    
    void profileSystemCall(int call_id, void (*syscall)()) {
        if(call_id < 0 || call_id >= profile_count) return;
        
        unsigned long start = micros();
        syscall();
        unsigned long duration = micros() - start;
        
        CallProfile* profile = &profiles[call_id];
        profile->call_count++;
        profile->total_time += duration;
        
        if(duration < profile->min_time) profile->min_time = duration;
        if(duration > profile->max_time) profile->max_time = duration;
    }
    
    void printProfile() {
        Serial.println("System Call Latency Profile:");
        for(int i = 0; i < profile_count; i++) {
            CallProfile* p = &profiles[i];
            float avg = (float)p->total_time / p->call_count;
            
            Serial.printf("%s:\n", p->call_name);
            Serial.printf("  Avg: %.2f μs, Min: %lu μs, Max: %lu μs\n", 
                         avg, p->min_time, p->max_time);
            Serial.printf("  Calls: %d, Total: %lu μs\n\n", 
                         p->call_count, p->total_time);
        }
    }
};
```

## ⚡ 레이턴시 최적화 기법

### 하드웨어 최적화
```cpp
// ARM Cortex-M 최적화 예제
class CortexMOptimization {
public:
    void setupLowLatencyInterrupts() {
        // 인터럽트 우선순위 최적화
        NVIC_SetPriority(TIMER1_IRQn, 0);  // 최고 우선순위
        NVIC_SetPriority(UART_IRQn, 1);
        NVIC_SetPriority(GPIO_IRQn, 2);
        
        // Tail-chaining 활용을 위한 설정
        SCB->CCR |= SCB_CCR_STKALIGN_Msk;  // 스택 정렬 최적화
        
        // 인터럽트 응답 최적화
        __enable_irq();
        
        // 프로세서 클록 최대화
        SystemCoreClockUpdate();
    }
    
    // 최적화된 ISR (어셈블리 수준 최적화)
    __attribute__((interrupt("IRQ")))
    void optimizedISR() {
        // 최소한의 레지스터만 백업
        register uint32_t temp asm("r0");
        
        // 크리티컬 패스 최적화
        temp = GPIOA->IDR;  // 직접 레지스터 접근
        GPIOA->ODR = temp;  // 즉시 출력
        
        // 인터럽트 클리어 (하드웨어 자동)
        TIMER1->SR = 0;
    }
    
    // DMA를 이용한 레이턴시 감소
    void setupDMATransfer() {
        // DMA 설정으로 CPU 개입 최소화
        DMA1_Channel1->CPAR = (uint32_t)&ADC1->DR;
        DMA1_Channel1->CMAR = (uint32_t)adc_buffer;
        DMA1_Channel1->CNDTR = BUFFER_SIZE;
        
        // 메모리 간 전송 최적화
        DMA1_Channel1->CCR = DMA_CCR_MEM2MEM | DMA_CCR_MINC | 
                           DMA_CCR_PINC | DMA_CCR_TCIE;
        
        DMA1_Channel1->CCR |= DMA_CCR_EN;
    }
};
```

### 소프트웨어 최적화
```cpp
// RTOS 레이턴시 최적화
class RTOSLatencyOptimizer {
private:
    TaskHandle_t critical_task_handle;
    
public:
    void setupRealTimeTask() {
        // 최고 우선순위 태스크 생성
        xTaskCreate(criticalTask, "CriticalTask", 
                   256, NULL, configMAX_PRIORITIES - 1, 
                   &critical_task_handle);
        
        // CPU 친화도 설정 (멀티코어)
        #ifdef CONFIG_FREERTOS_UNICORE
        // 단일 코어에서 최적화
        #else
        vTaskCoreAffinitySet(critical_task_handle, 1 << 1);  // 코어 1 전용
        #endif
        
        // 스케줄러 설정 최적화
        vTaskPrioritySet(critical_task_handle, configMAX_PRIORITIES - 1);
    }
    
    static void criticalTask(void* parameters) {
        TickType_t last_wake_time = xTaskGetTickCount();
        const TickType_t period = pdMS_TO_TICKS(1);  // 1ms 주기
        
        while(1) {
            // 정확한 주기 보장
            vTaskDelayUntil(&last_wake_time, period);
            
            // 크리티컬 작업 수행
            performTimeConstrainedOperation();
        }
    }
    
    // 인터럽트에서 태스크 활성화 (최소 레이턴시)
    void wakeTaskFromISR() {
        BaseType_t higher_priority_woken = pdFALSE;
        
        // 바이너리 세마포어로 즉시 깨우기
        xSemaphoreGiveFromISR(task_semaphore, &higher_priority_woken);
        
        // 컨텍스트 스위칭 요청
        portYIELD_FROM_ISR(higher_priority_woken);
    }
};

// 메모리 할당 최적화
class MemoryLatencyOptimizer {
private:
    static uint8_t static_pool[POOL_SIZE];
    static uint32_t pool_index;
    
public:
    // 정적 메모리 할당 (malloc 대신)
    static void* fast_alloc(size_t size) {
        if(pool_index + size < POOL_SIZE) {
            void* ptr = &static_pool[pool_index];
            pool_index += size;
            return ptr;
        }
        return nullptr;  // 할당 실패
    }
    
    // 스택 기반 임시 할당
    template<typename T, size_t N>
    class StackAllocator {
    private:
        alignas(T) uint8_t buffer[N * sizeof(T)];
        size_t used = 0;
        
    public:
        T* allocate(size_t n) {
            if(used + n <= N) {
                T* ptr = reinterpret_cast<T*>(&buffer[used * sizeof(T)]);
                used += n;
                return ptr;
            }
            return nullptr;
        }
        
        void reset() { used = 0; }
    };
};
```

## 📊 레이턴시 분석과 예측

### 최악 실행 시간 분석 (WCET)
```cpp
// WCET 분석을 위한 코드 계측
class WCETAnalyzer {
private:
    struct FunctionProfile {
        const char* name;
        unsigned long min_cycles;
        unsigned long max_cycles;
        unsigned long total_cycles;
        int calls;
    };
    
    FunctionProfile functions[50];
    int function_count = 0;
    
public:
    int registerFunction(const char* name) {
        if(function_count < 50) {
            functions[function_count] = {name, ULONG_MAX, 0, 0, 0};
            return function_count++;
        }
        return -1;
    }
    
    void measureFunction(int func_id, void (*function)()) {
        if(func_id < 0 || func_id >= function_count) return;
        
        // 사이클 카운터 사용 (ARM Cortex-M)
        DWT->CYCCNT = 0;  // 리셋
        
        unsigned long start = DWT->CYCCNT;
        function();
        unsigned long cycles = DWT->CYCCNT - start;
        
        FunctionProfile* prof = &functions[func_id];
        prof->calls++;
        prof->total_cycles += cycles;
        
        if(cycles < prof->min_cycles) prof->min_cycles = cycles;
        if(cycles > prof->max_cycles) prof->max_cycles = cycles;
    }
    
    void printWCETAnalysis() {
        Serial.println("WCET Analysis Results:");
        for(int i = 0; i < function_count; i++) {
            FunctionProfile* p = &functions[i];
            float avg_cycles = (float)p->total_cycles / p->calls;
            
            Serial.printf("%s:\n", p->name);
            Serial.printf("  WCET: %lu cycles\n", p->max_cycles);
            Serial.printf("  BCET: %lu cycles\n", p->min_cycles);
            Serial.printf("  Avg: %.1f cycles\n", avg_cycles);
            Serial.printf("  Calls: %d\n\n", p->calls);
        }
    }
    
    // 시스템 레벨 WCET 계산
    unsigned long calculateSystemWCET() {
        unsigned long total_wcet = 0;
        
        // 크리티컬 패스 상의 함수들 합산
        for(int i = 0; i < function_count; i++) {
            total_wcet += functions[i].max_cycles;
        }
        
        return total_wcet;
    }
};
```

### 확률적 레이턴시 분석
```cpp
// 통계적 레이턴시 모델링
class ProbabilisticLatencyModel {
private:
    static const int HISTOGRAM_BINS = 100;
    int latency_histogram[HISTOGRAM_BINS];
    unsigned long min_latency, max_latency;
    int total_samples;
    
public:
    ProbabilisticLatencyModel() {
        memset(latency_histogram, 0, sizeof(latency_histogram));
        min_latency = ULONG_MAX;
        max_latency = 0;
        total_samples = 0;
    }
    
    void addSample(unsigned long latency) {
        total_samples++;
        
        if(latency < min_latency) min_latency = latency;
        if(latency > max_latency) max_latency = latency;
        
        // 히스토그램 빈 계산
        if(max_latency > min_latency) {
            int bin = (latency - min_latency) * (HISTOGRAM_BINS - 1) / 
                     (max_latency - min_latency);
            if(bin >= 0 && bin < HISTOGRAM_BINS) {
                latency_histogram[bin]++;
            }
        }
    }
    
    float calculatePercentile(float percentile) {
        int target_samples = (int)(total_samples * percentile / 100.0);
        int accumulated = 0;
        
        for(int i = 0; i < HISTOGRAM_BINS; i++) {
            accumulated += latency_histogram[i];
            if(accumulated >= target_samples) {
                return min_latency + (float)i * (max_latency - min_latency) / 
                       (HISTOGRAM_BINS - 1);
            }
        }
        
        return max_latency;
    }
    
    void printStatistics() {
        Serial.printf("Latency Statistics (%d samples):\n", total_samples);
        Serial.printf("Min: %lu μs\n", min_latency);
        Serial.printf("Max: %lu μs\n", max_latency);
        Serial.printf("50th percentile: %.1f μs\n", calculatePercentile(50));
        Serial.printf("95th percentile: %.1f μs\n", calculatePercentile(95));
        Serial.printf("99th percentile: %.1f μs\n", calculatePercentile(99));
    }
};
```

---

## 🔗 연결 문서
- 상위: [[실시간제어]]
- 관련: [[데드라인]], [[지터]], [[처리량]]
- 하드웨어: [[마이크로컨트롤러]], [[인터럽트처리]]
- 측정: [[센서인터페이스]], [[ADC]]

## 📚 참고문헌
- [Harvie (2024). "Addressing Latency and Jitter in Time-Critical Firmware Applications"](https://medium.com/@lanceharvieruntime/addressing-latency-and-jitter-in-time-critical-firmware-applications-b1a03172981a)
- [ScienceDirect (2024). "Interrupt Latency - an overview"](https://www.sciencedirect.com/topics/computer-science/interrupt-latency)
- [GeeksforGeeks (2023). "What is Interrupt Latency?"](https://www.geeksforgeeks.org/what-is-interrupt-latency/)
- [IEEE (2007). "Latency-Aware Bus Arbitration for Real-Time Embedded Systems"](https://www.researchgate.net/publication/31465491_Latency-Aware_Bus_Arbitration_for_Real-Time_Embedded_Systems)
