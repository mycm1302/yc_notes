# ë ˆì´í„´ì‹œ

> ìƒìœ„: [[ì‹¤ì‹œê°„ì œì–´]]

ì‹¤ì‹œê°„ ì‹œìŠ¤í…œì—ì„œ ì…ë ¥ ì´ë²¤íŠ¸ë¶€í„° í•´ë‹¹ ì¶œë ¥ ì‘ë‹µê¹Œì§€ì˜ ì§€ì—° ì‹œê°„ìœ¼ë¡œ, ì‹œìŠ¤í…œ ì‘ë‹µì„±ì˜ í•µì‹¬ ì§€í‘œì…ë‹ˆë‹¤.

## â±ï¸ ë ˆì´í„´ì‹œ ì •ì˜ì™€ ë¶„ë¥˜

### ì¸í„°ëŸ½íŠ¸ ë ˆì´í„´ì‹œ (Interrupt Latency)
```
ì •ì˜: í•˜ë“œì›¨ì–´ ì¸í„°ëŸ½íŠ¸ ë°œìƒë¶€í„° ISR ì²« ëª…ë ¹ì–´ ì‹¤í–‰ê¹Œì§€ì˜ ì‹œê°„

êµ¬ì„± ìš”ì†Œ:
1. í•˜ë“œì›¨ì–´ ê°ì§€ ì‹œê°„ (1-2 ì‚¬ì´í´)
2. ì¸í„°ëŸ½íŠ¸ ì»¨íŠ¸ë¡¤ëŸ¬ ì²˜ë¦¬ (2-5 ì‚¬ì´í´)  
3. ì»¨í…ìŠ¤íŠ¸ ì €ì¥ (10-50 ì‚¬ì´í´)
4. ISR ì§„ì… (1-3 ì‚¬ì´í´)

ì´ ë ˆì´í„´ì‹œ = 14-60 ì‚¬ì´í´ (ì¼ë°˜ì )
```

### íƒœìŠ¤í¬ ìŠ¤ìœ„ì¹­ ë ˆì´í„´ì‹œ (Task Switching Latency)
```
ì •ì˜: ìŠ¤ì¼€ì¤„ëŸ¬ê°€ ë‹¤ë¥¸ íƒœìŠ¤í¬ë¡œ ì „í™˜í•˜ëŠ”ë° ê±¸ë¦¬ëŠ” ì‹œê°„

í¬í•¨ ìš”ì†Œ:
- í˜„ì¬ íƒœìŠ¤í¬ ì»¨í…ìŠ¤íŠ¸ ì €ì¥
- ìŠ¤ì¼€ì¤„ëŸ¬ ì‹¤í–‰ ì‹œê°„
- ìƒˆ íƒœìŠ¤í¬ ì»¨í…ìŠ¤íŠ¸ ë³µì›
- ìºì‹œ/TLB ë¯¸ìŠ¤ í˜ë„í‹°

ARM Cortex-M: 12-16 ì‚¬ì´í´
ARM Cortex-A: 100-500 ì‚¬ì´í´  
x86: 500-2000 ì‚¬ì´í´
```

### ì‹œìŠ¤í…œ ì‘ë‹µ ë ˆì´í„´ì‹œ (System Response Latency)
```
ì •ì˜: ì™¸ë¶€ ì´ë²¤íŠ¸ë¶€í„° ì‹¤ì œ ì œì–´ ì¶œë ¥ê¹Œì§€ì˜ ì „ì²´ ì§€ì—°

End-to-End ë ˆì´í„´ì‹œ = 
  ì„¼ì„œ ì‘ë‹µì‹œê°„ + 
  ADC ë³€í™˜ì‹œê°„ + 
  ì¸í„°ëŸ½íŠ¸ ë ˆì´í„´ì‹œ + 
  ì œì–´ ì•Œê³ ë¦¬ì¦˜ ì‹¤í–‰ì‹œê°„ + 
  PWM ì¶œë ¥ ì§€ì—°
```

## ğŸ” ë ˆì´í„´ì‹œ ì¸¡ì • ê¸°ë²•

### í•˜ë“œì›¨ì–´ ê¸°ë°˜ ì¸¡ì •
```cpp
// GPIO í† ê¸€ì„ ì´ìš©í•œ ì¸í„°ëŸ½íŠ¸ ë ˆì´í„´ì‹œ ì¸¡ì •
class LatencyMeasurement {
private:
    volatile unsigned long interrupt_start_time;
    volatile unsigned long handler_entry_time;
    
public:
    void setupMeasurement() {
        // ì¸¡ì •ìš© GPIO í•€ ì„¤ì •
        pinMode(TRIGGER_PIN, OUTPUT);
        pinMode(MEASURE_PIN, OUTPUT);
        
        // ì™¸ë¶€ ì¸í„°ëŸ½íŠ¸ ì„¤ì •
        attachInterrupt(digitalPinToInterrupt(INTERRUPT_PIN), 
                       measureISR, RISING);
    }
    
    void triggerInterrupt() {
        // íŠ¸ë¦¬ê±° ì‹ í˜¸ ìƒì„±ê³¼ ë™ì‹œì— ì‹œê°„ ê¸°ë¡
        digitalWrite(TRIGGER_PIN, HIGH);
        interrupt_start_time = micros();
        digitalWrite(TRIGGER_PIN, LOW);
    }
    
    // ì¸í„°ëŸ½íŠ¸ ì„œë¹„ìŠ¤ ë£¨í‹´
    static void measureISR() {
        // ISR ì§„ì… ì¦‰ì‹œ GPIO í† ê¸€ (ì˜¤ì‹¤ë¡œìŠ¤ì½”í”„ ì¸¡ì •ìš©)
        digitalWrite(MEASURE_PIN, HIGH);
        
        // ì†Œí”„íŠ¸ì›¨ì–´ íƒ€ì´ë° ê¸°ë¡
        handler_entry_time = micros();
        
        // ì‹¤ì œ ISR ì‘ì—… ìˆ˜í–‰
        performCriticalTask();
        
        digitalWrite(MEASURE_PIN, LOW);
    }
    
    void printLatencyStats() {
        unsigned long latency = handler_entry_time - interrupt_start_time;
        Serial.printf("Interrupt latency: %lu Î¼s\n", latency);
    }
};
```

### ì†Œí”„íŠ¸ì›¨ì–´ í”„ë¡œíŒŒì¼ë§
```cpp
// ì‹œìŠ¤í…œ í˜¸ì¶œ ë ˆì´í„´ì‹œ ì¸¡ì •
class SystemCallProfiler {
private:
    struct CallProfile {
        const char* call_name;
        unsigned long min_time;
        unsigned long max_time;
        unsigned long total_time;
        int call_count;
    };
    
    CallProfile profiles[20];
    int profile_count = 0;
    
public:
    int registerCall(const char* name) {
        if(profile_count < 20) {
            profiles[profile_count] = {name, ULONG_MAX, 0, 0, 0};
            return profile_count++;
        }
        return -1;
    }
    
    void profileSystemCall(int call_id, void (*syscall)()) {
        if(call_id < 0 || call_id >= profile_count) return;
        
        unsigned long start = micros();
        syscall();
        unsigned long duration = micros() - start;
        
        CallProfile* profile = &profiles[call_id];
        profile->call_count++;
        profile->total_time += duration;
        
        if(duration < profile->min_time) profile->min_time = duration;
        if(duration > profile->max_time) profile->max_time = duration;
    }
    
    void printProfile() {
        Serial.println("System Call Latency Profile:");
        for(int i = 0; i < profile_count; i++) {
            CallProfile* p = &profiles[i];
            float avg = (float)p->total_time / p->call_count;
            
            Serial.printf("%s:\n", p->call_name);
            Serial.printf("  Avg: %.2f Î¼s, Min: %lu Î¼s, Max: %lu Î¼s\n", 
                         avg, p->min_time, p->max_time);
            Serial.printf("  Calls: %d, Total: %lu Î¼s\n\n", 
                         p->call_count, p->total_time);
        }
    }
};
```

## âš¡ ë ˆì´í„´ì‹œ ìµœì í™” ê¸°ë²•

### í•˜ë“œì›¨ì–´ ìµœì í™”
```cpp
// ARM Cortex-M ìµœì í™” ì˜ˆì œ
class CortexMOptimization {
public:
    void setupLowLatencyInterrupts() {
        // ì¸í„°ëŸ½íŠ¸ ìš°ì„ ìˆœìœ„ ìµœì í™”
        NVIC_SetPriority(TIMER1_IRQn, 0);  // ìµœê³  ìš°ì„ ìˆœìœ„
        NVIC_SetPriority(UART_IRQn, 1);
        NVIC_SetPriority(GPIO_IRQn, 2);
        
        // Tail-chaining í™œìš©ì„ ìœ„í•œ ì„¤ì •
        SCB->CCR |= SCB_CCR_STKALIGN_Msk;  // ìŠ¤íƒ ì •ë ¬ ìµœì í™”
        
        // ì¸í„°ëŸ½íŠ¸ ì‘ë‹µ ìµœì í™”
        __enable_irq();
        
        // í”„ë¡œì„¸ì„œ í´ë¡ ìµœëŒ€í™”
        SystemCoreClockUpdate();
    }
    
    // ìµœì í™”ëœ ISR (ì–´ì…ˆë¸”ë¦¬ ìˆ˜ì¤€ ìµœì í™”)
    __attribute__((interrupt("IRQ")))
    void optimizedISR() {
        // ìµœì†Œí•œì˜ ë ˆì§€ìŠ¤í„°ë§Œ ë°±ì—…
        register uint32_t temp asm("r0");
        
        // í¬ë¦¬í‹°ì»¬ íŒ¨ìŠ¤ ìµœì í™”
        temp = GPIOA->IDR;  // ì§ì ‘ ë ˆì§€ìŠ¤í„° ì ‘ê·¼
        GPIOA->ODR = temp;  // ì¦‰ì‹œ ì¶œë ¥
        
        // ì¸í„°ëŸ½íŠ¸ í´ë¦¬ì–´ (í•˜ë“œì›¨ì–´ ìë™)
        TIMER1->SR = 0;
    }
    
    // DMAë¥¼ ì´ìš©í•œ ë ˆì´í„´ì‹œ ê°ì†Œ
    void setupDMATransfer() {
        // DMA ì„¤ì •ìœ¼ë¡œ CPU ê°œì… ìµœì†Œí™”
        DMA1_Channel1->CPAR = (uint32_t)&ADC1->DR;
        DMA1_Channel1->CMAR = (uint32_t)adc_buffer;
        DMA1_Channel1->CNDTR = BUFFER_SIZE;
        
        // ë©”ëª¨ë¦¬ ê°„ ì „ì†¡ ìµœì í™”
        DMA1_Channel1->CCR = DMA_CCR_MEM2MEM | DMA_CCR_MINC | 
                           DMA_CCR_PINC | DMA_CCR_TCIE;
        
        DMA1_Channel1->CCR |= DMA_CCR_EN;
    }
};
```

### ì†Œí”„íŠ¸ì›¨ì–´ ìµœì í™”
```cpp
// RTOS ë ˆì´í„´ì‹œ ìµœì í™”
class RTOSLatencyOptimizer {
private:
    TaskHandle_t critical_task_handle;
    
public:
    void setupRealTimeTask() {
        // ìµœê³  ìš°ì„ ìˆœìœ„ íƒœìŠ¤í¬ ìƒì„±
        xTaskCreate(criticalTask, "CriticalTask", 
                   256, NULL, configMAX_PRIORITIES - 1, 
                   &critical_task_handle);
        
        // CPU ì¹œí™”ë„ ì„¤ì • (ë©€í‹°ì½”ì–´)
        #ifdef CONFIG_FREERTOS_UNICORE
        // ë‹¨ì¼ ì½”ì–´ì—ì„œ ìµœì í™”
        #else
        vTaskCoreAffinitySet(critical_task_handle, 1 << 1);  // ì½”ì–´ 1 ì „ìš©
        #endif
        
        // ìŠ¤ì¼€ì¤„ëŸ¬ ì„¤ì • ìµœì í™”
        vTaskPrioritySet(critical_task_handle, configMAX_PRIORITIES - 1);
    }
    
    static void criticalTask(void* parameters) {
        TickType_t last_wake_time = xTaskGetTickCount();
        const TickType_t period = pdMS_TO_TICKS(1);  // 1ms ì£¼ê¸°
        
        while(1) {
            // ì •í™•í•œ ì£¼ê¸° ë³´ì¥
            vTaskDelayUntil(&last_wake_time, period);
            
            // í¬ë¦¬í‹°ì»¬ ì‘ì—… ìˆ˜í–‰
            performTimeConstrainedOperation();
        }
    }
    
    // ì¸í„°ëŸ½íŠ¸ì—ì„œ íƒœìŠ¤í¬ í™œì„±í™” (ìµœì†Œ ë ˆì´í„´ì‹œ)
    void wakeTaskFromISR() {
        BaseType_t higher_priority_woken = pdFALSE;
        
        // ë°”ì´ë„ˆë¦¬ ì„¸ë§ˆí¬ì–´ë¡œ ì¦‰ì‹œ ê¹¨ìš°ê¸°
        xSemaphoreGiveFromISR(task_semaphore, &higher_priority_woken);
        
        // ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­ ìš”ì²­
        portYIELD_FROM_ISR(higher_priority_woken);
    }
};

// ë©”ëª¨ë¦¬ í• ë‹¹ ìµœì í™”
class MemoryLatencyOptimizer {
private:
    static uint8_t static_pool[POOL_SIZE];
    static uint32_t pool_index;
    
public:
    // ì •ì  ë©”ëª¨ë¦¬ í• ë‹¹ (malloc ëŒ€ì‹ )
    static void* fast_alloc(size_t size) {
        if(pool_index + size < POOL_SIZE) {
            void* ptr = &static_pool[pool_index];
            pool_index += size;
            return ptr;
        }
        return nullptr;  // í• ë‹¹ ì‹¤íŒ¨
    }
    
    // ìŠ¤íƒ ê¸°ë°˜ ì„ì‹œ í• ë‹¹
    template<typename T, size_t N>
    class StackAllocator {
    private:
        alignas(T) uint8_t buffer[N * sizeof(T)];
        size_t used = 0;
        
    public:
        T* allocate(size_t n) {
            if(used + n <= N) {
                T* ptr = reinterpret_cast<T*>(&buffer[used * sizeof(T)]);
                used += n;
                return ptr;
            }
            return nullptr;
        }
        
        void reset() { used = 0; }
    };
};
```

## ğŸ“Š ë ˆì´í„´ì‹œ ë¶„ì„ê³¼ ì˜ˆì¸¡

### ìµœì•… ì‹¤í–‰ ì‹œê°„ ë¶„ì„ (WCET)
```cpp
// WCET ë¶„ì„ì„ ìœ„í•œ ì½”ë“œ ê³„ì¸¡
class WCETAnalyzer {
private:
    struct FunctionProfile {
        const char* name;
        unsigned long min_cycles;
        unsigned long max_cycles;
        unsigned long total_cycles;
        int calls;
    };
    
    FunctionProfile functions[50];
    int function_count = 0;
    
public:
    int registerFunction(const char* name) {
        if(function_count < 50) {
            functions[function_count] = {name, ULONG_MAX, 0, 0, 0};
            return function_count++;
        }
        return -1;
    }
    
    void measureFunction(int func_id, void (*function)()) {
        if(func_id < 0 || func_id >= function_count) return;
        
        // ì‚¬ì´í´ ì¹´ìš´í„° ì‚¬ìš© (ARM Cortex-M)
        DWT->CYCCNT = 0;  // ë¦¬ì…‹
        
        unsigned long start = DWT->CYCCNT;
        function();
        unsigned long cycles = DWT->CYCCNT - start;
        
        FunctionProfile* prof = &functions[func_id];
        prof->calls++;
        prof->total_cycles += cycles;
        
        if(cycles < prof->min_cycles) prof->min_cycles = cycles;
        if(cycles > prof->max_cycles) prof->max_cycles = cycles;
    }
    
    void printWCETAnalysis() {
        Serial.println("WCET Analysis Results:");
        for(int i = 0; i < function_count; i++) {
            FunctionProfile* p = &functions[i];
            float avg_cycles = (float)p->total_cycles / p->calls;
            
            Serial.printf("%s:\n", p->name);
            Serial.printf("  WCET: %lu cycles\n", p->max_cycles);
            Serial.printf("  BCET: %lu cycles\n", p->min_cycles);
            Serial.printf("  Avg: %.1f cycles\n", avg_cycles);
            Serial.printf("  Calls: %d\n\n", p->calls);
        }
    }
    
    // ì‹œìŠ¤í…œ ë ˆë²¨ WCET ê³„ì‚°
    unsigned long calculateSystemWCET() {
        unsigned long total_wcet = 0;
        
        // í¬ë¦¬í‹°ì»¬ íŒ¨ìŠ¤ ìƒì˜ í•¨ìˆ˜ë“¤ í•©ì‚°
        for(int i = 0; i < function_count; i++) {
            total_wcet += functions[i].max_cycles;
        }
        
        return total_wcet;
    }
};
```

### í™•ë¥ ì  ë ˆì´í„´ì‹œ ë¶„ì„
```cpp
// í†µê³„ì  ë ˆì´í„´ì‹œ ëª¨ë¸ë§
class ProbabilisticLatencyModel {
private:
    static const int HISTOGRAM_BINS = 100;
    int latency_histogram[HISTOGRAM_BINS];
    unsigned long min_latency, max_latency;
    int total_samples;
    
public:
    ProbabilisticLatencyModel() {
        memset(latency_histogram, 0, sizeof(latency_histogram));
        min_latency = ULONG_MAX;
        max_latency = 0;
        total_samples = 0;
    }
    
    void addSample(unsigned long latency) {
        total_samples++;
        
        if(latency < min_latency) min_latency = latency;
        if(latency > max_latency) max_latency = latency;
        
        // íˆìŠ¤í† ê·¸ë¨ ë¹ˆ ê³„ì‚°
        if(max_latency > min_latency) {
            int bin = (latency - min_latency) * (HISTOGRAM_BINS - 1) / 
                     (max_latency - min_latency);
            if(bin >= 0 && bin < HISTOGRAM_BINS) {
                latency_histogram[bin]++;
            }
        }
    }
    
    float calculatePercentile(float percentile) {
        int target_samples = (int)(total_samples * percentile / 100.0);
        int accumulated = 0;
        
        for(int i = 0; i < HISTOGRAM_BINS; i++) {
            accumulated += latency_histogram[i];
            if(accumulated >= target_samples) {
                return min_latency + (float)i * (max_latency - min_latency) / 
                       (HISTOGRAM_BINS - 1);
            }
        }
        
        return max_latency;
    }
    
    void printStatistics() {
        Serial.printf("Latency Statistics (%d samples):\n", total_samples);
        Serial.printf("Min: %lu Î¼s\n", min_latency);
        Serial.printf("Max: %lu Î¼s\n", max_latency);
        Serial.printf("50th percentile: %.1f Î¼s\n", calculatePercentile(50));
        Serial.printf("95th percentile: %.1f Î¼s\n", calculatePercentile(95));
        Serial.printf("99th percentile: %.1f Î¼s\n", calculatePercentile(99));
    }
};
```

---

## ğŸ”— ì—°ê²° ë¬¸ì„œ
- ìƒìœ„: [[ì‹¤ì‹œê°„ì œì–´]]
- ê´€ë ¨: [[ë°ë“œë¼ì¸]], [[ì§€í„°]], [[ì²˜ë¦¬ëŸ‰]]
- í•˜ë“œì›¨ì–´: [[ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬]], [[ì¸í„°ëŸ½íŠ¸ì²˜ë¦¬]]
- ì¸¡ì •: [[ì„¼ì„œì¸í„°í˜ì´ìŠ¤]], [[ADC]]

## ğŸ“š ì°¸ê³ ë¬¸í—Œ
- [Harvie (2024). "Addressing Latency and Jitter in Time-Critical Firmware Applications"](https://medium.com/@lanceharvieruntime/addressing-latency-and-jitter-in-time-critical-firmware-applications-b1a03172981a)
- [ScienceDirect (2024). "Interrupt Latency - an overview"](https://www.sciencedirect.com/topics/computer-science/interrupt-latency)
- [GeeksforGeeks (2023). "What is Interrupt Latency?"](https://www.geeksforgeeks.org/what-is-interrupt-latency/)
- [IEEE (2007). "Latency-Aware Bus Arbitration for Real-Time Embedded Systems"](https://www.researchgate.net/publication/31465491_Latency-Aware_Bus_Arbitration_for_Real-Time_Embedded_Systems)
