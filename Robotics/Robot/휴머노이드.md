# 휴머노이드

> 상위: [[분야별 로봇]]

## 1. 개념 및 개요

### 기본 정의

휴머노이드 로봇(Humanoid Robot)은 인간과 유사한 형태와 동작을 가지는 로봇으로, 복잡한 기구학적 구조와 동역학적 특성을 가진 고자유도 시스템입니다. 30개 이상의 관절을 가지며, 이족 보행과 전신 제어를 통해 인간과 유사한 작업을 수행할 수 있습니다.

### 주요 특징

#### 기구학적 특성
- **높은 자유도**: 30+ DOF (Degree of Freedom)
- **복잡한 기구학**: 다중 체인 구조 (머리, 몸통, 양팔, 양다리)
- **중복 자유도**: 대부분의 작업에 필요한 것보다 많은 관절
- **인간 유사 구조**: 어깨, 팔꿈치, 손목, 고관절, 무릎, 발목

#### 동역학적 특성
- **비선형 동역학**: 고차원, 비선형, 비볼록 시스템
- **결합 동역학**: 관절 간 상호작용
- **동적 불안정성**: 이족 보행으로 인한 본질적 불안정성
- **중력 의존성**: 항상 중력의 영향을 받는 시스템

#### 제어적 특성
- **다중 태스크**: 균형, 보행, 조작을 동시에 수행
- **계층적 제어**: 우선순위 기반 태스크 할당
- **실시간 제어**: 수십 Hz~수 kHz의 제어 주기
- **적응성**: 환경 변화와 외란에 대한 대응

## 2. 핵심 연구 기술

휴머노이드 로봇의 핵심 연구 기술들과 수학적 기반을 다룹니다. 이족 보행, 전신 제어, 궤적 최적화 등의 기술적 도전과 해결 방법을 포함합니다.

### 🚶 이족 보행 제어 기술

#### 1. ZMP (Zero Moment Point)

##### 개념과 정의
- **정의**: 수평 관성력과 중력의 합이 0인 지점
- **물리적 의미**: 발과 지면 접촉 시 수평 방향 모멘트가 0이 되는 점
- **안정성 기준**: ZMP가 지지 영역(발바닥) 내부에 있을 때 안정

##### 수학적 표현
```
ZMP 조건: Σ(수평 모멘트) = 0
- 중력에 의한 모멘트 + 관성력에 의한 모멘트 = 0
- ZMP 위치 = (Mx_total / Fz_total, My_total / Fz_total)
```

##### ZMP 기반 제어
- **정적 안정**: ZMP를 지지 영역 중앙에 유지
- **동적 안정**: ZMP 궤적을 미리 계획하여 추종
- **가변 ZMP**: 허용 영역 내에서 ZMP를 움직여 에너지 효율 향상
- **ZMP 추적 제어**: 목표 ZMP와 실제 ZMP 차이를 비용함수에 포함

##### 실제 응용
- Honda ASIMO: ZMP 피드백 기반 보행
- PAL Robotics REEM-C: 퍼지 로직 PD 컨트롤러로 ZMP 추적
- 질량중심(CoM) 위치 조정으로 ZMP 제어

#### 2. 보행 모델

##### Linear Inverted Pendulum Model (LIPM)
- **가정**: 로봇을 역진자 모델로 단순화
- **장점**: 수학적으로 해석 가능, 실시간 계산 가능
- **한계**: 상체 움직임과 다리 질량 무시

##### Cart-Table Model
- **구성**: 상체(Cart) + 다리(Table)
- **용도**: CoM/ZMP 보행 패턴 변환
- **특성**: 보폭, 보행시간, CoM 높이 변화 분석

##### 3D LIPM
- **확장**: 2차원을 3차원으로 확장
- **고려사항**: 좌우 방향 안정성 포함
- **복잡성**: 비선형, 비볼록 최적화 문제

#### 3. 보행 패턴 생성

##### 궤적 계획 방법
- **특징점 기반**: ZMP 궤적을 구간별 선형 보간
- **스플라인 보간**: 부드러운 궤적 생성
- **최적화 기반**: 에너지 최소화 목표함수

##### 보행 단계
1. **초기 단계**: 정지 상태에서 보행 시작
2. **주기 단계**: 안정적인 반복 보행
3. **종료 단계**: 보행에서 정지로 전환

### 🎯 기구학 및 역학

#### 1. 순기구학 (Forward Kinematics)

##### 정의와 목적
- **변환**: 관절 각도 → 엔드 이펙터 위치/방향
- **수식**: x = f(q), 여기서 q는 관절 각도 벡터
- **방법**: DH Parameter 기반 변환 행렬

##### DH Parameter
```
변환 행렬 = Rot(z,θ) × Trans(z,d) × Trans(x,a) × Rot(x,α)
- θ: 관절 각도
- d: 링크 오프셋
- a: 링크 길이  
- α: 링크 비틀림
```

##### 계산 과정
1. 각 관절별 DH Parameter 설정
2. 개별 변환 행렬 계산
3. 연쇄적 행렬 곱셈으로 최종 위치 산출

#### 2. 역기구학 (Inverse Kinematics)

##### 정의와 도전
- **변환**: 엔드 이펙터 목표 위치 → 관절 각도
- **수식**: q = f⁻¹(x)
- **어려움**: 비선형 방정식, 다중해 또는 해가 없는 경우

##### 해결 방법

###### 해석적 방법
- **기하학적 접근**: 삼각법과 기하학 이용
- **대수적 접근**: 연립방정식 해법
- **장점**: 정확한 해, 빠른 계산
- **단점**: 복잡한 로봇에는 적용 어려움

###### 수치적 방법
- **뉴턴-랩슨 방법**: 반복적 근사해법
- **경사하강법**: 오차 함수 최소화
- **의사역행렬**: 자코비안 기반 근사해

##### 특수 상황 처리
- **작업공간 벗어남**: 도달 불가능한 목표점
- **특이점**: 자코비안 행렬식이 0인 지점
- **다중해**: 여러 가능한 관절 구성

#### 3. 자코비안 (Jacobian)

##### 정의와 의미
- **수학적 정의**: 다변수 함수의 1차 편미분 행렬
- **로봇공학**: 관절 속도와 엔드 이펙터 속도 관계
- **선형화**: 비선형 변환을 국소적으로 선형 근사

##### 자코비안 행렬
```
J = ∂f/∂q = [∂x/∂q₁  ∂x/∂q₂  ...  ∂x/∂qₙ]
속도 관계: ẋ = J(q) × q̇
```

##### 기하학적 자코비안
- **선속도**: 각 관절이 엔드 이펙터 선속도에 기여
- **각속도**: 각 관절이 엔드 이펙터 각속도에 기여
- **구성**: [선속도 자코비안; 각속도 자코비안]

##### 특이점 (Singularity)
- **발생**: det(J) = 0일 때
- **문제**: 역자코비안 존재하지 않음
- **해결**: 특이점 회피 알고리즘, 감쇠 최소제곱법

##### 응용
- **속도 제어**: 목표 속도로 관절 속도 계산
- **역기구학**: 반복적 해법에 활용
- **힘 제어**: 힘과 토크 관계 변환

### 🔄 전신 제어 기술

#### 1. 다중 태스크 제어

##### 계층적 제어 (Hierarchical Control)
- **우선순위**: 균형 > 보행 > 상체 작업
- **Null Space**: 고우선순위 태스크를 방해하지 않는 범위에서 저우선순위 수행
- **수식**: q̇ = J₁⁺x₁ + (I - J₁⁺J₁)J₂⁺x₂

##### 가중 제어 (Weighted Control)  
- **가중합**: 여러 태스크를 가중치로 결합
- **실시간 조정**: 상황에 따라 가중치 동적 변경
- **최적화**: 2차 계획법으로 최적해 계산

#### 2. 중복 자유도 (Redundancy) 활용

##### 개념
- **정의**: 태스크 수행에 필요한 것보다 많은 관절
- **휴머노이드**: 30+ DOF로 높은 중복성
- **장점**: 다양한 자세, 특이점 회피, 제약 만족

##### 중복성 해결 방법
- **의사역행렬**: 최소 노름 해
- **가중 의사역행렬**: 관절별 중요도 고려
- **점진적 목표**: 보조 목표 함수 설정

#### 3. 제약 조건 처리

##### 물리적 제약
- **관절 한계**: 각도, 속도, 토크 제한
- **충돌 회피**: 자가 충돌 및 환경 충돌
- **균형 유지**: ZMP 제약

##### 수학적 표현
```
minimize: ||J(q)q̇ - ẋd||²
subject to: qmin ≤ q ≤ qmax
           q̇min ≤ q̇ ≤ q̇max
           ZMP ∈ Support polygon
```

### 📊 궤적 최적화

#### 1. 문제 정의

##### 목적 함수
- **에너지 최소화**: ∫τᵀτ dt (토크 제곱합)
- **시간 최소화**: 최단 시간 경로
- **부드러움**: ∫q̈ᵀq̈ dt (가속도 제곱합)
- **안정성**: ZMP 마진 최대화

##### 제약 조건
- **초기/종료**: 시작점과 끝점 조건
- **경유점**: 중간 통과점
- **물리적 한계**: 관절, 속도, 가속도 제한
- **충돌 회피**: 장애물 제약

#### 2. 최적화 기법

##### 직접 최적화
- **콜로케이션**: 연속 문제를 이산화
- **다중 사격법**: 경계값 문제 해법
- **의사 스펙트럼**: 체비셰프 다항식 이용

##### 간접 최적화
- **변분법**: 오일러-라그랑주 방정식
- **최적 제어**: 해밀턴-야코비-벨만 방정식
- **수치 해법**: 다중 점 경계값 문제

##### 비선형 계획법
- **SQP**: Sequential Quadratic Programming
- **내점법**: Interior Point Method
- **유전 알고리즘**: 전역 최적화

#### 3. 실시간 최적화

##### Model Predictive Control (MPC)
- **예측 모델**: 시스템 동역학 모델
- **순환 최적화**: 매 제어 주기마다 최적화
- **제약 만족**: 실시간 제약 조건 처리

##### 적응형 동작 최적화 (AMO)
- **sim-to-real**: 시뮬레이션과 실제 환경 연결
- **강화학습 결합**: RL + 궤적 최적화
- **실시간 적응**: 환경 변화에 즉시 대응

### 🧠 학습 기반 제어

#### 1. 강화학습 (Reinforcement Learning)

##### 기본 개념
- **환경**: 로봇과 주변 환경
- **상태**: 관절 각도, 속도, 위치 등
- **행동**: 관절 토크 또는 목표 위치
- **보상**: 태스크 성공도, 에너지 효율성 등

##### 휴머노이드 적용
- **보행 학습**: 안정적 이족 보행 패턴 학습
- **균형 제어**: 외란에 대한 동적 균형 대응
- **전신 협조**: 복합 태스크 동시 수행

##### 주요 알고리즘
- **PPO**: Proximal Policy Optimization
- **SAC**: Soft Actor-Critic  
- **TD3**: Twin Delayed Deep Deterministic policy gradient

#### 2. 모방학습 (Imitation Learning)

##### 행동 복제 (Behavior Cloning)
- **데이터**: 전문가 시연 데이터
- **학습**: 지도학습으로 정책 학습
- **장점**: 안정적, 빠른 학습
- **단점**: 분포 이동 문제

##### 모션 캡처 활용
- **인간 동작**: 모션 캡처로 인간 움직임 기록
- **변환**: 인간 골격을 로봇 관절로 매핑
- **최적화**: 로봇 제약에 맞게 동작 조정

##### 대화형 모방학습
- **DAgger**: Dataset Aggregation
- **전문가 피드백**: 학습 중 전문가 개입
- **점진적 개선**: 반복적 데이터 수집과 학습

#### 3. 하이브리드 접근법

##### 모델 기반 + 학습 기반
- **초기화**: 모델 기반으로 초기 정책
- **개선**: 강화학습으로 성능 향상
- **안전성**: 모델 기반 제약으로 안전 보장

##### 계층적 학습
- **상위 레벨**: 태스크 계획 및 목표 설정
- **하위 레벨**: 모터 제어 및 안정화
- **모듈화**: 각 레벨 독립적 학습 가능

### 🔧 센서 융합 및 상태 추정

#### 1. 센서 시스템

##### 관성 센서 (IMU)
- **가속도계**: 선형 가속도 측정
- **자이로스코프**: 각속도 측정
- **자력계**: 방향 기준 제공
- **융합**: 상보 필터, 칼만 필터

##### 시각 센서
- **RGB 카메라**: 색상 영상 정보
- **깊이 카메라**: 거리 정보
- **스테레오 비전**: 3D 구조 복원
- **LiDAR**: 고정밀 거리 측정

##### 촉각 센서
- **힘/토크 센서**: 발과 지면 간 상호작용력
- **압력 센서**: 접촉 압력 분포
- **관절 센서**: 관절 위치, 속도, 토크

#### 2. 상태 추정 알고리즘

##### 칼만 필터 (Kalman Filter)
- **선형 시스템**: 가우시안 노이즈 가정
- **예측**: 시스템 모델 기반 상태 예측
- **업데이트**: 센서 측정으로 상태 보정

##### 확장 칼만 필터 (EKF)
- **비선형 시스템**: 자코비안으로 선형화
- **로봇 적용**: 비선형 동역학 시스템
- **한계**: 강한 비선형성에서 성능 저하

##### 파티클 필터
- **비선형/비가우시안**: 일반적인 확률 분포
- **샘플링**: 파티클로 확률 분포 표현
- **재샘플링**: 가중치 기반 파티클 선택

#### 3. SLAM (Simultaneous Localization and Mapping)

##### 개념
- **동시 수행**: 위치 추정과 지도 작성
- **센서**: 카메라, LiDAR, IMU 융합
- **응용**: 미지 환경에서 내비게이션

##### 주요 방법
- **시각적 SLAM**: 카메라 기반 (ORB-SLAM, VINS)
- **LiDAR SLAM**: 레이저 스캐너 기반
- **융합 SLAM**: 여러 센서 결합

### 🔬 고급 연구 주제

#### 1. 적응 제어 (Adaptive Control)

##### 매개변수 적응
- **미지 매개변수**: 로봇 질량, 관성 등
- **실시간 추정**: 매개변수 온라인 학습
- **안정성**: 리아푸노프 안정성 보장

##### 견고 제어 (Robust Control)
- **불확실성**: 모델 오차, 외란
- **H∞ 제어**: 최악 경우 성능 보장
- **슬라이딩 모드**: 불연속 제어로 견고성 확보

#### 2. 최적 제어

##### Linear Quadratic Regulator (LQR)
- **선형 시스템**: 선형 동역학, 2차 비용
- **리카티 방정식**: 최적 피드백 게인
- **무한 수평**: 정상상태 최적 제어

##### Differential Dynamic Programming (DDP)
- **비선형 최적 제어**: 비선형 시스템
- **2차 근사**: 값 함수의 2차 근사
- **순방향-역방향**: 반복적 해법

#### 3. 확률적 제어

##### 확률적 최적 제어
- **불확실성**: 노이즈, 측정 오차
- **기댓값 최적화**: 확률적 비용 함수
- **동적 계획법**: 벨만 방정식

##### 베이지안 추론
- **사전 지식**: 이전 경험 활용
- **사후 업데이트**: 새로운 관측으로 업데이트
- **불확실성 정량화**: 확률적 추정

### 🔧 구현 및 검증

#### 1. 시뮬레이션 환경

##### 물리 엔진
- **강체 동역학**: 관절과 링크 모델링
- **접촉 모델**: 발-지면 상호작용
- **마찰 모델**: 정적/동적 마찰

##### 주요 시뮬레이터
- **Gazebo**: ROS 연동, 물리 시뮬레이션
- **MuJoCo**: 연속 제어 최적화
- **PyBullet**: 파이썬 기반 물리 엔진
- **CasADi**: 최적화 문제 모델링

#### 2. 실험 및 검증

##### 성능 지표
- **안정성**: 넘어지지 않고 보행한 거리
- **에너지 효율**: 단위 거리당 에너지 소비
- **속도**: 최대 보행 속도
- **적응성**: 외란에 대한 회복 능력

##### 실험 프로토콜
- **제어된 환경**: 실험실 조건
- **다양한 지형**: 평지, 경사, 계단
- **외란 테스트**: 밀기, 장애물
- **장시간 테스트**: 내구성 검증

#### 3. 안전 고려사항

##### 하드웨어 안전
- **비상 정지**: 즉시 모든 모터 정지
- **소프트 제한**: 관절 한계 보호
- **힘 제한**: 과도한 힘 방지

##### 소프트웨어 안전
- **예외 처리**: 센서 오류, 통신 실패
- **상태 감시**: 비정상 상태 감지
- **점진적 테스트**: 단계별 검증


## 3. ZMP (Zero Moment Point)

### 정의

ZMP(Zero Moment Point)는 지면과 로봇 발 사이의 접촉점에서 수평 방향 모멘트의 합이 0이 되는 점으로, 이족 보행 로봇의 동적 안정성을 평가하는 핵심 지표입니다.

### 수학적 정의

#### 기본 개념
```
ZMP 조건: Σ Mhorizontal = 0
여기서 Mhorizontal은 해당 점에서의 수평 모멘트
```

#### 좌표 계산
```
xZMP = Σ(fi × yi) / Σ(fzi)
yZMP = Σ(fi × xi) / Σ(fzi)

여기서:
- fi: i번째 힘 벡터
- xi, yi: i번째 힘의 작용점
- fzi: i번째 수직 힘 성분
```

#### 동역학적 표현
```
ZMP = (Σ(mi × g × ri) - Σ(mi × ai × ri)) / Σ(mi × g)

여기서:
- mi: i번째 링크 질량
- g: 중력 가속도
- ri: i번째 링크 위치
- ai: i번째 링크 가속도
```

### 물리적 의미

#### 안정성 기준
- **안정**: ZMP ∈ Support Polygon (발바닥 영역 내부)
- **불안정**: ZMP ∉ Support Polygon (발바닥 영역 외부)
- **한계**: ZMP가 지지 영역 경계에 위치

#### 지지 다각형 (Support Polygon)
- **단일 지지**: 한 발이 지면에 접촉 (발바닥 영역)
- **이중 지지**: 양발이 지면에 접촉 (두 발바닥을 잇는 볼록 껍질)
- **동적 변화**: 보행 중 지지 영역이 지속적으로 변화

### ZMP 기반 보행 제어

#### 1. ZMP 궤적 계획

##### 미리 계획된 ZMP (Pre-planned ZMP)
```python
# 단순한 ZMP 패턴 예시
def generate_zmp_trajectory(step_time, step_width):
    zmp_trajectory = []
    
    # 이중 지지 단계
    zmp_x = interpolate(left_foot_x, right_foot_x, ratio=0.5)
    
    # 단일 지지 단계  
    zmp_x = support_foot_x
    
    return zmp_trajectory
```

##### 가변 ZMP (Variable ZMP)
- **목적**: 에너지 효율성 향상
- **방법**: 허용 ZMP 영역 내에서 최적 경로 탐색
- **제약**: 지지 영역 내부 유지

#### 2. ZMP 추적 제어

##### 피드백 제어
```
CoM 보정 = Kp × (ZMPdesired - ZMPactual)
여기서 Kp는 비례 게인
```

##### PID 제어기 설계
```cpp
class ZMPController {
private:
    double kp, ki, kd;
    double integral_error = 0;
    double previous_error = 0;
    
public:
    double control(double zmp_error, double dt) {
        integral_error += zmp_error * dt;
        double derivative = (zmp_error - previous_error) / dt;
        
        double output = kp * zmp_error + 
                       ki * integral_error + 
                       kd * derivative;
        
        previous_error = zmp_error;
        return output;
    }
};
```

##### 퍼지 로직 제어
- **입력**: ZMP 오차, ZMP 변화율
- **출력**: CoM 위치 보정량
- **장점**: 비선형성에 강건

#### 3. ZMP 기반 보행 패턴 생성

##### Cart-Table Model
```
질량중심 방정식:
ẍ = (g/h) × (x - xZMP)

여기서:
- x: 질량중심 위치
- h: 질량중심 높이
- g: 중력 가속도
```

##### LIPM (Linear Inverted Pendulum Model)
- **가정**: 로봇을 단순한 역진자로 모델링
- **장점**: 해석적 해 존재, 실시간 계산 가능
- **단점**: 상체 움직임과 다리 질량 무시

### 실제 구현

#### 1. ZMP 측정

##### Force/Torque Sensor
```cpp
// 6축 F/T 센서를 이용한 ZMP 계산
Vector3 calculateZMP(Vector3 force, Vector3 moment) {
    double x_zmp = -moment.y / force.z;
    double y_zmp = moment.x / force.z;
    return Vector3(x_zmp, y_zmp, 0);
}
```

##### 압력 센서 배열
- **분포 측정**: 발바닥 여러 지점의 압력
- **ZMP 계산**: 압력 분포로부터 무게중심 계산
- **해상도**: 센서 개수에 따른 정밀도

#### 2. ZMP 제어기 설계

##### 상태공간 제어
```
상태: x = [CoM_position, CoM_velocity, ZMP_position]
제어입력: u = CoM_acceleration
출력: y = ZMP_position

상태방정식: ẋ = Ax + Bu
출력방정식: y = Cx
```

### 고급 ZMP 기법

#### 1. 예측 ZMP 제어

##### Model Predictive Control (MPC)
```
목적함수:
J = Σ(||ZMP_predicted - ZMP_reference||² + R||u||²)

제약조건:
- ZMP ∈ Support Polygon
- |CoM_acceleration| ≤ a_max
```

##### 미래 지지 영역 고려
- **다단계 예측**: 여러 스텝 앞의 지지 영역 예측
- **최적화**: 전체 보행 주기에 대한 최적 ZMP 궤적

#### 2. 적응적 ZMP 제어

##### 지형 적응
- **경사면**: 중력 방향 변화 고려
- **불규칙 지형**: 발 접촉 모델 실시간 업데이트
- **계단**: 높이 변화에 따른 ZMP 재계산

##### 외란 대응
- **밀림**: 급격한 ZMP 변화 대응
- **미끄러짐**: 마찰 계수 변화 고려
- **바람**: 외부 힘의 영향 보상

#### 3. ZMP 안정성 마진

##### 안정성 지표
```
안정성 마진 = min(distance(ZMP, boundary_of_support_polygon))
- 양수: 안정
- 0: 임계
- 음수: 불안정
```

##### 동적 안정성
- **ZMP 속도**: ZMP 이동 속도 제한
- **ZMP 가속도**: 급격한 ZMP 변화 방지
- **예측 안정성**: 미래 ZMP 궤적의 안정성 평가

### 한계 및 확장

#### ZMP 기법의 한계

##### 보수적 접근
- **정적 안정**: 동적 효과 무시
- **에너지 비효율**: 과도한 안전 마진
- **속도 제한**: 빠른 보행에 부적합

##### 가정의 한계
- **강체 가정**: 유연한 발바닥 무시
- **점 접촉**: 실제 면 접촉과 차이
- **마찰 무한**: 미끄러짐 가능성 무시

#### 확장 기법

##### Capture Point
- **정의**: 현재 상태에서 정지할 수 있는 발 위치
- **동적 안정성**: ZMP보다 동적 특성 반영
- **수식**: CP = CoM + CoM_velocity / ω₀

##### 중심압력점 (Center of Pressure, CoP)
- **차이점**: 실제 측정되는 압력 중심
- **관계**: ZMP는 이론적, CoP는 실측값
- **활용**: ZMP와 CoP 차이로 시스템 상태 평가

### 실험 및 검증

#### 성능 지표
- **ZMP 추적 오차**: RMS 오차, 최대 오차
- **안정성 마진**: 평균 마진, 최소 마진
- **에너지 효율**: 단위 거리당 에너지 소비
- **보행 속도**: 최대 안정 보행 속도

#### 실험 프로토콜
1. **정지 상태**: ZMP 위치 정확도 측정
2. **저속 보행**: ZMP 추적 성능 평가
3. **고속 보행**: 안정성 한계 측정
4. **외란 테스트**: 밀기, 미끄러짐 대응
5. **지형 테스트**: 경사, 계단, 불규칙 지형

#### 시뮬레이션 검증
- **물리 엔진**: 정확한 접촉 모델링
- **센서 모델**: 노이즈, 지연, 오차 모델
- **Monte Carlo**: 다양한 조건에서 통계적 검증

### 관련 연구

#### 초기 연구 (1970-1990)
- **Vukobratović**: ZMP 개념 최초 제안
- **기본 이론**: 정적 안정성 기준 확립

#### 발전기 (1990-2010)  
- **Honda**: ASIMO의 ZMP 기반 보행
- **실용화**: 실제 휴머노이드에 적용

#### 현대 연구 (2010-현재)
- **최적화**: MPC 기반 ZMP 제어
- **학습**: 강화학습과 ZMP 결합
- **동적 보행**: ZMP 한계 극복 연구

### 코드 예제

#### 기본 ZMP 계산
```python
import numpy as np

def calculate_zmp(masses, positions, accelerations):
    """
    질량, 위치, 가속도로부터 ZMP 계산
    """
    g = 9.81  # 중력가속도
    
    numerator_x = 0
    numerator_y = 0  
    denominator = 0
    
    for m, pos, acc in zip(masses, positions, accelerations):
        force_z = m * (g + acc[2])  # 수직력
        moment_x = m * (acc[1] * pos[2] - (g + acc[2]) * pos[1])
        moment_y = m * ((g + acc[2]) * pos[0] - acc[0] * pos[2])
        
        numerator_x += moment_y
        numerator_y += moment_x
        denominator += force_z
    
    zmp_x = numerator_x / denominator
    zmp_y = numerator_y / denominator
    
    return np.array([zmp_x, zmp_y])
```

#### ZMP 추적 제어기
```python
class ZMPTracker:
    def __init__(self, kp=100, ki=10, kd=5):
        self.kp = kp
        self.ki = ki  
        self.kd = kd
        self.integral_error = np.zeros(2)
        self.previous_error = np.zeros(2)
        
    def control(self, zmp_desired, zmp_actual, dt):
        error = zmp_desired - zmp_actual
        
        # PID 제어
        self.integral_error += error * dt
        derivative_error = (error - self.previous_error) / dt
        
        com_correction = (self.kp * error + 
                         self.ki * self.integral_error +
                         self.kd * derivative_error)
        
        self.previous_error = error.copy()
        return com_correction
```

## 4. 역기구학 (Inverse Kinematics)

### 정의

역기구학(Inverse Kinematics, IK)은 로봇의 엔드 이펙터(말단 장치)의 원하는 위치와 방향을 입력으로 하여, 각 관절이 어떤 각도로 움직여야 하는지를 계산하는 기법입니다.

### 수학적 정의

#### 순기구학과의 관계
```
순기구학 (FK): q → x
x = f(q)

역기구학 (IK): x → q  
q = f⁻¹(x)

여기서:
- q: 관절 각도 벡터 (n차원)
- x: 엔드 이펙터 위치/방향 (m차원)
- f: 순기구학 함수
```

#### 문제의 복잡성
- **비선형**: f(q)가 삼각함수의 복합함수
- **다중해**: 하나의 x에 대해 여러 q 존재 가능
- **해가 없음**: 작업공간 밖의 목표점
- **특이점**: 자코비안 행렬식이 0인 지점

### 해법 분류

#### 1. 해석적 방법 (Analytical Methods)

##### 기하학적 접근
```python
# 2링크 로봇팔 예시
def inverse_kinematics_2link(x, y, L1, L2):
    """
    2링크 로봇팔의 해석적 역기구학
    """
    # 목표점까지의 거리
    r = np.sqrt(x**2 + y**2)
    
    # 코사인 법칙 적용
    cos_theta2 = (r**2 - L1**2 - L2**2) / (2 * L1 * L2)
    
    # 해가 존재하는지 확인
    if abs(cos_theta2) > 1:
        return None  # 해가 없음
    
    # 두 가지 해 (elbow up/down)
    theta2_1 = np.arccos(cos_theta2)
    theta2_2 = -np.arccos(cos_theta2)
    
    # theta1 계산
    alpha = np.arctan2(y, x)
    beta = np.arccos((L1**2 + r**2 - L2**2) / (2 * L1 * r))
    
    theta1_1 = alpha - beta
    theta1_2 = alpha + beta
    
    return [(theta1_1, theta2_1), (theta1_2, theta2_2)]
```

##### 대수적 접근
- **연립방정식**: 순기구학 방정식을 q에 대해 해결
- **치환법**: 삼각함수 치환으로 다항식 변환
- **결과식**: 여러 변수를 하나씩 소거

##### 장단점
- **장점**: 정확한 해, 빠른 계산, 모든 해 탐색 가능
- **단점**: 복잡한 로봇에 적용 어려움, 6 DOF 이상에서 매우 복잡

#### 2. 수치적 방법 (Numerical Methods)

##### 뉴턴-랩슨 방법
```python
def newton_raphson_ik(target_pose, initial_guess, max_iterations=50):
    """
    뉴턴-랩슨 방법을 이용한 역기구학
    """
    q = initial_guess.copy()
    
    for i in range(max_iterations):
        # 현재 자세에서의 순기구학
        current_pose = forward_kinematics(q)
        
        # 오차 계산
        error = target_pose - current_pose
        
        # 수렴 검사
        if np.linalg.norm(error) < tolerance:
            return q, True
        
        # 자코비안 계산
        J = compute_jacobian(q)
        
        # 관절 각도 업데이트
        try:
            delta_q = np.linalg.solve(J, error)
            q += alpha * delta_q  # alpha: 스텝 크기
        except np.linalg.LinAlgError:
            return q, False  # 특이점에서 실패
    
    return q, False  # 수렴 실패
```

##### 경사하강법
```python
def gradient_descent_ik(target_pose, initial_guess):
    """
    경사하강법을 이용한 역기구학
    """
    q = initial_guess.copy()
    learning_rate = 0.01
    
    for iteration in range(max_iterations):
        # 오차 함수: E = 0.5 * ||f(q) - x_target||²
        current_pose = forward_kinematics(q)
        error = target_pose - current_pose
        
        if np.linalg.norm(error) < tolerance:
            return q, True
        
        # 그래디언트 계산: ∇E = J^T * error
        J = compute_jacobian(q)
        gradient = J.T @ error
        
        # 관절 각도 업데이트
        q += learning_rate * gradient
    
    return q, False
```

##### 의사역행렬 (Pseudoinverse)
```python
def pseudoinverse_ik(target_pose, current_q):
    """
    의사역행렬을 이용한 역기구학 (한 스텝)
    """
    # 자코비안 계산
    J = compute_jacobian(current_q)
    
    # 의사역행렬 계산
    if J.shape[0] == J.shape[1]:  # 정사각 행렬
        try:
            J_inv = np.linalg.inv(J)
        except np.linalg.LinAlgError:
            # 특이점에서 감쇠 최소제곱법
            lambda_reg = 0.01
            J_inv = J.T @ np.linalg.inv(J @ J.T + lambda_reg * np.eye(J.shape[0]))
    else:  # 직사각 행렬
        J_inv = np.linalg.pinv(J)
    
    # 현재 위치와 목표 위치의 차이
    current_pose = forward_kinematics(current_q)
    error = target_pose - current_pose
    
    # 관절 각도 변화량
    delta_q = J_inv @ error
    
    return current_q + delta_q
```

#### 3. 최적화 기반 방법

##### 목적함수 정의
```python
def ik_objective_function(q, target_pose, weights):
    """
    역기구학을 위한 목적함수
    """
    # 주 목적: 위치/방향 오차 최소화
    current_pose = forward_kinematics(q)
    pose_error = np.linalg.norm(target_pose - current_pose)
    
    # 부차 목적들
    joint_limit_penalty = compute_joint_limit_penalty(q)
    smoothness_penalty = compute_smoothness_penalty(q)
    singularity_penalty = compute_singularity_penalty(q)
    
    total_cost = (weights['pose'] * pose_error +
                  weights['limits'] * joint_limit_penalty +
                  weights['smooth'] * smoothness_penalty +
                  weights['singular'] * singularity_penalty)
    
    return total_cost
```

##### 제약 최적화
```python
from scipy.optimize import minimize

def constrained_ik(target_pose, initial_guess):
    """
    제약 조건이 있는 역기구학 최적화
    """
    # 목적함수
    def objective(q):
        current_pose = forward_kinematics(q)
        return np.linalg.norm(target_pose - current_pose)**2
    
    # 관절 한계 제약
    bounds = [(q_min[i], q_max[i]) for i in range(len(initial_guess))]
    
    # 충돌 회피 제약
    def collision_constraint(q):
        return minimum_distance_to_obstacle(q) - safety_margin
    
    constraints = [{'type': 'ineq', 'fun': collision_constraint}]
    
    # 최적화 실행
    result = minimize(objective, initial_guess, 
                     bounds=bounds, constraints=constraints,
                     method='SLSQP')
    
    return result.x, result.success
```


### 특수 상황 처리

#### 1. 중복 자유도 (Redundancy)

##### 문제 정의
- **정의**: 태스크 차원보다 관절 수가 많은 경우
- **예시**: 7-DOF 팔로 6-DOF 위치/방향 제어
- **결과**: 무한개의 해 존재

##### 해결 방법

###### Null Space 투영
```python
def redundant_ik_nullspace(target_pose, current_q, secondary_objective):
    """
    널 공간을 이용한 중복 자유도 역기구학
    """
    J = compute_jacobian(current_q)
    
    # 주 태스크: 위치/방향 제어
    current_pose = forward_kinematics(current_q)
    error = target_pose - current_pose
    J_pinv = np.linalg.pinv(J)
    
    # 주 태스크 해
    dq_primary = J_pinv @ error
    
    # 널 공간 투영자
    N = np.eye(len(current_q)) - J_pinv @ J
    
    # 부차 태스크 (예: 관절 중점 유지)
    dq_secondary = secondary_objective_gradient(current_q)
    
    # 최종 해
    dq_total = dq_primary + N @ dq_secondary
    
    return current_q + dq_total
```

###### 가중 의사역행렬
```python
def weighted_pseudoinverse_ik(target_pose, current_q, W):
    """
    가중 의사역행렬을 이용한 역기구학
    """
    J = compute_jacobian(current_q)
    
    # 가중 의사역행렬
    J_weighted_pinv = np.linalg.inv(W) @ J.T @ np.linalg.inv(J @ np.linalg.inv(W) @ J.T)
    
    current_pose = forward_kinematics(current_q)
    error = target_pose - current_pose
    
    delta_q = J_weighted_pinv @ error
    
    return current_q + delta_q
```

#### 2. 특이점 (Singularity) 처리

##### 특이점 감지
```python
def detect_singularity(q, threshold=1e-3):
    """
    특이점 감지
    """
    J = compute_jacobian(q)
    
    # 조건수 확인
    condition_number = np.linalg.cond(J)
    
    # 행렬식 확인 (정사각 행렬인 경우)
    if J.shape[0] == J.shape[1]:
        det_J = np.linalg.det(J)
        return abs(det_J) < threshold
    
    # 특이값 확인
    singular_values = np.linalg.svd(J, compute_uv=False)
    min_singular_value = np.min(singular_values)
    
    return min_singular_value < threshold
```

##### 감쇠 최소제곱법 (Damped Least Squares)
```python
def damped_least_squares_ik(target_pose, current_q, lambda_damping=0.01):
    """
    감쇠 최소제곱법을 이용한 특이점 회피
    """
    J = compute_jacobian(current_q)
    
    # 감쇠된 의사역행렬
    J_damped_pinv = J.T @ np.linalg.inv(J @ J.T + lambda_damping**2 * np.eye(J.shape[0]))
    
    current_pose = forward_kinematics(current_q)
    error = target_pose - current_pose
    
    delta_q = J_damped_pinv @ error
    
    return current_q + delta_q
```

##### 특이점 회피
```python
def singularity_avoidance_ik(target_pose, current_q):
    """
    특이점 회피를 포함한 역기구학
    """
    J = compute_jacobian(current_q)
    
    # 특이점 근접도 계산
    manipulability = np.sqrt(np.linalg.det(J @ J.T))
    
    if manipulability < singularity_threshold:
        # 특이점 회피 방향 계산
        avoidance_direction = compute_avoidance_direction(current_q)
        
        # 주 태스크와 회피 태스크 결합
        current_pose = forward_kinematics(current_q)
        error = target_pose - current_pose
        
        # 가중 결합
        weight_task = 1.0
        weight_avoidance = 1.0 - manipulability / singularity_threshold
        
        combined_objective = (weight_task * J.T @ error +
                             weight_avoidance * avoidance_direction)
        
        return current_q + alpha * combined_objective
    else:
        # 일반적인 역기구학
        return pseudoinverse_ik(target_pose, current_q)
```

#### 3. 작업공간 제한

##### 도달 가능성 검사
```python
def check_reachability(target_pose, robot_params):
    """
    목표 위치가 작업공간 내에 있는지 확인
    """
    # 단순한 구형 작업공간 검사
    max_reach = sum(robot_params['link_lengths'])
    distance_to_target = np.linalg.norm(target_pose[:3])
    
    if distance_to_target > max_reach:
        return False, "Target too far"
    
    # 최소 도달 거리 검사
    min_reach = abs(robot_params['link_lengths'][0] - 
                   sum(robot_params['link_lengths'][1:]))
    
    if distance_to_target < min_reach:
        return False, "Target too close"
    
    return True, "Reachable"
```

##### 최근접점 투영
```python
def project_to_workspace(target_pose, robot_params):
    """
    작업공간 밖의 목표를 작업공간 경계로 투영
    """
    max_reach = sum(robot_params['link_lengths'])
    distance = np.linalg.norm(target_pose[:3])
    
    if distance > max_reach:
        # 최대 도달 거리로 투영
        direction = target_pose[:3] / distance
        projected_position = direction * max_reach
        
        # 방향은 유지
        projected_pose = target_pose.copy()
        projected_pose[:3] = projected_position
        
        return projected_pose
    
    return target_pose
```

### 실시간 역기구학

#### 1. 점진적 해법

##### 속도 기반 IK
```python
def velocity_based_ik(target_velocity, current_q, dt):
    """
    속도 기반 실시간 역기구학
    """
    J = compute_jacobian(current_q)
    J_pinv = np.linalg.pinv(J)
    
    # 관절 속도 계산
    joint_velocity = J_pinv @ target_velocity
    
    # 관절 위치 업데이트
    new_q = current_q + joint_velocity * dt
    
    # 관절 한계 적용
    new_q = np.clip(new_q, joint_limits_min, joint_limits_max)
    
    return new_q
```

##### 궤적 추종
```python
def trajectory_following_ik(trajectory, initial_q, dt):
    """
    궤적 추종을 위한 연속적 역기구학
    """
    q_trajectory = [initial_q]
    current_q = initial_q.copy()
    
    for i in range(1, len(trajectory)):
        target_pose = trajectory[i]
        
        # 한 스텝 역기구학
        next_q = one_step_ik(target_pose, current_q, dt)
        
        # 부드러운 변화를 위한 필터링
        max_joint_velocity = 1.0  # rad/s
        max_change = max_joint_velocity * dt
        
        delta_q = next_q - current_q
        delta_q = np.clip(delta_q, -max_change, max_change)
        
        current_q = current_q + delta_q
        q_trajectory.append(current_q.copy())
    
    return q_trajectory
```

#### 2. 실시간 최적화

##### Model Predictive Control
```python
def mpc_based_ik(trajectory_segment, current_q, horizon=10):
    """
    MPC를 이용한 예측적 역기구학
    """
    def objective(q_sequence):
        cost = 0
        q = current_q.copy()
        
        for i, target_pose in enumerate(trajectory_segment[:horizon]):
            # 위치 오차
            current_pose = forward_kinematics(q)
            pose_error = np.linalg.norm(target_pose - current_pose)
            cost += pose_error**2
            
            # 관절 변화 평활화
            if i > 0:
                smoothness = np.linalg.norm(q - q_prev)**2
                cost += 0.1 * smoothness
            
            q_prev = q.copy()
            if i < len(q_sequence) - 1:
                q = q_sequence[i+1]
        
        return cost
    
    # 초기 추정: 선형 보간
    q_init = generate_initial_trajectory(current_q, trajectory_segment, horizon)
    
    # 최적화
    result = minimize(objective, q_init.flatten(), method='L-BFGS-B')
    
    return result.x.reshape(-1, len(current_q))
```

### 휴머노이드 특수 고려사항

#### 1. 전신 역기구학

##### 계층적 접근
```python
def whole_body_ik(tasks, current_q, priorities):
    """
    우선순위 기반 전신 역기구학
    """
    q = current_q.copy()
    
    # 우선순위 순으로 태스크 처리
    for priority_level in sorted(priorities.keys()):
        task_indices = priorities[priority_level]
        
        # 현재 우선순위 태스크들
        current_tasks = [tasks[i] for i in task_indices]
        
        # 복합 자코비안 구성
        J_combined = []
        error_combined = []
        
        for task in current_tasks:
            J_task = compute_task_jacobian(q, task)
            error_task = compute_task_error(q, task)
            
            J_combined.append(J_task)
            error_combined.append(error_task)
        
        J_combined = np.vstack(J_combined)
        error_combined = np.concatenate(error_combined)
        
        # 이전 우선순위 태스크의 널 공간에서 해결
        if priority_level > 0:
            N = compute_null_space_projector(q, higher_priority_tasks)
            J_projected = J_combined @ N
            delta_q = np.linalg.pinv(J_projected) @ error_combined
            delta_q = N @ delta_q
        else:
            delta_q = np.linalg.pinv(J_combined) @ error_combined
        
        q += delta_q
    
    return q
```

#### 2. 균형 제약 통합

##### ZMP 제약이 있는 IK
```python
def balance_constrained_ik(upper_body_target, current_q):
    """
    균형 제약을 고려한 상체 역기구학
    """
    def objective_with_balance(q):
        # 상체 위치 오차
        upper_pose = compute_upper_body_pose(q)
        pose_error = np.linalg.norm(upper_body_target - upper_pose)
        
        # ZMP 위치 계산
        zmp = compute_zmp(q)
        support_polygon = get_support_polygon(q)
        
        # ZMP 제약 위반 패널티
        zmp_penalty = compute_zmp_penalty(zmp, support_polygon)
        
        return pose_error**2 + 100 * zmp_penalty
    
    # 관절 한계 제약
    bounds = [(q_min[i], q_max[i]) for i in range(len(current_q))]
    
    result = minimize(objective_with_balance, current_q, bounds=bounds)
    return result.x
```

### 성능 평가

#### 평가 지표
- **정확도**: 목표 위치와 실제 위치의 오차
- **반복성**: 같은 목표에 대한 해의 일관성
- **수렴성**: 해로 수렴하는 속도와 안정성
- **계산 시간**: 실시간 응용을 위한 처리 속도

#### 벤치마크 테스트
```python
def evaluate_ik_performance(ik_solver, test_cases):
    """
    역기구학 솔버 성능 평가
    """
    results = {
        'position_errors': [],
        'orientation_errors': [],
        'computation_times': [],
        'success_rates': []
    }
    
    for target_pose in test_cases:
        start_time = time.time()
        
        # 역기구학 해결
        solution, success = ik_solver(target_pose)
        
        computation_time = time.time() - start_time
        results['computation_times'].append(computation_time)
        
        if success:
            # 정확도 검사
            achieved_pose = forward_kinematics(solution)
            pos_error = np.linalg.norm(target_pose[:3] - achieved_pose[:3])
            ori_error = compute_orientation_error(target_pose[3:], achieved_pose[3:])
            
            results['position_errors'].append(pos_error)
            results['orientation_errors'].append(ori_error)
            results['success_rates'].append(1)
        else:
            results['success_rates'].append(0)
    
    # 통계 계산
    stats = {
        'avg_pos_error': np.mean(results['position_errors']),
        'avg_ori_error': np.mean(results['orientation_errors']),
        'avg_computation_time': np.mean(results['computation_times']),
        'success_rate': np.mean(results['success_rates'])
    }
    
    return stats
```

## 5. 자코비안 (Jacobian)

### 정의

자코비안(Jacobian) 행렬은 다변수 벡터 함수의 1차 편미분으로 구성된 행렬로, 로봇공학에서는 관절 공간(Joint Space)과 작업 공간(Task Space) 사이의 미분 관계를 나타내는 핵심 도구입니다.

### 수학적 정의

#### 일반적 정의
n차원 입력 벡터 **q**를 m차원 출력 벡터 **x**로 변환하는 함수 f에 대해:

```
x = f(q) = [f₁(q₁, q₂, ..., qₙ)]
           [f₂(q₁, q₂, ..., qₙ)]
           [        ⋮          ]
           [fₘ(q₁, q₂, ..., qₙ)]
```

자코비안 행렬 J는:

```
J = ∂f/∂q = [∂f₁/∂q₁  ∂f₁/∂q₂  ...  ∂f₁/∂qₙ]
            [∂f₂/∂q₁  ∂f₂/∂q₂  ...  ∂f₂/∂qₙ]
            [   ⋮        ⋮      ⋱     ⋮   ]
            [∂fₘ/∂q₁  ∂fₘ/∂q₂  ...  ∂fₘ/∂qₙ]
```

#### 로봇공학에서의 의미

##### 속도 관계
```
ẋ = J(q) × q̇

여기서:
- ẋ: 엔드 이펙터 속도 (선속도 + 각속도)
- q̇: 관절 각속도 벡터
- J(q): 구성에 따라 변하는 자코비안 행렬
```

##### 미소 변위 관계
```
δx = J(q) × δq

여기서:
- δx: 엔드 이펙터 미소 변위
- δq: 관절 미소 변위
```

### 기하학적 자코비안

#### 구성 요소

##### 선속도 자코비안 (Jᵥ)
각 관절이 엔드 이펙터의 선속도에 기여하는 정도:

```python
def compute_linear_velocity_jacobian(q, link_positions):
    """
    선속도 자코비안 계산
    """
    n_joints = len(q)
    Jv = np.zeros((3, n_joints))
    
    end_effector_pos = link_positions[-1]
    
    for i in range(n_joints):
        if joint_type[i] == 'revolute':
            # 회전 관절: zi-1 × (pe - pi-1)
            z_axis = get_z_axis(i-1, q)
            r_vector = end_effector_pos - link_positions[i-1]
            Jv[:, i] = np.cross(z_axis, r_vector)
        elif joint_type[i] == 'prismatic':
            # 직선 관절: zi-1
            Jv[:, i] = get_z_axis(i-1, q)
    
    return Jv
```

##### 각속도 자코비안 (Jω)
각 관절이 엔드 이펙터의 각속도에 기여하는 정도:

```python
def compute_angular_velocity_jacobian(q):
    """
    각속도 자코비안 계산
    """
    n_joints = len(q)
    Jw = np.zeros((3, n_joints))
    
    for i in range(n_joints):
        if joint_type[i] == 'revolute':
            # 회전 관절: zi-1
            Jw[:, i] = get_z_axis(i-1, q)
        elif joint_type[i] == 'prismatic':
            # 직선 관절: 0
            Jw[:, i] = np.zeros(3)
    
    return Jw
```

##### 전체 자코비안
```python
def compute_geometric_jacobian(q):
    """
    기하학적 자코비안 계산
    """
    Jv = compute_linear_velocity_jacobian(q)
    Jw = compute_angular_velocity_jacobian(q)
    
    # 6×n 자코비안 (선속도 + 각속도)
    J = np.vstack([Jv, Jw])
    
    return J
```

### 해석적 자코비안

#### DH Parameter 기반 계산

```python
def compute_analytical_jacobian(q, dh_params):
    """
    DH Parameter를 이용한 해석적 자코비안 계산
    """
    n = len(q)
    J = np.zeros((6, n))
    
    # 현재 구성에서의 변환 행렬들
    T = [np.eye(4)]
    for i in range(n):
        Ti = dh_transform(dh_params[i], q[i])
        T.append(T[-1] @ Ti)
    
    # 엔드 이펙터 위치
    pe = T[-1][:3, 3]
    
    for i in range(n):
        if dh_params[i]['type'] == 'revolute':
            # 회전축 (z축)
            zi = T[i][:3, 2]
            
            # 관절에서 엔드 이펙터로의 벡터
            pi = T[i][:3, 3]
            r = pe - pi
            
            # 선속도 성분
            J[:3, i] = np.cross(zi, r)
            # 각속도 성분
            J[3:, i] = zi
            
        elif dh_params[i]['type'] == 'prismatic':
            # 이동축 (z축)
            zi = T[i][:3, 2]
            
            # 선속도 성분
            J[:3, i] = zi
            # 각속도 성분 (0)
            J[3:, i] = 0
    
    return J
```

#### 수치적 자코비안

```python
def compute_numerical_jacobian(q, forward_kinematics_func, epsilon=1e-6):
    """
    수치 미분을 이용한 자코비안 계산
    """
    n = len(q)
    x0 = forward_kinematics_func(q)
    m = len(x0)
    
    J = np.zeros((m, n))
    
    for i in range(n):
        # q[i]에 대한 편미분
        q_plus = q.copy()
        q_plus[i] += epsilon
        
        q_minus = q.copy()
        q_minus[i] -= epsilon
        
        x_plus = forward_kinematics_func(q_plus)
        x_minus = forward_kinematics_func(q_minus)
        
        # 중앙 차분
        J[:, i] = (x_plus - x_minus) / (2 * epsilon)
    
    return J
```


### 자코비안의 응용

#### 1. 역기구학

##### 반복적 해법
```python
def jacobian_inverse_kinematics(target_pose, initial_q, max_iter=100, tolerance=1e-6):
    """
    자코비안을 이용한 반복적 역기구학
    """
    q = initial_q.copy()
    
    for iteration in range(max_iter):
        # 현재 엔드 이펙터 위치
        current_pose = forward_kinematics(q)
        error = target_pose - current_pose
        
        # 수렴 확인
        if np.linalg.norm(error) < tolerance:
            return q, True
        
        # 자코비안 계산
        J = compute_jacobian(q)
        
        # 관절 각도 업데이트
        try:
            delta_q = np.linalg.solve(J, error)
        except np.linalg.LinAlgError:
            # 특이점에서 의사역행렬 사용
            delta_q = np.linalg.pinv(J) @ error
        
        # 스텝 크기 조절
        alpha = 0.5
        q += alpha * delta_q
    
    return q, False
```

##### 감쇠 최소제곱법
```python
def damped_least_squares_ik(target_pose, current_q, lambda_damping=0.01):
    """
    감쇠 최소제곱법을 이용한 안정적 역기구학
    """
    current_pose = forward_kinematics(current_q)
    error = target_pose - current_pose
    
    J = compute_jacobian(current_q)
    
    # 감쇠된 의사역행렬
    A = J @ J.T + lambda_damping**2 * np.eye(J.shape[0])
    J_damped = J.T @ np.linalg.inv(A)
    
    delta_q = J_damped @ error
    
    return current_q + delta_q
```

#### 2. 속도 제어

##### 직교 속도 제어
```python
def cartesian_velocity_control(desired_velocity, current_q):
    """
    직교 좌표계에서의 속도 제어
    """
    J = compute_jacobian(current_q)
    
    # 의사역행렬로 관절 속도 계산
    joint_velocity = np.linalg.pinv(J) @ desired_velocity
    
    return joint_velocity

def execute_velocity_control(robot, desired_velocity, current_q, dt):
    """
    속도 제어 실행
    """
    joint_velocity = cartesian_velocity_control(desired_velocity, current_q)
    
    # 관절 속도 제한 적용
    max_joint_velocity = robot.joint_velocity_limits
    joint_velocity = np.clip(joint_velocity, -max_joint_velocity, max_joint_velocity)
    
    # 관절 위치 업데이트
    new_q = current_q + joint_velocity * dt
    
    return new_q, joint_velocity
```

#### 3. 힘 제어

##### 정적 힘 변환
```python
def force_transformation(joint_torques, current_q):
    """
    관절 토크를 엔드 이펙터 힘으로 변환
    """
    J = compute_jacobian(current_q)
    
    # 이중성 원리: F = J^(-T) * τ
    try:
        end_effector_force = np.linalg.solve(J.T, joint_torques)
    except np.linalg.LinAlgError:
        end_effector_force = np.linalg.pinv(J.T) @ joint_torques
    
    return end_effector_force

def cartesian_force_control(desired_force, current_q):
    """
    직교좌표계 힘을 관절 토크로 변환
    """
    J = compute_jacobian(current_q)
    
    # τ = J^T * F
    joint_torques = J.T @ desired_force
    
    return joint_torques
```

#### 4. 다중 태스크 제어

##### 우선순위 기반 제어
```python
def prioritized_multitask_control(tasks, current_q):
    """
    우선순위 기반 다중 태스크 제어
    """
    q_dot = np.zeros(len(current_q))
    N = np.eye(len(current_q))  # 널 공간 투영자
    
    for task in sorted(tasks, key=lambda x: x.priority):
        # 태스크 자코비안
        J_task = compute_task_jacobian(current_q, task)
        
        # 널 공간으로 투영된 자코비안
        J_proj = J_task @ N
        
        # 태스크 오차
        error = compute_task_error(current_q, task)
        
        # 태스크 해결
        if np.linalg.matrix_rank(J_proj) > 0:
            J_proj_pinv = np.linalg.pinv(J_proj)
            q_dot_task = J_proj_pinv @ error
            
            # 전체 해에 추가
            q_dot += N @ q_dot_task
            
            # 널 공간 업데이트
            N = N - J_proj_pinv @ J_proj
    
    return q_dot
```

##### 가중 다중 태스크
```python
def weighted_multitask_control(tasks, current_q):
    """
    가중치 기반 다중 태스크 제어
    """
    # 복합 자코비안과 오차 구성
    J_combined = []
    error_combined = []
    
    for task in tasks:
        J_task = compute_task_jacobian(current_q, task)
        error_task = compute_task_error(current_q, task)
        
        J_combined.append(np.sqrt(task.weight) * J_task)
        error_combined.append(np.sqrt(task.weight) * error_task)
    
    J_combined = np.vstack(J_combined)
    error_combined = np.concatenate(error_combined)
    
    # 가중 최소제곱 해
    q_dot = np.linalg.pinv(J_combined) @ error_combined
    
    return q_dot
```

### 특이점 분석

#### 1. 특이점 정의

##### 수학적 조건
```python
def analyze_singularity(q):
    """
    특이점 분석
    """
    J = compute_jacobian(q)
    
    # 정사각 자코비안인 경우
    if J.shape[0] == J.shape[1]:
        det_J = np.linalg.det(J)
        condition_number = np.linalg.cond(J)
        
        return {
            'determinant': det_J,
            'condition_number': condition_number,
            'is_singular': abs(det_J) < 1e-6,
            'is_ill_conditioned': condition_number > 1e6
        }
    
    # 직사각 자코비안인 경우
    else:
        singular_values = np.linalg.svd(J, compute_uv=False)
        min_sv = np.min(singular_values)
        condition_number = np.max(singular_values) / min_sv
        
        return {
            'singular_values': singular_values,
            'min_singular_value': min_sv,
            'condition_number': condition_number,
            'is_singular': min_sv < 1e-6,
            'rank': np.sum(singular_values > 1e-6)
        }
```

#### 2. 특이점 유형

##### 운동학적 특이점
```python
def classify_kinematic_singularity(q, robot_model):
    """
    운동학적 특이점 분류
    """
    J = compute_jacobian(q)
    
    # 특이값 분해
    U, s, Vt = np.linalg.svd(J)
    
    # 영 공간과 치역 분석
    null_space_dim = len(s) - np.sum(s > 1e-6)
    
    if null_space_dim > 0:
        # 특이점 유형 판별
        if is_boundary_singularity(q, robot_model):
            return "Boundary Singularity"
        elif is_internal_singularity(q, robot_model):
            return "Internal Singularity"
        else:
            return "Unknown Singularity"
    
    return "Regular Configuration"

def is_boundary_singularity(q, robot_model):
    """
    경계 특이점 확인 (작업공간 경계)
    """
    end_effector_pos = forward_kinematics(q)[:3]
    max_reach = sum(robot_model.link_lengths)
    distance_from_origin = np.linalg.norm(end_effector_pos)
    
    return abs(distance_from_origin - max_reach) < 0.01
```

#### 3. 특이점 회피

##### 가조작도 (Manipulability) 기반
```python
def manipulability_measure(q):
    """
    가조작도 계산
    """
    J = compute_jacobian(q)
    
    if J.shape[0] == J.shape[1]:
        # 정사각 자코비안: |det(J)|
        return abs(np.linalg.det(J))
    else:
        # 직사각 자코비안: √det(JJ^T)
        return np.sqrt(np.linalg.det(J @ J.T))

def singularity_avoidance_control(target_velocity, current_q, threshold=0.1):
    """
    특이점 회피 제어
    """
    J = compute_jacobian(current_q)
    manipulability = manipulability_measure(current_q)
    
    if manipulability < threshold:
        # 특이점 근처에서 회피 동작
        grad_manipulability = compute_manipulability_gradient(current_q)
        
        # 주 태스크와 회피 태스크 결합
        primary_task = np.linalg.pinv(J) @ target_velocity
        avoidance_task = (threshold - manipulability) * grad_manipulability
        
        # 널 공간 투영으로 결합
        N = np.eye(len(current_q)) - np.linalg.pinv(J) @ J
        
        joint_velocity = primary_task + N @ avoidance_task
        
    else:
        # 일반적인 제어
        joint_velocity = np.linalg.pinv(J) @ target_velocity
    
    return joint_velocity
```

### 중복 자유도 활용

#### 1. 널 공간 활용

##### 부차 태스크 수행
```python
def null_space_control(primary_task_velocity, secondary_objective, current_q):
    """
    널 공간을 이용한 부차 태스크 수행
    """
    J = compute_jacobian(current_q)
    J_pinv = np.linalg.pinv(J)
    
    # 주 태스크 해
    q_dot_primary = J_pinv @ primary_task_velocity
    
    # 널 공간 투영자
    N = np.eye(len(current_q)) - J_pinv @ J
    
    # 부차 목적의 기울기
    if secondary_objective == 'joint_limits':
        grad_secondary = joint_limit_avoidance_gradient(current_q)
    elif secondary_objective == 'manipulability':
        grad_secondary = compute_manipulability_gradient(current_q)
    elif secondary_objective == 'energy':
        grad_secondary = energy_minimization_gradient(current_q)
    else:
        grad_secondary = np.zeros_like(current_q)
    
    # 부차 태스크 해 (널 공간에 투영)
    q_dot_secondary = N @ grad_secondary
    
    # 전체 해
    q_dot_total = q_dot_primary + q_dot_secondary
    
    return q_dot_total

def joint_limit_avoidance_gradient(q):
    """
    관절 한계 회피를 위한 기울기
    """
    gradient = np.zeros_like(q)
    
    for i, qi in enumerate(q):
        q_min, q_max = joint_limits[i]
        q_mid = (q_min + q_max) / 2
        
        # 중점으로 향하는 기울기
        gradient[i] = q_mid - qi
    
    return gradient
```

#### 2. 가중 제어

##### 관절별 가중치
```python
def weighted_control(target_velocity, current_q, joint_weights):
    """
    관절별 가중치를 고려한 제어
    """
    J = compute_jacobian(current_q)
    W = np.diag(joint_weights)
    
    # 가중 의사역행렬
    W_inv = np.linalg.inv(W)
    J_weighted_pinv = W_inv @ J.T @ np.linalg.inv(J @ W_inv @ J.T)
    
    joint_velocity = J_weighted_pinv @ target_velocity
    
    return joint_velocity

def adaptive_weighting(current_q):
    """
    적응적 가중치 계산
    """
    weights = np.ones(len(current_q))
    
    for i, qi in enumerate(current_q):
        q_min, q_max = joint_limits[i]
        
        # 관절 한계에 가까울수록 가중치 증가
        dist_to_min = qi - q_min
        dist_to_max = q_max - qi
        min_dist = min(dist_to_min, dist_to_max)
        
        # 한계에 가까우면 가중치 증가 (움직이기 어렵게)
        if min_dist < 0.1:
            weights[i] = 10.0
        elif min_dist < 0.2:
            weights[i] = 2.0
    
    return weights
```

### 자코비안 변환

#### 1. 좌표계 변환

##### 다른 기준점으로의 변환
```python
def transform_jacobian_to_point(J_original, current_q, new_reference_point):
    """
    자코비안을 다른 기준점으로 변환
    """
    # 현재 엔드 이펙터 위치
    current_ee_pos = forward_kinematics(current_q)[:3]
    
    # 새 기준점으로의 벡터
    r = new_reference_point - current_ee_pos
    
    # 변환 행렬
    Ad = np.zeros((6, 6))
    Ad[:3, :3] = np.eye(3)
    Ad[3:, 3:] = np.eye(3)
    Ad[:3, 3:] = skew_symmetric(r)
    
    # 변환된 자코비안
    J_transformed = Ad @ J_original
    
    return J_transformed

def skew_symmetric(v):
    """
    벡터의 반대칭 행렬
    """
    return np.array([[0, -v[2], v[1]],
                     [v[2], 0, -v[0]],
                     [-v[1], v[0], 0]])
```

#### 2. 속도 표현 변환

##### 각속도 표현 변환
```python
def convert_angular_velocity_representation(J_geometric, current_orientation):
    """
    기하학적 자코비안을 해석적 자코비안으로 변환
    (각속도 벡터 → 오일러각 미분)
    """
    # 오일러각에서 각속도로의 변환 행렬
    T_omega = compute_omega_transformation_matrix(current_orientation)
    
    # 변환 행렬 구성
    T = np.zeros((6, 6))
    T[:3, :3] = np.eye(3)  # 선속도는 그대로
    T[3:, 3:] = T_omega    # 각속도 변환
    
    J_analytical = T @ J_geometric
    
    return J_analytical
```

### 계산 최적화

#### 1. 효율적 계산

##### 재귀적 계산
```python
def recursive_jacobian_computation(q, dh_params):
    """
    재귀적 자코비안 계산 (O(n) 복잡도)
    """
    n = len(q)
    J = np.zeros((6, n))
    
    # 전방향 재귀: 변환 행렬들 계산
    T = [np.eye(4)]
    for i in range(n):
        Ti = dh_transform(dh_params[i], q[i])
        T.append(T[-1] @ Ti)
    
    # 엔드 이펙터 위치
    pe = T[-1][:3, 3]
    
    # 각 관절에 대한 자코비안 열 계산
    for i in range(n):
        # 관절 i의 축과 위치
        zi = T[i][:3, 2]
        pi = T[i][:3, 3]
        
        # 자코비안 i번째 열
        if dh_params[i]['type'] == 'revolute':
            J[:3, i] = np.cross(zi, pe - pi)
            J[3:, i] = zi
        else:  # prismatic
            J[:3, i] = zi
            J[3:, i] = 0
    
    return J
```

#### 2. 수치적 안정성

##### 조건수 모니터링
```python
def stable_jacobian_inversion(J, condition_threshold=1e6):
    """
    수치적으로 안정한 자코비안 역산
    """
    # SVD 분해
    U, s, Vt = np.linalg.svd(J)
    
    # 조건수 확인
    condition_number = s[0] / s[-1] if s[-1] > 0 else np.inf
    
    if condition_number > condition_threshold:
        # 특이값 임계화
        s_filtered = np.where(s > s[0]/condition_threshold, s, 0)
        
        # 필터링된 의사역행렬
        s_inv = np.where(s_filtered > 0, 1/s_filtered, 0)
        J_pinv = Vt.T @ np.diag(s_inv) @ U.T
        
        return J_pinv, True  # 필터링됨
    else:
        # 일반 의사역행렬
        J_pinv = Vt.T @ np.diag(1/s) @ U.T
        return J_pinv, False  # 필터링 안됨
```

### 실시간 응용

#### 1. 실시간 자코비안 계산

##### 하드웨어 최적화
```python
class RealTimeJacobianComputer:
    def __init__(self, robot_model):
        self.robot = robot_model
        self.prev_q = None
        self.prev_J = None
        self.update_threshold = 0.01  # rad
    
    def compute(self, current_q):
        """
        실시간 자코비안 계산
        """
        # 이전 계산 결과 재사용 검사
        if (self.prev_q is not None and 
            np.linalg.norm(current_q - self.prev_q) < self.update_threshold):
            return self.prev_J
        
        # 새로 계산
        J = self.fast_jacobian_computation(current_q)
        
        # 캐시 업데이트
        self.prev_q = current_q.copy()
        self.prev_J = J.copy()
        
        return J
```

## 6. 궤적 최적화 (Trajectory Optimization)

### 정의

궤적 최적화(Trajectory Optimization)는 로봇이 초기 상태에서 목표 상태까지 이동하는 과정에서 특정 성능 지표를 최적화하는 시간에 따른 상태와 제어 입력의 최적 궤적을 찾는 기법입니다.

### 수학적 정의

#### 일반적 형태
```
minimize: J = ∫₀ᵀ L(x(t), u(t), t) dt + Φ(x(T))

subject to: ẋ(t) = f(x(t), u(t), t)
           x(0) = x₀
           x(T) = xf (또는 자유)
           g(x(t), u(t), t) ≤ 0
           h(x(t), u(t), t) = 0

여기서:
- x(t): 시간 t에서의 상태 벡터
- u(t): 시간 t에서의 제어 입력
- L(·): 순간 비용 함수
- Φ(·): 종료 비용 함수
- f(·): 시스템 동역학
- g(·), h(·): 부등식/등식 제약
```

#### 이산화된 형태
```
minimize: J = Σₖ₌₀ᴺ⁻¹ L(xₖ, uₖ, k·Δt) + Φ(xₙ)

subject to: xₖ₊₁ = f_d(xₖ, uₖ, k·Δt)
           x₀ = x_initial
           xₙ ∈ X_final
           gₖ(xₖ, uₖ) ≤ 0, k = 0,1,...,N-1
           hₖ(xₖ, uₖ) = 0, k = 0,1,...,N-1
```

### 최적화 기법 분류

#### 1. 직접 방법 (Direct Methods)

##### 단일 사격법 (Single Shooting)
```python
def single_shooting_optimization(initial_state, final_state, horizon, dynamics):
    """
    단일 사격법을 이용한 궤적 최적화
    """
    # 제어 입력만을 최적화 변수로 사용
    def objective(u_flat):
        u_sequence = u_flat.reshape((horizon, control_dim))
        
        # 시뮬레이션 실행
        states = [initial_state]
        cost = 0
        
        for k in range(horizon):
            # 다음 상태 계산
            x_next = dynamics(states[-1], u_sequence[k], k*dt)
            states.append(x_next)
            
            # 순간 비용 누적
            cost += stage_cost(states[-2], u_sequence[k], k*dt)
        
        # 종료 비용 추가
        cost += terminal_cost(states[-1], final_state)
        
        return cost
    
    def constraints(u_flat):
        u_sequence = u_flat.reshape((horizon, control_dim))
        states = simulate_trajectory(initial_state, u_sequence, dynamics)
        
        constraints_violation = []
        
        for k in range(horizon + 1):
            # 상태 제약
            state_constraints = evaluate_state_constraints(states[k], k*dt)
            constraints_violation.extend(state_constraints)
            
            # 제어 제약 (마지막 스텝 제외)
            if k < horizon:
                control_constraints = evaluate_control_constraints(u_sequence[k], k*dt)
                constraints_violation.extend(control_constraints)
        
        return np.array(constraints_violation)
    
    # 최적화 실행
    initial_guess = np.zeros(horizon * control_dim)
    
    result = minimize(
        objective,
        initial_guess,
        method='SLSQP',
        constraints={'type': 'ineq', 'fun': lambda u: -constraints(u)},
        options={'maxiter': 1000}
    )
    
    return result
```

##### 다중 사격법 (Multiple Shooting)
```python
def multiple_shooting_optimization(initial_state, final_state, horizon, dynamics):
    """
    다중 사격법을 이용한 궤적 최적화
    """
    # 상태와 제어를 모두 최적화 변수로 사용
    def objective_and_constraints(z):
        states, controls = unpack_decision_variables(z, horizon)
        
        objective = 0
        defect_constraints = []
        
        for k in range(horizon):
            # 순간 비용
            objective += stage_cost(states[k], controls[k], k*dt)
            
            # 동역학 제약 (defect constraints)
            x_next_predicted = dynamics(states[k], controls[k], k*dt)
            defect = states[k+1] - x_next_predicted
            defect_constraints.extend(defect)
        
        # 종료 비용
        objective += terminal_cost(states[-1], final_state)
        
        return objective, np.array(defect_constraints)
    
    # 경계 조건 제약
    def boundary_constraints(z):
        states, controls = unpack_decision_variables(z, horizon)
        
        # 초기 조건
        initial_constraint = states[0] - initial_state
        
        return initial_constraint
    
    # 초기 추정
    initial_guess = generate_initial_trajectory_guess(initial_state, final_state, horizon)
    
    # 최적화 실행
    result = minimize(
        lambda z: objective_and_constraints(z)[0],
        initial_guess,
        method='SLSQP',
        constraints=[
            {'type': 'eq', 'fun': lambda z: objective_and_constraints(z)[1]},  # 동역학 제약
            {'type': 'eq', 'fun': boundary_constraints}  # 경계 조건
        ]
    )
    
    return result
```


##### 콜로케이션 방법 (Collocation Methods)
```python
def collocation_optimization(initial_state, final_state, N_segments, dynamics):
    """
    콜로케이션 방법을 이용한 궤적 최적화
    """
    # 르장드르-가우스-로바토 점들 사용
    tau, weights = legendre_gauss_lobatto_points(degree=3)
    
    def setup_collocation_constraints():
        constraints = []
        
        for seg in range(N_segments):
            # 각 세그먼트의 시작과 끝
            t_start = seg * segment_duration
            t_end = (seg + 1) * segment_duration
            
            # 콜로케이션 점들에서의 동역학 제약
            for i, tau_i in enumerate(tau[1:-1]):  # 내부 점들만
                t_col = t_start + tau_i * segment_duration
                
                # 상태와 제어를 보간
                x_col = interpolate_state(seg, tau_i)
                u_col = interpolate_control(seg, tau_i)
                
                # 상태 도함수 계산 (라그랑주 보간 미분)
                x_dot_col = compute_state_derivative(seg, tau_i)
                
                # 동역학 제약
                f_col = dynamics(x_col, u_col, t_col)
                defect = x_dot_col - f_col
                
                constraints.extend(defect)
        
        return np.array(constraints)
    
    # 목적 함수 (가우스 적분)
    def objective(decision_vars):
        cost = 0
        
        for seg in range(N_segments):
            for i, (tau_i, w_i) in enumerate(zip(tau, weights)):
                t_col = seg * segment_duration + tau_i * segment_duration
                x_col = interpolate_state(seg, tau_i)
                u_col = interpolate_control(seg, tau_i)
                
                stage_cost_val = stage_cost(x_col, u_col, t_col)
                cost += w_i * segment_duration * stage_cost_val
        
        # 종료 비용
        final_state = get_final_state()
        cost += terminal_cost(final_state, final_state)
        
        return cost
    
    # 최적화 실행
    return minimize(
        objective,
        initial_guess,
        constraints={'type': 'eq', 'fun': setup_collocation_constraints}
    )
```

#### 2. 간접 방법 (Indirect Methods)

##### 필요조건 기반 해법
```python
def indirect_optimization_pontryagin(initial_state, final_state, dynamics, hamiltonian):
    """
    폰트라긴 최소 원리를 이용한 간접 최적화
    """
    def two_point_bvp_residual(z):
        """
        2점 경계값 문제의 잔차
        """
        # z = [x(0), λ(0), T]
        N_states = len(initial_state)
        x0 = z[:N_states]
        lambda0 = z[N_states:2*N_states]
        T = z[-1]
        
        # 상태와 공상태 방정식 적분
        def augmented_dynamics(t, y):
            x = y[:N_states]
            lam = y[N_states:]
            
            # 최적 제어 계산 (해밀토니안 최소화)
            u_opt = compute_optimal_control(x, lam, t)
            
            # 상태 방정식
            x_dot = dynamics(x, u_opt, t)
            
            # 공상태 방정식 (해밀토니안의 상태에 대한 음의 편미분)
            lambda_dot = -compute_hamiltonian_state_gradient(x, lam, u_opt, t)
            
            return np.concatenate([x_dot, lambda_dot])
        
        # 적분 실행
        sol = solve_ivp(
            augmented_dynamics,
            [0, T],
            np.concatenate([x0, lambda0]),
            dense_output=True
        )
        
        # 종료 조건
        x_final = sol.y[:N_states, -1]
        lambda_final = sol.y[N_states:, -1]
        
        # 경계 조건 잔차
        residual = []
        
        # 초기 상태 조건
        residual.extend(x0 - initial_state)
        
        # 종료 상태 조건
        residual.extend(x_final - final_state)
        
        # 횡단 조건 (종료 시간이 자유인 경우)
        H_final = hamiltonian(x_final, lambda_final, 
                             compute_optimal_control(x_final, lambda_final, T), T)
        residual.append(H_final)  # H(T) = 0
        
        return np.array(residual)
    
    # 초기 추정
    initial_guess = np.concatenate([
        initial_state,
        np.ones_like(initial_state),  # 공상태 초기 추정
        [1.0]  # 종료 시간 추정
    ])
    
    # 뉴턴-랩슨으로 해결
    solution = fsolve(two_point_bvp_residual, initial_guess)
    
    return solution
```

#### 3. 혼합 방법 (Hybrid Methods)

##### 직접-간접 방법
```python
def hybrid_direct_indirect_optimization(problem_setup):
    """
    직접 방법으로 초기해를 구한 후 간접 방법으로 정제
    """
    # 1단계: 직접 방법으로 대략적 해 구하기
    print("Phase 1: Direct method for initial solution...")
    direct_result = multiple_shooting_optimization(**problem_setup)
    
    # 2단계: 직접 방법 결과를 간접 방법의 초기 추정으로 사용
    print("Phase 2: Indirect method for refinement...")
    
    # 공상태 초기 추정 (KKT 조건으로부터)
    lambda_initial = estimate_costate_from_direct_solution(direct_result)
    
    # 간접 방법 실행
    indirect_result = indirect_optimization_pontryagin(
        initial_state=problem_setup['initial_state'],
        final_state=problem_setup['final_state'],
        dynamics=problem_setup['dynamics'],
        hamiltonian=problem_setup['hamiltonian']
    )
    
    return indirect_result
```

### 휴머노이드 특수 응용

#### 1. 보행 궤적 최적화

##### 주기적 보행 최적화
```python
def periodic_walking_optimization(step_length, step_time, robot_model):
    """
    주기적 보행을 위한 궤적 최적화
    """
    def objective(decision_vars):
        joint_trajectories, com_trajectory, foot_trajectories = unpack_variables(decision_vars)
        
        cost = 0
        
        # 에너지 최소화
        for k in range(N_knots-1):
            joint_velocities = (joint_trajectories[k+1] - joint_trajectories[k]) / dt
            joint_accelerations = compute_joint_accelerations(joint_trajectories, k)
            
            # 토크 계산
            torques = compute_inverse_dynamics(
                joint_trajectories[k], joint_velocities, joint_accelerations
            )
            
            # 에너지 비용
            cost += dt * np.sum(torques**2)
        
        # 부드러움 비용
        smoothness_cost = compute_trajectory_smoothness(joint_trajectories)
        cost += 10.0 * smoothness_cost
        
        # ZMP 안정성 비용
        zmp_cost = compute_zmp_stability_cost(joint_trajectories, com_trajectory)
        cost += 100.0 * zmp_cost
        
        return cost
    
    def constraints(decision_vars):
        joint_trajectories, com_trajectory, foot_trajectories = unpack_variables(decision_vars)
        
        violations = []
        
        for k in range(N_knots):
            # 기구학 일관성
            computed_com = compute_com_from_joints(joint_trajectories[k])
            com_error = com_trajectory[k] - computed_com
            violations.extend(com_error)
            
            # ZMP 제약
            zmp = compute_zmp(joint_trajectories[k])
            support_polygon = get_support_polygon(foot_trajectories, k)
            
            if not point_in_polygon(zmp, support_polygon):
                violations.append(distance_to_polygon(zmp, support_polygon))
        
        # 주기성 제약
        periodicity_error = joint_trajectories[-1] - joint_trajectories[0]
        violations.extend(periodicity_error)
        
        return np.array(violations)
    
    # 최적화 실행
    result = minimize(
        objective,
        initial_guess,
        method='SLSQP',
        constraints={'type': 'ineq', 'fun': lambda x: -constraints(x)},
        options={'maxiter': 500, 'ftol': 1e-6}
    )
    
    return result
```

##### 지형 적응 보행
```python
def terrain_adaptive_walking_optimization(terrain_map, robot_model):
    """
    지형에 적응하는 보행 궤적 최적화
    """
    def terrain_constraint(decision_vars, k):
        """
        지형 제약 조건
        """
        foot_positions = extract_foot_positions(decision_vars, k)
        violations = []
        
        for foot_pos in foot_positions:
            # 지면 높이 계산
            ground_height = terrain_map.get_height(foot_pos[:2])
            
            # 발이 지면 위에 있어야 함
            clearance = foot_pos[2] - ground_height
            if clearance < min_foot_clearance:
                violations.append(min_foot_clearance - clearance)
        
        return violations
    
    def stability_on_terrain(decision_vars):
        """
        불규칙 지형에서의 안정성 비용
        """
        cost = 0
        
        for k in range(N_knots):
            # 현재 지지 발의 위치
            support_feet = get_support_feet(decision_vars, k)
            
            # 각 지지 발에서의 지면 경사
            for foot in support_feet:
                foot_pos = foot['position']
                ground_normal = terrain_map.get_normal(foot_pos[:2])
                
                # 지면 경사에 따른 안정성 비용
                slope_angle = np.arccos(np.dot(ground_normal, [0, 0, 1]))
                cost += slope_penalty_weight * slope_angle**2
        
        return cost
    
    # 지형 제약을 포함한 최적화
    enhanced_constraints = lambda x: np.concatenate([
        base_constraints(x),
        np.concatenate([terrain_constraint(x, k) for k in range(N_knots)])
    ])
    
    enhanced_objective = lambda x: (
        base_objective(x) + stability_on_terrain(x)
    )
    
    result = minimize(
        enhanced_objective,
        base_result.x,
        constraints={'type': 'ineq', 'fun': lambda x: -enhanced_constraints(x)}
    )
    
    return result
```

#### 2. 전신 동작 최적화

##### 복합 태스크 최적화
```python
def whole_body_task_optimization(tasks, robot_model, time_horizon):
    """
    여러 태스크를 동시에 수행하는 전신 동작 최적화
    """
    def multi_task_objective(decision_vars):
        joint_trajectories = reshape_decision_vars(decision_vars)
        total_cost = 0
        
        for task in tasks:
            task_cost = 0
            
            for k in range(N_knots):
                # 태스크별 성능 평가
                if task.type == 'reaching':
                    end_effector_pos = compute_end_effector_position(
                        joint_trajectories[k], task.chain
                    )
                    error = np.linalg.norm(end_effector_pos - task.target_position[k])
                    task_cost += task.weight * error**2
                
                elif task.type == 'balance':
                    com_pos = compute_com_position(joint_trajectories[k])
                    zmp = compute_zmp(joint_trajectories[k])
                    
                    # ZMP가 지지 영역 내에 있는지 확인
                    support_polygon = task.support_polygon[k]
                    if not point_in_polygon(zmp, support_polygon):
                        dist = distance_to_polygon(zmp, support_polygon)
                        task_cost += task.weight * 1000 * dist**2
                
                elif task.type == 'posture':
                    posture_error = joint_trajectories[k] - task.reference_posture[k]
                    task_cost += task.weight * np.sum(posture_error**2)
            
            total_cost += task_cost
        
        # 부드러움 정규화
        smoothness_cost = 0
        for k in range(N_knots-1):
            joint_vel = (joint_trajectories[k+1] - joint_trajectories[k]) / dt
            smoothness_cost += np.sum(joint_vel**2)
        
        total_cost += smoothness_weight * smoothness_cost
        
        return total_cost
    
    # 최적화 실행
    initial_guess = generate_multi_task_initial_guess(tasks, robot_model)
    
    result = minimize(
        multi_task_objective,
        initial_guess,
        method='SLSQP',
        constraints={'type': 'eq', 'fun': hierarchical_task_constraints},
        options={'maxiter': 1000}
    )
    
    return result
```

### 실시간 궤적 최적화

#### 1. Model Predictive Control (MPC)

##### 순환 최적화
```python
class RealTimeMPC:
    def __init__(self, robot_model, prediction_horizon, control_horizon):
        self.robot = robot_model
        self.N_pred = prediction_horizon
        self.N_ctrl = control_horizon
        self.dt = 0.01
        
    def solve_mpc(self, current_state, reference_trajectory):
        """
        MPC 최적화 문제 해결
        """
        def mpc_objective(u_sequence):
            u_seq = u_sequence.reshape((self.N_ctrl, self.robot.n_controls))
            
            # 상태 예측
            predicted_states = self.predict_states(current_state, u_seq)
            
            cost = 0
            
            # 추적 오차 비용
            for k in range(self.N_pred):
                if k < len(reference_trajectory):
                    tracking_error = predicted_states[k] - reference_trajectory[k]
                    cost += np.sum(Q @ tracking_error**2)
                
                # 제어 비용
                if k < self.N_ctrl:
                    cost += np.sum(R @ u_seq[k]**2)
            
            return cost
        
        # 실시간 최적화 (제한된 반복)
        result = minimize(
            mpc_objective,
            initial_guess,
            method='SQP',
            constraints={'type': 'ineq', 'fun': lambda u: -mpc_constraints(u)},
            options={'maxiter': 50}  # 실시간 제약
        )
        
        # 첫 번째 제어 입력 반환
        optimal_controls = result.x.reshape((self.N_ctrl, self.robot.n_controls))
        return optimal_controls[0]
```

#### 2. 적응형 궤적 최적화

##### 온라인 재계획
```python
class AdaptiveTrajectoryPlanner:
    def __init__(self, robot_model):
        self.robot = robot_model
        self.current_plan = None
        self.replanning_threshold = 0.1
        
    def update_trajectory(self, current_state, current_target, disturbances):
        """
        상황 변화에 따른 궤적 온라인 업데이트
        """
        # 현재 계획과의 편차 확인
        if self.current_plan is not None:
            deviation = self.compute_plan_deviation(current_state)
            
            if deviation > self.replanning_threshold:
                return self.replan_trajectory(current_state, current_target)
        
        # 외란 감지 및 대응
        if self.detect_significant_disturbance(disturbances):
            return self.robust_replan(current_state, current_target, disturbances)
        
        # 목표 변경 대응
        if self.target_changed(current_target):
            return self.replan_trajectory(current_state, current_target)
        
        # 현재 계획 유지
        return self.get_current_plan_segment(current_state)
    
    def robust_replan(self, current_state, target_state, disturbances):
        """
        외란을 고려한 강건한 재계획
        """
        # 외란 모델 업데이트
        disturbance_model = self.update_disturbance_model(disturbances)
        
        # 강건한 목적함수 (최악의 경우 고려)
        def robust_objective(decision_vars):
            nominal_cost = self.compute_nominal_cost(decision_vars)
            worst_case_cost = self.compute_worst_case_cost(decision_vars, disturbance_model)
            
            return nominal_cost + robustness_weight * worst_case_cost
        
        # 강건한 최적화 실행
        result = minimize(
            robust_objective,
            self.get_warm_start_guess(),
            constraints={'type': 'ineq', 'fun': robust_constraints},
            options={'maxiter': 100}
        )
        
        return result
```

### 고급 최적화 기법

#### 1. 다목적 최적화

##### 파레토 최적 해법
```python
def multi_objective_trajectory_optimization(objectives, weights=None):
    """
    다목적 궤적 최적화
    """
    if weights is None:
        # 파레토 프론트 탐색
        return compute_pareto_front(objectives)
    else:
        # 가중합 방법
        return weighted_sum_optimization(objectives, weights)

def compute_pareto_front(objectives):
    """
    파레토 최적 해 집합 계산
    """
    pareto_solutions = []
    
    # 다양한 가중치 조합으로 최적화
    for weight_combination in generate_weight_combinations(len(objectives)):
        def weighted_objective(decision_vars):
            costs = [obj(decision_vars) for obj in objectives]
            return sum(w * c for w, c in zip(weight_combination, costs))
        
        # 개별 최적화
        result = minimize(weighted_objective, initial_guess)
        
        if result.success:
            # 파레토 최적성 확인
            objective_values = [obj(result.x) for obj in objectives]
            
            if is_pareto_optimal(objective_values, pareto_solutions):
                pareto_solutions.append({
                    'solution': result.x,
                    'objectives': objective_values,
                    'weights': weight_combination
                })
    
    return pareto_solutions
```

#### 2. 확률적 최적화

##### 강건한 최적화
```python
def robust_trajectory_optimization(nominal_problem, uncertainty_model):
    """
    불확실성을 고려한 강건한 궤적 최적화
    """
    def robust_objective(decision_vars):
        # 몬테 카를로 샘플링으로 기댓값 계산
        costs = []
        
        for _ in range(n_samples):
            # 불확실성 샘플링
            uncertainty_sample = uncertainty_model.sample()
            
            # 샘플에 대한 비용 계산
            perturbed_cost = compute_cost_with_uncertainty(decision_vars, uncertainty_sample)
            costs.append(perturbed_cost)
        
        # 평균 + 분산 페널티 (mean-variance 최적화)
        mean_cost = np.mean(costs)
        var_cost = np.var(costs)
        
        return mean_cost + risk_aversion_parameter * var_cost
    
    def chance_constraints(decision_vars):
        """
        확률적 제약 (chance constraints)
        """
        violation_probabilities = []
        
        for constraint_func in constraint_functions:
            violations = 0
            
            for _ in range(n_samples):
                uncertainty_sample = uncertainty_model.sample()
                constraint_value = constraint_func(decision_vars, uncertainty_sample)
                
                if constraint_value > 0:  # 제약 위반
                    violations += 1
            
            violation_prob = violations / n_samples
            
            # 허용 위반 확률 이하여야 함
            violation_probabilities.append(violation_prob - allowable_violation_probability)
        
        return np.array(violation_probabilities)
    
    # 강건한 최적화 실행
    result = minimize(
        robust_objective,
        initial_guess,
        constraints={'type': 'ineq', 'fun': lambda x: -chance_constraints(x)}
    )
    
    return result
```

## 7. 전신 제어 기법 (Whole-body Control)

### 정의

전신 제어 기법(Whole-body Control)은 휴머노이드 로봇의 모든 관절을 통합적으로 제어하여 여러 태스크를 동시에 수행하면서도 물리적 제약과 안정성을 보장하는 고급 제어 방법입니다.

### 기본 개념

#### 다중 태스크 제어 문제
```
주어진 조건:
- n개의 관절 (q ∈ ℝⁿ)
- m개의 태스크 (각각 차원 kᵢ)
- 물리적 제약조건

목표:
모든 태스크를 동시에 만족하면서
물리적 실현 가능성 보장
```

#### 수학적 표현
```
태스크 i의 목적: ẋᵢ = Jᵢ(q) × q̇ = ẋᵢᵈ

전체 문제:
minimize: Σᵢ wᵢ ||Jᵢ(q)q̇ - ẋᵢᵈ||²

subject to: 
- 관절 한계: qₘᵢₙ ≤ q ≤ qₘₐₓ
- 속도 한계: q̇ₘᵢₙ ≤ q̇ ≤ q̇ₘₐₓ  
- 동역학 제약: M(q)q̈ + C(q,q̇) + G(q) = τ
- 접촉 제약: 발이 지면에 고정
- 안정성 제약: ZMP ∈ Support Polygon
```

### 계층적 제어 (Hierarchical Control)

#### 1. 우선순위 기반 제어

##### 기본 원리
```python
def hierarchical_whole_body_control(tasks, current_q, current_q_dot):
    """
    계층적 우선순위 기반 전신 제어
    """
    q_dot_command = np.zeros(len(current_q))
    N = np.eye(len(current_q))  # 널 공간 투영자
    
    # 우선순위 순서로 태스크 처리
    for priority_level in sorted(set(task.priority for task in tasks)):
        level_tasks = [task for task in tasks if task.priority == priority_level]
        
        # 현재 우선순위 레벨의 복합 자코비안 구성
        J_level = []
        error_level = []
        
        for task in level_tasks:
            J_task = compute_task_jacobian(current_q, task)
            error_task = compute_task_error(current_q, current_q_dot, task)
            
            J_level.append(J_task)
            error_level.append(error_task)
        
        if J_level:
            J_combined = np.vstack(J_level)
            error_combined = np.concatenate(error_level)
            
            # 널 공간으로 투영된 자코비안
            J_projected = J_combined @ N
            
            # 태스크 해결 (의사역행렬 사용)
            if np.linalg.matrix_rank(J_projected) > 0:
                J_proj_pinv = np.linalg.pinv(J_projected)
                q_dot_task = J_proj_pinv @ error_combined
                
                # 전체 해에 추가
                q_dot_command += N @ q_dot_task
                
                # 널 공간 업데이트 (현재 레벨 제거)
                N = N @ (np.eye(len(current_q)) - J_proj_pinv @ J_projected)
    
    return q_dot_command

def compute_task_jacobian(q, task):
    """
    태스크별 자코비안 계산
    """
    if task.type == 'end_effector_position':
        return compute_position_jacobian(q, task.end_effector_chain)
    
    elif task.type == 'end_effector_orientation':
        return compute_orientation_jacobian(q, task.end_effector_chain)
    
    elif task.type == 'center_of_mass':
        return compute_com_jacobian(q)
    
    elif task.type == 'joint_posture':
        return np.eye(len(q))[task.joint_indices, :]
    
    elif task.type == 'momentum':
        return compute_momentum_jacobian(q)
    
    else:
        raise ValueError(f"Unknown task type: {task.type}")

def compute_task_error(q, q_dot, task):
    """
    태스크 오차 계산
    """
    if task.type == 'end_effector_position':
        current_pos = forward_kinematics_position(q, task.end_effector_chain)
        desired_pos = task.desired_position
        desired_vel = task.desired_velocity
        
        # PD 제어 형태의 오차
        pos_error = desired_pos - current_pos
        vel_error = desired_vel - compute_current_ee_velocity(q, q_dot, task)
        
        return task.kp * pos_error + task.kd * vel_error
    
    elif task.type == 'center_of_mass':
        current_com = compute_center_of_mass(q)
        desired_com = task.desired_com
        
        com_error = desired_com - current_com
        return task.kp * com_error
    
    return np.zeros(task.dimension)
```

##### 엄격한 계층 구조
```python
class StrictHierarchicalController:
    def __init__(self, robot_model):
        self.robot = robot_model
        self.task_hierarchy = {}
        
    def add_task(self, task, priority_level):
        """태스크를 특정 우선순위 레벨에 추가"""
        if priority_level not in self.task_hierarchy:
            self.task_hierarchy[priority_level] = []
        self.task_hierarchy[priority_level].append(task)
    
    def compute_control(self, current_state):
        """엄격한 계층적 제어 계산"""
        q, q_dot = current_state
        q_dot_cmd = np.zeros(len(q))
        
        # 누적 널 공간 투영자
        N_accumulated = np.eye(len(q))
        
        for priority in sorted(self.task_hierarchy.keys()):
            tasks_at_level = self.task_hierarchy[priority]
            
            # 현재 레벨의 모든 태스크 결합
            J_level, error_level = self.combine_tasks_at_level(
                tasks_at_level, q, q_dot
            )
            
            if J_level.size > 0:
                # 상위 우선순위의 널 공간에서 해결
                J_constrained = J_level @ N_accumulated
                
                # 최소 노름 해
                if np.linalg.matrix_rank(J_constrained) > 0:
                    J_pinv = np.linalg.pinv(J_constrained)
                    q_dot_level = J_pinv @ error_level
                    
                    # 실제 관절 속도 추가
                    q_dot_cmd += N_accumulated @ q_dot_level
                    
                    # 널 공간 업데이트
                    N_level = np.eye(len(q)) - J_pinv @ J_constrained
                    N_accumulated = N_accumulated @ N_level
        
        return q_dot_cmd
```
