# íœ´ë¨¸ë…¸ì´ë“œ

> ìƒìœ„: [[ë¶„ì•¼ë³„ ë¡œë´‡]]

## 1. ê°œë… ë° ê°œìš”

### ê¸°ë³¸ ì •ì˜

íœ´ë¨¸ë…¸ì´ë“œ ë¡œë´‡(Humanoid Robot)ì€ ì¸ê°„ê³¼ ìœ ì‚¬í•œ í˜•íƒœì™€ ë™ì‘ì„ ê°€ì§€ëŠ” ë¡œë´‡ìœ¼ë¡œ, ë³µì¡í•œ ê¸°êµ¬í•™ì  êµ¬ì¡°ì™€ ë™ì—­í•™ì  íŠ¹ì„±ì„ ê°€ì§„ ê³ ììœ ë„ ì‹œìŠ¤í…œì…ë‹ˆë‹¤. 30ê°œ ì´ìƒì˜ ê´€ì ˆì„ ê°€ì§€ë©°, ì´ì¡± ë³´í–‰ê³¼ ì „ì‹  ì œì–´ë¥¼ í†µí•´ ì¸ê°„ê³¼ ìœ ì‚¬í•œ ì‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### ì£¼ìš” íŠ¹ì§•

#### ê¸°êµ¬í•™ì  íŠ¹ì„±
- **ë†’ì€ ììœ ë„**: 30+ DOF (Degree of Freedom)
- **ë³µì¡í•œ ê¸°êµ¬í•™**: ë‹¤ì¤‘ ì²´ì¸ êµ¬ì¡° (ë¨¸ë¦¬, ëª¸í†µ, ì–‘íŒ”, ì–‘ë‹¤ë¦¬)
- **ì¤‘ë³µ ììœ ë„**: ëŒ€ë¶€ë¶„ì˜ ì‘ì—…ì— í•„ìš”í•œ ê²ƒë³´ë‹¤ ë§ì€ ê´€ì ˆ
- **ì¸ê°„ ìœ ì‚¬ êµ¬ì¡°**: ì–´ê¹¨, íŒ”ê¿ˆì¹˜, ì†ëª©, ê³ ê´€ì ˆ, ë¬´ë¦, ë°œëª©

#### ë™ì—­í•™ì  íŠ¹ì„±
- **ë¹„ì„ í˜• ë™ì—­í•™**: ê³ ì°¨ì›, ë¹„ì„ í˜•, ë¹„ë³¼ë¡ ì‹œìŠ¤í…œ
- **ê²°í•© ë™ì—­í•™**: ê´€ì ˆ ê°„ ìƒí˜¸ì‘ìš©
- **ë™ì  ë¶ˆì•ˆì •ì„±**: ì´ì¡± ë³´í–‰ìœ¼ë¡œ ì¸í•œ ë³¸ì§ˆì  ë¶ˆì•ˆì •ì„±
- **ì¤‘ë ¥ ì˜ì¡´ì„±**: í•­ìƒ ì¤‘ë ¥ì˜ ì˜í–¥ì„ ë°›ëŠ” ì‹œìŠ¤í…œ

#### ì œì–´ì  íŠ¹ì„±
- **ë‹¤ì¤‘ íƒœìŠ¤í¬**: ê· í˜•, ë³´í–‰, ì¡°ì‘ì„ ë™ì‹œì— ìˆ˜í–‰
- **ê³„ì¸µì  ì œì–´**: ìš°ì„ ìˆœìœ„ ê¸°ë°˜ íƒœìŠ¤í¬ í• ë‹¹
- **ì‹¤ì‹œê°„ ì œì–´**: ìˆ˜ì‹­ Hz~ìˆ˜ kHzì˜ ì œì–´ ì£¼ê¸°
- **ì ì‘ì„±**: í™˜ê²½ ë³€í™”ì™€ ì™¸ë€ì— ëŒ€í•œ ëŒ€ì‘

## 2. í•µì‹¬ ì—°êµ¬ ê¸°ìˆ 

íœ´ë¨¸ë…¸ì´ë“œ ë¡œë´‡ì˜ í•µì‹¬ ì—°êµ¬ ê¸°ìˆ ë“¤ê³¼ ìˆ˜í•™ì  ê¸°ë°˜ì„ ë‹¤ë£¹ë‹ˆë‹¤. ì´ì¡± ë³´í–‰, ì „ì‹  ì œì–´, ê¶¤ì  ìµœì í™” ë“±ì˜ ê¸°ìˆ ì  ë„ì „ê³¼ í•´ê²° ë°©ë²•ì„ í¬í•¨í•©ë‹ˆë‹¤.

### ğŸš¶ ì´ì¡± ë³´í–‰ ì œì–´ ê¸°ìˆ 

#### 1. ZMP (Zero Moment Point)

##### ê°œë…ê³¼ ì •ì˜
- **ì •ì˜**: ìˆ˜í‰ ê´€ì„±ë ¥ê³¼ ì¤‘ë ¥ì˜ í•©ì´ 0ì¸ ì§€ì 
- **ë¬¼ë¦¬ì  ì˜ë¯¸**: ë°œê³¼ ì§€ë©´ ì ‘ì´‰ ì‹œ ìˆ˜í‰ ë°©í–¥ ëª¨ë©˜íŠ¸ê°€ 0ì´ ë˜ëŠ” ì 
- **ì•ˆì •ì„± ê¸°ì¤€**: ZMPê°€ ì§€ì§€ ì˜ì—­(ë°œë°”ë‹¥) ë‚´ë¶€ì— ìˆì„ ë•Œ ì•ˆì •

##### ìˆ˜í•™ì  í‘œí˜„
```
ZMP ì¡°ê±´: Î£(ìˆ˜í‰ ëª¨ë©˜íŠ¸) = 0
- ì¤‘ë ¥ì— ì˜í•œ ëª¨ë©˜íŠ¸ + ê´€ì„±ë ¥ì— ì˜í•œ ëª¨ë©˜íŠ¸ = 0
- ZMP ìœ„ì¹˜ = (Mx_total / Fz_total, My_total / Fz_total)
```

##### ZMP ê¸°ë°˜ ì œì–´
- **ì •ì  ì•ˆì •**: ZMPë¥¼ ì§€ì§€ ì˜ì—­ ì¤‘ì•™ì— ìœ ì§€
- **ë™ì  ì•ˆì •**: ZMP ê¶¤ì ì„ ë¯¸ë¦¬ ê³„íší•˜ì—¬ ì¶”ì¢…
- **ê°€ë³€ ZMP**: í—ˆìš© ì˜ì—­ ë‚´ì—ì„œ ZMPë¥¼ ì›€ì§ì—¬ ì—ë„ˆì§€ íš¨ìœ¨ í–¥ìƒ
- **ZMP ì¶”ì  ì œì–´**: ëª©í‘œ ZMPì™€ ì‹¤ì œ ZMP ì°¨ì´ë¥¼ ë¹„ìš©í•¨ìˆ˜ì— í¬í•¨

##### ì‹¤ì œ ì‘ìš©
- Honda ASIMO: ZMP í”¼ë“œë°± ê¸°ë°˜ ë³´í–‰
- PAL Robotics REEM-C: í¼ì§€ ë¡œì§ PD ì»¨íŠ¸ë¡¤ëŸ¬ë¡œ ZMP ì¶”ì 
- ì§ˆëŸ‰ì¤‘ì‹¬(CoM) ìœ„ì¹˜ ì¡°ì •ìœ¼ë¡œ ZMP ì œì–´

#### 2. ë³´í–‰ ëª¨ë¸

##### Linear Inverted Pendulum Model (LIPM)
- **ê°€ì •**: ë¡œë´‡ì„ ì—­ì§„ì ëª¨ë¸ë¡œ ë‹¨ìˆœí™”
- **ì¥ì **: ìˆ˜í•™ì ìœ¼ë¡œ í•´ì„ ê°€ëŠ¥, ì‹¤ì‹œê°„ ê³„ì‚° ê°€ëŠ¥
- **í•œê³„**: ìƒì²´ ì›€ì§ì„ê³¼ ë‹¤ë¦¬ ì§ˆëŸ‰ ë¬´ì‹œ

##### Cart-Table Model
- **êµ¬ì„±**: ìƒì²´(Cart) + ë‹¤ë¦¬(Table)
- **ìš©ë„**: CoM/ZMP ë³´í–‰ íŒ¨í„´ ë³€í™˜
- **íŠ¹ì„±**: ë³´í­, ë³´í–‰ì‹œê°„, CoM ë†’ì´ ë³€í™” ë¶„ì„

##### 3D LIPM
- **í™•ì¥**: 2ì°¨ì›ì„ 3ì°¨ì›ìœ¼ë¡œ í™•ì¥
- **ê³ ë ¤ì‚¬í•­**: ì¢Œìš° ë°©í–¥ ì•ˆì •ì„± í¬í•¨
- **ë³µì¡ì„±**: ë¹„ì„ í˜•, ë¹„ë³¼ë¡ ìµœì í™” ë¬¸ì œ

#### 3. ë³´í–‰ íŒ¨í„´ ìƒì„±

##### ê¶¤ì  ê³„íš ë°©ë²•
- **íŠ¹ì§•ì  ê¸°ë°˜**: ZMP ê¶¤ì ì„ êµ¬ê°„ë³„ ì„ í˜• ë³´ê°„
- **ìŠ¤í”Œë¼ì¸ ë³´ê°„**: ë¶€ë“œëŸ¬ìš´ ê¶¤ì  ìƒì„±
- **ìµœì í™” ê¸°ë°˜**: ì—ë„ˆì§€ ìµœì†Œí™” ëª©í‘œí•¨ìˆ˜

##### ë³´í–‰ ë‹¨ê³„
1. **ì´ˆê¸° ë‹¨ê³„**: ì •ì§€ ìƒíƒœì—ì„œ ë³´í–‰ ì‹œì‘
2. **ì£¼ê¸° ë‹¨ê³„**: ì•ˆì •ì ì¸ ë°˜ë³µ ë³´í–‰
3. **ì¢…ë£Œ ë‹¨ê³„**: ë³´í–‰ì—ì„œ ì •ì§€ë¡œ ì „í™˜

### ğŸ¯ ê¸°êµ¬í•™ ë° ì—­í•™

#### 1. ìˆœê¸°êµ¬í•™ (Forward Kinematics)

##### ì •ì˜ì™€ ëª©ì 
- **ë³€í™˜**: ê´€ì ˆ ê°ë„ â†’ ì—”ë“œ ì´í™í„° ìœ„ì¹˜/ë°©í–¥
- **ìˆ˜ì‹**: x = f(q), ì—¬ê¸°ì„œ qëŠ” ê´€ì ˆ ê°ë„ ë²¡í„°
- **ë°©ë²•**: DH Parameter ê¸°ë°˜ ë³€í™˜ í–‰ë ¬

##### DH Parameter
```
ë³€í™˜ í–‰ë ¬ = Rot(z,Î¸) Ã— Trans(z,d) Ã— Trans(x,a) Ã— Rot(x,Î±)
- Î¸: ê´€ì ˆ ê°ë„
- d: ë§í¬ ì˜¤í”„ì…‹
- a: ë§í¬ ê¸¸ì´  
- Î±: ë§í¬ ë¹„í‹€ë¦¼
```

##### ê³„ì‚° ê³¼ì •
1. ê° ê´€ì ˆë³„ DH Parameter ì„¤ì •
2. ê°œë³„ ë³€í™˜ í–‰ë ¬ ê³„ì‚°
3. ì—°ì‡„ì  í–‰ë ¬ ê³±ì…ˆìœ¼ë¡œ ìµœì¢… ìœ„ì¹˜ ì‚°ì¶œ

#### 2. ì—­ê¸°êµ¬í•™ (Inverse Kinematics)

##### ì •ì˜ì™€ ë„ì „
- **ë³€í™˜**: ì—”ë“œ ì´í™í„° ëª©í‘œ ìœ„ì¹˜ â†’ ê´€ì ˆ ê°ë„
- **ìˆ˜ì‹**: q = fâ»Â¹(x)
- **ì–´ë ¤ì›€**: ë¹„ì„ í˜• ë°©ì •ì‹, ë‹¤ì¤‘í•´ ë˜ëŠ” í•´ê°€ ì—†ëŠ” ê²½ìš°

##### í•´ê²° ë°©ë²•

###### í•´ì„ì  ë°©ë²•
- **ê¸°í•˜í•™ì  ì ‘ê·¼**: ì‚¼ê°ë²•ê³¼ ê¸°í•˜í•™ ì´ìš©
- **ëŒ€ìˆ˜ì  ì ‘ê·¼**: ì—°ë¦½ë°©ì •ì‹ í•´ë²•
- **ì¥ì **: ì •í™•í•œ í•´, ë¹ ë¥¸ ê³„ì‚°
- **ë‹¨ì **: ë³µì¡í•œ ë¡œë´‡ì—ëŠ” ì ìš© ì–´ë ¤ì›€

###### ìˆ˜ì¹˜ì  ë°©ë²•
- **ë‰´í„´-ë©ìŠ¨ ë°©ë²•**: ë°˜ë³µì  ê·¼ì‚¬í•´ë²•
- **ê²½ì‚¬í•˜ê°•ë²•**: ì˜¤ì°¨ í•¨ìˆ˜ ìµœì†Œí™”
- **ì˜ì‚¬ì—­í–‰ë ¬**: ìì½”ë¹„ì•ˆ ê¸°ë°˜ ê·¼ì‚¬í•´

##### íŠ¹ìˆ˜ ìƒí™© ì²˜ë¦¬
- **ì‘ì—…ê³µê°„ ë²—ì–´ë‚¨**: ë„ë‹¬ ë¶ˆê°€ëŠ¥í•œ ëª©í‘œì 
- **íŠ¹ì´ì **: ìì½”ë¹„ì•ˆ í–‰ë ¬ì‹ì´ 0ì¸ ì§€ì 
- **ë‹¤ì¤‘í•´**: ì—¬ëŸ¬ ê°€ëŠ¥í•œ ê´€ì ˆ êµ¬ì„±

#### 3. ìì½”ë¹„ì•ˆ (Jacobian)

##### ì •ì˜ì™€ ì˜ë¯¸
- **ìˆ˜í•™ì  ì •ì˜**: ë‹¤ë³€ìˆ˜ í•¨ìˆ˜ì˜ 1ì°¨ í¸ë¯¸ë¶„ í–‰ë ¬
- **ë¡œë´‡ê³µí•™**: ê´€ì ˆ ì†ë„ì™€ ì—”ë“œ ì´í™í„° ì†ë„ ê´€ê³„
- **ì„ í˜•í™”**: ë¹„ì„ í˜• ë³€í™˜ì„ êµ­ì†Œì ìœ¼ë¡œ ì„ í˜• ê·¼ì‚¬

##### ìì½”ë¹„ì•ˆ í–‰ë ¬
```
J = âˆ‚f/âˆ‚q = [âˆ‚x/âˆ‚qâ‚  âˆ‚x/âˆ‚qâ‚‚  ...  âˆ‚x/âˆ‚qâ‚™]
ì†ë„ ê´€ê³„: áº‹ = J(q) Ã— qÌ‡
```

##### ê¸°í•˜í•™ì  ìì½”ë¹„ì•ˆ
- **ì„ ì†ë„**: ê° ê´€ì ˆì´ ì—”ë“œ ì´í™í„° ì„ ì†ë„ì— ê¸°ì—¬
- **ê°ì†ë„**: ê° ê´€ì ˆì´ ì—”ë“œ ì´í™í„° ê°ì†ë„ì— ê¸°ì—¬
- **êµ¬ì„±**: [ì„ ì†ë„ ìì½”ë¹„ì•ˆ; ê°ì†ë„ ìì½”ë¹„ì•ˆ]

##### íŠ¹ì´ì  (Singularity)
- **ë°œìƒ**: det(J) = 0ì¼ ë•Œ
- **ë¬¸ì œ**: ì—­ìì½”ë¹„ì•ˆ ì¡´ì¬í•˜ì§€ ì•ŠìŒ
- **í•´ê²°**: íŠ¹ì´ì  íšŒí”¼ ì•Œê³ ë¦¬ì¦˜, ê°ì‡  ìµœì†Œì œê³±ë²•

##### ì‘ìš©
- **ì†ë„ ì œì–´**: ëª©í‘œ ì†ë„ë¡œ ê´€ì ˆ ì†ë„ ê³„ì‚°
- **ì—­ê¸°êµ¬í•™**: ë°˜ë³µì  í•´ë²•ì— í™œìš©
- **í˜ ì œì–´**: í˜ê³¼ í† í¬ ê´€ê³„ ë³€í™˜

### ğŸ”„ ì „ì‹  ì œì–´ ê¸°ìˆ 

#### 1. ë‹¤ì¤‘ íƒœìŠ¤í¬ ì œì–´

##### ê³„ì¸µì  ì œì–´ (Hierarchical Control)
- **ìš°ì„ ìˆœìœ„**: ê· í˜• > ë³´í–‰ > ìƒì²´ ì‘ì—…
- **Null Space**: ê³ ìš°ì„ ìˆœìœ„ íƒœìŠ¤í¬ë¥¼ ë°©í•´í•˜ì§€ ì•ŠëŠ” ë²”ìœ„ì—ì„œ ì €ìš°ì„ ìˆœìœ„ ìˆ˜í–‰
- **ìˆ˜ì‹**: qÌ‡ = Jâ‚âºxâ‚ + (I - Jâ‚âºJâ‚)Jâ‚‚âºxâ‚‚

##### ê°€ì¤‘ ì œì–´ (Weighted Control)  
- **ê°€ì¤‘í•©**: ì—¬ëŸ¬ íƒœìŠ¤í¬ë¥¼ ê°€ì¤‘ì¹˜ë¡œ ê²°í•©
- **ì‹¤ì‹œê°„ ì¡°ì •**: ìƒí™©ì— ë”°ë¼ ê°€ì¤‘ì¹˜ ë™ì  ë³€ê²½
- **ìµœì í™”**: 2ì°¨ ê³„íšë²•ìœ¼ë¡œ ìµœì í•´ ê³„ì‚°

#### 2. ì¤‘ë³µ ììœ ë„ (Redundancy) í™œìš©

##### ê°œë…
- **ì •ì˜**: íƒœìŠ¤í¬ ìˆ˜í–‰ì— í•„ìš”í•œ ê²ƒë³´ë‹¤ ë§ì€ ê´€ì ˆ
- **íœ´ë¨¸ë…¸ì´ë“œ**: 30+ DOFë¡œ ë†’ì€ ì¤‘ë³µì„±
- **ì¥ì **: ë‹¤ì–‘í•œ ìì„¸, íŠ¹ì´ì  íšŒí”¼, ì œì•½ ë§Œì¡±

##### ì¤‘ë³µì„± í•´ê²° ë°©ë²•
- **ì˜ì‚¬ì—­í–‰ë ¬**: ìµœì†Œ ë…¸ë¦„ í•´
- **ê°€ì¤‘ ì˜ì‚¬ì—­í–‰ë ¬**: ê´€ì ˆë³„ ì¤‘ìš”ë„ ê³ ë ¤
- **ì ì§„ì  ëª©í‘œ**: ë³´ì¡° ëª©í‘œ í•¨ìˆ˜ ì„¤ì •

#### 3. ì œì•½ ì¡°ê±´ ì²˜ë¦¬

##### ë¬¼ë¦¬ì  ì œì•½
- **ê´€ì ˆ í•œê³„**: ê°ë„, ì†ë„, í† í¬ ì œí•œ
- **ì¶©ëŒ íšŒí”¼**: ìê°€ ì¶©ëŒ ë° í™˜ê²½ ì¶©ëŒ
- **ê· í˜• ìœ ì§€**: ZMP ì œì•½

##### ìˆ˜í•™ì  í‘œí˜„
```
minimize: ||J(q)qÌ‡ - áº‹d||Â²
subject to: qmin â‰¤ q â‰¤ qmax
           qÌ‡min â‰¤ qÌ‡ â‰¤ qÌ‡max
           ZMP âˆˆ Support polygon
```

### ğŸ“Š ê¶¤ì  ìµœì í™”

#### 1. ë¬¸ì œ ì •ì˜

##### ëª©ì  í•¨ìˆ˜
- **ì—ë„ˆì§€ ìµœì†Œí™”**: âˆ«Ï„áµ€Ï„ dt (í† í¬ ì œê³±í•©)
- **ì‹œê°„ ìµœì†Œí™”**: ìµœë‹¨ ì‹œê°„ ê²½ë¡œ
- **ë¶€ë“œëŸ¬ì›€**: âˆ«qÌˆáµ€qÌˆ dt (ê°€ì†ë„ ì œê³±í•©)
- **ì•ˆì •ì„±**: ZMP ë§ˆì§„ ìµœëŒ€í™”

##### ì œì•½ ì¡°ê±´
- **ì´ˆê¸°/ì¢…ë£Œ**: ì‹œì‘ì ê³¼ ëì  ì¡°ê±´
- **ê²½ìœ ì **: ì¤‘ê°„ í†µê³¼ì 
- **ë¬¼ë¦¬ì  í•œê³„**: ê´€ì ˆ, ì†ë„, ê°€ì†ë„ ì œí•œ
- **ì¶©ëŒ íšŒí”¼**: ì¥ì• ë¬¼ ì œì•½

#### 2. ìµœì í™” ê¸°ë²•

##### ì§ì ‘ ìµœì í™”
- **ì½œë¡œì¼€ì´ì…˜**: ì—°ì† ë¬¸ì œë¥¼ ì´ì‚°í™”
- **ë‹¤ì¤‘ ì‚¬ê²©ë²•**: ê²½ê³„ê°’ ë¬¸ì œ í•´ë²•
- **ì˜ì‚¬ ìŠ¤í™íŠ¸ëŸ¼**: ì²´ë¹„ì…°í”„ ë‹¤í•­ì‹ ì´ìš©

##### ê°„ì ‘ ìµœì í™”
- **ë³€ë¶„ë²•**: ì˜¤ì¼ëŸ¬-ë¼ê·¸ë‘ì£¼ ë°©ì •ì‹
- **ìµœì  ì œì–´**: í•´ë°€í„´-ì•¼ì½”ë¹„-ë²¨ë§Œ ë°©ì •ì‹
- **ìˆ˜ì¹˜ í•´ë²•**: ë‹¤ì¤‘ ì  ê²½ê³„ê°’ ë¬¸ì œ

##### ë¹„ì„ í˜• ê³„íšë²•
- **SQP**: Sequential Quadratic Programming
- **ë‚´ì ë²•**: Interior Point Method
- **ìœ ì „ ì•Œê³ ë¦¬ì¦˜**: ì „ì—­ ìµœì í™”

#### 3. ì‹¤ì‹œê°„ ìµœì í™”

##### Model Predictive Control (MPC)
- **ì˜ˆì¸¡ ëª¨ë¸**: ì‹œìŠ¤í…œ ë™ì—­í•™ ëª¨ë¸
- **ìˆœí™˜ ìµœì í™”**: ë§¤ ì œì–´ ì£¼ê¸°ë§ˆë‹¤ ìµœì í™”
- **ì œì•½ ë§Œì¡±**: ì‹¤ì‹œê°„ ì œì•½ ì¡°ê±´ ì²˜ë¦¬

##### ì ì‘í˜• ë™ì‘ ìµœì í™” (AMO)
- **sim-to-real**: ì‹œë®¬ë ˆì´ì…˜ê³¼ ì‹¤ì œ í™˜ê²½ ì—°ê²°
- **ê°•í™”í•™ìŠµ ê²°í•©**: RL + ê¶¤ì  ìµœì í™”
- **ì‹¤ì‹œê°„ ì ì‘**: í™˜ê²½ ë³€í™”ì— ì¦‰ì‹œ ëŒ€ì‘

### ğŸ§  í•™ìŠµ ê¸°ë°˜ ì œì–´

#### 1. ê°•í™”í•™ìŠµ (Reinforcement Learning)

##### ê¸°ë³¸ ê°œë…
- **í™˜ê²½**: ë¡œë´‡ê³¼ ì£¼ë³€ í™˜ê²½
- **ìƒíƒœ**: ê´€ì ˆ ê°ë„, ì†ë„, ìœ„ì¹˜ ë“±
- **í–‰ë™**: ê´€ì ˆ í† í¬ ë˜ëŠ” ëª©í‘œ ìœ„ì¹˜
- **ë³´ìƒ**: íƒœìŠ¤í¬ ì„±ê³µë„, ì—ë„ˆì§€ íš¨ìœ¨ì„± ë“±

##### íœ´ë¨¸ë…¸ì´ë“œ ì ìš©
- **ë³´í–‰ í•™ìŠµ**: ì•ˆì •ì  ì´ì¡± ë³´í–‰ íŒ¨í„´ í•™ìŠµ
- **ê· í˜• ì œì–´**: ì™¸ë€ì— ëŒ€í•œ ë™ì  ê· í˜• ëŒ€ì‘
- **ì „ì‹  í˜‘ì¡°**: ë³µí•© íƒœìŠ¤í¬ ë™ì‹œ ìˆ˜í–‰

##### ì£¼ìš” ì•Œê³ ë¦¬ì¦˜
- **PPO**: Proximal Policy Optimization
- **SAC**: Soft Actor-Critic  
- **TD3**: Twin Delayed Deep Deterministic policy gradient

#### 2. ëª¨ë°©í•™ìŠµ (Imitation Learning)

##### í–‰ë™ ë³µì œ (Behavior Cloning)
- **ë°ì´í„°**: ì „ë¬¸ê°€ ì‹œì—° ë°ì´í„°
- **í•™ìŠµ**: ì§€ë„í•™ìŠµìœ¼ë¡œ ì •ì±… í•™ìŠµ
- **ì¥ì **: ì•ˆì •ì , ë¹ ë¥¸ í•™ìŠµ
- **ë‹¨ì **: ë¶„í¬ ì´ë™ ë¬¸ì œ

##### ëª¨ì…˜ ìº¡ì²˜ í™œìš©
- **ì¸ê°„ ë™ì‘**: ëª¨ì…˜ ìº¡ì²˜ë¡œ ì¸ê°„ ì›€ì§ì„ ê¸°ë¡
- **ë³€í™˜**: ì¸ê°„ ê³¨ê²©ì„ ë¡œë´‡ ê´€ì ˆë¡œ ë§¤í•‘
- **ìµœì í™”**: ë¡œë´‡ ì œì•½ì— ë§ê²Œ ë™ì‘ ì¡°ì •

##### ëŒ€í™”í˜• ëª¨ë°©í•™ìŠµ
- **DAgger**: Dataset Aggregation
- **ì „ë¬¸ê°€ í”¼ë“œë°±**: í•™ìŠµ ì¤‘ ì „ë¬¸ê°€ ê°œì…
- **ì ì§„ì  ê°œì„ **: ë°˜ë³µì  ë°ì´í„° ìˆ˜ì§‘ê³¼ í•™ìŠµ

#### 3. í•˜ì´ë¸Œë¦¬ë“œ ì ‘ê·¼ë²•

##### ëª¨ë¸ ê¸°ë°˜ + í•™ìŠµ ê¸°ë°˜
- **ì´ˆê¸°í™”**: ëª¨ë¸ ê¸°ë°˜ìœ¼ë¡œ ì´ˆê¸° ì •ì±…
- **ê°œì„ **: ê°•í™”í•™ìŠµìœ¼ë¡œ ì„±ëŠ¥ í–¥ìƒ
- **ì•ˆì „ì„±**: ëª¨ë¸ ê¸°ë°˜ ì œì•½ìœ¼ë¡œ ì•ˆì „ ë³´ì¥

##### ê³„ì¸µì  í•™ìŠµ
- **ìƒìœ„ ë ˆë²¨**: íƒœìŠ¤í¬ ê³„íš ë° ëª©í‘œ ì„¤ì •
- **í•˜ìœ„ ë ˆë²¨**: ëª¨í„° ì œì–´ ë° ì•ˆì •í™”
- **ëª¨ë“ˆí™”**: ê° ë ˆë²¨ ë…ë¦½ì  í•™ìŠµ ê°€ëŠ¥

### ğŸ”§ ì„¼ì„œ ìœµí•© ë° ìƒíƒœ ì¶”ì •

#### 1. ì„¼ì„œ ì‹œìŠ¤í…œ

##### ê´€ì„± ì„¼ì„œ (IMU)
- **ê°€ì†ë„ê³„**: ì„ í˜• ê°€ì†ë„ ì¸¡ì •
- **ìì´ë¡œìŠ¤ì½”í”„**: ê°ì†ë„ ì¸¡ì •
- **ìë ¥ê³„**: ë°©í–¥ ê¸°ì¤€ ì œê³µ
- **ìœµí•©**: ìƒë³´ í•„í„°, ì¹¼ë§Œ í•„í„°

##### ì‹œê° ì„¼ì„œ
- **RGB ì¹´ë©”ë¼**: ìƒ‰ìƒ ì˜ìƒ ì •ë³´
- **ê¹Šì´ ì¹´ë©”ë¼**: ê±°ë¦¬ ì •ë³´
- **ìŠ¤í…Œë ˆì˜¤ ë¹„ì „**: 3D êµ¬ì¡° ë³µì›
- **LiDAR**: ê³ ì •ë°€ ê±°ë¦¬ ì¸¡ì •

##### ì´‰ê° ì„¼ì„œ
- **í˜/í† í¬ ì„¼ì„œ**: ë°œê³¼ ì§€ë©´ ê°„ ìƒí˜¸ì‘ìš©ë ¥
- **ì••ë ¥ ì„¼ì„œ**: ì ‘ì´‰ ì••ë ¥ ë¶„í¬
- **ê´€ì ˆ ì„¼ì„œ**: ê´€ì ˆ ìœ„ì¹˜, ì†ë„, í† í¬

#### 2. ìƒíƒœ ì¶”ì • ì•Œê³ ë¦¬ì¦˜

##### ì¹¼ë§Œ í•„í„° (Kalman Filter)
- **ì„ í˜• ì‹œìŠ¤í…œ**: ê°€ìš°ì‹œì•ˆ ë…¸ì´ì¦ˆ ê°€ì •
- **ì˜ˆì¸¡**: ì‹œìŠ¤í…œ ëª¨ë¸ ê¸°ë°˜ ìƒíƒœ ì˜ˆì¸¡
- **ì—…ë°ì´íŠ¸**: ì„¼ì„œ ì¸¡ì •ìœ¼ë¡œ ìƒíƒœ ë³´ì •

##### í™•ì¥ ì¹¼ë§Œ í•„í„° (EKF)
- **ë¹„ì„ í˜• ì‹œìŠ¤í…œ**: ìì½”ë¹„ì•ˆìœ¼ë¡œ ì„ í˜•í™”
- **ë¡œë´‡ ì ìš©**: ë¹„ì„ í˜• ë™ì—­í•™ ì‹œìŠ¤í…œ
- **í•œê³„**: ê°•í•œ ë¹„ì„ í˜•ì„±ì—ì„œ ì„±ëŠ¥ ì €í•˜

##### íŒŒí‹°í´ í•„í„°
- **ë¹„ì„ í˜•/ë¹„ê°€ìš°ì‹œì•ˆ**: ì¼ë°˜ì ì¸ í™•ë¥  ë¶„í¬
- **ìƒ˜í”Œë§**: íŒŒí‹°í´ë¡œ í™•ë¥  ë¶„í¬ í‘œí˜„
- **ì¬ìƒ˜í”Œë§**: ê°€ì¤‘ì¹˜ ê¸°ë°˜ íŒŒí‹°í´ ì„ íƒ

#### 3. SLAM (Simultaneous Localization and Mapping)

##### ê°œë…
- **ë™ì‹œ ìˆ˜í–‰**: ìœ„ì¹˜ ì¶”ì •ê³¼ ì§€ë„ ì‘ì„±
- **ì„¼ì„œ**: ì¹´ë©”ë¼, LiDAR, IMU ìœµí•©
- **ì‘ìš©**: ë¯¸ì§€ í™˜ê²½ì—ì„œ ë‚´ë¹„ê²Œì´ì…˜

##### ì£¼ìš” ë°©ë²•
- **ì‹œê°ì  SLAM**: ì¹´ë©”ë¼ ê¸°ë°˜ (ORB-SLAM, VINS)
- **LiDAR SLAM**: ë ˆì´ì € ìŠ¤ìºë„ˆ ê¸°ë°˜
- **ìœµí•© SLAM**: ì—¬ëŸ¬ ì„¼ì„œ ê²°í•©

### ğŸ”¬ ê³ ê¸‰ ì—°êµ¬ ì£¼ì œ

#### 1. ì ì‘ ì œì–´ (Adaptive Control)

##### ë§¤ê°œë³€ìˆ˜ ì ì‘
- **ë¯¸ì§€ ë§¤ê°œë³€ìˆ˜**: ë¡œë´‡ ì§ˆëŸ‰, ê´€ì„± ë“±
- **ì‹¤ì‹œê°„ ì¶”ì •**: ë§¤ê°œë³€ìˆ˜ ì˜¨ë¼ì¸ í•™ìŠµ
- **ì•ˆì •ì„±**: ë¦¬ì•„í‘¸ë…¸í”„ ì•ˆì •ì„± ë³´ì¥

##### ê²¬ê³  ì œì–´ (Robust Control)
- **ë¶ˆí™•ì‹¤ì„±**: ëª¨ë¸ ì˜¤ì°¨, ì™¸ë€
- **Hâˆ ì œì–´**: ìµœì•… ê²½ìš° ì„±ëŠ¥ ë³´ì¥
- **ìŠ¬ë¼ì´ë”© ëª¨ë“œ**: ë¶ˆì—°ì† ì œì–´ë¡œ ê²¬ê³ ì„± í™•ë³´

#### 2. ìµœì  ì œì–´

##### Linear Quadratic Regulator (LQR)
- **ì„ í˜• ì‹œìŠ¤í…œ**: ì„ í˜• ë™ì—­í•™, 2ì°¨ ë¹„ìš©
- **ë¦¬ì¹´í‹° ë°©ì •ì‹**: ìµœì  í”¼ë“œë°± ê²Œì¸
- **ë¬´í•œ ìˆ˜í‰**: ì •ìƒìƒíƒœ ìµœì  ì œì–´

##### Differential Dynamic Programming (DDP)
- **ë¹„ì„ í˜• ìµœì  ì œì–´**: ë¹„ì„ í˜• ì‹œìŠ¤í…œ
- **2ì°¨ ê·¼ì‚¬**: ê°’ í•¨ìˆ˜ì˜ 2ì°¨ ê·¼ì‚¬
- **ìˆœë°©í–¥-ì—­ë°©í–¥**: ë°˜ë³µì  í•´ë²•

#### 3. í™•ë¥ ì  ì œì–´

##### í™•ë¥ ì  ìµœì  ì œì–´
- **ë¶ˆí™•ì‹¤ì„±**: ë…¸ì´ì¦ˆ, ì¸¡ì • ì˜¤ì°¨
- **ê¸°ëŒ“ê°’ ìµœì í™”**: í™•ë¥ ì  ë¹„ìš© í•¨ìˆ˜
- **ë™ì  ê³„íšë²•**: ë²¨ë§Œ ë°©ì •ì‹

##### ë² ì´ì§€ì•ˆ ì¶”ë¡ 
- **ì‚¬ì „ ì§€ì‹**: ì´ì „ ê²½í—˜ í™œìš©
- **ì‚¬í›„ ì—…ë°ì´íŠ¸**: ìƒˆë¡œìš´ ê´€ì¸¡ìœ¼ë¡œ ì—…ë°ì´íŠ¸
- **ë¶ˆí™•ì‹¤ì„± ì •ëŸ‰í™”**: í™•ë¥ ì  ì¶”ì •

### ğŸ”§ êµ¬í˜„ ë° ê²€ì¦

#### 1. ì‹œë®¬ë ˆì´ì…˜ í™˜ê²½

##### ë¬¼ë¦¬ ì—”ì§„
- **ê°•ì²´ ë™ì—­í•™**: ê´€ì ˆê³¼ ë§í¬ ëª¨ë¸ë§
- **ì ‘ì´‰ ëª¨ë¸**: ë°œ-ì§€ë©´ ìƒí˜¸ì‘ìš©
- **ë§ˆì°° ëª¨ë¸**: ì •ì /ë™ì  ë§ˆì°°

##### ì£¼ìš” ì‹œë®¬ë ˆì´í„°
- **Gazebo**: ROS ì—°ë™, ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜
- **MuJoCo**: ì—°ì† ì œì–´ ìµœì í™”
- **PyBullet**: íŒŒì´ì¬ ê¸°ë°˜ ë¬¼ë¦¬ ì—”ì§„
- **CasADi**: ìµœì í™” ë¬¸ì œ ëª¨ë¸ë§

#### 2. ì‹¤í—˜ ë° ê²€ì¦

##### ì„±ëŠ¥ ì§€í‘œ
- **ì•ˆì •ì„±**: ë„˜ì–´ì§€ì§€ ì•Šê³  ë³´í–‰í•œ ê±°ë¦¬
- **ì—ë„ˆì§€ íš¨ìœ¨**: ë‹¨ìœ„ ê±°ë¦¬ë‹¹ ì—ë„ˆì§€ ì†Œë¹„
- **ì†ë„**: ìµœëŒ€ ë³´í–‰ ì†ë„
- **ì ì‘ì„±**: ì™¸ë€ì— ëŒ€í•œ íšŒë³µ ëŠ¥ë ¥

##### ì‹¤í—˜ í”„ë¡œí† ì½œ
- **ì œì–´ëœ í™˜ê²½**: ì‹¤í—˜ì‹¤ ì¡°ê±´
- **ë‹¤ì–‘í•œ ì§€í˜•**: í‰ì§€, ê²½ì‚¬, ê³„ë‹¨
- **ì™¸ë€ í…ŒìŠ¤íŠ¸**: ë°€ê¸°, ì¥ì• ë¬¼
- **ì¥ì‹œê°„ í…ŒìŠ¤íŠ¸**: ë‚´êµ¬ì„± ê²€ì¦

#### 3. ì•ˆì „ ê³ ë ¤ì‚¬í•­

##### í•˜ë“œì›¨ì–´ ì•ˆì „
- **ë¹„ìƒ ì •ì§€**: ì¦‰ì‹œ ëª¨ë“  ëª¨í„° ì •ì§€
- **ì†Œí”„íŠ¸ ì œí•œ**: ê´€ì ˆ í•œê³„ ë³´í˜¸
- **í˜ ì œí•œ**: ê³¼ë„í•œ í˜ ë°©ì§€

##### ì†Œí”„íŠ¸ì›¨ì–´ ì•ˆì „
- **ì˜ˆì™¸ ì²˜ë¦¬**: ì„¼ì„œ ì˜¤ë¥˜, í†µì‹  ì‹¤íŒ¨
- **ìƒíƒœ ê°ì‹œ**: ë¹„ì •ìƒ ìƒíƒœ ê°ì§€
- **ì ì§„ì  í…ŒìŠ¤íŠ¸**: ë‹¨ê³„ë³„ ê²€ì¦


## 3. ZMP (Zero Moment Point)

### ì •ì˜

ZMP(Zero Moment Point)ëŠ” ì§€ë©´ê³¼ ë¡œë´‡ ë°œ ì‚¬ì´ì˜ ì ‘ì´‰ì ì—ì„œ ìˆ˜í‰ ë°©í–¥ ëª¨ë©˜íŠ¸ì˜ í•©ì´ 0ì´ ë˜ëŠ” ì ìœ¼ë¡œ, ì´ì¡± ë³´í–‰ ë¡œë´‡ì˜ ë™ì  ì•ˆì •ì„±ì„ í‰ê°€í•˜ëŠ” í•µì‹¬ ì§€í‘œì…ë‹ˆë‹¤.

### ìˆ˜í•™ì  ì •ì˜

#### ê¸°ë³¸ ê°œë…
```
ZMP ì¡°ê±´: Î£ Mhorizontal = 0
ì—¬ê¸°ì„œ Mhorizontalì€ í•´ë‹¹ ì ì—ì„œì˜ ìˆ˜í‰ ëª¨ë©˜íŠ¸
```

#### ì¢Œí‘œ ê³„ì‚°
```
xZMP = Î£(fi Ã— yi) / Î£(fzi)
yZMP = Î£(fi Ã— xi) / Î£(fzi)

ì—¬ê¸°ì„œ:
- fi: ië²ˆì§¸ í˜ ë²¡í„°
- xi, yi: ië²ˆì§¸ í˜ì˜ ì‘ìš©ì 
- fzi: ië²ˆì§¸ ìˆ˜ì§ í˜ ì„±ë¶„
```

#### ë™ì—­í•™ì  í‘œí˜„
```
ZMP = (Î£(mi Ã— g Ã— ri) - Î£(mi Ã— ai Ã— ri)) / Î£(mi Ã— g)

ì—¬ê¸°ì„œ:
- mi: ië²ˆì§¸ ë§í¬ ì§ˆëŸ‰
- g: ì¤‘ë ¥ ê°€ì†ë„
- ri: ië²ˆì§¸ ë§í¬ ìœ„ì¹˜
- ai: ië²ˆì§¸ ë§í¬ ê°€ì†ë„
```

### ë¬¼ë¦¬ì  ì˜ë¯¸

#### ì•ˆì •ì„± ê¸°ì¤€
- **ì•ˆì •**: ZMP âˆˆ Support Polygon (ë°œë°”ë‹¥ ì˜ì—­ ë‚´ë¶€)
- **ë¶ˆì•ˆì •**: ZMP âˆ‰ Support Polygon (ë°œë°”ë‹¥ ì˜ì—­ ì™¸ë¶€)
- **í•œê³„**: ZMPê°€ ì§€ì§€ ì˜ì—­ ê²½ê³„ì— ìœ„ì¹˜

#### ì§€ì§€ ë‹¤ê°í˜• (Support Polygon)
- **ë‹¨ì¼ ì§€ì§€**: í•œ ë°œì´ ì§€ë©´ì— ì ‘ì´‰ (ë°œë°”ë‹¥ ì˜ì—­)
- **ì´ì¤‘ ì§€ì§€**: ì–‘ë°œì´ ì§€ë©´ì— ì ‘ì´‰ (ë‘ ë°œë°”ë‹¥ì„ ì‡ëŠ” ë³¼ë¡ ê»ì§ˆ)
- **ë™ì  ë³€í™”**: ë³´í–‰ ì¤‘ ì§€ì§€ ì˜ì—­ì´ ì§€ì†ì ìœ¼ë¡œ ë³€í™”

### ZMP ê¸°ë°˜ ë³´í–‰ ì œì–´

#### 1. ZMP ê¶¤ì  ê³„íš

##### ë¯¸ë¦¬ ê³„íšëœ ZMP (Pre-planned ZMP)
```python
# ë‹¨ìˆœí•œ ZMP íŒ¨í„´ ì˜ˆì‹œ
def generate_zmp_trajectory(step_time, step_width):
    zmp_trajectory = []
    
    # ì´ì¤‘ ì§€ì§€ ë‹¨ê³„
    zmp_x = interpolate(left_foot_x, right_foot_x, ratio=0.5)
    
    # ë‹¨ì¼ ì§€ì§€ ë‹¨ê³„  
    zmp_x = support_foot_x
    
    return zmp_trajectory
```

##### ê°€ë³€ ZMP (Variable ZMP)
- **ëª©ì **: ì—ë„ˆì§€ íš¨ìœ¨ì„± í–¥ìƒ
- **ë°©ë²•**: í—ˆìš© ZMP ì˜ì—­ ë‚´ì—ì„œ ìµœì  ê²½ë¡œ íƒìƒ‰
- **ì œì•½**: ì§€ì§€ ì˜ì—­ ë‚´ë¶€ ìœ ì§€

#### 2. ZMP ì¶”ì  ì œì–´

##### í”¼ë“œë°± ì œì–´
```
CoM ë³´ì • = Kp Ã— (ZMPdesired - ZMPactual)
ì—¬ê¸°ì„œ KpëŠ” ë¹„ë¡€ ê²Œì¸
```

##### PID ì œì–´ê¸° ì„¤ê³„
```cpp
class ZMPController {
private:
    double kp, ki, kd;
    double integral_error = 0;
    double previous_error = 0;
    
public:
    double control(double zmp_error, double dt) {
        integral_error += zmp_error * dt;
        double derivative = (zmp_error - previous_error) / dt;
        
        double output = kp * zmp_error + 
                       ki * integral_error + 
                       kd * derivative;
        
        previous_error = zmp_error;
        return output;
    }
};
```

##### í¼ì§€ ë¡œì§ ì œì–´
- **ì…ë ¥**: ZMP ì˜¤ì°¨, ZMP ë³€í™”ìœ¨
- **ì¶œë ¥**: CoM ìœ„ì¹˜ ë³´ì •ëŸ‰
- **ì¥ì **: ë¹„ì„ í˜•ì„±ì— ê°•ê±´

#### 3. ZMP ê¸°ë°˜ ë³´í–‰ íŒ¨í„´ ìƒì„±

##### Cart-Table Model
```
ì§ˆëŸ‰ì¤‘ì‹¬ ë°©ì •ì‹:
áº = (g/h) Ã— (x - xZMP)

ì—¬ê¸°ì„œ:
- x: ì§ˆëŸ‰ì¤‘ì‹¬ ìœ„ì¹˜
- h: ì§ˆëŸ‰ì¤‘ì‹¬ ë†’ì´
- g: ì¤‘ë ¥ ê°€ì†ë„
```

##### LIPM (Linear Inverted Pendulum Model)
- **ê°€ì •**: ë¡œë´‡ì„ ë‹¨ìˆœí•œ ì—­ì§„ìë¡œ ëª¨ë¸ë§
- **ì¥ì **: í•´ì„ì  í•´ ì¡´ì¬, ì‹¤ì‹œê°„ ê³„ì‚° ê°€ëŠ¥
- **ë‹¨ì **: ìƒì²´ ì›€ì§ì„ê³¼ ë‹¤ë¦¬ ì§ˆëŸ‰ ë¬´ì‹œ

### ì‹¤ì œ êµ¬í˜„

#### 1. ZMP ì¸¡ì •

##### Force/Torque Sensor
```cpp
// 6ì¶• F/T ì„¼ì„œë¥¼ ì´ìš©í•œ ZMP ê³„ì‚°
Vector3 calculateZMP(Vector3 force, Vector3 moment) {
    double x_zmp = -moment.y / force.z;
    double y_zmp = moment.x / force.z;
    return Vector3(x_zmp, y_zmp, 0);
}
```

##### ì••ë ¥ ì„¼ì„œ ë°°ì—´
- **ë¶„í¬ ì¸¡ì •**: ë°œë°”ë‹¥ ì—¬ëŸ¬ ì§€ì ì˜ ì••ë ¥
- **ZMP ê³„ì‚°**: ì••ë ¥ ë¶„í¬ë¡œë¶€í„° ë¬´ê²Œì¤‘ì‹¬ ê³„ì‚°
- **í•´ìƒë„**: ì„¼ì„œ ê°œìˆ˜ì— ë”°ë¥¸ ì •ë°€ë„

#### 2. ZMP ì œì–´ê¸° ì„¤ê³„

##### ìƒíƒœê³µê°„ ì œì–´
```
ìƒíƒœ: x = [CoM_position, CoM_velocity, ZMP_position]
ì œì–´ì…ë ¥: u = CoM_acceleration
ì¶œë ¥: y = ZMP_position

ìƒíƒœë°©ì •ì‹: áº‹ = Ax + Bu
ì¶œë ¥ë°©ì •ì‹: y = Cx
```

### ê³ ê¸‰ ZMP ê¸°ë²•

#### 1. ì˜ˆì¸¡ ZMP ì œì–´

##### Model Predictive Control (MPC)
```
ëª©ì í•¨ìˆ˜:
J = Î£(||ZMP_predicted - ZMP_reference||Â² + R||u||Â²)

ì œì•½ì¡°ê±´:
- ZMP âˆˆ Support Polygon
- |CoM_acceleration| â‰¤ a_max
```

##### ë¯¸ë˜ ì§€ì§€ ì˜ì—­ ê³ ë ¤
- **ë‹¤ë‹¨ê³„ ì˜ˆì¸¡**: ì—¬ëŸ¬ ìŠ¤í… ì•ì˜ ì§€ì§€ ì˜ì—­ ì˜ˆì¸¡
- **ìµœì í™”**: ì „ì²´ ë³´í–‰ ì£¼ê¸°ì— ëŒ€í•œ ìµœì  ZMP ê¶¤ì 

#### 2. ì ì‘ì  ZMP ì œì–´

##### ì§€í˜• ì ì‘
- **ê²½ì‚¬ë©´**: ì¤‘ë ¥ ë°©í–¥ ë³€í™” ê³ ë ¤
- **ë¶ˆê·œì¹™ ì§€í˜•**: ë°œ ì ‘ì´‰ ëª¨ë¸ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
- **ê³„ë‹¨**: ë†’ì´ ë³€í™”ì— ë”°ë¥¸ ZMP ì¬ê³„ì‚°

##### ì™¸ë€ ëŒ€ì‘
- **ë°€ë¦¼**: ê¸‰ê²©í•œ ZMP ë³€í™” ëŒ€ì‘
- **ë¯¸ë„ëŸ¬ì§**: ë§ˆì°° ê³„ìˆ˜ ë³€í™” ê³ ë ¤
- **ë°”ëŒ**: ì™¸ë¶€ í˜ì˜ ì˜í–¥ ë³´ìƒ

#### 3. ZMP ì•ˆì •ì„± ë§ˆì§„

##### ì•ˆì •ì„± ì§€í‘œ
```
ì•ˆì •ì„± ë§ˆì§„ = min(distance(ZMP, boundary_of_support_polygon))
- ì–‘ìˆ˜: ì•ˆì •
- 0: ì„ê³„
- ìŒìˆ˜: ë¶ˆì•ˆì •
```

##### ë™ì  ì•ˆì •ì„±
- **ZMP ì†ë„**: ZMP ì´ë™ ì†ë„ ì œí•œ
- **ZMP ê°€ì†ë„**: ê¸‰ê²©í•œ ZMP ë³€í™” ë°©ì§€
- **ì˜ˆì¸¡ ì•ˆì •ì„±**: ë¯¸ë˜ ZMP ê¶¤ì ì˜ ì•ˆì •ì„± í‰ê°€

### í•œê³„ ë° í™•ì¥

#### ZMP ê¸°ë²•ì˜ í•œê³„

##### ë³´ìˆ˜ì  ì ‘ê·¼
- **ì •ì  ì•ˆì •**: ë™ì  íš¨ê³¼ ë¬´ì‹œ
- **ì—ë„ˆì§€ ë¹„íš¨ìœ¨**: ê³¼ë„í•œ ì•ˆì „ ë§ˆì§„
- **ì†ë„ ì œí•œ**: ë¹ ë¥¸ ë³´í–‰ì— ë¶€ì í•©

##### ê°€ì •ì˜ í•œê³„
- **ê°•ì²´ ê°€ì •**: ìœ ì—°í•œ ë°œë°”ë‹¥ ë¬´ì‹œ
- **ì  ì ‘ì´‰**: ì‹¤ì œ ë©´ ì ‘ì´‰ê³¼ ì°¨ì´
- **ë§ˆì°° ë¬´í•œ**: ë¯¸ë„ëŸ¬ì§ ê°€ëŠ¥ì„± ë¬´ì‹œ

#### í™•ì¥ ê¸°ë²•

##### Capture Point
- **ì •ì˜**: í˜„ì¬ ìƒíƒœì—ì„œ ì •ì§€í•  ìˆ˜ ìˆëŠ” ë°œ ìœ„ì¹˜
- **ë™ì  ì•ˆì •ì„±**: ZMPë³´ë‹¤ ë™ì  íŠ¹ì„± ë°˜ì˜
- **ìˆ˜ì‹**: CP = CoM + CoM_velocity / Ï‰â‚€

##### ì¤‘ì‹¬ì••ë ¥ì  (Center of Pressure, CoP)
- **ì°¨ì´ì **: ì‹¤ì œ ì¸¡ì •ë˜ëŠ” ì••ë ¥ ì¤‘ì‹¬
- **ê´€ê³„**: ZMPëŠ” ì´ë¡ ì , CoPëŠ” ì‹¤ì¸¡ê°’
- **í™œìš©**: ZMPì™€ CoP ì°¨ì´ë¡œ ì‹œìŠ¤í…œ ìƒíƒœ í‰ê°€

### ì‹¤í—˜ ë° ê²€ì¦

#### ì„±ëŠ¥ ì§€í‘œ
- **ZMP ì¶”ì  ì˜¤ì°¨**: RMS ì˜¤ì°¨, ìµœëŒ€ ì˜¤ì°¨
- **ì•ˆì •ì„± ë§ˆì§„**: í‰ê·  ë§ˆì§„, ìµœì†Œ ë§ˆì§„
- **ì—ë„ˆì§€ íš¨ìœ¨**: ë‹¨ìœ„ ê±°ë¦¬ë‹¹ ì—ë„ˆì§€ ì†Œë¹„
- **ë³´í–‰ ì†ë„**: ìµœëŒ€ ì•ˆì • ë³´í–‰ ì†ë„

#### ì‹¤í—˜ í”„ë¡œí† ì½œ
1. **ì •ì§€ ìƒíƒœ**: ZMP ìœ„ì¹˜ ì •í™•ë„ ì¸¡ì •
2. **ì €ì† ë³´í–‰**: ZMP ì¶”ì  ì„±ëŠ¥ í‰ê°€
3. **ê³ ì† ë³´í–‰**: ì•ˆì •ì„± í•œê³„ ì¸¡ì •
4. **ì™¸ë€ í…ŒìŠ¤íŠ¸**: ë°€ê¸°, ë¯¸ë„ëŸ¬ì§ ëŒ€ì‘
5. **ì§€í˜• í…ŒìŠ¤íŠ¸**: ê²½ì‚¬, ê³„ë‹¨, ë¶ˆê·œì¹™ ì§€í˜•

#### ì‹œë®¬ë ˆì´ì…˜ ê²€ì¦
- **ë¬¼ë¦¬ ì—”ì§„**: ì •í™•í•œ ì ‘ì´‰ ëª¨ë¸ë§
- **ì„¼ì„œ ëª¨ë¸**: ë…¸ì´ì¦ˆ, ì§€ì—°, ì˜¤ì°¨ ëª¨ë¸
- **Monte Carlo**: ë‹¤ì–‘í•œ ì¡°ê±´ì—ì„œ í†µê³„ì  ê²€ì¦

### ê´€ë ¨ ì—°êµ¬

#### ì´ˆê¸° ì—°êµ¬ (1970-1990)
- **VukobratoviÄ‡**: ZMP ê°œë… ìµœì´ˆ ì œì•ˆ
- **ê¸°ë³¸ ì´ë¡ **: ì •ì  ì•ˆì •ì„± ê¸°ì¤€ í™•ë¦½

#### ë°œì „ê¸° (1990-2010)  
- **Honda**: ASIMOì˜ ZMP ê¸°ë°˜ ë³´í–‰
- **ì‹¤ìš©í™”**: ì‹¤ì œ íœ´ë¨¸ë…¸ì´ë“œì— ì ìš©

#### í˜„ëŒ€ ì—°êµ¬ (2010-í˜„ì¬)
- **ìµœì í™”**: MPC ê¸°ë°˜ ZMP ì œì–´
- **í•™ìŠµ**: ê°•í™”í•™ìŠµê³¼ ZMP ê²°í•©
- **ë™ì  ë³´í–‰**: ZMP í•œê³„ ê·¹ë³µ ì—°êµ¬

### ì½”ë“œ ì˜ˆì œ

#### ê¸°ë³¸ ZMP ê³„ì‚°
```python
import numpy as np

def calculate_zmp(masses, positions, accelerations):
    """
    ì§ˆëŸ‰, ìœ„ì¹˜, ê°€ì†ë„ë¡œë¶€í„° ZMP ê³„ì‚°
    """
    g = 9.81  # ì¤‘ë ¥ê°€ì†ë„
    
    numerator_x = 0
    numerator_y = 0  
    denominator = 0
    
    for m, pos, acc in zip(masses, positions, accelerations):
        force_z = m * (g + acc[2])  # ìˆ˜ì§ë ¥
        moment_x = m * (acc[1] * pos[2] - (g + acc[2]) * pos[1])
        moment_y = m * ((g + acc[2]) * pos[0] - acc[0] * pos[2])
        
        numerator_x += moment_y
        numerator_y += moment_x
        denominator += force_z
    
    zmp_x = numerator_x / denominator
    zmp_y = numerator_y / denominator
    
    return np.array([zmp_x, zmp_y])
```

#### ZMP ì¶”ì  ì œì–´ê¸°
```python
class ZMPTracker:
    def __init__(self, kp=100, ki=10, kd=5):
        self.kp = kp
        self.ki = ki  
        self.kd = kd
        self.integral_error = np.zeros(2)
        self.previous_error = np.zeros(2)
        
    def control(self, zmp_desired, zmp_actual, dt):
        error = zmp_desired - zmp_actual
        
        # PID ì œì–´
        self.integral_error += error * dt
        derivative_error = (error - self.previous_error) / dt
        
        com_correction = (self.kp * error + 
                         self.ki * self.integral_error +
                         self.kd * derivative_error)
        
        self.previous_error = error.copy()
        return com_correction
```

## 4. ì—­ê¸°êµ¬í•™ (Inverse Kinematics)

### ì •ì˜

ì—­ê¸°êµ¬í•™(Inverse Kinematics, IK)ì€ ë¡œë´‡ì˜ ì—”ë“œ ì´í™í„°(ë§ë‹¨ ì¥ì¹˜)ì˜ ì›í•˜ëŠ” ìœ„ì¹˜ì™€ ë°©í–¥ì„ ì…ë ¥ìœ¼ë¡œ í•˜ì—¬, ê° ê´€ì ˆì´ ì–´ë–¤ ê°ë„ë¡œ ì›€ì§ì—¬ì•¼ í•˜ëŠ”ì§€ë¥¼ ê³„ì‚°í•˜ëŠ” ê¸°ë²•ì…ë‹ˆë‹¤.

### ìˆ˜í•™ì  ì •ì˜

#### ìˆœê¸°êµ¬í•™ê³¼ì˜ ê´€ê³„
```
ìˆœê¸°êµ¬í•™ (FK): q â†’ x
x = f(q)

ì—­ê¸°êµ¬í•™ (IK): x â†’ q  
q = fâ»Â¹(x)

ì—¬ê¸°ì„œ:
- q: ê´€ì ˆ ê°ë„ ë²¡í„° (nì°¨ì›)
- x: ì—”ë“œ ì´í™í„° ìœ„ì¹˜/ë°©í–¥ (mì°¨ì›)
- f: ìˆœê¸°êµ¬í•™ í•¨ìˆ˜
```

#### ë¬¸ì œì˜ ë³µì¡ì„±
- **ë¹„ì„ í˜•**: f(q)ê°€ ì‚¼ê°í•¨ìˆ˜ì˜ ë³µí•©í•¨ìˆ˜
- **ë‹¤ì¤‘í•´**: í•˜ë‚˜ì˜ xì— ëŒ€í•´ ì—¬ëŸ¬ q ì¡´ì¬ ê°€ëŠ¥
- **í•´ê°€ ì—†ìŒ**: ì‘ì—…ê³µê°„ ë°–ì˜ ëª©í‘œì 
- **íŠ¹ì´ì **: ìì½”ë¹„ì•ˆ í–‰ë ¬ì‹ì´ 0ì¸ ì§€ì 

### í•´ë²• ë¶„ë¥˜

#### 1. í•´ì„ì  ë°©ë²• (Analytical Methods)

##### ê¸°í•˜í•™ì  ì ‘ê·¼
```python
# 2ë§í¬ ë¡œë´‡íŒ” ì˜ˆì‹œ
def inverse_kinematics_2link(x, y, L1, L2):
    """
    2ë§í¬ ë¡œë´‡íŒ”ì˜ í•´ì„ì  ì—­ê¸°êµ¬í•™
    """
    # ëª©í‘œì ê¹Œì§€ì˜ ê±°ë¦¬
    r = np.sqrt(x**2 + y**2)
    
    # ì½”ì‚¬ì¸ ë²•ì¹™ ì ìš©
    cos_theta2 = (r**2 - L1**2 - L2**2) / (2 * L1 * L2)
    
    # í•´ê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
    if abs(cos_theta2) > 1:
        return None  # í•´ê°€ ì—†ìŒ
    
    # ë‘ ê°€ì§€ í•´ (elbow up/down)
    theta2_1 = np.arccos(cos_theta2)
    theta2_2 = -np.arccos(cos_theta2)
    
    # theta1 ê³„ì‚°
    alpha = np.arctan2(y, x)
    beta = np.arccos((L1**2 + r**2 - L2**2) / (2 * L1 * r))
    
    theta1_1 = alpha - beta
    theta1_2 = alpha + beta
    
    return [(theta1_1, theta2_1), (theta1_2, theta2_2)]
```

##### ëŒ€ìˆ˜ì  ì ‘ê·¼
- **ì—°ë¦½ë°©ì •ì‹**: ìˆœê¸°êµ¬í•™ ë°©ì •ì‹ì„ qì— ëŒ€í•´ í•´ê²°
- **ì¹˜í™˜ë²•**: ì‚¼ê°í•¨ìˆ˜ ì¹˜í™˜ìœ¼ë¡œ ë‹¤í•­ì‹ ë³€í™˜
- **ê²°ê³¼ì‹**: ì—¬ëŸ¬ ë³€ìˆ˜ë¥¼ í•˜ë‚˜ì”© ì†Œê±°

##### ì¥ë‹¨ì 
- **ì¥ì **: ì •í™•í•œ í•´, ë¹ ë¥¸ ê³„ì‚°, ëª¨ë“  í•´ íƒìƒ‰ ê°€ëŠ¥
- **ë‹¨ì **: ë³µì¡í•œ ë¡œë´‡ì— ì ìš© ì–´ë ¤ì›€, 6 DOF ì´ìƒì—ì„œ ë§¤ìš° ë³µì¡

#### 2. ìˆ˜ì¹˜ì  ë°©ë²• (Numerical Methods)

##### ë‰´í„´-ë©ìŠ¨ ë°©ë²•
```python
def newton_raphson_ik(target_pose, initial_guess, max_iterations=50):
    """
    ë‰´í„´-ë©ìŠ¨ ë°©ë²•ì„ ì´ìš©í•œ ì—­ê¸°êµ¬í•™
    """
    q = initial_guess.copy()
    
    for i in range(max_iterations):
        # í˜„ì¬ ìì„¸ì—ì„œì˜ ìˆœê¸°êµ¬í•™
        current_pose = forward_kinematics(q)
        
        # ì˜¤ì°¨ ê³„ì‚°
        error = target_pose - current_pose
        
        # ìˆ˜ë ´ ê²€ì‚¬
        if np.linalg.norm(error) < tolerance:
            return q, True
        
        # ìì½”ë¹„ì•ˆ ê³„ì‚°
        J = compute_jacobian(q)
        
        # ê´€ì ˆ ê°ë„ ì—…ë°ì´íŠ¸
        try:
            delta_q = np.linalg.solve(J, error)
            q += alpha * delta_q  # alpha: ìŠ¤í… í¬ê¸°
        except np.linalg.LinAlgError:
            return q, False  # íŠ¹ì´ì ì—ì„œ ì‹¤íŒ¨
    
    return q, False  # ìˆ˜ë ´ ì‹¤íŒ¨
```

##### ê²½ì‚¬í•˜ê°•ë²•
```python
def gradient_descent_ik(target_pose, initial_guess):
    """
    ê²½ì‚¬í•˜ê°•ë²•ì„ ì´ìš©í•œ ì—­ê¸°êµ¬í•™
    """
    q = initial_guess.copy()
    learning_rate = 0.01
    
    for iteration in range(max_iterations):
        # ì˜¤ì°¨ í•¨ìˆ˜: E = 0.5 * ||f(q) - x_target||Â²
        current_pose = forward_kinematics(q)
        error = target_pose - current_pose
        
        if np.linalg.norm(error) < tolerance:
            return q, True
        
        # ê·¸ë˜ë””ì–¸íŠ¸ ê³„ì‚°: âˆ‡E = J^T * error
        J = compute_jacobian(q)
        gradient = J.T @ error
        
        # ê´€ì ˆ ê°ë„ ì—…ë°ì´íŠ¸
        q += learning_rate * gradient
    
    return q, False
```

##### ì˜ì‚¬ì—­í–‰ë ¬ (Pseudoinverse)
```python
def pseudoinverse_ik(target_pose, current_q):
    """
    ì˜ì‚¬ì—­í–‰ë ¬ì„ ì´ìš©í•œ ì—­ê¸°êµ¬í•™ (í•œ ìŠ¤í…)
    """
    # ìì½”ë¹„ì•ˆ ê³„ì‚°
    J = compute_jacobian(current_q)
    
    # ì˜ì‚¬ì—­í–‰ë ¬ ê³„ì‚°
    if J.shape[0] == J.shape[1]:  # ì •ì‚¬ê° í–‰ë ¬
        try:
            J_inv = np.linalg.inv(J)
        except np.linalg.LinAlgError:
            # íŠ¹ì´ì ì—ì„œ ê°ì‡  ìµœì†Œì œê³±ë²•
            lambda_reg = 0.01
            J_inv = J.T @ np.linalg.inv(J @ J.T + lambda_reg * np.eye(J.shape[0]))
    else:  # ì§ì‚¬ê° í–‰ë ¬
        J_inv = np.linalg.pinv(J)
    
    # í˜„ì¬ ìœ„ì¹˜ì™€ ëª©í‘œ ìœ„ì¹˜ì˜ ì°¨ì´
    current_pose = forward_kinematics(current_q)
    error = target_pose - current_pose
    
    # ê´€ì ˆ ê°ë„ ë³€í™”ëŸ‰
    delta_q = J_inv @ error
    
    return current_q + delta_q
```

#### 3. ìµœì í™” ê¸°ë°˜ ë°©ë²•

##### ëª©ì í•¨ìˆ˜ ì •ì˜
```python
def ik_objective_function(q, target_pose, weights):
    """
    ì—­ê¸°êµ¬í•™ì„ ìœ„í•œ ëª©ì í•¨ìˆ˜
    """
    # ì£¼ ëª©ì : ìœ„ì¹˜/ë°©í–¥ ì˜¤ì°¨ ìµœì†Œí™”
    current_pose = forward_kinematics(q)
    pose_error = np.linalg.norm(target_pose - current_pose)
    
    # ë¶€ì°¨ ëª©ì ë“¤
    joint_limit_penalty = compute_joint_limit_penalty(q)
    smoothness_penalty = compute_smoothness_penalty(q)
    singularity_penalty = compute_singularity_penalty(q)
    
    total_cost = (weights['pose'] * pose_error +
                  weights['limits'] * joint_limit_penalty +
                  weights['smooth'] * smoothness_penalty +
                  weights['singular'] * singularity_penalty)
    
    return total_cost
```

##### ì œì•½ ìµœì í™”
```python
from scipy.optimize import minimize

def constrained_ik(target_pose, initial_guess):
    """
    ì œì•½ ì¡°ê±´ì´ ìˆëŠ” ì—­ê¸°êµ¬í•™ ìµœì í™”
    """
    # ëª©ì í•¨ìˆ˜
    def objective(q):
        current_pose = forward_kinematics(q)
        return np.linalg.norm(target_pose - current_pose)**2
    
    # ê´€ì ˆ í•œê³„ ì œì•½
    bounds = [(q_min[i], q_max[i]) for i in range(len(initial_guess))]
    
    # ì¶©ëŒ íšŒí”¼ ì œì•½
    def collision_constraint(q):
        return minimum_distance_to_obstacle(q) - safety_margin
    
    constraints = [{'type': 'ineq', 'fun': collision_constraint}]
    
    # ìµœì í™” ì‹¤í–‰
    result = minimize(objective, initial_guess, 
                     bounds=bounds, constraints=constraints,
                     method='SLSQP')
    
    return result.x, result.success
```


### íŠ¹ìˆ˜ ìƒí™© ì²˜ë¦¬

#### 1. ì¤‘ë³µ ììœ ë„ (Redundancy)

##### ë¬¸ì œ ì •ì˜
- **ì •ì˜**: íƒœìŠ¤í¬ ì°¨ì›ë³´ë‹¤ ê´€ì ˆ ìˆ˜ê°€ ë§ì€ ê²½ìš°
- **ì˜ˆì‹œ**: 7-DOF íŒ”ë¡œ 6-DOF ìœ„ì¹˜/ë°©í–¥ ì œì–´
- **ê²°ê³¼**: ë¬´í•œê°œì˜ í•´ ì¡´ì¬

##### í•´ê²° ë°©ë²•

###### Null Space íˆ¬ì˜
```python
def redundant_ik_nullspace(target_pose, current_q, secondary_objective):
    """
    ë„ ê³µê°„ì„ ì´ìš©í•œ ì¤‘ë³µ ììœ ë„ ì—­ê¸°êµ¬í•™
    """
    J = compute_jacobian(current_q)
    
    # ì£¼ íƒœìŠ¤í¬: ìœ„ì¹˜/ë°©í–¥ ì œì–´
    current_pose = forward_kinematics(current_q)
    error = target_pose - current_pose
    J_pinv = np.linalg.pinv(J)
    
    # ì£¼ íƒœìŠ¤í¬ í•´
    dq_primary = J_pinv @ error
    
    # ë„ ê³µê°„ íˆ¬ì˜ì
    N = np.eye(len(current_q)) - J_pinv @ J
    
    # ë¶€ì°¨ íƒœìŠ¤í¬ (ì˜ˆ: ê´€ì ˆ ì¤‘ì  ìœ ì§€)
    dq_secondary = secondary_objective_gradient(current_q)
    
    # ìµœì¢… í•´
    dq_total = dq_primary + N @ dq_secondary
    
    return current_q + dq_total
```

###### ê°€ì¤‘ ì˜ì‚¬ì—­í–‰ë ¬
```python
def weighted_pseudoinverse_ik(target_pose, current_q, W):
    """
    ê°€ì¤‘ ì˜ì‚¬ì—­í–‰ë ¬ì„ ì´ìš©í•œ ì—­ê¸°êµ¬í•™
    """
    J = compute_jacobian(current_q)
    
    # ê°€ì¤‘ ì˜ì‚¬ì—­í–‰ë ¬
    J_weighted_pinv = np.linalg.inv(W) @ J.T @ np.linalg.inv(J @ np.linalg.inv(W) @ J.T)
    
    current_pose = forward_kinematics(current_q)
    error = target_pose - current_pose
    
    delta_q = J_weighted_pinv @ error
    
    return current_q + delta_q
```

#### 2. íŠ¹ì´ì  (Singularity) ì²˜ë¦¬

##### íŠ¹ì´ì  ê°ì§€
```python
def detect_singularity(q, threshold=1e-3):
    """
    íŠ¹ì´ì  ê°ì§€
    """
    J = compute_jacobian(q)
    
    # ì¡°ê±´ìˆ˜ í™•ì¸
    condition_number = np.linalg.cond(J)
    
    # í–‰ë ¬ì‹ í™•ì¸ (ì •ì‚¬ê° í–‰ë ¬ì¸ ê²½ìš°)
    if J.shape[0] == J.shape[1]:
        det_J = np.linalg.det(J)
        return abs(det_J) < threshold
    
    # íŠ¹ì´ê°’ í™•ì¸
    singular_values = np.linalg.svd(J, compute_uv=False)
    min_singular_value = np.min(singular_values)
    
    return min_singular_value < threshold
```

##### ê°ì‡  ìµœì†Œì œê³±ë²• (Damped Least Squares)
```python
def damped_least_squares_ik(target_pose, current_q, lambda_damping=0.01):
    """
    ê°ì‡  ìµœì†Œì œê³±ë²•ì„ ì´ìš©í•œ íŠ¹ì´ì  íšŒí”¼
    """
    J = compute_jacobian(current_q)
    
    # ê°ì‡ ëœ ì˜ì‚¬ì—­í–‰ë ¬
    J_damped_pinv = J.T @ np.linalg.inv(J @ J.T + lambda_damping**2 * np.eye(J.shape[0]))
    
    current_pose = forward_kinematics(current_q)
    error = target_pose - current_pose
    
    delta_q = J_damped_pinv @ error
    
    return current_q + delta_q
```

##### íŠ¹ì´ì  íšŒí”¼
```python
def singularity_avoidance_ik(target_pose, current_q):
    """
    íŠ¹ì´ì  íšŒí”¼ë¥¼ í¬í•¨í•œ ì—­ê¸°êµ¬í•™
    """
    J = compute_jacobian(current_q)
    
    # íŠ¹ì´ì  ê·¼ì ‘ë„ ê³„ì‚°
    manipulability = np.sqrt(np.linalg.det(J @ J.T))
    
    if manipulability < singularity_threshold:
        # íŠ¹ì´ì  íšŒí”¼ ë°©í–¥ ê³„ì‚°
        avoidance_direction = compute_avoidance_direction(current_q)
        
        # ì£¼ íƒœìŠ¤í¬ì™€ íšŒí”¼ íƒœìŠ¤í¬ ê²°í•©
        current_pose = forward_kinematics(current_q)
        error = target_pose - current_pose
        
        # ê°€ì¤‘ ê²°í•©
        weight_task = 1.0
        weight_avoidance = 1.0 - manipulability / singularity_threshold
        
        combined_objective = (weight_task * J.T @ error +
                             weight_avoidance * avoidance_direction)
        
        return current_q + alpha * combined_objective
    else:
        # ì¼ë°˜ì ì¸ ì—­ê¸°êµ¬í•™
        return pseudoinverse_ik(target_pose, current_q)
```

#### 3. ì‘ì—…ê³µê°„ ì œí•œ

##### ë„ë‹¬ ê°€ëŠ¥ì„± ê²€ì‚¬
```python
def check_reachability(target_pose, robot_params):
    """
    ëª©í‘œ ìœ„ì¹˜ê°€ ì‘ì—…ê³µê°„ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
    """
    # ë‹¨ìˆœí•œ êµ¬í˜• ì‘ì—…ê³µê°„ ê²€ì‚¬
    max_reach = sum(robot_params['link_lengths'])
    distance_to_target = np.linalg.norm(target_pose[:3])
    
    if distance_to_target > max_reach:
        return False, "Target too far"
    
    # ìµœì†Œ ë„ë‹¬ ê±°ë¦¬ ê²€ì‚¬
    min_reach = abs(robot_params['link_lengths'][0] - 
                   sum(robot_params['link_lengths'][1:]))
    
    if distance_to_target < min_reach:
        return False, "Target too close"
    
    return True, "Reachable"
```

##### ìµœê·¼ì ‘ì  íˆ¬ì˜
```python
def project_to_workspace(target_pose, robot_params):
    """
    ì‘ì—…ê³µê°„ ë°–ì˜ ëª©í‘œë¥¼ ì‘ì—…ê³µê°„ ê²½ê³„ë¡œ íˆ¬ì˜
    """
    max_reach = sum(robot_params['link_lengths'])
    distance = np.linalg.norm(target_pose[:3])
    
    if distance > max_reach:
        # ìµœëŒ€ ë„ë‹¬ ê±°ë¦¬ë¡œ íˆ¬ì˜
        direction = target_pose[:3] / distance
        projected_position = direction * max_reach
        
        # ë°©í–¥ì€ ìœ ì§€
        projected_pose = target_pose.copy()
        projected_pose[:3] = projected_position
        
        return projected_pose
    
    return target_pose
```

### ì‹¤ì‹œê°„ ì—­ê¸°êµ¬í•™

#### 1. ì ì§„ì  í•´ë²•

##### ì†ë„ ê¸°ë°˜ IK
```python
def velocity_based_ik(target_velocity, current_q, dt):
    """
    ì†ë„ ê¸°ë°˜ ì‹¤ì‹œê°„ ì—­ê¸°êµ¬í•™
    """
    J = compute_jacobian(current_q)
    J_pinv = np.linalg.pinv(J)
    
    # ê´€ì ˆ ì†ë„ ê³„ì‚°
    joint_velocity = J_pinv @ target_velocity
    
    # ê´€ì ˆ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
    new_q = current_q + joint_velocity * dt
    
    # ê´€ì ˆ í•œê³„ ì ìš©
    new_q = np.clip(new_q, joint_limits_min, joint_limits_max)
    
    return new_q
```

##### ê¶¤ì  ì¶”ì¢…
```python
def trajectory_following_ik(trajectory, initial_q, dt):
    """
    ê¶¤ì  ì¶”ì¢…ì„ ìœ„í•œ ì—°ì†ì  ì—­ê¸°êµ¬í•™
    """
    q_trajectory = [initial_q]
    current_q = initial_q.copy()
    
    for i in range(1, len(trajectory)):
        target_pose = trajectory[i]
        
        # í•œ ìŠ¤í… ì—­ê¸°êµ¬í•™
        next_q = one_step_ik(target_pose, current_q, dt)
        
        # ë¶€ë“œëŸ¬ìš´ ë³€í™”ë¥¼ ìœ„í•œ í•„í„°ë§
        max_joint_velocity = 1.0  # rad/s
        max_change = max_joint_velocity * dt
        
        delta_q = next_q - current_q
        delta_q = np.clip(delta_q, -max_change, max_change)
        
        current_q = current_q + delta_q
        q_trajectory.append(current_q.copy())
    
    return q_trajectory
```

#### 2. ì‹¤ì‹œê°„ ìµœì í™”

##### Model Predictive Control
```python
def mpc_based_ik(trajectory_segment, current_q, horizon=10):
    """
    MPCë¥¼ ì´ìš©í•œ ì˜ˆì¸¡ì  ì—­ê¸°êµ¬í•™
    """
    def objective(q_sequence):
        cost = 0
        q = current_q.copy()
        
        for i, target_pose in enumerate(trajectory_segment[:horizon]):
            # ìœ„ì¹˜ ì˜¤ì°¨
            current_pose = forward_kinematics(q)
            pose_error = np.linalg.norm(target_pose - current_pose)
            cost += pose_error**2
            
            # ê´€ì ˆ ë³€í™” í‰í™œí™”
            if i > 0:
                smoothness = np.linalg.norm(q - q_prev)**2
                cost += 0.1 * smoothness
            
            q_prev = q.copy()
            if i < len(q_sequence) - 1:
                q = q_sequence[i+1]
        
        return cost
    
    # ì´ˆê¸° ì¶”ì •: ì„ í˜• ë³´ê°„
    q_init = generate_initial_trajectory(current_q, trajectory_segment, horizon)
    
    # ìµœì í™”
    result = minimize(objective, q_init.flatten(), method='L-BFGS-B')
    
    return result.x.reshape(-1, len(current_q))
```

### íœ´ë¨¸ë…¸ì´ë“œ íŠ¹ìˆ˜ ê³ ë ¤ì‚¬í•­

#### 1. ì „ì‹  ì—­ê¸°êµ¬í•™

##### ê³„ì¸µì  ì ‘ê·¼
```python
def whole_body_ik(tasks, current_q, priorities):
    """
    ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ì „ì‹  ì—­ê¸°êµ¬í•™
    """
    q = current_q.copy()
    
    # ìš°ì„ ìˆœìœ„ ìˆœìœ¼ë¡œ íƒœìŠ¤í¬ ì²˜ë¦¬
    for priority_level in sorted(priorities.keys()):
        task_indices = priorities[priority_level]
        
        # í˜„ì¬ ìš°ì„ ìˆœìœ„ íƒœìŠ¤í¬ë“¤
        current_tasks = [tasks[i] for i in task_indices]
        
        # ë³µí•© ìì½”ë¹„ì•ˆ êµ¬ì„±
        J_combined = []
        error_combined = []
        
        for task in current_tasks:
            J_task = compute_task_jacobian(q, task)
            error_task = compute_task_error(q, task)
            
            J_combined.append(J_task)
            error_combined.append(error_task)
        
        J_combined = np.vstack(J_combined)
        error_combined = np.concatenate(error_combined)
        
        # ì´ì „ ìš°ì„ ìˆœìœ„ íƒœìŠ¤í¬ì˜ ë„ ê³µê°„ì—ì„œ í•´ê²°
        if priority_level > 0:
            N = compute_null_space_projector(q, higher_priority_tasks)
            J_projected = J_combined @ N
            delta_q = np.linalg.pinv(J_projected) @ error_combined
            delta_q = N @ delta_q
        else:
            delta_q = np.linalg.pinv(J_combined) @ error_combined
        
        q += delta_q
    
    return q
```

#### 2. ê· í˜• ì œì•½ í†µí•©

##### ZMP ì œì•½ì´ ìˆëŠ” IK
```python
def balance_constrained_ik(upper_body_target, current_q):
    """
    ê· í˜• ì œì•½ì„ ê³ ë ¤í•œ ìƒì²´ ì—­ê¸°êµ¬í•™
    """
    def objective_with_balance(q):
        # ìƒì²´ ìœ„ì¹˜ ì˜¤ì°¨
        upper_pose = compute_upper_body_pose(q)
        pose_error = np.linalg.norm(upper_body_target - upper_pose)
        
        # ZMP ìœ„ì¹˜ ê³„ì‚°
        zmp = compute_zmp(q)
        support_polygon = get_support_polygon(q)
        
        # ZMP ì œì•½ ìœ„ë°˜ íŒ¨ë„í‹°
        zmp_penalty = compute_zmp_penalty(zmp, support_polygon)
        
        return pose_error**2 + 100 * zmp_penalty
    
    # ê´€ì ˆ í•œê³„ ì œì•½
    bounds = [(q_min[i], q_max[i]) for i in range(len(current_q))]
    
    result = minimize(objective_with_balance, current_q, bounds=bounds)
    return result.x
```

### ì„±ëŠ¥ í‰ê°€

#### í‰ê°€ ì§€í‘œ
- **ì •í™•ë„**: ëª©í‘œ ìœ„ì¹˜ì™€ ì‹¤ì œ ìœ„ì¹˜ì˜ ì˜¤ì°¨
- **ë°˜ë³µì„±**: ê°™ì€ ëª©í‘œì— ëŒ€í•œ í•´ì˜ ì¼ê´€ì„±
- **ìˆ˜ë ´ì„±**: í•´ë¡œ ìˆ˜ë ´í•˜ëŠ” ì†ë„ì™€ ì•ˆì •ì„±
- **ê³„ì‚° ì‹œê°„**: ì‹¤ì‹œê°„ ì‘ìš©ì„ ìœ„í•œ ì²˜ë¦¬ ì†ë„

#### ë²¤ì¹˜ë§ˆí¬ í…ŒìŠ¤íŠ¸
```python
def evaluate_ik_performance(ik_solver, test_cases):
    """
    ì—­ê¸°êµ¬í•™ ì†”ë²„ ì„±ëŠ¥ í‰ê°€
    """
    results = {
        'position_errors': [],
        'orientation_errors': [],
        'computation_times': [],
        'success_rates': []
    }
    
    for target_pose in test_cases:
        start_time = time.time()
        
        # ì—­ê¸°êµ¬í•™ í•´ê²°
        solution, success = ik_solver(target_pose)
        
        computation_time = time.time() - start_time
        results['computation_times'].append(computation_time)
        
        if success:
            # ì •í™•ë„ ê²€ì‚¬
            achieved_pose = forward_kinematics(solution)
            pos_error = np.linalg.norm(target_pose[:3] - achieved_pose[:3])
            ori_error = compute_orientation_error(target_pose[3:], achieved_pose[3:])
            
            results['position_errors'].append(pos_error)
            results['orientation_errors'].append(ori_error)
            results['success_rates'].append(1)
        else:
            results['success_rates'].append(0)
    
    # í†µê³„ ê³„ì‚°
    stats = {
        'avg_pos_error': np.mean(results['position_errors']),
        'avg_ori_error': np.mean(results['orientation_errors']),
        'avg_computation_time': np.mean(results['computation_times']),
        'success_rate': np.mean(results['success_rates'])
    }
    
    return stats
```

## 5. ìì½”ë¹„ì•ˆ (Jacobian)

### ì •ì˜

ìì½”ë¹„ì•ˆ(Jacobian) í–‰ë ¬ì€ ë‹¤ë³€ìˆ˜ ë²¡í„° í•¨ìˆ˜ì˜ 1ì°¨ í¸ë¯¸ë¶„ìœ¼ë¡œ êµ¬ì„±ëœ í–‰ë ¬ë¡œ, ë¡œë´‡ê³µí•™ì—ì„œëŠ” ê´€ì ˆ ê³µê°„(Joint Space)ê³¼ ì‘ì—… ê³µê°„(Task Space) ì‚¬ì´ì˜ ë¯¸ë¶„ ê´€ê³„ë¥¼ ë‚˜íƒ€ë‚´ëŠ” í•µì‹¬ ë„êµ¬ì…ë‹ˆë‹¤.

### ìˆ˜í•™ì  ì •ì˜

#### ì¼ë°˜ì  ì •ì˜
nì°¨ì› ì…ë ¥ ë²¡í„° **q**ë¥¼ mì°¨ì› ì¶œë ¥ ë²¡í„° **x**ë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜ fì— ëŒ€í•´:

```
x = f(q) = [fâ‚(qâ‚, qâ‚‚, ..., qâ‚™)]
           [fâ‚‚(qâ‚, qâ‚‚, ..., qâ‚™)]
           [        â‹®          ]
           [fâ‚˜(qâ‚, qâ‚‚, ..., qâ‚™)]
```

ìì½”ë¹„ì•ˆ í–‰ë ¬ JëŠ”:

```
J = âˆ‚f/âˆ‚q = [âˆ‚fâ‚/âˆ‚qâ‚  âˆ‚fâ‚/âˆ‚qâ‚‚  ...  âˆ‚fâ‚/âˆ‚qâ‚™]
            [âˆ‚fâ‚‚/âˆ‚qâ‚  âˆ‚fâ‚‚/âˆ‚qâ‚‚  ...  âˆ‚fâ‚‚/âˆ‚qâ‚™]
            [   â‹®        â‹®      â‹±     â‹®   ]
            [âˆ‚fâ‚˜/âˆ‚qâ‚  âˆ‚fâ‚˜/âˆ‚qâ‚‚  ...  âˆ‚fâ‚˜/âˆ‚qâ‚™]
```

#### ë¡œë´‡ê³µí•™ì—ì„œì˜ ì˜ë¯¸

##### ì†ë„ ê´€ê³„
```
áº‹ = J(q) Ã— qÌ‡

ì—¬ê¸°ì„œ:
- áº‹: ì—”ë“œ ì´í™í„° ì†ë„ (ì„ ì†ë„ + ê°ì†ë„)
- qÌ‡: ê´€ì ˆ ê°ì†ë„ ë²¡í„°
- J(q): êµ¬ì„±ì— ë”°ë¼ ë³€í•˜ëŠ” ìì½”ë¹„ì•ˆ í–‰ë ¬
```

##### ë¯¸ì†Œ ë³€ìœ„ ê´€ê³„
```
Î´x = J(q) Ã— Î´q

ì—¬ê¸°ì„œ:
- Î´x: ì—”ë“œ ì´í™í„° ë¯¸ì†Œ ë³€ìœ„
- Î´q: ê´€ì ˆ ë¯¸ì†Œ ë³€ìœ„
```

### ê¸°í•˜í•™ì  ìì½”ë¹„ì•ˆ

#### êµ¬ì„± ìš”ì†Œ

##### ì„ ì†ë„ ìì½”ë¹„ì•ˆ (Jáµ¥)
ê° ê´€ì ˆì´ ì—”ë“œ ì´í™í„°ì˜ ì„ ì†ë„ì— ê¸°ì—¬í•˜ëŠ” ì •ë„:

```python
def compute_linear_velocity_jacobian(q, link_positions):
    """
    ì„ ì†ë„ ìì½”ë¹„ì•ˆ ê³„ì‚°
    """
    n_joints = len(q)
    Jv = np.zeros((3, n_joints))
    
    end_effector_pos = link_positions[-1]
    
    for i in range(n_joints):
        if joint_type[i] == 'revolute':
            # íšŒì „ ê´€ì ˆ: zi-1 Ã— (pe - pi-1)
            z_axis = get_z_axis(i-1, q)
            r_vector = end_effector_pos - link_positions[i-1]
            Jv[:, i] = np.cross(z_axis, r_vector)
        elif joint_type[i] == 'prismatic':
            # ì§ì„  ê´€ì ˆ: zi-1
            Jv[:, i] = get_z_axis(i-1, q)
    
    return Jv
```

##### ê°ì†ë„ ìì½”ë¹„ì•ˆ (JÏ‰)
ê° ê´€ì ˆì´ ì—”ë“œ ì´í™í„°ì˜ ê°ì†ë„ì— ê¸°ì—¬í•˜ëŠ” ì •ë„:

```python
def compute_angular_velocity_jacobian(q):
    """
    ê°ì†ë„ ìì½”ë¹„ì•ˆ ê³„ì‚°
    """
    n_joints = len(q)
    Jw = np.zeros((3, n_joints))
    
    for i in range(n_joints):
        if joint_type[i] == 'revolute':
            # íšŒì „ ê´€ì ˆ: zi-1
            Jw[:, i] = get_z_axis(i-1, q)
        elif joint_type[i] == 'prismatic':
            # ì§ì„  ê´€ì ˆ: 0
            Jw[:, i] = np.zeros(3)
    
    return Jw
```

##### ì „ì²´ ìì½”ë¹„ì•ˆ
```python
def compute_geometric_jacobian(q):
    """
    ê¸°í•˜í•™ì  ìì½”ë¹„ì•ˆ ê³„ì‚°
    """
    Jv = compute_linear_velocity_jacobian(q)
    Jw = compute_angular_velocity_jacobian(q)
    
    # 6Ã—n ìì½”ë¹„ì•ˆ (ì„ ì†ë„ + ê°ì†ë„)
    J = np.vstack([Jv, Jw])
    
    return J
```

### í•´ì„ì  ìì½”ë¹„ì•ˆ

#### DH Parameter ê¸°ë°˜ ê³„ì‚°

```python
def compute_analytical_jacobian(q, dh_params):
    """
    DH Parameterë¥¼ ì´ìš©í•œ í•´ì„ì  ìì½”ë¹„ì•ˆ ê³„ì‚°
    """
    n = len(q)
    J = np.zeros((6, n))
    
    # í˜„ì¬ êµ¬ì„±ì—ì„œì˜ ë³€í™˜ í–‰ë ¬ë“¤
    T = [np.eye(4)]
    for i in range(n):
        Ti = dh_transform(dh_params[i], q[i])
        T.append(T[-1] @ Ti)
    
    # ì—”ë“œ ì´í™í„° ìœ„ì¹˜
    pe = T[-1][:3, 3]
    
    for i in range(n):
        if dh_params[i]['type'] == 'revolute':
            # íšŒì „ì¶• (zì¶•)
            zi = T[i][:3, 2]
            
            # ê´€ì ˆì—ì„œ ì—”ë“œ ì´í™í„°ë¡œì˜ ë²¡í„°
            pi = T[i][:3, 3]
            r = pe - pi
            
            # ì„ ì†ë„ ì„±ë¶„
            J[:3, i] = np.cross(zi, r)
            # ê°ì†ë„ ì„±ë¶„
            J[3:, i] = zi
            
        elif dh_params[i]['type'] == 'prismatic':
            # ì´ë™ì¶• (zì¶•)
            zi = T[i][:3, 2]
            
            # ì„ ì†ë„ ì„±ë¶„
            J[:3, i] = zi
            # ê°ì†ë„ ì„±ë¶„ (0)
            J[3:, i] = 0
    
    return J
```

#### ìˆ˜ì¹˜ì  ìì½”ë¹„ì•ˆ

```python
def compute_numerical_jacobian(q, forward_kinematics_func, epsilon=1e-6):
    """
    ìˆ˜ì¹˜ ë¯¸ë¶„ì„ ì´ìš©í•œ ìì½”ë¹„ì•ˆ ê³„ì‚°
    """
    n = len(q)
    x0 = forward_kinematics_func(q)
    m = len(x0)
    
    J = np.zeros((m, n))
    
    for i in range(n):
        # q[i]ì— ëŒ€í•œ í¸ë¯¸ë¶„
        q_plus = q.copy()
        q_plus[i] += epsilon
        
        q_minus = q.copy()
        q_minus[i] -= epsilon
        
        x_plus = forward_kinematics_func(q_plus)
        x_minus = forward_kinematics_func(q_minus)
        
        # ì¤‘ì•™ ì°¨ë¶„
        J[:, i] = (x_plus - x_minus) / (2 * epsilon)
    
    return J
```


### ìì½”ë¹„ì•ˆì˜ ì‘ìš©

#### 1. ì—­ê¸°êµ¬í•™

##### ë°˜ë³µì  í•´ë²•
```python
def jacobian_inverse_kinematics(target_pose, initial_q, max_iter=100, tolerance=1e-6):
    """
    ìì½”ë¹„ì•ˆì„ ì´ìš©í•œ ë°˜ë³µì  ì—­ê¸°êµ¬í•™
    """
    q = initial_q.copy()
    
    for iteration in range(max_iter):
        # í˜„ì¬ ì—”ë“œ ì´í™í„° ìœ„ì¹˜
        current_pose = forward_kinematics(q)
        error = target_pose - current_pose
        
        # ìˆ˜ë ´ í™•ì¸
        if np.linalg.norm(error) < tolerance:
            return q, True
        
        # ìì½”ë¹„ì•ˆ ê³„ì‚°
        J = compute_jacobian(q)
        
        # ê´€ì ˆ ê°ë„ ì—…ë°ì´íŠ¸
        try:
            delta_q = np.linalg.solve(J, error)
        except np.linalg.LinAlgError:
            # íŠ¹ì´ì ì—ì„œ ì˜ì‚¬ì—­í–‰ë ¬ ì‚¬ìš©
            delta_q = np.linalg.pinv(J) @ error
        
        # ìŠ¤í… í¬ê¸° ì¡°ì ˆ
        alpha = 0.5
        q += alpha * delta_q
    
    return q, False
```

##### ê°ì‡  ìµœì†Œì œê³±ë²•
```python
def damped_least_squares_ik(target_pose, current_q, lambda_damping=0.01):
    """
    ê°ì‡  ìµœì†Œì œê³±ë²•ì„ ì´ìš©í•œ ì•ˆì •ì  ì—­ê¸°êµ¬í•™
    """
    current_pose = forward_kinematics(current_q)
    error = target_pose - current_pose
    
    J = compute_jacobian(current_q)
    
    # ê°ì‡ ëœ ì˜ì‚¬ì—­í–‰ë ¬
    A = J @ J.T + lambda_damping**2 * np.eye(J.shape[0])
    J_damped = J.T @ np.linalg.inv(A)
    
    delta_q = J_damped @ error
    
    return current_q + delta_q
```

#### 2. ì†ë„ ì œì–´

##### ì§êµ ì†ë„ ì œì–´
```python
def cartesian_velocity_control(desired_velocity, current_q):
    """
    ì§êµ ì¢Œí‘œê³„ì—ì„œì˜ ì†ë„ ì œì–´
    """
    J = compute_jacobian(current_q)
    
    # ì˜ì‚¬ì—­í–‰ë ¬ë¡œ ê´€ì ˆ ì†ë„ ê³„ì‚°
    joint_velocity = np.linalg.pinv(J) @ desired_velocity
    
    return joint_velocity

def execute_velocity_control(robot, desired_velocity, current_q, dt):
    """
    ì†ë„ ì œì–´ ì‹¤í–‰
    """
    joint_velocity = cartesian_velocity_control(desired_velocity, current_q)
    
    # ê´€ì ˆ ì†ë„ ì œí•œ ì ìš©
    max_joint_velocity = robot.joint_velocity_limits
    joint_velocity = np.clip(joint_velocity, -max_joint_velocity, max_joint_velocity)
    
    # ê´€ì ˆ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
    new_q = current_q + joint_velocity * dt
    
    return new_q, joint_velocity
```

#### 3. í˜ ì œì–´

##### ì •ì  í˜ ë³€í™˜
```python
def force_transformation(joint_torques, current_q):
    """
    ê´€ì ˆ í† í¬ë¥¼ ì—”ë“œ ì´í™í„° í˜ìœ¼ë¡œ ë³€í™˜
    """
    J = compute_jacobian(current_q)
    
    # ì´ì¤‘ì„± ì›ë¦¬: F = J^(-T) * Ï„
    try:
        end_effector_force = np.linalg.solve(J.T, joint_torques)
    except np.linalg.LinAlgError:
        end_effector_force = np.linalg.pinv(J.T) @ joint_torques
    
    return end_effector_force

def cartesian_force_control(desired_force, current_q):
    """
    ì§êµì¢Œí‘œê³„ í˜ì„ ê´€ì ˆ í† í¬ë¡œ ë³€í™˜
    """
    J = compute_jacobian(current_q)
    
    # Ï„ = J^T * F
    joint_torques = J.T @ desired_force
    
    return joint_torques
```

#### 4. ë‹¤ì¤‘ íƒœìŠ¤í¬ ì œì–´

##### ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ì œì–´
```python
def prioritized_multitask_control(tasks, current_q):
    """
    ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ë‹¤ì¤‘ íƒœìŠ¤í¬ ì œì–´
    """
    q_dot = np.zeros(len(current_q))
    N = np.eye(len(current_q))  # ë„ ê³µê°„ íˆ¬ì˜ì
    
    for task in sorted(tasks, key=lambda x: x.priority):
        # íƒœìŠ¤í¬ ìì½”ë¹„ì•ˆ
        J_task = compute_task_jacobian(current_q, task)
        
        # ë„ ê³µê°„ìœ¼ë¡œ íˆ¬ì˜ëœ ìì½”ë¹„ì•ˆ
        J_proj = J_task @ N
        
        # íƒœìŠ¤í¬ ì˜¤ì°¨
        error = compute_task_error(current_q, task)
        
        # íƒœìŠ¤í¬ í•´ê²°
        if np.linalg.matrix_rank(J_proj) > 0:
            J_proj_pinv = np.linalg.pinv(J_proj)
            q_dot_task = J_proj_pinv @ error
            
            # ì „ì²´ í•´ì— ì¶”ê°€
            q_dot += N @ q_dot_task
            
            # ë„ ê³µê°„ ì—…ë°ì´íŠ¸
            N = N - J_proj_pinv @ J_proj
    
    return q_dot
```

##### ê°€ì¤‘ ë‹¤ì¤‘ íƒœìŠ¤í¬
```python
def weighted_multitask_control(tasks, current_q):
    """
    ê°€ì¤‘ì¹˜ ê¸°ë°˜ ë‹¤ì¤‘ íƒœìŠ¤í¬ ì œì–´
    """
    # ë³µí•© ìì½”ë¹„ì•ˆê³¼ ì˜¤ì°¨ êµ¬ì„±
    J_combined = []
    error_combined = []
    
    for task in tasks:
        J_task = compute_task_jacobian(current_q, task)
        error_task = compute_task_error(current_q, task)
        
        J_combined.append(np.sqrt(task.weight) * J_task)
        error_combined.append(np.sqrt(task.weight) * error_task)
    
    J_combined = np.vstack(J_combined)
    error_combined = np.concatenate(error_combined)
    
    # ê°€ì¤‘ ìµœì†Œì œê³± í•´
    q_dot = np.linalg.pinv(J_combined) @ error_combined
    
    return q_dot
```

### íŠ¹ì´ì  ë¶„ì„

#### 1. íŠ¹ì´ì  ì •ì˜

##### ìˆ˜í•™ì  ì¡°ê±´
```python
def analyze_singularity(q):
    """
    íŠ¹ì´ì  ë¶„ì„
    """
    J = compute_jacobian(q)
    
    # ì •ì‚¬ê° ìì½”ë¹„ì•ˆì¸ ê²½ìš°
    if J.shape[0] == J.shape[1]:
        det_J = np.linalg.det(J)
        condition_number = np.linalg.cond(J)
        
        return {
            'determinant': det_J,
            'condition_number': condition_number,
            'is_singular': abs(det_J) < 1e-6,
            'is_ill_conditioned': condition_number > 1e6
        }
    
    # ì§ì‚¬ê° ìì½”ë¹„ì•ˆì¸ ê²½ìš°
    else:
        singular_values = np.linalg.svd(J, compute_uv=False)
        min_sv = np.min(singular_values)
        condition_number = np.max(singular_values) / min_sv
        
        return {
            'singular_values': singular_values,
            'min_singular_value': min_sv,
            'condition_number': condition_number,
            'is_singular': min_sv < 1e-6,
            'rank': np.sum(singular_values > 1e-6)
        }
```

#### 2. íŠ¹ì´ì  ìœ í˜•

##### ìš´ë™í•™ì  íŠ¹ì´ì 
```python
def classify_kinematic_singularity(q, robot_model):
    """
    ìš´ë™í•™ì  íŠ¹ì´ì  ë¶„ë¥˜
    """
    J = compute_jacobian(q)
    
    # íŠ¹ì´ê°’ ë¶„í•´
    U, s, Vt = np.linalg.svd(J)
    
    # ì˜ ê³µê°„ê³¼ ì¹˜ì—­ ë¶„ì„
    null_space_dim = len(s) - np.sum(s > 1e-6)
    
    if null_space_dim > 0:
        # íŠ¹ì´ì  ìœ í˜• íŒë³„
        if is_boundary_singularity(q, robot_model):
            return "Boundary Singularity"
        elif is_internal_singularity(q, robot_model):
            return "Internal Singularity"
        else:
            return "Unknown Singularity"
    
    return "Regular Configuration"

def is_boundary_singularity(q, robot_model):
    """
    ê²½ê³„ íŠ¹ì´ì  í™•ì¸ (ì‘ì—…ê³µê°„ ê²½ê³„)
    """
    end_effector_pos = forward_kinematics(q)[:3]
    max_reach = sum(robot_model.link_lengths)
    distance_from_origin = np.linalg.norm(end_effector_pos)
    
    return abs(distance_from_origin - max_reach) < 0.01
```

#### 3. íŠ¹ì´ì  íšŒí”¼

##### ê°€ì¡°ì‘ë„ (Manipulability) ê¸°ë°˜
```python
def manipulability_measure(q):
    """
    ê°€ì¡°ì‘ë„ ê³„ì‚°
    """
    J = compute_jacobian(q)
    
    if J.shape[0] == J.shape[1]:
        # ì •ì‚¬ê° ìì½”ë¹„ì•ˆ: |det(J)|
        return abs(np.linalg.det(J))
    else:
        # ì§ì‚¬ê° ìì½”ë¹„ì•ˆ: âˆšdet(JJ^T)
        return np.sqrt(np.linalg.det(J @ J.T))

def singularity_avoidance_control(target_velocity, current_q, threshold=0.1):
    """
    íŠ¹ì´ì  íšŒí”¼ ì œì–´
    """
    J = compute_jacobian(current_q)
    manipulability = manipulability_measure(current_q)
    
    if manipulability < threshold:
        # íŠ¹ì´ì  ê·¼ì²˜ì—ì„œ íšŒí”¼ ë™ì‘
        grad_manipulability = compute_manipulability_gradient(current_q)
        
        # ì£¼ íƒœìŠ¤í¬ì™€ íšŒí”¼ íƒœìŠ¤í¬ ê²°í•©
        primary_task = np.linalg.pinv(J) @ target_velocity
        avoidance_task = (threshold - manipulability) * grad_manipulability
        
        # ë„ ê³µê°„ íˆ¬ì˜ìœ¼ë¡œ ê²°í•©
        N = np.eye(len(current_q)) - np.linalg.pinv(J) @ J
        
        joint_velocity = primary_task + N @ avoidance_task
        
    else:
        # ì¼ë°˜ì ì¸ ì œì–´
        joint_velocity = np.linalg.pinv(J) @ target_velocity
    
    return joint_velocity
```

### ì¤‘ë³µ ììœ ë„ í™œìš©

#### 1. ë„ ê³µê°„ í™œìš©

##### ë¶€ì°¨ íƒœìŠ¤í¬ ìˆ˜í–‰
```python
def null_space_control(primary_task_velocity, secondary_objective, current_q):
    """
    ë„ ê³µê°„ì„ ì´ìš©í•œ ë¶€ì°¨ íƒœìŠ¤í¬ ìˆ˜í–‰
    """
    J = compute_jacobian(current_q)
    J_pinv = np.linalg.pinv(J)
    
    # ì£¼ íƒœìŠ¤í¬ í•´
    q_dot_primary = J_pinv @ primary_task_velocity
    
    # ë„ ê³µê°„ íˆ¬ì˜ì
    N = np.eye(len(current_q)) - J_pinv @ J
    
    # ë¶€ì°¨ ëª©ì ì˜ ê¸°ìš¸ê¸°
    if secondary_objective == 'joint_limits':
        grad_secondary = joint_limit_avoidance_gradient(current_q)
    elif secondary_objective == 'manipulability':
        grad_secondary = compute_manipulability_gradient(current_q)
    elif secondary_objective == 'energy':
        grad_secondary = energy_minimization_gradient(current_q)
    else:
        grad_secondary = np.zeros_like(current_q)
    
    # ë¶€ì°¨ íƒœìŠ¤í¬ í•´ (ë„ ê³µê°„ì— íˆ¬ì˜)
    q_dot_secondary = N @ grad_secondary
    
    # ì „ì²´ í•´
    q_dot_total = q_dot_primary + q_dot_secondary
    
    return q_dot_total

def joint_limit_avoidance_gradient(q):
    """
    ê´€ì ˆ í•œê³„ íšŒí”¼ë¥¼ ìœ„í•œ ê¸°ìš¸ê¸°
    """
    gradient = np.zeros_like(q)
    
    for i, qi in enumerate(q):
        q_min, q_max = joint_limits[i]
        q_mid = (q_min + q_max) / 2
        
        # ì¤‘ì ìœ¼ë¡œ í–¥í•˜ëŠ” ê¸°ìš¸ê¸°
        gradient[i] = q_mid - qi
    
    return gradient
```

#### 2. ê°€ì¤‘ ì œì–´

##### ê´€ì ˆë³„ ê°€ì¤‘ì¹˜
```python
def weighted_control(target_velocity, current_q, joint_weights):
    """
    ê´€ì ˆë³„ ê°€ì¤‘ì¹˜ë¥¼ ê³ ë ¤í•œ ì œì–´
    """
    J = compute_jacobian(current_q)
    W = np.diag(joint_weights)
    
    # ê°€ì¤‘ ì˜ì‚¬ì—­í–‰ë ¬
    W_inv = np.linalg.inv(W)
    J_weighted_pinv = W_inv @ J.T @ np.linalg.inv(J @ W_inv @ J.T)
    
    joint_velocity = J_weighted_pinv @ target_velocity
    
    return joint_velocity

def adaptive_weighting(current_q):
    """
    ì ì‘ì  ê°€ì¤‘ì¹˜ ê³„ì‚°
    """
    weights = np.ones(len(current_q))
    
    for i, qi in enumerate(current_q):
        q_min, q_max = joint_limits[i]
        
        # ê´€ì ˆ í•œê³„ì— ê°€ê¹Œìš¸ìˆ˜ë¡ ê°€ì¤‘ì¹˜ ì¦ê°€
        dist_to_min = qi - q_min
        dist_to_max = q_max - qi
        min_dist = min(dist_to_min, dist_to_max)
        
        # í•œê³„ì— ê°€ê¹Œìš°ë©´ ê°€ì¤‘ì¹˜ ì¦ê°€ (ì›€ì§ì´ê¸° ì–´ë µê²Œ)
        if min_dist < 0.1:
            weights[i] = 10.0
        elif min_dist < 0.2:
            weights[i] = 2.0
    
    return weights
```

### ìì½”ë¹„ì•ˆ ë³€í™˜

#### 1. ì¢Œí‘œê³„ ë³€í™˜

##### ë‹¤ë¥¸ ê¸°ì¤€ì ìœ¼ë¡œì˜ ë³€í™˜
```python
def transform_jacobian_to_point(J_original, current_q, new_reference_point):
    """
    ìì½”ë¹„ì•ˆì„ ë‹¤ë¥¸ ê¸°ì¤€ì ìœ¼ë¡œ ë³€í™˜
    """
    # í˜„ì¬ ì—”ë“œ ì´í™í„° ìœ„ì¹˜
    current_ee_pos = forward_kinematics(current_q)[:3]
    
    # ìƒˆ ê¸°ì¤€ì ìœ¼ë¡œì˜ ë²¡í„°
    r = new_reference_point - current_ee_pos
    
    # ë³€í™˜ í–‰ë ¬
    Ad = np.zeros((6, 6))
    Ad[:3, :3] = np.eye(3)
    Ad[3:, 3:] = np.eye(3)
    Ad[:3, 3:] = skew_symmetric(r)
    
    # ë³€í™˜ëœ ìì½”ë¹„ì•ˆ
    J_transformed = Ad @ J_original
    
    return J_transformed

def skew_symmetric(v):
    """
    ë²¡í„°ì˜ ë°˜ëŒ€ì¹­ í–‰ë ¬
    """
    return np.array([[0, -v[2], v[1]],
                     [v[2], 0, -v[0]],
                     [-v[1], v[0], 0]])
```

#### 2. ì†ë„ í‘œí˜„ ë³€í™˜

##### ê°ì†ë„ í‘œí˜„ ë³€í™˜
```python
def convert_angular_velocity_representation(J_geometric, current_orientation):
    """
    ê¸°í•˜í•™ì  ìì½”ë¹„ì•ˆì„ í•´ì„ì  ìì½”ë¹„ì•ˆìœ¼ë¡œ ë³€í™˜
    (ê°ì†ë„ ë²¡í„° â†’ ì˜¤ì¼ëŸ¬ê° ë¯¸ë¶„)
    """
    # ì˜¤ì¼ëŸ¬ê°ì—ì„œ ê°ì†ë„ë¡œì˜ ë³€í™˜ í–‰ë ¬
    T_omega = compute_omega_transformation_matrix(current_orientation)
    
    # ë³€í™˜ í–‰ë ¬ êµ¬ì„±
    T = np.zeros((6, 6))
    T[:3, :3] = np.eye(3)  # ì„ ì†ë„ëŠ” ê·¸ëŒ€ë¡œ
    T[3:, 3:] = T_omega    # ê°ì†ë„ ë³€í™˜
    
    J_analytical = T @ J_geometric
    
    return J_analytical
```

### ê³„ì‚° ìµœì í™”

#### 1. íš¨ìœ¨ì  ê³„ì‚°

##### ì¬ê·€ì  ê³„ì‚°
```python
def recursive_jacobian_computation(q, dh_params):
    """
    ì¬ê·€ì  ìì½”ë¹„ì•ˆ ê³„ì‚° (O(n) ë³µì¡ë„)
    """
    n = len(q)
    J = np.zeros((6, n))
    
    # ì „ë°©í–¥ ì¬ê·€: ë³€í™˜ í–‰ë ¬ë“¤ ê³„ì‚°
    T = [np.eye(4)]
    for i in range(n):
        Ti = dh_transform(dh_params[i], q[i])
        T.append(T[-1] @ Ti)
    
    # ì—”ë“œ ì´í™í„° ìœ„ì¹˜
    pe = T[-1][:3, 3]
    
    # ê° ê´€ì ˆì— ëŒ€í•œ ìì½”ë¹„ì•ˆ ì—´ ê³„ì‚°
    for i in range(n):
        # ê´€ì ˆ iì˜ ì¶•ê³¼ ìœ„ì¹˜
        zi = T[i][:3, 2]
        pi = T[i][:3, 3]
        
        # ìì½”ë¹„ì•ˆ ië²ˆì§¸ ì—´
        if dh_params[i]['type'] == 'revolute':
            J[:3, i] = np.cross(zi, pe - pi)
            J[3:, i] = zi
        else:  # prismatic
            J[:3, i] = zi
            J[3:, i] = 0
    
    return J
```

#### 2. ìˆ˜ì¹˜ì  ì•ˆì •ì„±

##### ì¡°ê±´ìˆ˜ ëª¨ë‹ˆí„°ë§
```python
def stable_jacobian_inversion(J, condition_threshold=1e6):
    """
    ìˆ˜ì¹˜ì ìœ¼ë¡œ ì•ˆì •í•œ ìì½”ë¹„ì•ˆ ì—­ì‚°
    """
    # SVD ë¶„í•´
    U, s, Vt = np.linalg.svd(J)
    
    # ì¡°ê±´ìˆ˜ í™•ì¸
    condition_number = s[0] / s[-1] if s[-1] > 0 else np.inf
    
    if condition_number > condition_threshold:
        # íŠ¹ì´ê°’ ì„ê³„í™”
        s_filtered = np.where(s > s[0]/condition_threshold, s, 0)
        
        # í•„í„°ë§ëœ ì˜ì‚¬ì—­í–‰ë ¬
        s_inv = np.where(s_filtered > 0, 1/s_filtered, 0)
        J_pinv = Vt.T @ np.diag(s_inv) @ U.T
        
        return J_pinv, True  # í•„í„°ë§ë¨
    else:
        # ì¼ë°˜ ì˜ì‚¬ì—­í–‰ë ¬
        J_pinv = Vt.T @ np.diag(1/s) @ U.T
        return J_pinv, False  # í•„í„°ë§ ì•ˆë¨
```

### ì‹¤ì‹œê°„ ì‘ìš©

#### 1. ì‹¤ì‹œê°„ ìì½”ë¹„ì•ˆ ê³„ì‚°

##### í•˜ë“œì›¨ì–´ ìµœì í™”
```python
class RealTimeJacobianComputer:
    def __init__(self, robot_model):
        self.robot = robot_model
        self.prev_q = None
        self.prev_J = None
        self.update_threshold = 0.01  # rad
    
    def compute(self, current_q):
        """
        ì‹¤ì‹œê°„ ìì½”ë¹„ì•ˆ ê³„ì‚°
        """
        # ì´ì „ ê³„ì‚° ê²°ê³¼ ì¬ì‚¬ìš© ê²€ì‚¬
        if (self.prev_q is not None and 
            np.linalg.norm(current_q - self.prev_q) < self.update_threshold):
            return self.prev_J
        
        # ìƒˆë¡œ ê³„ì‚°
        J = self.fast_jacobian_computation(current_q)
        
        # ìºì‹œ ì—…ë°ì´íŠ¸
        self.prev_q = current_q.copy()
        self.prev_J = J.copy()
        
        return J
```

## 6. ê¶¤ì  ìµœì í™” (Trajectory Optimization)

### ì •ì˜

ê¶¤ì  ìµœì í™”(Trajectory Optimization)ëŠ” ë¡œë´‡ì´ ì´ˆê¸° ìƒíƒœì—ì„œ ëª©í‘œ ìƒíƒœê¹Œì§€ ì´ë™í•˜ëŠ” ê³¼ì •ì—ì„œ íŠ¹ì • ì„±ëŠ¥ ì§€í‘œë¥¼ ìµœì í™”í•˜ëŠ” ì‹œê°„ì— ë”°ë¥¸ ìƒíƒœì™€ ì œì–´ ì…ë ¥ì˜ ìµœì  ê¶¤ì ì„ ì°¾ëŠ” ê¸°ë²•ì…ë‹ˆë‹¤.

### ìˆ˜í•™ì  ì •ì˜

#### ì¼ë°˜ì  í˜•íƒœ
```
minimize: J = âˆ«â‚€áµ€ L(x(t), u(t), t) dt + Î¦(x(T))

subject to: áº‹(t) = f(x(t), u(t), t)
           x(0) = xâ‚€
           x(T) = xf (ë˜ëŠ” ììœ )
           g(x(t), u(t), t) â‰¤ 0
           h(x(t), u(t), t) = 0

ì—¬ê¸°ì„œ:
- x(t): ì‹œê°„ tì—ì„œì˜ ìƒíƒœ ë²¡í„°
- u(t): ì‹œê°„ tì—ì„œì˜ ì œì–´ ì…ë ¥
- L(Â·): ìˆœê°„ ë¹„ìš© í•¨ìˆ˜
- Î¦(Â·): ì¢…ë£Œ ë¹„ìš© í•¨ìˆ˜
- f(Â·): ì‹œìŠ¤í…œ ë™ì—­í•™
- g(Â·), h(Â·): ë¶€ë“±ì‹/ë“±ì‹ ì œì•½
```

#### ì´ì‚°í™”ëœ í˜•íƒœ
```
minimize: J = Î£â‚–â‚Œâ‚€á´ºâ»Â¹ L(xâ‚–, uâ‚–, kÂ·Î”t) + Î¦(xâ‚™)

subject to: xâ‚–â‚Šâ‚ = f_d(xâ‚–, uâ‚–, kÂ·Î”t)
           xâ‚€ = x_initial
           xâ‚™ âˆˆ X_final
           gâ‚–(xâ‚–, uâ‚–) â‰¤ 0, k = 0,1,...,N-1
           hâ‚–(xâ‚–, uâ‚–) = 0, k = 0,1,...,N-1
```

### ìµœì í™” ê¸°ë²• ë¶„ë¥˜

#### 1. ì§ì ‘ ë°©ë²• (Direct Methods)

##### ë‹¨ì¼ ì‚¬ê²©ë²• (Single Shooting)
```python
def single_shooting_optimization(initial_state, final_state, horizon, dynamics):
    """
    ë‹¨ì¼ ì‚¬ê²©ë²•ì„ ì´ìš©í•œ ê¶¤ì  ìµœì í™”
    """
    # ì œì–´ ì…ë ¥ë§Œì„ ìµœì í™” ë³€ìˆ˜ë¡œ ì‚¬ìš©
    def objective(u_flat):
        u_sequence = u_flat.reshape((horizon, control_dim))
        
        # ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰
        states = [initial_state]
        cost = 0
        
        for k in range(horizon):
            # ë‹¤ìŒ ìƒíƒœ ê³„ì‚°
            x_next = dynamics(states[-1], u_sequence[k], k*dt)
            states.append(x_next)
            
            # ìˆœê°„ ë¹„ìš© ëˆ„ì 
            cost += stage_cost(states[-2], u_sequence[k], k*dt)
        
        # ì¢…ë£Œ ë¹„ìš© ì¶”ê°€
        cost += terminal_cost(states[-1], final_state)
        
        return cost
    
    def constraints(u_flat):
        u_sequence = u_flat.reshape((horizon, control_dim))
        states = simulate_trajectory(initial_state, u_sequence, dynamics)
        
        constraints_violation = []
        
        for k in range(horizon + 1):
            # ìƒíƒœ ì œì•½
            state_constraints = evaluate_state_constraints(states[k], k*dt)
            constraints_violation.extend(state_constraints)
            
            # ì œì–´ ì œì•½ (ë§ˆì§€ë§‰ ìŠ¤í… ì œì™¸)
            if k < horizon:
                control_constraints = evaluate_control_constraints(u_sequence[k], k*dt)
                constraints_violation.extend(control_constraints)
        
        return np.array(constraints_violation)
    
    # ìµœì í™” ì‹¤í–‰
    initial_guess = np.zeros(horizon * control_dim)
    
    result = minimize(
        objective,
        initial_guess,
        method='SLSQP',
        constraints={'type': 'ineq', 'fun': lambda u: -constraints(u)},
        options={'maxiter': 1000}
    )
    
    return result
```

##### ë‹¤ì¤‘ ì‚¬ê²©ë²• (Multiple Shooting)
```python
def multiple_shooting_optimization(initial_state, final_state, horizon, dynamics):
    """
    ë‹¤ì¤‘ ì‚¬ê²©ë²•ì„ ì´ìš©í•œ ê¶¤ì  ìµœì í™”
    """
    # ìƒíƒœì™€ ì œì–´ë¥¼ ëª¨ë‘ ìµœì í™” ë³€ìˆ˜ë¡œ ì‚¬ìš©
    def objective_and_constraints(z):
        states, controls = unpack_decision_variables(z, horizon)
        
        objective = 0
        defect_constraints = []
        
        for k in range(horizon):
            # ìˆœê°„ ë¹„ìš©
            objective += stage_cost(states[k], controls[k], k*dt)
            
            # ë™ì—­í•™ ì œì•½ (defect constraints)
            x_next_predicted = dynamics(states[k], controls[k], k*dt)
            defect = states[k+1] - x_next_predicted
            defect_constraints.extend(defect)
        
        # ì¢…ë£Œ ë¹„ìš©
        objective += terminal_cost(states[-1], final_state)
        
        return objective, np.array(defect_constraints)
    
    # ê²½ê³„ ì¡°ê±´ ì œì•½
    def boundary_constraints(z):
        states, controls = unpack_decision_variables(z, horizon)
        
        # ì´ˆê¸° ì¡°ê±´
        initial_constraint = states[0] - initial_state
        
        return initial_constraint
    
    # ì´ˆê¸° ì¶”ì •
    initial_guess = generate_initial_trajectory_guess(initial_state, final_state, horizon)
    
    # ìµœì í™” ì‹¤í–‰
    result = minimize(
        lambda z: objective_and_constraints(z)[0],
        initial_guess,
        method='SLSQP',
        constraints=[
            {'type': 'eq', 'fun': lambda z: objective_and_constraints(z)[1]},  # ë™ì—­í•™ ì œì•½
            {'type': 'eq', 'fun': boundary_constraints}  # ê²½ê³„ ì¡°ê±´
        ]
    )
    
    return result
```


##### ì½œë¡œì¼€ì´ì…˜ ë°©ë²• (Collocation Methods)
```python
def collocation_optimization(initial_state, final_state, N_segments, dynamics):
    """
    ì½œë¡œì¼€ì´ì…˜ ë°©ë²•ì„ ì´ìš©í•œ ê¶¤ì  ìµœì í™”
    """
    # ë¥´ì¥ë“œë¥´-ê°€ìš°ìŠ¤-ë¡œë°”í†  ì ë“¤ ì‚¬ìš©
    tau, weights = legendre_gauss_lobatto_points(degree=3)
    
    def setup_collocation_constraints():
        constraints = []
        
        for seg in range(N_segments):
            # ê° ì„¸ê·¸ë¨¼íŠ¸ì˜ ì‹œì‘ê³¼ ë
            t_start = seg * segment_duration
            t_end = (seg + 1) * segment_duration
            
            # ì½œë¡œì¼€ì´ì…˜ ì ë“¤ì—ì„œì˜ ë™ì—­í•™ ì œì•½
            for i, tau_i in enumerate(tau[1:-1]):  # ë‚´ë¶€ ì ë“¤ë§Œ
                t_col = t_start + tau_i * segment_duration
                
                # ìƒíƒœì™€ ì œì–´ë¥¼ ë³´ê°„
                x_col = interpolate_state(seg, tau_i)
                u_col = interpolate_control(seg, tau_i)
                
                # ìƒíƒœ ë„í•¨ìˆ˜ ê³„ì‚° (ë¼ê·¸ë‘ì£¼ ë³´ê°„ ë¯¸ë¶„)
                x_dot_col = compute_state_derivative(seg, tau_i)
                
                # ë™ì—­í•™ ì œì•½
                f_col = dynamics(x_col, u_col, t_col)
                defect = x_dot_col - f_col
                
                constraints.extend(defect)
        
        return np.array(constraints)
    
    # ëª©ì  í•¨ìˆ˜ (ê°€ìš°ìŠ¤ ì ë¶„)
    def objective(decision_vars):
        cost = 0
        
        for seg in range(N_segments):
            for i, (tau_i, w_i) in enumerate(zip(tau, weights)):
                t_col = seg * segment_duration + tau_i * segment_duration
                x_col = interpolate_state(seg, tau_i)
                u_col = interpolate_control(seg, tau_i)
                
                stage_cost_val = stage_cost(x_col, u_col, t_col)
                cost += w_i * segment_duration * stage_cost_val
        
        # ì¢…ë£Œ ë¹„ìš©
        final_state = get_final_state()
        cost += terminal_cost(final_state, final_state)
        
        return cost
    
    # ìµœì í™” ì‹¤í–‰
    return minimize(
        objective,
        initial_guess,
        constraints={'type': 'eq', 'fun': setup_collocation_constraints}
    )
```

#### 2. ê°„ì ‘ ë°©ë²• (Indirect Methods)

##### í•„ìš”ì¡°ê±´ ê¸°ë°˜ í•´ë²•
```python
def indirect_optimization_pontryagin(initial_state, final_state, dynamics, hamiltonian):
    """
    í°íŠ¸ë¼ê¸´ ìµœì†Œ ì›ë¦¬ë¥¼ ì´ìš©í•œ ê°„ì ‘ ìµœì í™”
    """
    def two_point_bvp_residual(z):
        """
        2ì  ê²½ê³„ê°’ ë¬¸ì œì˜ ì”ì°¨
        """
        # z = [x(0), Î»(0), T]
        N_states = len(initial_state)
        x0 = z[:N_states]
        lambda0 = z[N_states:2*N_states]
        T = z[-1]
        
        # ìƒíƒœì™€ ê³µìƒíƒœ ë°©ì •ì‹ ì ë¶„
        def augmented_dynamics(t, y):
            x = y[:N_states]
            lam = y[N_states:]
            
            # ìµœì  ì œì–´ ê³„ì‚° (í•´ë°€í† ë‹ˆì•ˆ ìµœì†Œí™”)
            u_opt = compute_optimal_control(x, lam, t)
            
            # ìƒíƒœ ë°©ì •ì‹
            x_dot = dynamics(x, u_opt, t)
            
            # ê³µìƒíƒœ ë°©ì •ì‹ (í•´ë°€í† ë‹ˆì•ˆì˜ ìƒíƒœì— ëŒ€í•œ ìŒì˜ í¸ë¯¸ë¶„)
            lambda_dot = -compute_hamiltonian_state_gradient(x, lam, u_opt, t)
            
            return np.concatenate([x_dot, lambda_dot])
        
        # ì ë¶„ ì‹¤í–‰
        sol = solve_ivp(
            augmented_dynamics,
            [0, T],
            np.concatenate([x0, lambda0]),
            dense_output=True
        )
        
        # ì¢…ë£Œ ì¡°ê±´
        x_final = sol.y[:N_states, -1]
        lambda_final = sol.y[N_states:, -1]
        
        # ê²½ê³„ ì¡°ê±´ ì”ì°¨
        residual = []
        
        # ì´ˆê¸° ìƒíƒœ ì¡°ê±´
        residual.extend(x0 - initial_state)
        
        # ì¢…ë£Œ ìƒíƒœ ì¡°ê±´
        residual.extend(x_final - final_state)
        
        # íš¡ë‹¨ ì¡°ê±´ (ì¢…ë£Œ ì‹œê°„ì´ ììœ ì¸ ê²½ìš°)
        H_final = hamiltonian(x_final, lambda_final, 
                             compute_optimal_control(x_final, lambda_final, T), T)
        residual.append(H_final)  # H(T) = 0
        
        return np.array(residual)
    
    # ì´ˆê¸° ì¶”ì •
    initial_guess = np.concatenate([
        initial_state,
        np.ones_like(initial_state),  # ê³µìƒíƒœ ì´ˆê¸° ì¶”ì •
        [1.0]  # ì¢…ë£Œ ì‹œê°„ ì¶”ì •
    ])
    
    # ë‰´í„´-ë©ìŠ¨ìœ¼ë¡œ í•´ê²°
    solution = fsolve(two_point_bvp_residual, initial_guess)
    
    return solution
```

#### 3. í˜¼í•© ë°©ë²• (Hybrid Methods)

##### ì§ì ‘-ê°„ì ‘ ë°©ë²•
```python
def hybrid_direct_indirect_optimization(problem_setup):
    """
    ì§ì ‘ ë°©ë²•ìœ¼ë¡œ ì´ˆê¸°í•´ë¥¼ êµ¬í•œ í›„ ê°„ì ‘ ë°©ë²•ìœ¼ë¡œ ì •ì œ
    """
    # 1ë‹¨ê³„: ì§ì ‘ ë°©ë²•ìœ¼ë¡œ ëŒ€ëµì  í•´ êµ¬í•˜ê¸°
    print("Phase 1: Direct method for initial solution...")
    direct_result = multiple_shooting_optimization(**problem_setup)
    
    # 2ë‹¨ê³„: ì§ì ‘ ë°©ë²• ê²°ê³¼ë¥¼ ê°„ì ‘ ë°©ë²•ì˜ ì´ˆê¸° ì¶”ì •ìœ¼ë¡œ ì‚¬ìš©
    print("Phase 2: Indirect method for refinement...")
    
    # ê³µìƒíƒœ ì´ˆê¸° ì¶”ì • (KKT ì¡°ê±´ìœ¼ë¡œë¶€í„°)
    lambda_initial = estimate_costate_from_direct_solution(direct_result)
    
    # ê°„ì ‘ ë°©ë²• ì‹¤í–‰
    indirect_result = indirect_optimization_pontryagin(
        initial_state=problem_setup['initial_state'],
        final_state=problem_setup['final_state'],
        dynamics=problem_setup['dynamics'],
        hamiltonian=problem_setup['hamiltonian']
    )
    
    return indirect_result
```

### íœ´ë¨¸ë…¸ì´ë“œ íŠ¹ìˆ˜ ì‘ìš©

#### 1. ë³´í–‰ ê¶¤ì  ìµœì í™”

##### ì£¼ê¸°ì  ë³´í–‰ ìµœì í™”
```python
def periodic_walking_optimization(step_length, step_time, robot_model):
    """
    ì£¼ê¸°ì  ë³´í–‰ì„ ìœ„í•œ ê¶¤ì  ìµœì í™”
    """
    def objective(decision_vars):
        joint_trajectories, com_trajectory, foot_trajectories = unpack_variables(decision_vars)
        
        cost = 0
        
        # ì—ë„ˆì§€ ìµœì†Œí™”
        for k in range(N_knots-1):
            joint_velocities = (joint_trajectories[k+1] - joint_trajectories[k]) / dt
            joint_accelerations = compute_joint_accelerations(joint_trajectories, k)
            
            # í† í¬ ê³„ì‚°
            torques = compute_inverse_dynamics(
                joint_trajectories[k], joint_velocities, joint_accelerations
            )
            
            # ì—ë„ˆì§€ ë¹„ìš©
            cost += dt * np.sum(torques**2)
        
        # ë¶€ë“œëŸ¬ì›€ ë¹„ìš©
        smoothness_cost = compute_trajectory_smoothness(joint_trajectories)
        cost += 10.0 * smoothness_cost
        
        # ZMP ì•ˆì •ì„± ë¹„ìš©
        zmp_cost = compute_zmp_stability_cost(joint_trajectories, com_trajectory)
        cost += 100.0 * zmp_cost
        
        return cost
    
    def constraints(decision_vars):
        joint_trajectories, com_trajectory, foot_trajectories = unpack_variables(decision_vars)
        
        violations = []
        
        for k in range(N_knots):
            # ê¸°êµ¬í•™ ì¼ê´€ì„±
            computed_com = compute_com_from_joints(joint_trajectories[k])
            com_error = com_trajectory[k] - computed_com
            violations.extend(com_error)
            
            # ZMP ì œì•½
            zmp = compute_zmp(joint_trajectories[k])
            support_polygon = get_support_polygon(foot_trajectories, k)
            
            if not point_in_polygon(zmp, support_polygon):
                violations.append(distance_to_polygon(zmp, support_polygon))
        
        # ì£¼ê¸°ì„± ì œì•½
        periodicity_error = joint_trajectories[-1] - joint_trajectories[0]
        violations.extend(periodicity_error)
        
        return np.array(violations)
    
    # ìµœì í™” ì‹¤í–‰
    result = minimize(
        objective,
        initial_guess,
        method='SLSQP',
        constraints={'type': 'ineq', 'fun': lambda x: -constraints(x)},
        options={'maxiter': 500, 'ftol': 1e-6}
    )
    
    return result
```

##### ì§€í˜• ì ì‘ ë³´í–‰
```python
def terrain_adaptive_walking_optimization(terrain_map, robot_model):
    """
    ì§€í˜•ì— ì ì‘í•˜ëŠ” ë³´í–‰ ê¶¤ì  ìµœì í™”
    """
    def terrain_constraint(decision_vars, k):
        """
        ì§€í˜• ì œì•½ ì¡°ê±´
        """
        foot_positions = extract_foot_positions(decision_vars, k)
        violations = []
        
        for foot_pos in foot_positions:
            # ì§€ë©´ ë†’ì´ ê³„ì‚°
            ground_height = terrain_map.get_height(foot_pos[:2])
            
            # ë°œì´ ì§€ë©´ ìœ„ì— ìˆì–´ì•¼ í•¨
            clearance = foot_pos[2] - ground_height
            if clearance < min_foot_clearance:
                violations.append(min_foot_clearance - clearance)
        
        return violations
    
    def stability_on_terrain(decision_vars):
        """
        ë¶ˆê·œì¹™ ì§€í˜•ì—ì„œì˜ ì•ˆì •ì„± ë¹„ìš©
        """
        cost = 0
        
        for k in range(N_knots):
            # í˜„ì¬ ì§€ì§€ ë°œì˜ ìœ„ì¹˜
            support_feet = get_support_feet(decision_vars, k)
            
            # ê° ì§€ì§€ ë°œì—ì„œì˜ ì§€ë©´ ê²½ì‚¬
            for foot in support_feet:
                foot_pos = foot['position']
                ground_normal = terrain_map.get_normal(foot_pos[:2])
                
                # ì§€ë©´ ê²½ì‚¬ì— ë”°ë¥¸ ì•ˆì •ì„± ë¹„ìš©
                slope_angle = np.arccos(np.dot(ground_normal, [0, 0, 1]))
                cost += slope_penalty_weight * slope_angle**2
        
        return cost
    
    # ì§€í˜• ì œì•½ì„ í¬í•¨í•œ ìµœì í™”
    enhanced_constraints = lambda x: np.concatenate([
        base_constraints(x),
        np.concatenate([terrain_constraint(x, k) for k in range(N_knots)])
    ])
    
    enhanced_objective = lambda x: (
        base_objective(x) + stability_on_terrain(x)
    )
    
    result = minimize(
        enhanced_objective,
        base_result.x,
        constraints={'type': 'ineq', 'fun': lambda x: -enhanced_constraints(x)}
    )
    
    return result
```

#### 2. ì „ì‹  ë™ì‘ ìµœì í™”

##### ë³µí•© íƒœìŠ¤í¬ ìµœì í™”
```python
def whole_body_task_optimization(tasks, robot_model, time_horizon):
    """
    ì—¬ëŸ¬ íƒœìŠ¤í¬ë¥¼ ë™ì‹œì— ìˆ˜í–‰í•˜ëŠ” ì „ì‹  ë™ì‘ ìµœì í™”
    """
    def multi_task_objective(decision_vars):
        joint_trajectories = reshape_decision_vars(decision_vars)
        total_cost = 0
        
        for task in tasks:
            task_cost = 0
            
            for k in range(N_knots):
                # íƒœìŠ¤í¬ë³„ ì„±ëŠ¥ í‰ê°€
                if task.type == 'reaching':
                    end_effector_pos = compute_end_effector_position(
                        joint_trajectories[k], task.chain
                    )
                    error = np.linalg.norm(end_effector_pos - task.target_position[k])
                    task_cost += task.weight * error**2
                
                elif task.type == 'balance':
                    com_pos = compute_com_position(joint_trajectories[k])
                    zmp = compute_zmp(joint_trajectories[k])
                    
                    # ZMPê°€ ì§€ì§€ ì˜ì—­ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
                    support_polygon = task.support_polygon[k]
                    if not point_in_polygon(zmp, support_polygon):
                        dist = distance_to_polygon(zmp, support_polygon)
                        task_cost += task.weight * 1000 * dist**2
                
                elif task.type == 'posture':
                    posture_error = joint_trajectories[k] - task.reference_posture[k]
                    task_cost += task.weight * np.sum(posture_error**2)
            
            total_cost += task_cost
        
        # ë¶€ë“œëŸ¬ì›€ ì •ê·œí™”
        smoothness_cost = 0
        for k in range(N_knots-1):
            joint_vel = (joint_trajectories[k+1] - joint_trajectories[k]) / dt
            smoothness_cost += np.sum(joint_vel**2)
        
        total_cost += smoothness_weight * smoothness_cost
        
        return total_cost
    
    # ìµœì í™” ì‹¤í–‰
    initial_guess = generate_multi_task_initial_guess(tasks, robot_model)
    
    result = minimize(
        multi_task_objective,
        initial_guess,
        method='SLSQP',
        constraints={'type': 'eq', 'fun': hierarchical_task_constraints},
        options={'maxiter': 1000}
    )
    
    return result
```

### ì‹¤ì‹œê°„ ê¶¤ì  ìµœì í™”

#### 1. Model Predictive Control (MPC)

##### ìˆœí™˜ ìµœì í™”
```python
class RealTimeMPC:
    def __init__(self, robot_model, prediction_horizon, control_horizon):
        self.robot = robot_model
        self.N_pred = prediction_horizon
        self.N_ctrl = control_horizon
        self.dt = 0.01
        
    def solve_mpc(self, current_state, reference_trajectory):
        """
        MPC ìµœì í™” ë¬¸ì œ í•´ê²°
        """
        def mpc_objective(u_sequence):
            u_seq = u_sequence.reshape((self.N_ctrl, self.robot.n_controls))
            
            # ìƒíƒœ ì˜ˆì¸¡
            predicted_states = self.predict_states(current_state, u_seq)
            
            cost = 0
            
            # ì¶”ì  ì˜¤ì°¨ ë¹„ìš©
            for k in range(self.N_pred):
                if k < len(reference_trajectory):
                    tracking_error = predicted_states[k] - reference_trajectory[k]
                    cost += np.sum(Q @ tracking_error**2)
                
                # ì œì–´ ë¹„ìš©
                if k < self.N_ctrl:
                    cost += np.sum(R @ u_seq[k]**2)
            
            return cost
        
        # ì‹¤ì‹œê°„ ìµœì í™” (ì œí•œëœ ë°˜ë³µ)
        result = minimize(
            mpc_objective,
            initial_guess,
            method='SQP',
            constraints={'type': 'ineq', 'fun': lambda u: -mpc_constraints(u)},
            options={'maxiter': 50}  # ì‹¤ì‹œê°„ ì œì•½
        )
        
        # ì²« ë²ˆì§¸ ì œì–´ ì…ë ¥ ë°˜í™˜
        optimal_controls = result.x.reshape((self.N_ctrl, self.robot.n_controls))
        return optimal_controls[0]
```

#### 2. ì ì‘í˜• ê¶¤ì  ìµœì í™”

##### ì˜¨ë¼ì¸ ì¬ê³„íš
```python
class AdaptiveTrajectoryPlanner:
    def __init__(self, robot_model):
        self.robot = robot_model
        self.current_plan = None
        self.replanning_threshold = 0.1
        
    def update_trajectory(self, current_state, current_target, disturbances):
        """
        ìƒí™© ë³€í™”ì— ë”°ë¥¸ ê¶¤ì  ì˜¨ë¼ì¸ ì—…ë°ì´íŠ¸
        """
        # í˜„ì¬ ê³„íšê³¼ì˜ í¸ì°¨ í™•ì¸
        if self.current_plan is not None:
            deviation = self.compute_plan_deviation(current_state)
            
            if deviation > self.replanning_threshold:
                return self.replan_trajectory(current_state, current_target)
        
        # ì™¸ë€ ê°ì§€ ë° ëŒ€ì‘
        if self.detect_significant_disturbance(disturbances):
            return self.robust_replan(current_state, current_target, disturbances)
        
        # ëª©í‘œ ë³€ê²½ ëŒ€ì‘
        if self.target_changed(current_target):
            return self.replan_trajectory(current_state, current_target)
        
        # í˜„ì¬ ê³„íš ìœ ì§€
        return self.get_current_plan_segment(current_state)
    
    def robust_replan(self, current_state, target_state, disturbances):
        """
        ì™¸ë€ì„ ê³ ë ¤í•œ ê°•ê±´í•œ ì¬ê³„íš
        """
        # ì™¸ë€ ëª¨ë¸ ì—…ë°ì´íŠ¸
        disturbance_model = self.update_disturbance_model(disturbances)
        
        # ê°•ê±´í•œ ëª©ì í•¨ìˆ˜ (ìµœì•…ì˜ ê²½ìš° ê³ ë ¤)
        def robust_objective(decision_vars):
            nominal_cost = self.compute_nominal_cost(decision_vars)
            worst_case_cost = self.compute_worst_case_cost(decision_vars, disturbance_model)
            
            return nominal_cost + robustness_weight * worst_case_cost
        
        # ê°•ê±´í•œ ìµœì í™” ì‹¤í–‰
        result = minimize(
            robust_objective,
            self.get_warm_start_guess(),
            constraints={'type': 'ineq', 'fun': robust_constraints},
            options={'maxiter': 100}
        )
        
        return result
```

### ê³ ê¸‰ ìµœì í™” ê¸°ë²•

#### 1. ë‹¤ëª©ì  ìµœì í™”

##### íŒŒë ˆí†  ìµœì  í•´ë²•
```python
def multi_objective_trajectory_optimization(objectives, weights=None):
    """
    ë‹¤ëª©ì  ê¶¤ì  ìµœì í™”
    """
    if weights is None:
        # íŒŒë ˆí†  í”„ë¡ íŠ¸ íƒìƒ‰
        return compute_pareto_front(objectives)
    else:
        # ê°€ì¤‘í•© ë°©ë²•
        return weighted_sum_optimization(objectives, weights)

def compute_pareto_front(objectives):
    """
    íŒŒë ˆí†  ìµœì  í•´ ì§‘í•© ê³„ì‚°
    """
    pareto_solutions = []
    
    # ë‹¤ì–‘í•œ ê°€ì¤‘ì¹˜ ì¡°í•©ìœ¼ë¡œ ìµœì í™”
    for weight_combination in generate_weight_combinations(len(objectives)):
        def weighted_objective(decision_vars):
            costs = [obj(decision_vars) for obj in objectives]
            return sum(w * c for w, c in zip(weight_combination, costs))
        
        # ê°œë³„ ìµœì í™”
        result = minimize(weighted_objective, initial_guess)
        
        if result.success:
            # íŒŒë ˆí†  ìµœì ì„± í™•ì¸
            objective_values = [obj(result.x) for obj in objectives]
            
            if is_pareto_optimal(objective_values, pareto_solutions):
                pareto_solutions.append({
                    'solution': result.x,
                    'objectives': objective_values,
                    'weights': weight_combination
                })
    
    return pareto_solutions
```

#### 2. í™•ë¥ ì  ìµœì í™”

##### ê°•ê±´í•œ ìµœì í™”
```python
def robust_trajectory_optimization(nominal_problem, uncertainty_model):
    """
    ë¶ˆí™•ì‹¤ì„±ì„ ê³ ë ¤í•œ ê°•ê±´í•œ ê¶¤ì  ìµœì í™”
    """
    def robust_objective(decision_vars):
        # ëª¬í…Œ ì¹´ë¥¼ë¡œ ìƒ˜í”Œë§ìœ¼ë¡œ ê¸°ëŒ“ê°’ ê³„ì‚°
        costs = []
        
        for _ in range(n_samples):
            # ë¶ˆí™•ì‹¤ì„± ìƒ˜í”Œë§
            uncertainty_sample = uncertainty_model.sample()
            
            # ìƒ˜í”Œì— ëŒ€í•œ ë¹„ìš© ê³„ì‚°
            perturbed_cost = compute_cost_with_uncertainty(decision_vars, uncertainty_sample)
            costs.append(perturbed_cost)
        
        # í‰ê·  + ë¶„ì‚° í˜ë„í‹° (mean-variance ìµœì í™”)
        mean_cost = np.mean(costs)
        var_cost = np.var(costs)
        
        return mean_cost + risk_aversion_parameter * var_cost
    
    def chance_constraints(decision_vars):
        """
        í™•ë¥ ì  ì œì•½ (chance constraints)
        """
        violation_probabilities = []
        
        for constraint_func in constraint_functions:
            violations = 0
            
            for _ in range(n_samples):
                uncertainty_sample = uncertainty_model.sample()
                constraint_value = constraint_func(decision_vars, uncertainty_sample)
                
                if constraint_value > 0:  # ì œì•½ ìœ„ë°˜
                    violations += 1
            
            violation_prob = violations / n_samples
            
            # í—ˆìš© ìœ„ë°˜ í™•ë¥  ì´í•˜ì—¬ì•¼ í•¨
            violation_probabilities.append(violation_prob - allowable_violation_probability)
        
        return np.array(violation_probabilities)
    
    # ê°•ê±´í•œ ìµœì í™” ì‹¤í–‰
    result = minimize(
        robust_objective,
        initial_guess,
        constraints={'type': 'ineq', 'fun': lambda x: -chance_constraints(x)}
    )
    
    return result
```

## 7. ì „ì‹  ì œì–´ ê¸°ë²• (Whole-body Control)

### ì •ì˜

ì „ì‹  ì œì–´ ê¸°ë²•(Whole-body Control)ì€ íœ´ë¨¸ë…¸ì´ë“œ ë¡œë´‡ì˜ ëª¨ë“  ê´€ì ˆì„ í†µí•©ì ìœ¼ë¡œ ì œì–´í•˜ì—¬ ì—¬ëŸ¬ íƒœìŠ¤í¬ë¥¼ ë™ì‹œì— ìˆ˜í–‰í•˜ë©´ì„œë„ ë¬¼ë¦¬ì  ì œì•½ê³¼ ì•ˆì •ì„±ì„ ë³´ì¥í•˜ëŠ” ê³ ê¸‰ ì œì–´ ë°©ë²•ì…ë‹ˆë‹¤.

### ê¸°ë³¸ ê°œë…

#### ë‹¤ì¤‘ íƒœìŠ¤í¬ ì œì–´ ë¬¸ì œ
```
ì£¼ì–´ì§„ ì¡°ê±´:
- nê°œì˜ ê´€ì ˆ (q âˆˆ â„â¿)
- mê°œì˜ íƒœìŠ¤í¬ (ê°ê° ì°¨ì› káµ¢)
- ë¬¼ë¦¬ì  ì œì•½ì¡°ê±´

ëª©í‘œ:
ëª¨ë“  íƒœìŠ¤í¬ë¥¼ ë™ì‹œì— ë§Œì¡±í•˜ë©´ì„œ
ë¬¼ë¦¬ì  ì‹¤í˜„ ê°€ëŠ¥ì„± ë³´ì¥
```

#### ìˆ˜í•™ì  í‘œí˜„
```
íƒœìŠ¤í¬ iì˜ ëª©ì : áº‹áµ¢ = Jáµ¢(q) Ã— qÌ‡ = áº‹áµ¢áµˆ

ì „ì²´ ë¬¸ì œ:
minimize: Î£áµ¢ wáµ¢ ||Jáµ¢(q)qÌ‡ - áº‹áµ¢áµˆ||Â²

subject to: 
- ê´€ì ˆ í•œê³„: qâ‚˜áµ¢â‚™ â‰¤ q â‰¤ qâ‚˜â‚â‚“
- ì†ë„ í•œê³„: qÌ‡â‚˜áµ¢â‚™ â‰¤ qÌ‡ â‰¤ qÌ‡â‚˜â‚â‚“  
- ë™ì—­í•™ ì œì•½: M(q)qÌˆ + C(q,qÌ‡) + G(q) = Ï„
- ì ‘ì´‰ ì œì•½: ë°œì´ ì§€ë©´ì— ê³ ì •
- ì•ˆì •ì„± ì œì•½: ZMP âˆˆ Support Polygon
```

### ê³„ì¸µì  ì œì–´ (Hierarchical Control)

#### 1. ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ì œì–´

##### ê¸°ë³¸ ì›ë¦¬
```python
def hierarchical_whole_body_control(tasks, current_q, current_q_dot):
    """
    ê³„ì¸µì  ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ì „ì‹  ì œì–´
    """
    q_dot_command = np.zeros(len(current_q))
    N = np.eye(len(current_q))  # ë„ ê³µê°„ íˆ¬ì˜ì
    
    # ìš°ì„ ìˆœìœ„ ìˆœì„œë¡œ íƒœìŠ¤í¬ ì²˜ë¦¬
    for priority_level in sorted(set(task.priority for task in tasks)):
        level_tasks = [task for task in tasks if task.priority == priority_level]
        
        # í˜„ì¬ ìš°ì„ ìˆœìœ„ ë ˆë²¨ì˜ ë³µí•© ìì½”ë¹„ì•ˆ êµ¬ì„±
        J_level = []
        error_level = []
        
        for task in level_tasks:
            J_task = compute_task_jacobian(current_q, task)
            error_task = compute_task_error(current_q, current_q_dot, task)
            
            J_level.append(J_task)
            error_level.append(error_task)
        
        if J_level:
            J_combined = np.vstack(J_level)
            error_combined = np.concatenate(error_level)
            
            # ë„ ê³µê°„ìœ¼ë¡œ íˆ¬ì˜ëœ ìì½”ë¹„ì•ˆ
            J_projected = J_combined @ N
            
            # íƒœìŠ¤í¬ í•´ê²° (ì˜ì‚¬ì—­í–‰ë ¬ ì‚¬ìš©)
            if np.linalg.matrix_rank(J_projected) > 0:
                J_proj_pinv = np.linalg.pinv(J_projected)
                q_dot_task = J_proj_pinv @ error_combined
                
                # ì „ì²´ í•´ì— ì¶”ê°€
                q_dot_command += N @ q_dot_task
                
                # ë„ ê³µê°„ ì—…ë°ì´íŠ¸ (í˜„ì¬ ë ˆë²¨ ì œê±°)
                N = N @ (np.eye(len(current_q)) - J_proj_pinv @ J_projected)
    
    return q_dot_command

def compute_task_jacobian(q, task):
    """
    íƒœìŠ¤í¬ë³„ ìì½”ë¹„ì•ˆ ê³„ì‚°
    """
    if task.type == 'end_effector_position':
        return compute_position_jacobian(q, task.end_effector_chain)
    
    elif task.type == 'end_effector_orientation':
        return compute_orientation_jacobian(q, task.end_effector_chain)
    
    elif task.type == 'center_of_mass':
        return compute_com_jacobian(q)
    
    elif task.type == 'joint_posture':
        return np.eye(len(q))[task.joint_indices, :]
    
    elif task.type == 'momentum':
        return compute_momentum_jacobian(q)
    
    else:
        raise ValueError(f"Unknown task type: {task.type}")

def compute_task_error(q, q_dot, task):
    """
    íƒœìŠ¤í¬ ì˜¤ì°¨ ê³„ì‚°
    """
    if task.type == 'end_effector_position':
        current_pos = forward_kinematics_position(q, task.end_effector_chain)
        desired_pos = task.desired_position
        desired_vel = task.desired_velocity
        
        # PD ì œì–´ í˜•íƒœì˜ ì˜¤ì°¨
        pos_error = desired_pos - current_pos
        vel_error = desired_vel - compute_current_ee_velocity(q, q_dot, task)
        
        return task.kp * pos_error + task.kd * vel_error
    
    elif task.type == 'center_of_mass':
        current_com = compute_center_of_mass(q)
        desired_com = task.desired_com
        
        com_error = desired_com - current_com
        return task.kp * com_error
    
    return np.zeros(task.dimension)
```

##### ì—„ê²©í•œ ê³„ì¸µ êµ¬ì¡°
```python
class StrictHierarchicalController:
    def __init__(self, robot_model):
        self.robot = robot_model
        self.task_hierarchy = {}
        
    def add_task(self, task, priority_level):
        """íƒœìŠ¤í¬ë¥¼ íŠ¹ì • ìš°ì„ ìˆœìœ„ ë ˆë²¨ì— ì¶”ê°€"""
        if priority_level not in self.task_hierarchy:
            self.task_hierarchy[priority_level] = []
        self.task_hierarchy[priority_level].append(task)
    
    def compute_control(self, current_state):
        """ì—„ê²©í•œ ê³„ì¸µì  ì œì–´ ê³„ì‚°"""
        q, q_dot = current_state
        q_dot_cmd = np.zeros(len(q))
        
        # ëˆ„ì  ë„ ê³µê°„ íˆ¬ì˜ì
        N_accumulated = np.eye(len(q))
        
        for priority in sorted(self.task_hierarchy.keys()):
            tasks_at_level = self.task_hierarchy[priority]
            
            # í˜„ì¬ ë ˆë²¨ì˜ ëª¨ë“  íƒœìŠ¤í¬ ê²°í•©
            J_level, error_level = self.combine_tasks_at_level(
                tasks_at_level, q, q_dot
            )
            
            if J_level.size > 0:
                # ìƒìœ„ ìš°ì„ ìˆœìœ„ì˜ ë„ ê³µê°„ì—ì„œ í•´ê²°
                J_constrained = J_level @ N_accumulated
                
                # ìµœì†Œ ë…¸ë¦„ í•´
                if np.linalg.matrix_rank(J_constrained) > 0:
                    J_pinv = np.linalg.pinv(J_constrained)
                    q_dot_level = J_pinv @ error_level
                    
                    # ì‹¤ì œ ê´€ì ˆ ì†ë„ ì¶”ê°€
                    q_dot_cmd += N_accumulated @ q_dot_level
                    
                    # ë„ ê³µê°„ ì—…ë°ì´íŠ¸
                    N_level = np.eye(len(q)) - J_pinv @ J_constrained
                    N_accumulated = N_accumulated @ N_level
        
        return q_dot_cmd
```
