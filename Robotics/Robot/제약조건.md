# ì œì•½ì¡°ê±´

> ìƒìœ„: [[ìµœì í™”ì„¤ê³„]]

ì„¤ê³„ê°€ ë§Œì¡±í•´ì•¼ í•˜ëŠ” ìš”êµ¬ì‚¬í•­ë“¤ì„ ìˆ˜í•™ì  ë¶€ë“±ì‹ì´ë‚˜ ë“±ì‹ìœ¼ë¡œ í‘œí˜„í•œ ì¡°ê±´ë“¤ì…ë‹ˆë‹¤. ì‰½ê²Œ ë§í•´ "ì„¤ê³„ì•ˆì´ ì§€ì¼œì•¼ í•  ê·œì¹™ë“¤"ì„ ìˆ˜ì‹ìœ¼ë¡œ ë‚˜íƒ€ë‚¸ ê²ƒì…ë‹ˆë‹¤.

## ğŸ“‹ ê¸°ë³¸ ê°œë…

### ì œì•½ì¡°ê±´ì´ë€ ë¬´ì—‡ì¸ê°€?

**ì¼ìƒì  ë¹„ìœ :**
ì§‘ì„ ì§“ëŠ”ë‹¤ê³  ìƒê°í•´ë³´ì„¸ìš”.
- **ë²•ì  ì œì•½**: ê±´íìœ¨ â‰¤ 60%, ë†’ì´ â‰¤ 4ì¸µ
- **ì˜ˆì‚° ì œì•½**: ì´ ê±´ì¶•ë¹„ â‰¤ 5ì–µì›
- **ë¬¼ë¦¬ì  ì œì•½**: ê¸°ì´ˆ ê¹Šì´ â‰¥ 1.5m
- **ê¸°ëŠ¥ì  ì œì•½**: ë°© ê°œìˆ˜ â‰¥ 3ê°œ

**ê³µí•™ì  ì˜ˆì‹œ:**
```
êµëŸ‰ ì„¤ê³„:
- ì•ˆì „ì„±: ìµœëŒ€ì‘ë ¥ â‰¤ í—ˆìš©ì‘ë ¥
- ì‚¬ìš©ì„±: ì²˜ì§ â‰¤ ê²½ê°„/250  
- ë‚´êµ¬ì„±: í”¼ë¡œìˆ˜ëª… â‰¥ 100ë…„
- ê²½ì œì„±: ê±´ì„¤ë¹„ â‰¤ ì˜ˆì‚°
```

### ìˆ˜í•™ì  í‘œí˜„

**ì¼ë°˜í˜•:**
```
ì œì•½ì¡°ê±´:
  ë“±ì‹ ì œì•½: hâ±¼(x) = 0,  j = 1, 2, ..., p
  ë¶€ë“±ì‹ ì œì•½: gáµ¢(x) â‰¤ 0,  i = 1, 2, ..., m
  ë°•ìŠ¤ ì œì•½: xâ‚— â‰¤ x â‰¤ xáµ¤
```

**ì˜ˆì‹œ:**
```matlab
% ì›í˜• íƒ±í¬ ì„¤ê³„
% ì„¤ê³„ë³€ìˆ˜: r(ë°˜ì§€ë¦„), h(ë†’ì´)

% ë“±ì‹ ì œì•½: ë¶€í”¼ = 1000L
constraint_eq = @(x) pi * x(1)^2 * x(2) - 1000;

% ë¶€ë“±ì‹ ì œì•½: ì‘ë ¥ â‰¤ í—ˆìš©ì‘ë ¥  
constraint_ineq = @(x) calculate_stress(x) - allowable_stress;

% ë°•ìŠ¤ ì œì•½: 0.5m â‰¤ r â‰¤ 2m, 1m â‰¤ h â‰¤ 5m
bounds_lower = [0.5, 1.0];
bounds_upper = [2.0, 5.0];
```

### ì‹¤í˜„ê°€ëŠ¥ì˜ì—­ (Feasible Region)

**ì •ì˜:** ëª¨ë“  ì œì•½ì¡°ê±´ì„ ë™ì‹œì— ë§Œì¡±í•˜ëŠ” ì„¤ê³„ë³€ìˆ˜ë“¤ì˜ ì§‘í•©

**2ì°¨ì› ì˜ˆì‹œ:**
```matlab
% ì œì•½ì¡°ê±´ ì‹œê°í™”
x1 = 0:0.1:10;
x2 = 0:0.1:10;
[X1, X2] = meshgrid(x1, x2);

% ì œì•½ì¡°ê±´ë“¤
g1 = X1 + X2 - 8;          % x1 + x2 â‰¤ 8
g2 = 2*X1 + X2 - 10;       % 2x1 + x2 â‰¤ 10  
g3 = -X1;                  % x1 â‰¥ 0
g4 = -X2;                  % x2 â‰¥ 0

% ì‹¤í˜„ê°€ëŠ¥ì˜ì—­ (ëª¨ë“  ì œì•½ì¡°ê±´ ë§Œì¡±)
feasible = (g1 <= 0) & (g2 <= 0) & (g3 <= 0) & (g4 <= 0);

contour(X1, X2, g1, [0 0], 'r', 'LineWidth', 2);
hold on;
contour(X1, X2, g2, [0 0], 'b', 'LineWidth', 2);
contourf(X1, X2, double(feasible), [0.5 1.5], 'FaceAlpha', 0.3);
```

---

## ğŸ”§ ì œì•½ì¡°ê±´ ë¶„ë¥˜

### 1. ë¬¼ë¦¬ì  ì œì•½

#### ì‘ë ¥ ì œì•½ (Stress Constraints)
**ê°€ì¥ ê¸°ë³¸ì ì¸ êµ¬ì¡° ì•ˆì „ì„± ì œì•½**

**í° ë¯¸ì œìŠ¤ ì‘ë ¥:**
```matlab
function stress_constraint = von_mises_constraint(x, load_case)
    % ìœ í•œìš”ì†Œ í•´ì„
    [stress_tensor] = finite_element_analysis(x, load_case);
    
    % í° ë¯¸ì œìŠ¤ ì‘ë ¥ ê³„ì‚°
    sigma_vm = calculate_von_mises_stress(stress_tensor);
    
    % ìµœëŒ€ ì‘ë ¥
    sigma_max = max(sigma_vm);
    
    % í—ˆìš© ì‘ë ¥
    sigma_allowable = material.yield_strength / safety_factor;
    
    % ì œì•½ì¡°ê±´ (â‰¤ 0ì´ë©´ ë§Œì¡±)
    stress_constraint = sigma_max - sigma_allowable;
end
```

**ë‹¤ì¶• ì‘ë ¥ ìƒíƒœ:**
```matlab
function constraint = multiaxial_stress_constraint(sigma_xx, sigma_yy, tau_xy)
    % ì£¼ì‘ë ¥ ê³„ì‚°
    sigma_avg = (sigma_xx + sigma_yy) / 2;
    sigma_diff = (sigma_xx - sigma_yy) / 2;
    
    sigma_1 = sigma_avg + sqrt(sigma_diff^2 + tau_xy^2);
    sigma_2 = sigma_avg - sqrt(sigma_diff^2 + tau_xy^2);
    
    % ìµœëŒ€ ì£¼ì‘ë ¥ ì´ë¡ 
    constraint = max(abs(sigma_1), abs(sigma_2)) - sigma_allowable;
end
```

#### ë³€ìœ„ ì œì•½ (Displacement Constraints)
**êµ¬ì¡°ë¬¼ì˜ ê³¼ë„í•œ ë³€í˜• ë°©ì§€**

**ì²˜ì§ ì œí•œ:**
```matlab
function deflection_constraint = beam_deflection_limit(x)
    % ë³´ì˜ ì¹˜ìˆ˜
    width = x(1); height = x(2); length = x(3);
    
    % ìµœëŒ€ ì²˜ì§ ê³„ì‚°
    I = width * height^3 / 12;
    E = 200e9;  % íƒ„ì„±ê³„ìˆ˜ [Pa]
    P = 10000;  % í•˜ì¤‘ [N]
    
    delta_max = P * length^3 / (3 * E * I);
    
    % í—ˆìš© ì²˜ì§ (ë³´í†µ ê²½ê°„ì˜ 1/250 ~ 1/400)
    delta_allowable = length / 300;
    
    deflection_constraint = delta_max - delta_allowable;
end
```

**ì ˆëŒ€ ë³€ìœ„ ì œí•œ:**
```matlab
function displacement_constraint = max_displacement_limit(x, load_cases)
    max_displacement = 0;
    
    for i = 1:length(load_cases)
        % ê° í•˜ì¤‘ ì¼€ì´ìŠ¤ì— ëŒ€í•œ í•´ì„
        displacements = structural_analysis(x, load_cases{i});
        max_disp_case = max(abs(displacements));
        max_displacement = max(max_displacement, max_disp_case);
    end
    
    % í—ˆìš© ë³€ìœ„ (ì˜ˆ: 10mm)
    allowable_displacement = 0.01;  % m
    
    displacement_constraint = max_displacement - allowable_displacement;
end
```

#### ì§„ë™ ì œì•½ (Vibration Constraints)
**ê³µì§„ íšŒí”¼ ë° ë™ì  ì•ˆì •ì„± í™•ë³´**

**ê³ ìœ ì§„ë™ìˆ˜ ë²”ìœ„ ì œì•½:**
```matlab
function frequency_constraint = natural_frequency_limits(x)
    % ê³ ìœ ê°’ í•´ì„
    [K, M] = assemble_matrices(x);
    [eigenvectors, eigenvalues] = eig(K, M);
    
    % ê³ ìœ ì§„ë™ìˆ˜ ê³„ì‚° [Hz]
    frequencies = sqrt(diag(eigenvalues)) / (2*pi);
    first_frequency = min(frequencies);
    
    % ì§„ë™ìˆ˜ ì œì•½ (ì˜ˆ: 15Hz ì´ìƒ)
    min_required_freq = 15;  % Hz
    frequency_constraint = min_required_freq - first_frequency;
end
```

**ì§„ë™ìˆ˜ íšŒí”¼:**
```matlab
function avoidance_constraint = frequency_avoidance(frequencies, avoid_ranges)
    % íšŒí”¼í•´ì•¼ í•  ì§„ë™ìˆ˜ ë²”ìœ„ë“¤
    % avoid_ranges = [10, 12; 25, 27; 50, 55];  % Hz
    
    constraints = [];
    
    for freq = frequencies
        for i = 1:size(avoid_ranges, 1)
            f_min = avoid_ranges(i, 1);
            f_max = avoid_ranges(i, 2);
            
            if freq >= f_min && freq <= f_max
                % ê¸ˆì§€ êµ¬ê°„ ë‚´ë¶€: ê±°ë¦¬ ê¸°ë°˜ í˜ë„í‹°
                distance_to_boundary = min(freq - f_min, f_max - freq);
                constraints(end+1) = -distance_to_boundary;
            end
        end
    end
    
    if isempty(constraints)
        avoidance_constraint = 0;  % ëª¨ë“  ì§„ë™ìˆ˜ê°€ ì•ˆì „ êµ¬ê°„
    else
        avoidance_constraint = max(constraints);
    end
end
```

#### ì¢Œêµ´ ì œì•½ (Buckling Constraints)
**ì••ì¶• ë¶€ì¬ì˜ ì¢Œêµ´ ë°©ì§€**

**ì˜¤ì¼ëŸ¬ ì¢Œêµ´ í•˜ì¤‘:**
```matlab
function buckling_constraint = euler_buckling_check(x, compression_force)
    % ê¸°ë‘¥ ì¹˜ìˆ˜
    length = x(1);
    diameter = x(2);
    
    % ë‹¨ë©´ íŠ¹ì„±
    area = pi * diameter^2 / 4;
    I = pi * diameter^4 / 64;
    radius_gyration = sqrt(I / area);
    
    % ì„¸ì¥ë¹„
    slenderness_ratio = length / radius_gyration;
    
    % ì˜¤ì¼ëŸ¬ ì¢Œêµ´ í•˜ì¤‘
    E = 200e9;  % íƒ„ì„±ê³„ìˆ˜ [Pa]
    P_euler = pi^2 * E * I / length^2;
    
    % ì•ˆì „ê³„ìˆ˜ ì ìš©
    safety_factor = 2.0;
    P_allowable = P_euler / safety_factor;
    
    buckling_constraint = compression_force - P_allowable;
end
```

### 2. ê¸°í•˜í•™ì  ì œì•½

#### ì¹˜ìˆ˜ í•œê³„
```matlab
function geometry_constraints = geometric_limits(x)
    width = x(1); height = x(2); thickness = x(3);
    
    constraints = [];
    
    % ìµœì†Œ ì œì¡° ë‘ê»˜
    min_thickness = 0.001;  % 1mm
    constraints(end+1) = min_thickness - thickness;
    
    % ì¢…íš¡ë¹„ ì œí•œ (ê°€ë¡œì„¸ë¡œ ë¹„ìœ¨)
    aspect_ratio = height / width;
    max_aspect_ratio = 5.0;
    constraints(end+1) = aspect_ratio - max_aspect_ratio;
    
    % ìµœì†Œ ë‹¨ë©´ì 
    area = width * thickness;
    min_area = 0.0001;  % mÂ²
    constraints(end+1) = min_area - area;
    
    geometry_constraints = constraints;
end
```

#### ê°„ì„­ íšŒí”¼
```matlab
function interference_constraint = check_interference(positions, sizes)
    % ì—¬ëŸ¬ êµ¬ì„±ìš”ì†Œ ê°„ ê°„ì„­ ì²´í¬
    n_components = length(positions);
    min_clearance = 0.005;  % 5mm ìµœì†Œ ê°„ê²©
    
    max_interference = 0;
    
    for i = 1:n_components
        for j = i+1:n_components
            % ë‘ êµ¬ì„±ìš”ì†Œ ê°„ ê±°ë¦¬
            distance = norm(positions{i} - positions{j});
            
            % í•„ìš”í•œ ìµœì†Œ ê±°ë¦¬
            required_distance = (sizes(i) + sizes(j))/2 + min_clearance;
            
            % ê°„ì„­ëŸ‰ ê³„ì‚°
            interference = required_distance - distance;
            max_interference = max(max_interference, interference);
        end
    end
    
    interference_constraint = max_interference;
end
```

### 3. ì œì¡° ì œì•½

#### ê°€ê³µ ê°€ëŠ¥ì„±
```matlab
function manufacturing_constraints = machining_constraints(x)
    % ì„¤ê³„ í˜•ìƒ íŒŒë¼ë¯¸í„°
    hole_diameter = x(1);
    hole_depth = x(2);
    corner_radius = x(3);
    
    constraints = [];
    
    % ë“œë¦´ ê°€ê³µ ì œì•½: ê¹Šì´/ì§€ë¦„ ë¹„ìœ¨
    depth_diameter_ratio = hole_depth / hole_diameter;
    max_ratio = 10;  % ì¼ë°˜ì  í•œê³„
    constraints(end+1) = depth_diameter_ratio - max_ratio;
    
    % ìµœì†Œ ëª¨ì„œë¦¬ ë°˜ì§€ë¦„ (ì—”ë“œë°€ ë°˜ì§€ë¦„)
    min_corner_radius = 0.0005;  % 0.5mm
    constraints(end+1) = min_corner_radius - corner_radius;
    
    % ìµœì†Œ ë²½ ë‘ê»˜ (ê³µêµ¬ ì ‘ê·¼ì„±)
    wall_thickness = calculate_min_wall_thickness(x);
    min_wall = 0.002;  % 2mm
    constraints(end+1) = min_wall - wall_thickness;
    
    manufacturing_constraints = constraints;
end
```

#### 3D í”„ë¦°íŒ… ì œì•½
```matlab
function am_constraints = additive_manufacturing_constraints(x, print_direction)
    constraints = [];
    
    % ì˜¤ë²„í–‰ ê°ë„ ì œí•œ
    overhang_angles = calculate_overhang_angles(x, print_direction);
    max_overhang = 45;  % ë„
    for angle = overhang_angles
        constraints(end+1) = angle - max_overhang;
    end
    
    % ìµœì†Œ íŠ¹ì§• í¬ê¸°
    min_feature_size = 0.0002;  % 0.2mm
    feature_sizes = extract_feature_sizes(x);
    for size = feature_sizes
        constraints(end+1) = min_feature_size - size;
    end
    
    % ì„œí¬íŠ¸ êµ¬ì¡° í•„ìš”ì„± ìµœì†Œí™”
    support_area = calculate_support_area(x, print_direction);
    max_support_ratio = 0.1;  % ì „ì²´ ë©´ì ì˜ 10%
    total_area = calculate_total_surface_area(x);
    constraints(end+1) = support_area/total_area - max_support_ratio;
    
    am_constraints = constraints;
end
```

### 4. ì„±ëŠ¥ ì œì•½

#### ì—´ ì „ë‹¬ ì œì•½
```matlab
function thermal_constraint = heat_transfer_limits(x, heat_source)
    % ì—´ì „ë„ í•´ì„
    temperature_field = thermal_analysis(x, heat_source);
    max_temperature = max(temperature_field);
    
    % í—ˆìš© ì˜¨ë„ (ì¬ë£Œ/ë¶€í’ˆ í•œê³„)
    allowable_temperature = 150;  % Â°C
    
    thermal_constraint = max_temperature - allowable_temperature;
end
```

#### ìœ ë™ ì œì•½
```matlab
function flow_constraint = pressure_drop_limit(x, flow_rate)
    % CFD í•´ì„ ë˜ëŠ” ê²½í—˜ì‹
    pressure_drop = calculate_pressure_drop(x, flow_rate);
    
    % í—ˆìš© ì••ë ¥ ì†ì‹¤
    max_pressure_drop = 1000;  % Pa
    
    flow_constraint = pressure_drop - max_pressure_drop;
end
```

---

## âš™ï¸ ì œì•½ì¡°ê±´ ì²˜ë¦¬ ê¸°ë²•

### 1. ëŠ¥ë™/ìˆ˜ë™ ì œì•½ ê°œë…

#### KKT ì¡°ê±´ê³¼ì˜ ê´€ë ¨ì„±
```matlab
function [active_constraints, inactive_constraints] = classify_constraints(x, constraints, tolerance)
    % ì œì•½ì¡°ê±´ ê°’ ê³„ì‚°
    g_values = zeros(length(constraints), 1);
    for i = 1:length(constraints)
        g_values(i) = constraints{i}(x);
    end
    
    % ëŠ¥ë™/ìˆ˜ë™ ë¶„ë¥˜
    active_idx = abs(g_values) < tolerance;
    inactive_idx = g_values < -tolerance;
    
    active_constraints = find(active_idx);
    inactive_constraints = find(inactive_idx);
    
    % ìœ„ë°˜ëœ ì œì•½ì¡°ê±´ í™•ì¸
    violated_idx = g_values > tolerance;
    if any(violated_idx)
        warning('Some constraints are violated');
        disp(find(violated_idx));
    end
end
```

### 2. ë²Œì í•¨ìˆ˜ë²• (Penalty Method)

#### ì™¸ë¶€ ë²Œì ë²•
```matlab
function f_penalty = external_penalty(x, objective, constraints, penalty_coef)
    % ì›ë˜ ëª©ì í•¨ìˆ˜
    f0 = objective(x);
    
    % ì œì•½ì¡°ê±´ ë²Œì 
    penalty_sum = 0;
    for i = 1:length(constraints)
        g_i = constraints{i}(x);
        
        % ë¶€ë“±ì‹ ì œì•½: g(x) â‰¤ 0
        if g_i > 0
            penalty_sum = penalty_sum + g_i^2;
        end
    end
    
    f_penalty = f0 + penalty_coef * penalty_sum;
end

% ì ì§„ì  ë²Œì  ê³„ìˆ˜ ì¦ê°€
function x_opt = progressive_penalty_optimization(x0, objective, constraints)
    penalty_coefficients = [1, 10, 100, 1000, 10000];
    x_current = x0;
    
    for r = penalty_coefficients
        penalty_objective = @(x) external_penalty(x, objective, constraints, r);
        
        options = optimoptions('fminunc', 'Display', 'off');
        x_current = fminunc(penalty_objective, x_current, options);
        
        fprintf('Penalty coefficient: %g, Objective: %g\n', r, objective(x_current));
    end
    
    x_opt = x_current;
end
```

#### ë‚´ë¶€ ë²Œì ë²• (ì¥ë²½ë²•)
```matlab
function f_barrier = barrier_method(x, objective, constraints, barrier_coef)
    % ì›ë˜ ëª©ì í•¨ìˆ˜
    f0 = objective(x);
    
    % ì¥ë²½ í•¨ìˆ˜
    barrier_sum = 0;
    for i = 1:length(constraints)
        g_i = constraints{i}(x);
        
        if g_i >= 0
            % ì œì•½ì¡°ê±´ ìœ„ë°˜ ì‹œ ë¬´í•œëŒ€
            f_barrier = Inf;
            return;
        else
            % ë¡œê·¸ ì¥ë²½
            barrier_sum = barrier_sum - log(-g_i);
        end
    end
    
    f_barrier = f0 + barrier_coef * barrier_sum;
end
```

### 3. ë¼ê·¸ë‘ì§€ ìŠ¹ìˆ˜ë²•

#### ë“±ì‹ ì œì•½ë§Œ ìˆëŠ” ê²½ìš°
```matlab
function [x_opt, lambda_opt] = lagrange_multiplier_method(objective, equality_constraints, x0)
    % ë¼ê·¸ë‘ì§€ì•ˆ í•¨ìˆ˜ ì •ì˜
    lagrangian = @(vars) lagrangian_function(vars, objective, equality_constraints);
    
    % ë³€ìˆ˜: [x; lambda]
    n_vars = length(x0);
    n_eq_constraints = length(equality_constraints);
    vars0 = [x0; zeros(n_eq_constraints, 1)];
    
    % ìµœì í™” (ë¼ê·¸ë‘ì§€ì•ˆì˜ ê·¸ë˜ë””ì–¸íŠ¸ = 0)
    options = optimoptions('fsolve', 'Display', 'iter');
    vars_opt = fsolve(@(vars) lagrangian_gradient(vars, objective, equality_constraints), vars0, options);
    
    x_opt = vars_opt(1:n_vars);
    lambda_opt = vars_opt(n_vars+1:end);
end

function grad = lagrangian_gradient(vars, objective, equality_constraints)
    n_vars = length(vars) - length(equality_constraints);
    x = vars(1:n_vars);
    lambda = vars(n_vars+1:end);
    
    % ëª©ì í•¨ìˆ˜ ê·¸ë˜ë””ì–¸íŠ¸
    grad_f = gradient_fd(objective, x);
    
    % ì œì•½ì¡°ê±´ ê·¸ë˜ë””ì–¸íŠ¸
    grad_h = zeros(n_vars, length(equality_constraints));
    for i = 1:length(equality_constraints)
        grad_h(:, i) = gradient_fd(equality_constraints{i}, x);
    end
    
    % KKT ì¡°ê±´
    grad_x = grad_f + grad_h * lambda;
    grad_lambda = zeros(length(equality_constraints), 1);
    for i = 1:length(equality_constraints)
        grad_lambda(i) = equality_constraints{i}(x);
    end
    
    grad = [grad_x; grad_lambda];
end
```

### 4. ì œì•½ ê·¼ì‚¬í™” ê¸°ë²•

#### ìˆœì°¨ ì„ í˜•ê³„íšë²• (SLP)
```matlab
function x_opt = sequential_linear_programming(x0, objective, constraints, max_iter)
    x_current = x0;
    
    for iter = 1:max_iter
        % í˜„ì¬ì ì—ì„œ ì„ í˜•í™”
        [c, A, b] = linearize_problem(x_current, objective, constraints);
        
        % ì‹ ë¢°ì˜ì—­ ì œì•½
        trust_radius = 0.1;
        lb = x_current - trust_radius;
        ub = x_current + trust_radius;
        
        % ì„ í˜•ê³„íšë²• í•´ê²°
        options = optimoptions('linprog', 'Display', 'off');
        [x_new, ~, exitflag] = linprog(c, A, b, [], [], lb, ub, options);
        
        if exitflag <= 0
            warning('Linear programming failed');
            break;
        end
        
        % ìˆ˜ë ´ í™•ì¸
        if norm(x_new - x_current) < 1e-6
            break;
        end
        
        x_current = x_new;
    end
    
    x_opt = x_current;
end

function [c, A, b] = linearize_problem(x0, objective, constraints)
    % ëª©ì í•¨ìˆ˜ ì„ í˜•í™”: f(x) â‰ˆ f(x0) + âˆ‡f(x0)áµ€(x - x0)
    grad_f = gradient_fd(objective, x0);
    c = grad_f;
    
    % ì œì•½ì¡°ê±´ ì„ í˜•í™”: g(x) â‰ˆ g(x0) + âˆ‡g(x0)áµ€(x - x0) â‰¤ 0
    n_constraints = length(constraints);
    A = zeros(n_constraints, length(x0));
    b = zeros(n_constraints, 1);
    
    for i = 1:n_constraints
        g_i = constraints{i}(x0);
        grad_g_i = gradient_fd(constraints{i}, x0);
        
        A(i, :) = grad_g_i';
        b(i) = -g_i + grad_g_i' * x0;
    end
end
```

#### ìˆœì°¨ ì´ì°¨ê³„íšë²• (SQP)
```matlab
function x_opt = sequential_quadratic_programming(x0, objective, constraints)
    % MATLABì˜ fminconì„ ì‚¬ìš©í•œ SQP
    
    % ì œì•½ì¡°ê±´ í•¨ìˆ˜ ì •ì˜
    nonlcon = @(x) constraint_function(x, constraints);
    
    % ìµœì í™” ì˜µì…˜
    options = optimoptions('fmincon', ...
        'Algorithm', 'sqp', ...
        'Display', 'iter', ...
        'OptimalityTolerance', 1e-6, ...
        'ConstraintTolerance', 1e-6);
    
    % ìµœì í™” ì‹¤í–‰
    [x_opt, fval, exitflag, output] = fmincon(objective, x0, [], [], [], [], [], [], nonlcon, options);
    
    if exitflag <= 0
        warning('SQP optimization failed');
    end
end

function [c, ceq] = constraint_function(x, constraints)
    % ë¶€ë“±ì‹ ì œì•½ì¡°ê±´
    c = zeros(length(constraints.inequality), 1);
    for i = 1:length(constraints.inequality)
        c(i) = constraints.inequality{i}(x);
    end
    
    % ë“±ì‹ ì œì•½ì¡°ê±´  
    ceq = zeros(length(constraints.equality), 1);
    for i = 1:length(constraints.equality)
        ceq(i) = constraints.equality{i}(x);
    end
end
```

---

## ğŸ“Š ì‹¤ì œ ì„¤ê³„ ì‚¬ë¡€

### ì‚¬ë¡€ 1: ì••ë ¥ìš©ê¸° ì„¤ê³„

**ì„¤ê³„ë³€ìˆ˜:**
- ë‚´ë¶€ ë°˜ì§€ë¦„: r
- ë²½ ë‘ê»˜: t
- ê¸¸ì´: L

**ì œì•½ì¡°ê±´:**

```matlab
function constraints = pressure_vessel_constraints(x, design_data)
    r = x(1);  % ë‚´ë¶€ ë°˜ì§€ë¦„ [m]
    t = x(2);  % ë²½ ë‘ê»˜ [m]  
    L = x(3);  % ê¸¸ì´ [m]
    
    P = design_data.pressure;        % ë‚´ë¶€ ì••ë ¥ [Pa]
    sigma_y = design_data.yield;     % í•­ë³µê°•ë„ [Pa]
    sf = design_data.safety_factor;  % ì•ˆì „ê³„ìˆ˜
    
    constraints = [];
    
    % 1. í›„í”„ ì‘ë ¥ ì œì•½ (ì›ì£¼ë°©í–¥)
    sigma_hoop = P * r / t;
    sigma_allow = sigma_y / sf;
    constraints(end+1) = sigma_hoop - sigma_allow;
    
    % 2. ì¶• ì‘ë ¥ ì œì•½ (ê¸¸ì´ë°©í–¥)  
    sigma_axial = P * r / (2 * t);
    constraints(end+1) = sigma_axial - sigma_allow;
    
    % 3. ìµœì†Œ ë‘ê»˜ (ì œì¡° í•œê³„)
    min_thickness = 0.005;  % 5mm
    constraints(end+1) = min_thickness - t;
    
    % 4. ì„¸ì¥ë¹„ ì œí•œ (ì¢Œêµ´ ë°©ì§€)
    slenderness = L / (2 * r);
    max_slenderness = 10;
    constraints(end+1) = slenderness - max_slenderness;
    
    % 5. ë¶€í”¼ ìš”êµ¬ì‚¬í•­ (ë“±ì‹ ì œì•½ì¡°ê±´ìœ¼ë¡œ ì²˜ë¦¬)
    required_volume = design_data.volume;
    actual_volume = pi * r^2 * L;
    volume_error = abs(actual_volume - required_volume) / required_volume;
    tolerance = 0.01;  % 1% í—ˆìš©ì˜¤ì°¨
    constraints(end+1) = volume_error - tolerance;
end

% ì‚¬ìš© ì˜ˆì‹œ
design_data = struct(...
    'pressure', 2e6, ...      % 2 MPa
    'yield', 250e6, ...       % 250 MPa
    'safety_factor', 2.5, ... 
    'volume', 10 ...          % 10 mÂ³
);

x0 = [1.0, 0.02, 5.0];  % ì´ˆê¸° ì¶”ì •ê°’
constraints_func = @(x) pressure_vessel_constraints(x, design_data);
```

### ì‚¬ë¡€ 2: í•­ê³µê¸° ë‚ ê°œ êµ¬ì¡° ìµœì í™”

**ë³µì¡í•œ ë‹¤ì¤‘ ì œì•½ì¡°ê±´:**

```matlab
function constraints = wing_structure_constraints(x, load_cases, materials)
    % x: ì„¤ê³„ë³€ìˆ˜ ë²¡í„° (ìŠ¤í‚¨ ë‘ê»˜, ìŠ¤íŠ¸ë§ê±° ì¹˜ìˆ˜ ë“±)
    
    constraints = [];
    
    % 1. ì‘ë ¥ ì œì•½ (ëª¨ë“  í•˜ì¤‘ ì¼€ì´ìŠ¤)
    for i = 1:length(load_cases)
        stress_field = structural_analysis(x, load_cases{i});
        max_stress = max(stress_field);
        allowable = materials.yield_strength / materials.safety_factor;
        constraints(end+1) = max_stress - allowable;
    end
    
    % 2. ì¢Œêµ´ ì œì•½ (ì••ì¶• íŒ¨ë„)
    compression_panels = identify_compression_panels(x, load_cases);
    for panel = compression_panels
        buckling_load = calculate_buckling_load(panel, x);
        applied_load = panel.compression_force;
        buckling_safety = 1.5;
        constraints(end+1) = applied_load - buckling_load/buckling_safety;
    end
    
    % 3. ì²˜ì§ ì œì•½ (ê³µë ¥ ì„±ëŠ¥ ìœ ì§€)
    tip_deflection = calculate_tip_deflection(x, load_cases.cruise);
    max_deflection = 0.1 * wing_span;  % ë‚ ê°œ ìŠ¤íŒ¬ì˜ 10%
    constraints(end+1) = tip_deflection - max_deflection;
    
    % 4. ì§„ë™ ì œì•½ (í”ŒëŸ¬í„° ë°©ì§€)
    natural_frequencies = modal_analysis(x);
    first_freq = min(natural_frequencies);
    min_required_freq = 5.0;  % Hz (í”ŒëŸ¬í„° ì—¬ìœ )
    constraints(end+1) = min_required_freq - first_freq;
    
    % 5. ì œì¡° ì œì•½
    manufacturing_constraints = apply_manufacturing_rules(x);
    constraints = [constraints, manufacturing_constraints];
    
    % 6. ì—°ë£Œ íƒ±í¬ ë¶€í”¼ (ë“±ì‹ ì œì•½)
    fuel_volume = calculate_internal_volume(x);
    required_fuel_volume = 50000;  % L
    volume_tolerance = 0.02;  % 2%
    volume_error = abs(fuel_volume - required_fuel_volume) / required_fuel_volume;
    constraints(end+1) = volume_error - volume_tolerance;
end
```

### ì‚¬ë¡€ 3: ë¡œë´‡ ë§¤ë‹ˆí“°ë ˆì´í„° ì„¤ê³„

**ë‹¤ì–‘í•œ ì„±ëŠ¥ ì œì•½:**

```matlab
function constraints = robot_manipulator_constraints(x, workspace_requirements)
    % x: [link_lengths, joint_limits, motor_specs]
    
    link_lengths = x(1:6);
    joint_limits = reshape(x(7:18), 6, 2);  % [min, max] for each joint
    motor_torques = x(19:24);
    
    constraints = [];
    
    % 1. ì‘ì—…ê³µê°„ ìš”êµ¬ì‚¬í•­
    workspace_points = workspace_requirements.required_points;
    for point = workspace_points
        reachability = check_reachability(link_lengths, joint_limits, point);
        constraints(end+1) = -reachability;  % ë„ë‹¬ ë¶ˆê°€ëŠ¥í•˜ë©´ ì–‘ìˆ˜
    end
    
    % 2. íŠ¹ì´ì  íšŒí”¼ (ìµœì†Œ ì¡°ì‘ì„± í™•ë³´)
    test_configurations = generate_test_configurations(joint_limits);
    min_manipulability = Inf;
    
    for config = test_configurations
        jacobian = compute_jacobian(link_lengths, config);
        manipulability = sqrt(det(jacobian * jacobian'));
        min_manipulability = min(min_manipulability, manipulability);
    end
    
    required_manipulability = 0.01;
    constraints(end+1) = required_manipulability - min_manipulability;
    
    % 3. ë™ì  ì„±ëŠ¥ (ìµœëŒ€ ê°€ì†ë„)
    max_joint_accelerations = calculate_max_accelerations(link_lengths, motor_torques);
    required_acceleration = 10;  % rad/sÂ²
    for acc = max_joint_accelerations
        constraints(end+1) = required_acceleration - acc;
    end
    
    % 4. ì¶©ëŒ íšŒí”¼ (ìê¸° ê°„ì„­)
    collision_margin = 0.05;  % 5cm
    min_clearance = check_self_collision(link_lengths, joint_limits);
    constraints(end+1) = collision_margin - min_clearance;
    
    % 5. ëª¨í„° í† í¬ í•œê³„
    max_required_torques = calculate_required_torques(link_lengths, workspace_requirements.loads);
    for i = 1:6
        constraints(end+1) = max_required_torques(i) - motor_torques(i);
    end
end
```

---

## ğŸ’» ê³ ê¸‰ êµ¬í˜„ ê¸°ë²•

### ì ì‘ì  ì œì•½ì¡°ê±´ ì²˜ë¦¬

```matlab
classdef AdaptiveConstraintHandler < handle
    properties
        constraint_functions
        tolerance
        active_constraints
        constraint_history
        penalty_parameters
    end
    
    methods
        function obj = AdaptiveConstraintHandler(constraints, tol)
            obj.constraint_functions = constraints;
            obj.tolerance = tol;
            obj.active_constraints = [];
            obj.constraint_history = [];
            obj.penalty_parameters = ones(length(constraints), 1);
        end
        
        function [c, active_idx] = evaluate_constraints(obj, x)
            c = zeros(length(obj.constraint_functions), 1);
            
            for i = 1:length(obj.constraint_functions)
                c(i) = obj.constraint_functions{i}(x);
            end
            
            % ëŠ¥ë™ ì œì•½ì¡°ê±´ ì‹ë³„
            active_idx = abs(c) < obj.tolerance;
            obj.active_constraints = find(active_idx);
            
            % íˆìŠ¤í† ë¦¬ ì €ì¥
            obj.constraint_history(end+1, :) = c';
            
            % ë²Œì  ë§¤ê°œë³€ìˆ˜ ì ì‘ì  ì¡°ì •
            obj.update_penalty_parameters(c);
        end
        
        function update_penalty_parameters(obj, c)
            % ìœ„ë°˜ëœ ì œì•½ì¡°ê±´ì˜ ë²Œì  ê³„ìˆ˜ ì¦ê°€
            violation_factor = 2.0;
            
            for i = 1:length(c)
                if c(i) > obj.tolerance
                    obj.penalty_parameters(i) = obj.penalty_parameters(i) * violation_factor;
                elseif c(i) < -obj.tolerance && obj.penalty_parameters(i) > 1
                    obj.penalty_parameters(i) = obj.penalty_parameters(i) / violation_factor;
                end
            end
        end
        
        function f_penalty = penalized_objective(obj, x, original_objective)
            [c, ~] = obj.evaluate_constraints(x);
            f0 = original_objective(x);
            
            penalty = 0;
            for i = 1:length(c)
                if c(i) > 0
                    penalty = penalty + obj.penalty_parameters(i) * c(i)^2;
                end
            end
            
            f_penalty = f0 + penalty;
        end
        
        function plot_constraint_history(obj)
            if isempty(obj.constraint_history)
                warning('No constraint history available');
                return;
            end
            
            figure;
            plot(obj.constraint_history);
            xlabel('Iteration');
            ylabel('Constraint Value');
            title('Constraint Evolution');
            legend(arrayfun(@(i) sprintf('g_%d', i), 1:size(obj.constraint_history,2), 'UniformOutput', false));
            grid on;
        end
    end
end
```

### ë³‘ë ¬ ì œì•½ì¡°ê±´ í‰ê°€

```matlab
function constraints = parallel_constraint_evaluation(x, constraint_functions)
    % ì œì•½ì¡°ê±´ë“¤ì„ ë³‘ë ¬ë¡œ í‰ê°€
    n_constraints = length(constraint_functions);
    constraints = zeros(n_constraints, 1);
    
    % ë³‘ë ¬ ì²˜ë¦¬ê°€ ê°€ëŠ¥í•œ ê²½ìš°
    if n_constraints > 4 && ~isempty(gcp('nocreate'))
        parfor i = 1:n_constraints
            constraints(i) = constraint_functions{i}(x);
        end
    else
        % ìˆœì°¨ ì²˜ë¦¬
        for i = 1:n_constraints
            constraints(i) = constraint_functions{i}(x);
        end
    end
end
```

---

## ğŸ“ í•™ìŠµ ë‹¨ê³„ë³„ ê°€ì´ë“œ

### ì´ˆê¸‰ (1-2ê°œì›”)

**1ì£¼ì°¨: ê¸°ë³¸ ê°œë…**
```matlab
% ê°„ë‹¨í•œ 2ë³€ìˆ˜ ì œì•½ ìµœì í™”
objective = @(x) (x(1)-2)^2 + (x(2)-1)^2;

% ì œì•½ì¡°ê±´: x1 + x2 â‰¤ 3, x1 â‰¥ 0, x2 â‰¥ 0
constraint = @(x) x(1) + x(2) - 3;

% ì‹œê°í™”ë¡œ ì´í•´
x1 = 0:0.1:4; x2 = 0:0.1:4;
[X1, X2] = meshgrid(x1, x2);
Z = (X1-2).^2 + (X2-1).^2;

contour(X1, X2, Z, 20);
hold on;
plot([0 3], [3 0], 'r-', 'LineWidth', 2);  % ì œì•½ì¡°ê±´ ê²½ê³„
```

**2ì£¼ì°¨: ë¼ê·¸ë‘ì§€ ìŠ¹ìˆ˜ë²•**
```matlab
% ë“±ì‹ ì œì•½ì´ ìˆëŠ” ë¬¸ì œ ì†í’€ì´
% min f(x,y) = xÂ² + yÂ²
% s.t. g(x,y) = x + y - 1 = 0

syms x y lambda
L = x^2 + y^2 + lambda*(x + y - 1);

% KKT ì¡°ê±´
dL_dx = diff(L, x);  % 2x + lambda = 0
dL_dy = diff(L, y);  % 2y + lambda = 0  
dL_dlambda = diff(L, lambda);  % x + y - 1 = 0

% í•´ êµ¬í•˜ê¸°
sol = solve([dL_dx, dL_dy, dL_dlambda], [x, y, lambda]);
```

### ì¤‘ê¸‰ (3-4ê°œì›”)

**3-4ì£¼ì°¨: ì‹¤ì œ ê³µí•™ ë¬¸ì œ**
```matlab
% íŠ¸ëŸ¬ìŠ¤ ìµœì í™” ë¬¸ì œ
function example_truss_optimization()
    % 10-bar íŠ¸ëŸ¬ìŠ¤ ë¬¸ì œ
    areas_initial = ones(10, 1) * 0.001;  % ì´ˆê¸° ë‹¨ë©´ì  [mÂ²]
    
    % ëª©ì í•¨ìˆ˜: ì§ˆëŸ‰ ìµœì†Œí™”
    objective = @(A) truss_mass(A);
    
    % ì œì•½ì¡°ê±´
    nonlcon = @(A) truss_constraints(A);
    
    % ë°•ìŠ¤ ì œì•½ (ë‹¨ë©´ì  ë²”ìœ„)
    lb = ones(10, 1) * 0.0001;  % ìµœì†Œ ë‹¨ë©´ì 
    ub = ones(10, 1) * 0.01;    % ìµœëŒ€ ë‹¨ë©´ì 
    
    % ìµœì í™” ì‹¤í–‰
    options = optimoptions('fmincon', 'Display', 'iter');
    [A_opt, mass_opt] = fmincon(objective, areas_initial, [], [], [], [], lb, ub, nonlcon, options);
    
    fprintf('Optimal mass: %.2f kg\n', mass_opt);
end
```

### ê³ ê¸‰ (6ê°œì›”+)

**5-8ì£¼ì°¨: ê³ ê¸‰ ì œì•½ì¡°ê±´**
- ë™ì  ì œì•½ì¡°ê±´
- í™•ë¥ ì  ì œì•½ì¡°ê±´  
- PDE ì œì•½ì¡°ê±´

**9-12ì£¼ì°¨: ì‹¤ë¬´ í”„ë¡œì íŠ¸**
- ë‹¤ë¶„ì•¼ ì—°ì„± ì œì•½
- ëŒ€ê·œëª¨ ì œì•½ì¡°ê±´ ì‹œìŠ¤í…œ
- ì‹¤ì‹œê°„ ì œì•½ì¡°ê±´ ì²˜ë¦¬

---

**ì°¸ê³ ë¬¸í—Œ:**
- Nocedal, J. & Wright, S.J. (2006). *Numerical Optimization*. Springer.
- Bertsekas, D.P. (2016). *Nonlinear Programming*. Athena Scientific.
- Boyd, S. & Vandenberghe, L. (2004). *Convex Optimization*. Cambridge University Press.
- Bazaraa, M.S., Sherali, H.D. & Shetty, C.M. (2013). *Nonlinear Programming: Theory and Algorithms*. Wiley.