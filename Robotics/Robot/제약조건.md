# 제약조건

> 상위: [[최적화설계]]

설계가 만족해야 하는 요구사항들을 수학적 부등식이나 등식으로 표현한 조건들입니다. 쉽게 말해 "설계안이 지켜야 할 규칙들"을 수식으로 나타낸 것입니다.

## 📋 기본 개념

### 제약조건이란 무엇인가?

**일상적 비유:**
집을 짓는다고 생각해보세요.
- **법적 제약**: 건폐율 ≤ 60%, 높이 ≤ 4층
- **예산 제약**: 총 건축비 ≤ 5억원
- **물리적 제약**: 기초 깊이 ≥ 1.5m
- **기능적 제약**: 방 개수 ≥ 3개

**공학적 예시:**
```
교량 설계:
- 안전성: 최대응력 ≤ 허용응력
- 사용성: 처짐 ≤ 경간/250  
- 내구성: 피로수명 ≥ 100년
- 경제성: 건설비 ≤ 예산
```

### 수학적 표현

**일반형:**
```
제약조건:
  등식 제약: hⱼ(x) = 0,  j = 1, 2, ..., p
  부등식 제약: gᵢ(x) ≤ 0,  i = 1, 2, ..., m
  박스 제약: xₗ ≤ x ≤ xᵤ
```

**예시:**
```matlab
% 원형 탱크 설계
% 설계변수: r(반지름), h(높이)

% 등식 제약: 부피 = 1000L
constraint_eq = @(x) pi * x(1)^2 * x(2) - 1000;

% 부등식 제약: 응력 ≤ 허용응력  
constraint_ineq = @(x) calculate_stress(x) - allowable_stress;

% 박스 제약: 0.5m ≤ r ≤ 2m, 1m ≤ h ≤ 5m
bounds_lower = [0.5, 1.0];
bounds_upper = [2.0, 5.0];
```

### 실현가능영역 (Feasible Region)

**정의:** 모든 제약조건을 동시에 만족하는 설계변수들의 집합

**2차원 예시:**
```matlab
% 제약조건 시각화
x1 = 0:0.1:10;
x2 = 0:0.1:10;
[X1, X2] = meshgrid(x1, x2);

% 제약조건들
g1 = X1 + X2 - 8;          % x1 + x2 ≤ 8
g2 = 2*X1 + X2 - 10;       % 2x1 + x2 ≤ 10  
g3 = -X1;                  % x1 ≥ 0
g4 = -X2;                  % x2 ≥ 0

% 실현가능영역 (모든 제약조건 만족)
feasible = (g1 <= 0) & (g2 <= 0) & (g3 <= 0) & (g4 <= 0);

contour(X1, X2, g1, [0 0], 'r', 'LineWidth', 2);
hold on;
contour(X1, X2, g2, [0 0], 'b', 'LineWidth', 2);
contourf(X1, X2, double(feasible), [0.5 1.5], 'FaceAlpha', 0.3);
```

---

## 🔧 제약조건 분류

### 1. 물리적 제약

#### 응력 제약 (Stress Constraints)
**가장 기본적인 구조 안전성 제약**

**폰 미제스 응력:**
```matlab
function stress_constraint = von_mises_constraint(x, load_case)
    % 유한요소 해석
    [stress_tensor] = finite_element_analysis(x, load_case);
    
    % 폰 미제스 응력 계산
    sigma_vm = calculate_von_mises_stress(stress_tensor);
    
    % 최대 응력
    sigma_max = max(sigma_vm);
    
    % 허용 응력
    sigma_allowable = material.yield_strength / safety_factor;
    
    % 제약조건 (≤ 0이면 만족)
    stress_constraint = sigma_max - sigma_allowable;
end
```

**다축 응력 상태:**
```matlab
function constraint = multiaxial_stress_constraint(sigma_xx, sigma_yy, tau_xy)
    % 주응력 계산
    sigma_avg = (sigma_xx + sigma_yy) / 2;
    sigma_diff = (sigma_xx - sigma_yy) / 2;
    
    sigma_1 = sigma_avg + sqrt(sigma_diff^2 + tau_xy^2);
    sigma_2 = sigma_avg - sqrt(sigma_diff^2 + tau_xy^2);
    
    % 최대 주응력 이론
    constraint = max(abs(sigma_1), abs(sigma_2)) - sigma_allowable;
end
```

#### 변위 제약 (Displacement Constraints)
**구조물의 과도한 변형 방지**

**처짐 제한:**
```matlab
function deflection_constraint = beam_deflection_limit(x)
    % 보의 치수
    width = x(1); height = x(2); length = x(3);
    
    % 최대 처짐 계산
    I = width * height^3 / 12;
    E = 200e9;  % 탄성계수 [Pa]
    P = 10000;  % 하중 [N]
    
    delta_max = P * length^3 / (3 * E * I);
    
    % 허용 처짐 (보통 경간의 1/250 ~ 1/400)
    delta_allowable = length / 300;
    
    deflection_constraint = delta_max - delta_allowable;
end
```

**절대 변위 제한:**
```matlab
function displacement_constraint = max_displacement_limit(x, load_cases)
    max_displacement = 0;
    
    for i = 1:length(load_cases)
        % 각 하중 케이스에 대한 해석
        displacements = structural_analysis(x, load_cases{i});
        max_disp_case = max(abs(displacements));
        max_displacement = max(max_displacement, max_disp_case);
    end
    
    % 허용 변위 (예: 10mm)
    allowable_displacement = 0.01;  % m
    
    displacement_constraint = max_displacement - allowable_displacement;
end
```

#### 진동 제약 (Vibration Constraints)
**공진 회피 및 동적 안정성 확보**

**고유진동수 범위 제약:**
```matlab
function frequency_constraint = natural_frequency_limits(x)
    % 고유값 해석
    [K, M] = assemble_matrices(x);
    [eigenvectors, eigenvalues] = eig(K, M);
    
    % 고유진동수 계산 [Hz]
    frequencies = sqrt(diag(eigenvalues)) / (2*pi);
    first_frequency = min(frequencies);
    
    % 진동수 제약 (예: 15Hz 이상)
    min_required_freq = 15;  % Hz
    frequency_constraint = min_required_freq - first_frequency;
end
```

**진동수 회피:**
```matlab
function avoidance_constraint = frequency_avoidance(frequencies, avoid_ranges)
    % 회피해야 할 진동수 범위들
    % avoid_ranges = [10, 12; 25, 27; 50, 55];  % Hz
    
    constraints = [];
    
    for freq = frequencies
        for i = 1:size(avoid_ranges, 1)
            f_min = avoid_ranges(i, 1);
            f_max = avoid_ranges(i, 2);
            
            if freq >= f_min && freq <= f_max
                % 금지 구간 내부: 거리 기반 페널티
                distance_to_boundary = min(freq - f_min, f_max - freq);
                constraints(end+1) = -distance_to_boundary;
            end
        end
    end
    
    if isempty(constraints)
        avoidance_constraint = 0;  % 모든 진동수가 안전 구간
    else
        avoidance_constraint = max(constraints);
    end
end
```

#### 좌굴 제약 (Buckling Constraints)
**압축 부재의 좌굴 방지**

**오일러 좌굴 하중:**
```matlab
function buckling_constraint = euler_buckling_check(x, compression_force)
    % 기둥 치수
    length = x(1);
    diameter = x(2);
    
    % 단면 특성
    area = pi * diameter^2 / 4;
    I = pi * diameter^4 / 64;
    radius_gyration = sqrt(I / area);
    
    % 세장비
    slenderness_ratio = length / radius_gyration;
    
    % 오일러 좌굴 하중
    E = 200e9;  % 탄성계수 [Pa]
    P_euler = pi^2 * E * I / length^2;
    
    % 안전계수 적용
    safety_factor = 2.0;
    P_allowable = P_euler / safety_factor;
    
    buckling_constraint = compression_force - P_allowable;
end
```

### 2. 기하학적 제약

#### 치수 한계
```matlab
function geometry_constraints = geometric_limits(x)
    width = x(1); height = x(2); thickness = x(3);
    
    constraints = [];
    
    % 최소 제조 두께
    min_thickness = 0.001;  % 1mm
    constraints(end+1) = min_thickness - thickness;
    
    % 종횡비 제한 (가로세로 비율)
    aspect_ratio = height / width;
    max_aspect_ratio = 5.0;
    constraints(end+1) = aspect_ratio - max_aspect_ratio;
    
    % 최소 단면적
    area = width * thickness;
    min_area = 0.0001;  % m²
    constraints(end+1) = min_area - area;
    
    geometry_constraints = constraints;
end
```

#### 간섭 회피
```matlab
function interference_constraint = check_interference(positions, sizes)
    % 여러 구성요소 간 간섭 체크
    n_components = length(positions);
    min_clearance = 0.005;  % 5mm 최소 간격
    
    max_interference = 0;
    
    for i = 1:n_components
        for j = i+1:n_components
            % 두 구성요소 간 거리
            distance = norm(positions{i} - positions{j});
            
            % 필요한 최소 거리
            required_distance = (sizes(i) + sizes(j))/2 + min_clearance;
            
            % 간섭량 계산
            interference = required_distance - distance;
            max_interference = max(max_interference, interference);
        end
    end
    
    interference_constraint = max_interference;
end
```

### 3. 제조 제약

#### 가공 가능성
```matlab
function manufacturing_constraints = machining_constraints(x)
    % 설계 형상 파라미터
    hole_diameter = x(1);
    hole_depth = x(2);
    corner_radius = x(3);
    
    constraints = [];
    
    % 드릴 가공 제약: 깊이/지름 비율
    depth_diameter_ratio = hole_depth / hole_diameter;
    max_ratio = 10;  % 일반적 한계
    constraints(end+1) = depth_diameter_ratio - max_ratio;
    
    % 최소 모서리 반지름 (엔드밀 반지름)
    min_corner_radius = 0.0005;  % 0.5mm
    constraints(end+1) = min_corner_radius - corner_radius;
    
    % 최소 벽 두께 (공구 접근성)
    wall_thickness = calculate_min_wall_thickness(x);
    min_wall = 0.002;  % 2mm
    constraints(end+1) = min_wall - wall_thickness;
    
    manufacturing_constraints = constraints;
end
```

#### 3D 프린팅 제약
```matlab
function am_constraints = additive_manufacturing_constraints(x, print_direction)
    constraints = [];
    
    % 오버행 각도 제한
    overhang_angles = calculate_overhang_angles(x, print_direction);
    max_overhang = 45;  % 도
    for angle = overhang_angles
        constraints(end+1) = angle - max_overhang;
    end
    
    % 최소 특징 크기
    min_feature_size = 0.0002;  % 0.2mm
    feature_sizes = extract_feature_sizes(x);
    for size = feature_sizes
        constraints(end+1) = min_feature_size - size;
    end
    
    % 서포트 구조 필요성 최소화
    support_area = calculate_support_area(x, print_direction);
    max_support_ratio = 0.1;  % 전체 면적의 10%
    total_area = calculate_total_surface_area(x);
    constraints(end+1) = support_area/total_area - max_support_ratio;
    
    am_constraints = constraints;
end
```

### 4. 성능 제약

#### 열 전달 제약
```matlab
function thermal_constraint = heat_transfer_limits(x, heat_source)
    % 열전도 해석
    temperature_field = thermal_analysis(x, heat_source);
    max_temperature = max(temperature_field);
    
    % 허용 온도 (재료/부품 한계)
    allowable_temperature = 150;  % °C
    
    thermal_constraint = max_temperature - allowable_temperature;
end
```

#### 유동 제약
```matlab
function flow_constraint = pressure_drop_limit(x, flow_rate)
    % CFD 해석 또는 경험식
    pressure_drop = calculate_pressure_drop(x, flow_rate);
    
    % 허용 압력 손실
    max_pressure_drop = 1000;  % Pa
    
    flow_constraint = pressure_drop - max_pressure_drop;
end
```

---

## ⚙️ 제약조건 처리 기법

### 1. 능동/수동 제약 개념

#### KKT 조건과의 관련성
```matlab
function [active_constraints, inactive_constraints] = classify_constraints(x, constraints, tolerance)
    % 제약조건 값 계산
    g_values = zeros(length(constraints), 1);
    for i = 1:length(constraints)
        g_values(i) = constraints{i}(x);
    end
    
    % 능동/수동 분류
    active_idx = abs(g_values) < tolerance;
    inactive_idx = g_values < -tolerance;
    
    active_constraints = find(active_idx);
    inactive_constraints = find(inactive_idx);
    
    % 위반된 제약조건 확인
    violated_idx = g_values > tolerance;
    if any(violated_idx)
        warning('Some constraints are violated');
        disp(find(violated_idx));
    end
end
```

### 2. 벌점함수법 (Penalty Method)

#### 외부 벌점법
```matlab
function f_penalty = external_penalty(x, objective, constraints, penalty_coef)
    % 원래 목적함수
    f0 = objective(x);
    
    % 제약조건 벌점
    penalty_sum = 0;
    for i = 1:length(constraints)
        g_i = constraints{i}(x);
        
        % 부등식 제약: g(x) ≤ 0
        if g_i > 0
            penalty_sum = penalty_sum + g_i^2;
        end
    end
    
    f_penalty = f0 + penalty_coef * penalty_sum;
end

% 점진적 벌점 계수 증가
function x_opt = progressive_penalty_optimization(x0, objective, constraints)
    penalty_coefficients = [1, 10, 100, 1000, 10000];
    x_current = x0;
    
    for r = penalty_coefficients
        penalty_objective = @(x) external_penalty(x, objective, constraints, r);
        
        options = optimoptions('fminunc', 'Display', 'off');
        x_current = fminunc(penalty_objective, x_current, options);
        
        fprintf('Penalty coefficient: %g, Objective: %g\n', r, objective(x_current));
    end
    
    x_opt = x_current;
end
```

#### 내부 벌점법 (장벽법)
```matlab
function f_barrier = barrier_method(x, objective, constraints, barrier_coef)
    % 원래 목적함수
    f0 = objective(x);
    
    % 장벽 함수
    barrier_sum = 0;
    for i = 1:length(constraints)
        g_i = constraints{i}(x);
        
        if g_i >= 0
            % 제약조건 위반 시 무한대
            f_barrier = Inf;
            return;
        else
            % 로그 장벽
            barrier_sum = barrier_sum - log(-g_i);
        end
    end
    
    f_barrier = f0 + barrier_coef * barrier_sum;
end
```

### 3. 라그랑지 승수법

#### 등식 제약만 있는 경우
```matlab
function [x_opt, lambda_opt] = lagrange_multiplier_method(objective, equality_constraints, x0)
    % 라그랑지안 함수 정의
    lagrangian = @(vars) lagrangian_function(vars, objective, equality_constraints);
    
    % 변수: [x; lambda]
    n_vars = length(x0);
    n_eq_constraints = length(equality_constraints);
    vars0 = [x0; zeros(n_eq_constraints, 1)];
    
    % 최적화 (라그랑지안의 그래디언트 = 0)
    options = optimoptions('fsolve', 'Display', 'iter');
    vars_opt = fsolve(@(vars) lagrangian_gradient(vars, objective, equality_constraints), vars0, options);
    
    x_opt = vars_opt(1:n_vars);
    lambda_opt = vars_opt(n_vars+1:end);
end

function grad = lagrangian_gradient(vars, objective, equality_constraints)
    n_vars = length(vars) - length(equality_constraints);
    x = vars(1:n_vars);
    lambda = vars(n_vars+1:end);
    
    % 목적함수 그래디언트
    grad_f = gradient_fd(objective, x);
    
    % 제약조건 그래디언트
    grad_h = zeros(n_vars, length(equality_constraints));
    for i = 1:length(equality_constraints)
        grad_h(:, i) = gradient_fd(equality_constraints{i}, x);
    end
    
    % KKT 조건
    grad_x = grad_f + grad_h * lambda;
    grad_lambda = zeros(length(equality_constraints), 1);
    for i = 1:length(equality_constraints)
        grad_lambda(i) = equality_constraints{i}(x);
    end
    
    grad = [grad_x; grad_lambda];
end
```

### 4. 제약 근사화 기법

#### 순차 선형계획법 (SLP)
```matlab
function x_opt = sequential_linear_programming(x0, objective, constraints, max_iter)
    x_current = x0;
    
    for iter = 1:max_iter
        % 현재점에서 선형화
        [c, A, b] = linearize_problem(x_current, objective, constraints);
        
        % 신뢰영역 제약
        trust_radius = 0.1;
        lb = x_current - trust_radius;
        ub = x_current + trust_radius;
        
        % 선형계획법 해결
        options = optimoptions('linprog', 'Display', 'off');
        [x_new, ~, exitflag] = linprog(c, A, b, [], [], lb, ub, options);
        
        if exitflag <= 0
            warning('Linear programming failed');
            break;
        end
        
        % 수렴 확인
        if norm(x_new - x_current) < 1e-6
            break;
        end
        
        x_current = x_new;
    end
    
    x_opt = x_current;
end

function [c, A, b] = linearize_problem(x0, objective, constraints)
    % 목적함수 선형화: f(x) ≈ f(x0) + ∇f(x0)ᵀ(x - x0)
    grad_f = gradient_fd(objective, x0);
    c = grad_f;
    
    % 제약조건 선형화: g(x) ≈ g(x0) + ∇g(x0)ᵀ(x - x0) ≤ 0
    n_constraints = length(constraints);
    A = zeros(n_constraints, length(x0));
    b = zeros(n_constraints, 1);
    
    for i = 1:n_constraints
        g_i = constraints{i}(x0);
        grad_g_i = gradient_fd(constraints{i}, x0);
        
        A(i, :) = grad_g_i';
        b(i) = -g_i + grad_g_i' * x0;
    end
end
```

#### 순차 이차계획법 (SQP)
```matlab
function x_opt = sequential_quadratic_programming(x0, objective, constraints)
    % MATLAB의 fmincon을 사용한 SQP
    
    % 제약조건 함수 정의
    nonlcon = @(x) constraint_function(x, constraints);
    
    % 최적화 옵션
    options = optimoptions('fmincon', ...
        'Algorithm', 'sqp', ...
        'Display', 'iter', ...
        'OptimalityTolerance', 1e-6, ...
        'ConstraintTolerance', 1e-6);
    
    % 최적화 실행
    [x_opt, fval, exitflag, output] = fmincon(objective, x0, [], [], [], [], [], [], nonlcon, options);
    
    if exitflag <= 0
        warning('SQP optimization failed');
    end
end

function [c, ceq] = constraint_function(x, constraints)
    % 부등식 제약조건
    c = zeros(length(constraints.inequality), 1);
    for i = 1:length(constraints.inequality)
        c(i) = constraints.inequality{i}(x);
    end
    
    % 등식 제약조건  
    ceq = zeros(length(constraints.equality), 1);
    for i = 1:length(constraints.equality)
        ceq(i) = constraints.equality{i}(x);
    end
end
```

---

## 📊 실제 설계 사례

### 사례 1: 압력용기 설계

**설계변수:**
- 내부 반지름: r
- 벽 두께: t
- 길이: L

**제약조건:**

```matlab
function constraints = pressure_vessel_constraints(x, design_data)
    r = x(1);  % 내부 반지름 [m]
    t = x(2);  % 벽 두께 [m]  
    L = x(3);  % 길이 [m]
    
    P = design_data.pressure;        % 내부 압력 [Pa]
    sigma_y = design_data.yield;     % 항복강도 [Pa]
    sf = design_data.safety_factor;  % 안전계수
    
    constraints = [];
    
    % 1. 후프 응력 제약 (원주방향)
    sigma_hoop = P * r / t;
    sigma_allow = sigma_y / sf;
    constraints(end+1) = sigma_hoop - sigma_allow;
    
    % 2. 축 응력 제약 (길이방향)  
    sigma_axial = P * r / (2 * t);
    constraints(end+1) = sigma_axial - sigma_allow;
    
    % 3. 최소 두께 (제조 한계)
    min_thickness = 0.005;  % 5mm
    constraints(end+1) = min_thickness - t;
    
    % 4. 세장비 제한 (좌굴 방지)
    slenderness = L / (2 * r);
    max_slenderness = 10;
    constraints(end+1) = slenderness - max_slenderness;
    
    % 5. 부피 요구사항 (등식 제약조건으로 처리)
    required_volume = design_data.volume;
    actual_volume = pi * r^2 * L;
    volume_error = abs(actual_volume - required_volume) / required_volume;
    tolerance = 0.01;  % 1% 허용오차
    constraints(end+1) = volume_error - tolerance;
end

% 사용 예시
design_data = struct(...
    'pressure', 2e6, ...      % 2 MPa
    'yield', 250e6, ...       % 250 MPa
    'safety_factor', 2.5, ... 
    'volume', 10 ...          % 10 m³
);

x0 = [1.0, 0.02, 5.0];  % 초기 추정값
constraints_func = @(x) pressure_vessel_constraints(x, design_data);
```

### 사례 2: 항공기 날개 구조 최적화

**복잡한 다중 제약조건:**

```matlab
function constraints = wing_structure_constraints(x, load_cases, materials)
    % x: 설계변수 벡터 (스킨 두께, 스트링거 치수 등)
    
    constraints = [];
    
    % 1. 응력 제약 (모든 하중 케이스)
    for i = 1:length(load_cases)
        stress_field = structural_analysis(x, load_cases{i});
        max_stress = max(stress_field);
        allowable = materials.yield_strength / materials.safety_factor;
        constraints(end+1) = max_stress - allowable;
    end
    
    % 2. 좌굴 제약 (압축 패널)
    compression_panels = identify_compression_panels(x, load_cases);
    for panel = compression_panels
        buckling_load = calculate_buckling_load(panel, x);
        applied_load = panel.compression_force;
        buckling_safety = 1.5;
        constraints(end+1) = applied_load - buckling_load/buckling_safety;
    end
    
    % 3. 처짐 제약 (공력 성능 유지)
    tip_deflection = calculate_tip_deflection(x, load_cases.cruise);
    max_deflection = 0.1 * wing_span;  % 날개 스팬의 10%
    constraints(end+1) = tip_deflection - max_deflection;
    
    % 4. 진동 제약 (플러터 방지)
    natural_frequencies = modal_analysis(x);
    first_freq = min(natural_frequencies);
    min_required_freq = 5.0;  % Hz (플러터 여유)
    constraints(end+1) = min_required_freq - first_freq;
    
    % 5. 제조 제약
    manufacturing_constraints = apply_manufacturing_rules(x);
    constraints = [constraints, manufacturing_constraints];
    
    % 6. 연료 탱크 부피 (등식 제약)
    fuel_volume = calculate_internal_volume(x);
    required_fuel_volume = 50000;  % L
    volume_tolerance = 0.02;  % 2%
    volume_error = abs(fuel_volume - required_fuel_volume) / required_fuel_volume;
    constraints(end+1) = volume_error - volume_tolerance;
end
```

### 사례 3: 로봇 매니퓰레이터 설계

**다양한 성능 제약:**

```matlab
function constraints = robot_manipulator_constraints(x, workspace_requirements)
    % x: [link_lengths, joint_limits, motor_specs]
    
    link_lengths = x(1:6);
    joint_limits = reshape(x(7:18), 6, 2);  % [min, max] for each joint
    motor_torques = x(19:24);
    
    constraints = [];
    
    % 1. 작업공간 요구사항
    workspace_points = workspace_requirements.required_points;
    for point = workspace_points
        reachability = check_reachability(link_lengths, joint_limits, point);
        constraints(end+1) = -reachability;  % 도달 불가능하면 양수
    end
    
    % 2. 특이점 회피 (최소 조작성 확보)
    test_configurations = generate_test_configurations(joint_limits);
    min_manipulability = Inf;
    
    for config = test_configurations
        jacobian = compute_jacobian(link_lengths, config);
        manipulability = sqrt(det(jacobian * jacobian'));
        min_manipulability = min(min_manipulability, manipulability);
    end
    
    required_manipulability = 0.01;
    constraints(end+1) = required_manipulability - min_manipulability;
    
    % 3. 동적 성능 (최대 가속도)
    max_joint_accelerations = calculate_max_accelerations(link_lengths, motor_torques);
    required_acceleration = 10;  % rad/s²
    for acc = max_joint_accelerations
        constraints(end+1) = required_acceleration - acc;
    end
    
    % 4. 충돌 회피 (자기 간섭)
    collision_margin = 0.05;  % 5cm
    min_clearance = check_self_collision(link_lengths, joint_limits);
    constraints(end+1) = collision_margin - min_clearance;
    
    % 5. 모터 토크 한계
    max_required_torques = calculate_required_torques(link_lengths, workspace_requirements.loads);
    for i = 1:6
        constraints(end+1) = max_required_torques(i) - motor_torques(i);
    end
end
```

---

## 💻 고급 구현 기법

### 적응적 제약조건 처리

```matlab
classdef AdaptiveConstraintHandler < handle
    properties
        constraint_functions
        tolerance
        active_constraints
        constraint_history
        penalty_parameters
    end
    
    methods
        function obj = AdaptiveConstraintHandler(constraints, tol)
            obj.constraint_functions = constraints;
            obj.tolerance = tol;
            obj.active_constraints = [];
            obj.constraint_history = [];
            obj.penalty_parameters = ones(length(constraints), 1);
        end
        
        function [c, active_idx] = evaluate_constraints(obj, x)
            c = zeros(length(obj.constraint_functions), 1);
            
            for i = 1:length(obj.constraint_functions)
                c(i) = obj.constraint_functions{i}(x);
            end
            
            % 능동 제약조건 식별
            active_idx = abs(c) < obj.tolerance;
            obj.active_constraints = find(active_idx);
            
            % 히스토리 저장
            obj.constraint_history(end+1, :) = c';
            
            % 벌점 매개변수 적응적 조정
            obj.update_penalty_parameters(c);
        end
        
        function update_penalty_parameters(obj, c)
            % 위반된 제약조건의 벌점 계수 증가
            violation_factor = 2.0;
            
            for i = 1:length(c)
                if c(i) > obj.tolerance
                    obj.penalty_parameters(i) = obj.penalty_parameters(i) * violation_factor;
                elseif c(i) < -obj.tolerance && obj.penalty_parameters(i) > 1
                    obj.penalty_parameters(i) = obj.penalty_parameters(i) / violation_factor;
                end
            end
        end
        
        function f_penalty = penalized_objective(obj, x, original_objective)
            [c, ~] = obj.evaluate_constraints(x);
            f0 = original_objective(x);
            
            penalty = 0;
            for i = 1:length(c)
                if c(i) > 0
                    penalty = penalty + obj.penalty_parameters(i) * c(i)^2;
                end
            end
            
            f_penalty = f0 + penalty;
        end
        
        function plot_constraint_history(obj)
            if isempty(obj.constraint_history)
                warning('No constraint history available');
                return;
            end
            
            figure;
            plot(obj.constraint_history);
            xlabel('Iteration');
            ylabel('Constraint Value');
            title('Constraint Evolution');
            legend(arrayfun(@(i) sprintf('g_%d', i), 1:size(obj.constraint_history,2), 'UniformOutput', false));
            grid on;
        end
    end
end
```

### 병렬 제약조건 평가

```matlab
function constraints = parallel_constraint_evaluation(x, constraint_functions)
    % 제약조건들을 병렬로 평가
    n_constraints = length(constraint_functions);
    constraints = zeros(n_constraints, 1);
    
    % 병렬 처리가 가능한 경우
    if n_constraints > 4 && ~isempty(gcp('nocreate'))
        parfor i = 1:n_constraints
            constraints(i) = constraint_functions{i}(x);
        end
    else
        % 순차 처리
        for i = 1:n_constraints
            constraints(i) = constraint_functions{i}(x);
        end
    end
end
```

---

## 🎓 학습 단계별 가이드

### 초급 (1-2개월)

**1주차: 기본 개념**
```matlab
% 간단한 2변수 제약 최적화
objective = @(x) (x(1)-2)^2 + (x(2)-1)^2;

% 제약조건: x1 + x2 ≤ 3, x1 ≥ 0, x2 ≥ 0
constraint = @(x) x(1) + x(2) - 3;

% 시각화로 이해
x1 = 0:0.1:4; x2 = 0:0.1:4;
[X1, X2] = meshgrid(x1, x2);
Z = (X1-2).^2 + (X2-1).^2;

contour(X1, X2, Z, 20);
hold on;
plot([0 3], [3 0], 'r-', 'LineWidth', 2);  % 제약조건 경계
```

**2주차: 라그랑지 승수법**
```matlab
% 등식 제약이 있는 문제 손풀이
% min f(x,y) = x² + y²
% s.t. g(x,y) = x + y - 1 = 0

syms x y lambda
L = x^2 + y^2 + lambda*(x + y - 1);

% KKT 조건
dL_dx = diff(L, x);  % 2x + lambda = 0
dL_dy = diff(L, y);  % 2y + lambda = 0  
dL_dlambda = diff(L, lambda);  % x + y - 1 = 0

% 해 구하기
sol = solve([dL_dx, dL_dy, dL_dlambda], [x, y, lambda]);
```

### 중급 (3-4개월)

**3-4주차: 실제 공학 문제**
```matlab
% 트러스 최적화 문제
function example_truss_optimization()
    % 10-bar 트러스 문제
    areas_initial = ones(10, 1) * 0.001;  % 초기 단면적 [m²]
    
    % 목적함수: 질량 최소화
    objective = @(A) truss_mass(A);
    
    % 제약조건
    nonlcon = @(A) truss_constraints(A);
    
    % 박스 제약 (단면적 범위)
    lb = ones(10, 1) * 0.0001;  % 최소 단면적
    ub = ones(10, 1) * 0.01;    % 최대 단면적
    
    % 최적화 실행
    options = optimoptions('fmincon', 'Display', 'iter');
    [A_opt, mass_opt] = fmincon(objective, areas_initial, [], [], [], [], lb, ub, nonlcon, options);
    
    fprintf('Optimal mass: %.2f kg\n', mass_opt);
end
```

### 고급 (6개월+)

**5-8주차: 고급 제약조건**
- 동적 제약조건
- 확률적 제약조건  
- PDE 제약조건

**9-12주차: 실무 프로젝트**
- 다분야 연성 제약
- 대규모 제약조건 시스템
- 실시간 제약조건 처리

---

**참고문헌:**
- Nocedal, J. & Wright, S.J. (2006). *Numerical Optimization*. Springer.
- Bertsekas, D.P. (2016). *Nonlinear Programming*. Athena Scientific.
- Boyd, S. & Vandenberghe, L. (2004). *Convex Optimization*. Cambridge University Press.
- Bazaraa, M.S., Sherali, H.D. & Shetty, C.M. (2013). *Nonlinear Programming: Theory and Algorithms*. Wiley.