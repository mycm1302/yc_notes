# 처리량

> 상위: [[실시간제어]]

실시간 시스템에서 단위 시간당 처리할 수 있는 작업량이나 데이터량을 나타내는 성능 지표입니다.

## 📊 처리량 정의와 측정

### 기본 정의
```
처리량 (Throughput) = 총 처리된 요청 수 / 총 소요 시간

측정 단위:
- TPS (Transactions Per Second): 초당 트랜잭션 수
- RPS (Requests Per Second): 초당 요청 수  
- BPS (Bytes Per Second): 초당 바이트 수
- Hz (Hertz): 초당 사이클 수 (제어 시스템)
```

### 실시간 시스템에서의 처리량
```cpp
// 실시간 제어 시스템 처리량 측정
class RealTimeThroughputMonitor {
private:
    unsigned long total_processed_tasks = 0;
    unsigned long measurement_start_time;
    static const int WINDOW_SIZE = 1000;  // 1초 윈도우
    
    int task_count_window[WINDOW_SIZE];
    int window_index = 0;
    
public:
    void startMeasurement() {
        measurement_start_time = millis();
        total_processed_tasks = 0;
        memset(task_count_window, 0, sizeof(task_count_window));
    }
    
    void recordTaskCompletion() {
        total_processed_tasks++;
        
        // 현재 밀리초에 해당하는 윈도우에 기록
        int current_ms = millis() % WINDOW_SIZE;
        task_count_window[current_ms]++;
    }
    
    float calculateInstantaneousThroughput() {
        // 최근 1초간 처리량 계산
        int recent_tasks = 0;
        int current_ms = millis() % WINDOW_SIZE;
        
        for(int i = 0; i < WINDOW_SIZE; i++) {
            int index = (current_ms - i + WINDOW_SIZE) % WINDOW_SIZE;
            recent_tasks += task_count_window[index];
        }
        
        return recent_tasks;  // 초당 처리량
    }
    
    float calculateAverageThroughput() {
        unsigned long elapsed_time = millis() - measurement_start_time;
        return (float)total_processed_tasks * 1000.0 / elapsed_time;
    }
    
    void printThroughputStats() {
        Serial.printf("Total processed: %lu tasks\n", total_processed_tasks);
        Serial.printf("Average throughput: %.2f TPS\n", calculateAverageThroughput());
        Serial.printf("Current throughput: %.2f TPS\n", calculateInstantaneousThroughput());
    }
};
```

## ⚙️ 처리량 영향 요인

### 하드웨어 제약
```cpp
// CPU 성능과 처리량 관계
class CPUThroughputAnalyzer {
private:
    int cpu_utilization = 0;
    float max_theoretical_throughput;
    
public:
    void measureCPUUtilization() {
        // 간단한 CPU 사용률 추정
        unsigned long busy_time = 0;
        unsigned long total_time = 1000;  // 1초
        
        unsigned long start = micros();
        
        // 1초간 실제 작업 수행
        while(micros() - start < 1000000) {
            unsigned long task_start = micros();
            performTypicalTask();
            busy_time += micros() - task_start;
        }
        
        cpu_utilization = (busy_time * 100) / total_time;
    }
    
    float estimateMaxThroughput(float task_execution_time_us) {
        // 이론적 최대 처리량 계산
        max_theoretical_throughput = 1000000.0 / task_execution_time_us;
        
        // CPU 오버헤드 고려 (스케줄링, 인터럽트 등)
        float practical_throughput = max_theoretical_throughput * 0.8;
        
        return practical_throughput;
    }
    
    bool isBottleneck() {
        return cpu_utilization > 80;  // 80% 이상이면 CPU 병목
    }
};

// 메모리 대역폭과 처리량
class MemoryBandwidthAnalyzer {
private:
    size_t data_transferred = 0;
    unsigned long transfer_start_time;
    
public:
    void measureMemoryThroughput() {
        const size_t buffer_size = 1024;
        uint8_t source[buffer_size];
        uint8_t dest[buffer_size];
        
        transfer_start_time = micros();
        
        // 메모리 복사 성능 측정
        for(int i = 0; i < 1000; i++) {
            memcpy(dest, source, buffer_size);
            data_transferred += buffer_size;
        }
        
        unsigned long elapsed = micros() - transfer_start_time;
        float bandwidth_mbps = (float)data_transferred * 8.0 / elapsed;
        
        Serial.printf("Memory bandwidth: %.2f Mbps\n", bandwidth_mbps);
    }
    
    void optimizeMemoryAccess() {
        // 캐시 친화적 메모리 접근 패턴
        // 순차적 접근으로 캐시 미스 최소화
        // 적절한 데이터 정렬 사용
    }
};
```

### 소프트웨어 최적화
```cpp
// 알고리즘 최적화를 통한 처리량 향상
class AlgorithmOptimizer {
public:
    // O(n²) 버블 정렬 대신 O(n log n) 퀵정렬
    void optimizeSort(int arr[], int size) {
        // 기존 버블 정렬: O(n²)
        // for(int i = 0; i < size-1; i++) {
        //     for(int j = 0; j < size-i-1; j++) {
        //         if(arr[j] > arr[j+1]) {
        //             swap(arr[j], arr[j+1]);
        //         }
        //     }
        // }
        
        // 최적화된 퀵정렬: O(n log n)
        quickSort(arr, 0, size - 1);
    }
    
    // 룩업 테이블을 이용한 삼각함수 최적화
    class TrigLookupTable {
    private:
        static const int TABLE_SIZE = 360;
        float sin_table[TABLE_SIZE];
        float cos_table[TABLE_SIZE];
        
    public:
        TrigLookupTable() {
            for(int i = 0; i < TABLE_SIZE; i++) {
                float angle = i * PI / 180.0;
                sin_table[i] = sin(angle);
                cos_table[i] = cos(angle);
            }
        }
        
        float fastSin(int degrees) {
            return sin_table[degrees % 360];
        }
        
        float fastCos(int degrees) {
            return cos_table[degrees % 360];
        }
    };
    
    // 고정점 연산으로 부동소수점 연산 대체
    typedef int32_t fixed_point_t;
    #define FIXED_POINT_SHIFT 16
    #define FLOAT_TO_FIXED(x) ((fixed_point_t)((x) * (1 << FIXED_POINT_SHIFT)))
    #define FIXED_TO_FLOAT(x) ((float)(x) / (1 << FIXED_POINT_SHIFT))
    
    fixed_point_t fixedMultiply(fixed_point_t a, fixed_point_t b) {
        return (a * b) >> FIXED_POINT_SHIFT;
    }
    
private:
    void quickSort(int arr[], int low, int high) {
        if(low < high) {
            int pivot = partition(arr, low, high);
            quickSort(arr, low, pivot - 1);
            quickSort(arr, pivot + 1, high);
        }
    }
    
    int partition(int arr[], int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for(int j = low; j < high; j++) {
            if(arr[j] < pivot) {
                i++;
                swap(arr[i], arr[j]);
            }
        }
        swap(arr[i + 1], arr[high]);
        return i + 1;
    }
    
    void swap(int& a, int& b) {
        int temp = a;
        a = b;
        b = temp;
    }
};
```

## 🎯 처리량 최적화 전략

### 파이프라인 처리
```cpp
// 파이프라인을 이용한 처리량 향상
class PipelineProcessor {
private:
    enum PipelineStage {
        STAGE_INPUT,
        STAGE_PROCESS,
        STAGE_OUTPUT,
        NUM_STAGES
    };
    
    struct PipelineData {
        int id;
        float input_value;
        float processed_value;
        bool ready[NUM_STAGES];
    };
    
    PipelineData pipeline[4];  // 4단계 파이프라인
    int current_input = 0;
    
public:
    void processPipeline() {
        // 각 스테이지를 병렬로 처리
        
        // Stage 3: 출력 (가장 늦은 단계부터)
        if(pipeline[3].ready[STAGE_PROCESS]) {
            outputResult(pipeline[3]);
            pipeline[3].ready[STAGE_OUTPUT] = true;
            pipeline[3].ready[STAGE_PROCESS] = false;
        }
        
        // Stage 2: 처리
        if(pipeline[2].ready[STAGE_INPUT]) {
            pipeline[2].processed_value = processData(pipeline[2].input_value);
            pipeline[2].ready[STAGE_PROCESS] = true;
            pipeline[2].ready[STAGE_INPUT] = false;
            
            // 다음 단계로 전달
            pipeline[3] = pipeline[2];
        }
        
        // Stage 1: 입력
        if(hasNewInput()) {
            pipeline[1].id = current_input++;
            pipeline[1].input_value = getNextInput();
            pipeline[1].ready[STAGE_INPUT] = true;
            
            // 다음 단계로 전달  
            pipeline[2] = pipeline[1];
        }
    }
    
    float calculatePipelineThroughput() {
        // 파이프라인이 가득 찬 후의 처리량
        // 매 사이클마다 하나의 결과 출력 가능
        return 1000.0;  // 1kHz 클록에서 1000 TPS
    }
    
private:
    float processData(float input) {
        // 복잡한 처리 로직
        return input * 2.5 + 10.0;
    }
    
    void outputResult(const PipelineData& data) {
        Serial.printf("Result %d: %.2f\n", data.id, data.processed_value);
    }
    
    bool hasNewInput() {
        // 새로운 입력 데이터 확인
        return true;  // 예시
    }
    
    float getNextInput() {
        return random(0, 100);
    }
};
```

### 병렬 처리
```cpp
// 멀티태스킹을 이용한 병렬 처리
class ParallelProcessor {
private:
    TaskHandle_t worker_tasks[4];
    QueueHandle_t input_queue;
    QueueHandle_t output_queue;
    
    struct WorkItem {
        int id;
        float data[100];
        int data_size;
    };
    
public:
    void setupParallelProcessing() {
        // 입출력 큐 생성
        input_queue = xQueueCreate(20, sizeof(WorkItem));
        output_queue = xQueueCreate(20, sizeof(WorkItem));
        
        // 워커 태스크들 생성
        for(int i = 0; i < 4; i++) {
            char task_name[16];
            sprintf(task_name, "Worker%d", i);
            
            xTaskCreate(workerTask, task_name, 2048, 
                       (void*)i, tskIDLE_PRIORITY + 2, &worker_tasks[i]);
        }
        
        // 입력 태스크 생성
        xTaskCreate(inputTask, "InputTask", 1024, 
                   NULL, tskIDLE_PRIORITY + 1, NULL);
        
        // 출력 태스크 생성
        xTaskCreate(outputTask, "OutputTask", 1024, 
                   NULL, tskIDLE_PRIORITY + 1, NULL);
    }
    
    static void workerTask(void* parameter) {
        int worker_id = (int)parameter;
        WorkItem item;
        
        while(1) {
            // 입력 큐에서 작업 가져오기
            if(xQueueReceive(input_queue, &item, portMAX_DELAY) == pdTRUE) {
                
                // 데이터 처리 (병렬로 수행)
                for(int i = 0; i < item.data_size; i++) {
                    item.data[i] = processDataPoint(item.data[i], worker_id);
                }
                
                // 결과를 출력 큐에 전송
                xQueueSend(output_queue, &item, portMAX_DELAY);
            }
        }
    }
    
    static void inputTask(void* parameter) {
        WorkItem item;
        int id_counter = 0;
        
        while(1) {
            // 새로운 데이터 생성
            item.id = id_counter++;
            item.data_size = 100;
            
            for(int i = 0; i < item.data_size; i++) {
                item.data[i] = random(0, 1000) / 100.0;
            }
            
            // 입력 큐에 전송
            xQueueSend(input_queue, &item, 100);  // 100ms 타임아웃
            
            vTaskDelay(pdMS_TO_TICKS(10));  // 10ms 간격
        }
    }
    
    static void outputTask(void* parameter) {
        WorkItem item;
        unsigned long processed_count = 0;
        unsigned long start_time = millis();
        
        while(1) {
            // 출력 큐에서 결과 받기
            if(xQueueReceive(output_queue, &item, portMAX_DELAY) == pdTRUE) {
                processed_count++;
                
                // 주기적으로 처리량 출력
                if(processed_count % 100 == 0) {
                    unsigned long elapsed = millis() - start_time;
                    float throughput = (float)processed_count * 1000.0 / elapsed;
                    
                    Serial.printf("Processed %lu items, Throughput: %.2f TPS\n", 
                                 processed_count, throughput);
                }
            }
        }
    }
    
private:
    static float processDataPoint(float input, int worker_id) {
        // 각 워커별로 다른 처리 또는 동일한 처리
        return input * 1.5 + worker_id * 0.1;
    }
};
```

## 📈 처리량 vs 다른 성능 지표

### 처리량-레이턴시 트레이드오프
```cpp
// 처리량과 레이턴시 간의 균형 관리
class ThroughputLatencyBalancer {
private:
    float target_throughput;
    float max_acceptable_latency;
    int batch_size = 1;
    
public:
    void optimizeForThroughput() {
        // 배치 크기 증가로 처리량 향상
        batch_size = 32;
        
        // 더 많은 데이터를 한 번에 처리하여 오버헤드 감소
        // 단점: 개별 요청의 레이턴시 증가
    }
    
    void optimizeForLatency() {
        // 배치 크기 감소로 레이턴시 최소화
        batch_size = 1;
        
        // 즉시 처리로 응답 시간 최소화
        // 단점: 전체 처리량 감소
    }
    
    void balancePerformance(float current_latency, float current_throughput) {
        if(current_latency > max_acceptable_latency) {
            // 레이턴시가 임계값 초과 시 배치 크기 감소
            batch_size = max(1, batch_size - 1);
        } else if(current_throughput < target_throughput) {
            // 처리량이 목표 미달 시 배치 크기 증가
            batch_size = min(64, batch_size + 1);
        }
    }
    
    void processBatch() {
        static float input_buffer[64];
        static int buffer_count = 0;
        
        // 배치가 가득 찰 때까지 대기하거나 타임아웃
        while(buffer_count < batch_size && hasMoreInput()) {
            input_buffer[buffer_count++] = getNextInput();
        }
        
        if(buffer_count > 0) {
            // 배치 처리
            unsigned long start = micros();
            
            for(int i = 0; i < buffer_count; i++) {
                processItem(input_buffer[i]);
            }
            
            unsigned long processing_time = micros() - start;
            float avg_latency = (float)processing_time / buffer_count;
            
            // 성능 메트릭 업데이트
            updatePerformanceMetrics(buffer_count, avg_latency);
            
            buffer_count = 0;
        }
    }
    
private:
    bool hasMoreInput() { return true; }  // 예시
    float getNextInput() { return random(0, 100); }
    void processItem(float item) { /* 처리 로직 */ }
    void updatePerformanceMetrics(int processed, float latency) {
        // 메트릭 업데이트 로직
    }
};
```

### 처리량 벤치마킹
```cpp
// 시스템 처리량 벤치마크
class ThroughputBenchmark {
private:
    struct BenchmarkResult {
        const char* test_name;
        float max_throughput;
        float sustainable_throughput;
        int test_duration_ms;
    };
    
    BenchmarkResult results[10];
    int result_count = 0;
    
public:
    void runComprehensiveBenchmark() {
        // 다양한 시나리오에서 처리량 측정
        runBenchmark("Simple Addition", testSimpleAddition, 10000);
        runBenchmark("Floating Point Math", testFloatMath, 10000);
        runBenchmark("Memory Copy", testMemoryCopy, 10000);
        runBenchmark("Trigonometry", testTrigonometry, 10000);
        runBenchmark("Sorting Algorithm", testSorting, 5000);
        
        printBenchmarkResults();
    }
    
    void runBenchmark(const char* name, void (*test_func)(), int duration_ms) {
        if(result_count >= 10) return;
        
        unsigned long start_time = millis();
        unsigned long operations = 0;
        float max_tps = 0;
        
        // 지정된 시간 동안 테스트 실행
        while(millis() - start_time < duration_ms) {
            unsigned long op_start = micros();
            
            test_func();
            operations++;
            
            // 초당 처리량 계산 (1초마다)
            if(operations % 1000 == 0) {
                unsigned long elapsed = millis() - start_time;
                float current_tps = (float)operations * 1000.0 / elapsed;
                if(current_tps > max_tps) {
                    max_tps = current_tps;
                }
            }
        }
        
        unsigned long total_elapsed = millis() - start_time;
        float avg_tps = (float)operations * 1000.0 / total_elapsed;
        
        // 결과 저장
        results[result_count] = {name, max_tps, avg_tps, duration_ms};
        result_count++;
    }
    
    void printBenchmarkResults() {
        Serial.println("=== Throughput Benchmark Results ===");
        for(int i = 0; i < result_count; i++) {
            BenchmarkResult* r = &results[i];
            Serial.printf("%s:\n", r->test_name);
            Serial.printf("  Max TPS: %.2f\n", r->max_throughput);
            Serial.printf("  Sustainable TPS: %.2f\n", r->sustainable_throughput);
            Serial.printf("  Test duration: %d ms\n\n", r->test_duration_ms);
        }
    }
    
private:
    static void testSimpleAddition() {
        volatile int a = 123, b = 456;
        volatile int result = a + b;
    }
    
    static void testFloatMath() {
        volatile float a = 3.14159, b = 2.71828;
        volatile float result = a * b + sqrt(a);
    }
    
    static void testMemoryCopy() {
        static uint8_t src[64], dst[64];
        memcpy(dst, src, 64);
    }
    
    static void testTrigonometry() {
        volatile float angle = 1.5708;
        volatile float result = sin(angle) + cos(angle);
    }
    
    static void testSorting() {
        static int arr[10] = {5, 2, 8, 1, 9, 3, 7, 4, 6, 0};
        // 간단한 정렬 (실제로는 더 복잡한 알고리즘 사용)
        for(int i = 0; i < 9; i++) {
            if(arr[i] > arr[i+1]) {
                int temp = arr[i];
                arr[i] = arr[i+1];
                arr[i+1] = temp;
            }
        }
    }
};
```

---

## 🔗 연결 문서
- 상위: [[실시간제어]]
- 관련: [[데드라인]], [[지터]], [[레이턴시]]
- 하드웨어: [[마이크로컨트롤러]], [[센서인터페이스]]
- 최적화: [[우선순위스케줄링]], [[시분할스케줄링]]

## 📚 참고문헌
- [AWS (2025). "Throughput vs Latency - Difference Between Computer Network Performances"](https://aws.amazon.com/compare/the-difference-between-throughput-and-latency/)
- [BrowserStack (2025). "What is Throughput in Performance Testing"](https://www.browserstack.com/guide/throughput-in-performance-testing)
- [Abstracta (2025). "What is Throughput in Performance Testing? A Complete Guide"](https://abstracta.us/blog/performance-testing/what-is-throughput-in-performance-testing/)
- [Equinix (2024). "Understanding Network Performance: Latency vs. Throughput"](https://deploy.equinix.com/blog/explaining-key-network-performance-metrics-latency-vs-throughput/)
