# ì²˜ë¦¬ëŸ‰

> ìƒìœ„: [[ì‹¤ì‹œê°„ì œì–´]]

ì‹¤ì‹œê°„ ì‹œìŠ¤í…œì—ì„œ ë‹¨ìœ„ ì‹œê°„ë‹¹ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” ì‘ì—…ëŸ‰ì´ë‚˜ ë°ì´í„°ëŸ‰ì„ ë‚˜íƒ€ë‚´ëŠ” ì„±ëŠ¥ ì§€í‘œì…ë‹ˆë‹¤.

## ğŸ“Š ì²˜ë¦¬ëŸ‰ ì •ì˜ì™€ ì¸¡ì •

### ê¸°ë³¸ ì •ì˜
```
ì²˜ë¦¬ëŸ‰ (Throughput) = ì´ ì²˜ë¦¬ëœ ìš”ì²­ ìˆ˜ / ì´ ì†Œìš” ì‹œê°„

ì¸¡ì • ë‹¨ìœ„:
- TPS (Transactions Per Second): ì´ˆë‹¹ íŠ¸ëœì­ì…˜ ìˆ˜
- RPS (Requests Per Second): ì´ˆë‹¹ ìš”ì²­ ìˆ˜  
- BPS (Bytes Per Second): ì´ˆë‹¹ ë°”ì´íŠ¸ ìˆ˜
- Hz (Hertz): ì´ˆë‹¹ ì‚¬ì´í´ ìˆ˜ (ì œì–´ ì‹œìŠ¤í…œ)
```

### ì‹¤ì‹œê°„ ì‹œìŠ¤í…œì—ì„œì˜ ì²˜ë¦¬ëŸ‰
```cpp
// ì‹¤ì‹œê°„ ì œì–´ ì‹œìŠ¤í…œ ì²˜ë¦¬ëŸ‰ ì¸¡ì •
class RealTimeThroughputMonitor {
private:
    unsigned long total_processed_tasks = 0;
    unsigned long measurement_start_time;
    static const int WINDOW_SIZE = 1000;  // 1ì´ˆ ìœˆë„ìš°
    
    int task_count_window[WINDOW_SIZE];
    int window_index = 0;
    
public:
    void startMeasurement() {
        measurement_start_time = millis();
        total_processed_tasks = 0;
        memset(task_count_window, 0, sizeof(task_count_window));
    }
    
    void recordTaskCompletion() {
        total_processed_tasks++;
        
        // í˜„ì¬ ë°€ë¦¬ì´ˆì— í•´ë‹¹í•˜ëŠ” ìœˆë„ìš°ì— ê¸°ë¡
        int current_ms = millis() % WINDOW_SIZE;
        task_count_window[current_ms]++;
    }
    
    float calculateInstantaneousThroughput() {
        // ìµœê·¼ 1ì´ˆê°„ ì²˜ë¦¬ëŸ‰ ê³„ì‚°
        int recent_tasks = 0;
        int current_ms = millis() % WINDOW_SIZE;
        
        for(int i = 0; i < WINDOW_SIZE; i++) {
            int index = (current_ms - i + WINDOW_SIZE) % WINDOW_SIZE;
            recent_tasks += task_count_window[index];
        }
        
        return recent_tasks;  // ì´ˆë‹¹ ì²˜ë¦¬ëŸ‰
    }
    
    float calculateAverageThroughput() {
        unsigned long elapsed_time = millis() - measurement_start_time;
        return (float)total_processed_tasks * 1000.0 / elapsed_time;
    }
    
    void printThroughputStats() {
        Serial.printf("Total processed: %lu tasks\n", total_processed_tasks);
        Serial.printf("Average throughput: %.2f TPS\n", calculateAverageThroughput());
        Serial.printf("Current throughput: %.2f TPS\n", calculateInstantaneousThroughput());
    }
};
```

## âš™ï¸ ì²˜ë¦¬ëŸ‰ ì˜í–¥ ìš”ì¸

### í•˜ë“œì›¨ì–´ ì œì•½
```cpp
// CPU ì„±ëŠ¥ê³¼ ì²˜ë¦¬ëŸ‰ ê´€ê³„
class CPUThroughputAnalyzer {
private:
    int cpu_utilization = 0;
    float max_theoretical_throughput;
    
public:
    void measureCPUUtilization() {
        // ê°„ë‹¨í•œ CPU ì‚¬ìš©ë¥  ì¶”ì •
        unsigned long busy_time = 0;
        unsigned long total_time = 1000;  // 1ì´ˆ
        
        unsigned long start = micros();
        
        // 1ì´ˆê°„ ì‹¤ì œ ì‘ì—… ìˆ˜í–‰
        while(micros() - start < 1000000) {
            unsigned long task_start = micros();
            performTypicalTask();
            busy_time += micros() - task_start;
        }
        
        cpu_utilization = (busy_time * 100) / total_time;
    }
    
    float estimateMaxThroughput(float task_execution_time_us) {
        // ì´ë¡ ì  ìµœëŒ€ ì²˜ë¦¬ëŸ‰ ê³„ì‚°
        max_theoretical_throughput = 1000000.0 / task_execution_time_us;
        
        // CPU ì˜¤ë²„í—¤ë“œ ê³ ë ¤ (ìŠ¤ì¼€ì¤„ë§, ì¸í„°ëŸ½íŠ¸ ë“±)
        float practical_throughput = max_theoretical_throughput * 0.8;
        
        return practical_throughput;
    }
    
    bool isBottleneck() {
        return cpu_utilization > 80;  // 80% ì´ìƒì´ë©´ CPU ë³‘ëª©
    }
};

// ë©”ëª¨ë¦¬ ëŒ€ì—­í­ê³¼ ì²˜ë¦¬ëŸ‰
class MemoryBandwidthAnalyzer {
private:
    size_t data_transferred = 0;
    unsigned long transfer_start_time;
    
public:
    void measureMemoryThroughput() {
        const size_t buffer_size = 1024;
        uint8_t source[buffer_size];
        uint8_t dest[buffer_size];
        
        transfer_start_time = micros();
        
        // ë©”ëª¨ë¦¬ ë³µì‚¬ ì„±ëŠ¥ ì¸¡ì •
        for(int i = 0; i < 1000; i++) {
            memcpy(dest, source, buffer_size);
            data_transferred += buffer_size;
        }
        
        unsigned long elapsed = micros() - transfer_start_time;
        float bandwidth_mbps = (float)data_transferred * 8.0 / elapsed;
        
        Serial.printf("Memory bandwidth: %.2f Mbps\n", bandwidth_mbps);
    }
    
    void optimizeMemoryAccess() {
        // ìºì‹œ ì¹œí™”ì  ë©”ëª¨ë¦¬ ì ‘ê·¼ íŒ¨í„´
        // ìˆœì°¨ì  ì ‘ê·¼ìœ¼ë¡œ ìºì‹œ ë¯¸ìŠ¤ ìµœì†Œí™”
        // ì ì ˆí•œ ë°ì´í„° ì •ë ¬ ì‚¬ìš©
    }
};
```

### ì†Œí”„íŠ¸ì›¨ì–´ ìµœì í™”
```cpp
// ì•Œê³ ë¦¬ì¦˜ ìµœì í™”ë¥¼ í†µí•œ ì²˜ë¦¬ëŸ‰ í–¥ìƒ
class AlgorithmOptimizer {
public:
    // O(nÂ²) ë²„ë¸” ì •ë ¬ ëŒ€ì‹  O(n log n) í€µì •ë ¬
    void optimizeSort(int arr[], int size) {
        // ê¸°ì¡´ ë²„ë¸” ì •ë ¬: O(nÂ²)
        // for(int i = 0; i < size-1; i++) {
        //     for(int j = 0; j < size-i-1; j++) {
        //         if(arr[j] > arr[j+1]) {
        //             swap(arr[j], arr[j+1]);
        //         }
        //     }
        // }
        
        // ìµœì í™”ëœ í€µì •ë ¬: O(n log n)
        quickSort(arr, 0, size - 1);
    }
    
    // ë£©ì—… í…Œì´ë¸”ì„ ì´ìš©í•œ ì‚¼ê°í•¨ìˆ˜ ìµœì í™”
    class TrigLookupTable {
    private:
        static const int TABLE_SIZE = 360;
        float sin_table[TABLE_SIZE];
        float cos_table[TABLE_SIZE];
        
    public:
        TrigLookupTable() {
            for(int i = 0; i < TABLE_SIZE; i++) {
                float angle = i * PI / 180.0;
                sin_table[i] = sin(angle);
                cos_table[i] = cos(angle);
            }
        }
        
        float fastSin(int degrees) {
            return sin_table[degrees % 360];
        }
        
        float fastCos(int degrees) {
            return cos_table[degrees % 360];
        }
    };
    
    // ê³ ì •ì  ì—°ì‚°ìœ¼ë¡œ ë¶€ë™ì†Œìˆ˜ì  ì—°ì‚° ëŒ€ì²´
    typedef int32_t fixed_point_t;
    #define FIXED_POINT_SHIFT 16
    #define FLOAT_TO_FIXED(x) ((fixed_point_t)((x) * (1 << FIXED_POINT_SHIFT)))
    #define FIXED_TO_FLOAT(x) ((float)(x) / (1 << FIXED_POINT_SHIFT))
    
    fixed_point_t fixedMultiply(fixed_point_t a, fixed_point_t b) {
        return (a * b) >> FIXED_POINT_SHIFT;
    }
    
private:
    void quickSort(int arr[], int low, int high) {
        if(low < high) {
            int pivot = partition(arr, low, high);
            quickSort(arr, low, pivot - 1);
            quickSort(arr, pivot + 1, high);
        }
    }
    
    int partition(int arr[], int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for(int j = low; j < high; j++) {
            if(arr[j] < pivot) {
                i++;
                swap(arr[i], arr[j]);
            }
        }
        swap(arr[i + 1], arr[high]);
        return i + 1;
    }
    
    void swap(int& a, int& b) {
        int temp = a;
        a = b;
        b = temp;
    }
};
```

## ğŸ¯ ì²˜ë¦¬ëŸ‰ ìµœì í™” ì „ëµ

### íŒŒì´í”„ë¼ì¸ ì²˜ë¦¬
```cpp
// íŒŒì´í”„ë¼ì¸ì„ ì´ìš©í•œ ì²˜ë¦¬ëŸ‰ í–¥ìƒ
class PipelineProcessor {
private:
    enum PipelineStage {
        STAGE_INPUT,
        STAGE_PROCESS,
        STAGE_OUTPUT,
        NUM_STAGES
    };
    
    struct PipelineData {
        int id;
        float input_value;
        float processed_value;
        bool ready[NUM_STAGES];
    };
    
    PipelineData pipeline[4];  // 4ë‹¨ê³„ íŒŒì´í”„ë¼ì¸
    int current_input = 0;
    
public:
    void processPipeline() {
        // ê° ìŠ¤í…Œì´ì§€ë¥¼ ë³‘ë ¬ë¡œ ì²˜ë¦¬
        
        // Stage 3: ì¶œë ¥ (ê°€ì¥ ëŠ¦ì€ ë‹¨ê³„ë¶€í„°)
        if(pipeline[3].ready[STAGE_PROCESS]) {
            outputResult(pipeline[3]);
            pipeline[3].ready[STAGE_OUTPUT] = true;
            pipeline[3].ready[STAGE_PROCESS] = false;
        }
        
        // Stage 2: ì²˜ë¦¬
        if(pipeline[2].ready[STAGE_INPUT]) {
            pipeline[2].processed_value = processData(pipeline[2].input_value);
            pipeline[2].ready[STAGE_PROCESS] = true;
            pipeline[2].ready[STAGE_INPUT] = false;
            
            // ë‹¤ìŒ ë‹¨ê³„ë¡œ ì „ë‹¬
            pipeline[3] = pipeline[2];
        }
        
        // Stage 1: ì…ë ¥
        if(hasNewInput()) {
            pipeline[1].id = current_input++;
            pipeline[1].input_value = getNextInput();
            pipeline[1].ready[STAGE_INPUT] = true;
            
            // ë‹¤ìŒ ë‹¨ê³„ë¡œ ì „ë‹¬  
            pipeline[2] = pipeline[1];
        }
    }
    
    float calculatePipelineThroughput() {
        // íŒŒì´í”„ë¼ì¸ì´ ê°€ë“ ì°¬ í›„ì˜ ì²˜ë¦¬ëŸ‰
        // ë§¤ ì‚¬ì´í´ë§ˆë‹¤ í•˜ë‚˜ì˜ ê²°ê³¼ ì¶œë ¥ ê°€ëŠ¥
        return 1000.0;  // 1kHz í´ë¡ì—ì„œ 1000 TPS
    }
    
private:
    float processData(float input) {
        // ë³µì¡í•œ ì²˜ë¦¬ ë¡œì§
        return input * 2.5 + 10.0;
    }
    
    void outputResult(const PipelineData& data) {
        Serial.printf("Result %d: %.2f\n", data.id, data.processed_value);
    }
    
    bool hasNewInput() {
        // ìƒˆë¡œìš´ ì…ë ¥ ë°ì´í„° í™•ì¸
        return true;  // ì˜ˆì‹œ
    }
    
    float getNextInput() {
        return random(0, 100);
    }
};
```

### ë³‘ë ¬ ì²˜ë¦¬
```cpp
// ë©€í‹°íƒœìŠ¤í‚¹ì„ ì´ìš©í•œ ë³‘ë ¬ ì²˜ë¦¬
class ParallelProcessor {
private:
    TaskHandle_t worker_tasks[4];
    QueueHandle_t input_queue;
    QueueHandle_t output_queue;
    
    struct WorkItem {
        int id;
        float data[100];
        int data_size;
    };
    
public:
    void setupParallelProcessing() {
        // ì…ì¶œë ¥ í ìƒì„±
        input_queue = xQueueCreate(20, sizeof(WorkItem));
        output_queue = xQueueCreate(20, sizeof(WorkItem));
        
        // ì›Œì»¤ íƒœìŠ¤í¬ë“¤ ìƒì„±
        for(int i = 0; i < 4; i++) {
            char task_name[16];
            sprintf(task_name, "Worker%d", i);
            
            xTaskCreate(workerTask, task_name, 2048, 
                       (void*)i, tskIDLE_PRIORITY + 2, &worker_tasks[i]);
        }
        
        // ì…ë ¥ íƒœìŠ¤í¬ ìƒì„±
        xTaskCreate(inputTask, "InputTask", 1024, 
                   NULL, tskIDLE_PRIORITY + 1, NULL);
        
        // ì¶œë ¥ íƒœìŠ¤í¬ ìƒì„±
        xTaskCreate(outputTask, "OutputTask", 1024, 
                   NULL, tskIDLE_PRIORITY + 1, NULL);
    }
    
    static void workerTask(void* parameter) {
        int worker_id = (int)parameter;
        WorkItem item;
        
        while(1) {
            // ì…ë ¥ íì—ì„œ ì‘ì—… ê°€ì ¸ì˜¤ê¸°
            if(xQueueReceive(input_queue, &item, portMAX_DELAY) == pdTRUE) {
                
                // ë°ì´í„° ì²˜ë¦¬ (ë³‘ë ¬ë¡œ ìˆ˜í–‰)
                for(int i = 0; i < item.data_size; i++) {
                    item.data[i] = processDataPoint(item.data[i], worker_id);
                }
                
                // ê²°ê³¼ë¥¼ ì¶œë ¥ íì— ì „ì†¡
                xQueueSend(output_queue, &item, portMAX_DELAY);
            }
        }
    }
    
    static void inputTask(void* parameter) {
        WorkItem item;
        int id_counter = 0;
        
        while(1) {
            // ìƒˆë¡œìš´ ë°ì´í„° ìƒì„±
            item.id = id_counter++;
            item.data_size = 100;
            
            for(int i = 0; i < item.data_size; i++) {
                item.data[i] = random(0, 1000) / 100.0;
            }
            
            // ì…ë ¥ íì— ì „ì†¡
            xQueueSend(input_queue, &item, 100);  // 100ms íƒ€ì„ì•„ì›ƒ
            
            vTaskDelay(pdMS_TO_TICKS(10));  // 10ms ê°„ê²©
        }
    }
    
    static void outputTask(void* parameter) {
        WorkItem item;
        unsigned long processed_count = 0;
        unsigned long start_time = millis();
        
        while(1) {
            // ì¶œë ¥ íì—ì„œ ê²°ê³¼ ë°›ê¸°
            if(xQueueReceive(output_queue, &item, portMAX_DELAY) == pdTRUE) {
                processed_count++;
                
                // ì£¼ê¸°ì ìœ¼ë¡œ ì²˜ë¦¬ëŸ‰ ì¶œë ¥
                if(processed_count % 100 == 0) {
                    unsigned long elapsed = millis() - start_time;
                    float throughput = (float)processed_count * 1000.0 / elapsed;
                    
                    Serial.printf("Processed %lu items, Throughput: %.2f TPS\n", 
                                 processed_count, throughput);
                }
            }
        }
    }
    
private:
    static float processDataPoint(float input, int worker_id) {
        // ê° ì›Œì»¤ë³„ë¡œ ë‹¤ë¥¸ ì²˜ë¦¬ ë˜ëŠ” ë™ì¼í•œ ì²˜ë¦¬
        return input * 1.5 + worker_id * 0.1;
    }
};
```

## ğŸ“ˆ ì²˜ë¦¬ëŸ‰ vs ë‹¤ë¥¸ ì„±ëŠ¥ ì§€í‘œ

### ì²˜ë¦¬ëŸ‰-ë ˆì´í„´ì‹œ íŠ¸ë ˆì´ë“œì˜¤í”„
```cpp
// ì²˜ë¦¬ëŸ‰ê³¼ ë ˆì´í„´ì‹œ ê°„ì˜ ê· í˜• ê´€ë¦¬
class ThroughputLatencyBalancer {
private:
    float target_throughput;
    float max_acceptable_latency;
    int batch_size = 1;
    
public:
    void optimizeForThroughput() {
        // ë°°ì¹˜ í¬ê¸° ì¦ê°€ë¡œ ì²˜ë¦¬ëŸ‰ í–¥ìƒ
        batch_size = 32;
        
        // ë” ë§ì€ ë°ì´í„°ë¥¼ í•œ ë²ˆì— ì²˜ë¦¬í•˜ì—¬ ì˜¤ë²„í—¤ë“œ ê°ì†Œ
        // ë‹¨ì : ê°œë³„ ìš”ì²­ì˜ ë ˆì´í„´ì‹œ ì¦ê°€
    }
    
    void optimizeForLatency() {
        // ë°°ì¹˜ í¬ê¸° ê°ì†Œë¡œ ë ˆì´í„´ì‹œ ìµœì†Œí™”
        batch_size = 1;
        
        // ì¦‰ì‹œ ì²˜ë¦¬ë¡œ ì‘ë‹µ ì‹œê°„ ìµœì†Œí™”
        // ë‹¨ì : ì „ì²´ ì²˜ë¦¬ëŸ‰ ê°ì†Œ
    }
    
    void balancePerformance(float current_latency, float current_throughput) {
        if(current_latency > max_acceptable_latency) {
            // ë ˆì´í„´ì‹œê°€ ì„ê³„ê°’ ì´ˆê³¼ ì‹œ ë°°ì¹˜ í¬ê¸° ê°ì†Œ
            batch_size = max(1, batch_size - 1);
        } else if(current_throughput < target_throughput) {
            // ì²˜ë¦¬ëŸ‰ì´ ëª©í‘œ ë¯¸ë‹¬ ì‹œ ë°°ì¹˜ í¬ê¸° ì¦ê°€
            batch_size = min(64, batch_size + 1);
        }
    }
    
    void processBatch() {
        static float input_buffer[64];
        static int buffer_count = 0;
        
        // ë°°ì¹˜ê°€ ê°€ë“ ì°° ë•Œê¹Œì§€ ëŒ€ê¸°í•˜ê±°ë‚˜ íƒ€ì„ì•„ì›ƒ
        while(buffer_count < batch_size && hasMoreInput()) {
            input_buffer[buffer_count++] = getNextInput();
        }
        
        if(buffer_count > 0) {
            // ë°°ì¹˜ ì²˜ë¦¬
            unsigned long start = micros();
            
            for(int i = 0; i < buffer_count; i++) {
                processItem(input_buffer[i]);
            }
            
            unsigned long processing_time = micros() - start;
            float avg_latency = (float)processing_time / buffer_count;
            
            // ì„±ëŠ¥ ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
            updatePerformanceMetrics(buffer_count, avg_latency);
            
            buffer_count = 0;
        }
    }
    
private:
    bool hasMoreInput() { return true; }  // ì˜ˆì‹œ
    float getNextInput() { return random(0, 100); }
    void processItem(float item) { /* ì²˜ë¦¬ ë¡œì§ */ }
    void updatePerformanceMetrics(int processed, float latency) {
        // ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸ ë¡œì§
    }
};
```

### ì²˜ë¦¬ëŸ‰ ë²¤ì¹˜ë§ˆí‚¹
```cpp
// ì‹œìŠ¤í…œ ì²˜ë¦¬ëŸ‰ ë²¤ì¹˜ë§ˆí¬
class ThroughputBenchmark {
private:
    struct BenchmarkResult {
        const char* test_name;
        float max_throughput;
        float sustainable_throughput;
        int test_duration_ms;
    };
    
    BenchmarkResult results[10];
    int result_count = 0;
    
public:
    void runComprehensiveBenchmark() {
        // ë‹¤ì–‘í•œ ì‹œë‚˜ë¦¬ì˜¤ì—ì„œ ì²˜ë¦¬ëŸ‰ ì¸¡ì •
        runBenchmark("Simple Addition", testSimpleAddition, 10000);
        runBenchmark("Floating Point Math", testFloatMath, 10000);
        runBenchmark("Memory Copy", testMemoryCopy, 10000);
        runBenchmark("Trigonometry", testTrigonometry, 10000);
        runBenchmark("Sorting Algorithm", testSorting, 5000);
        
        printBenchmarkResults();
    }
    
    void runBenchmark(const char* name, void (*test_func)(), int duration_ms) {
        if(result_count >= 10) return;
        
        unsigned long start_time = millis();
        unsigned long operations = 0;
        float max_tps = 0;
        
        // ì§€ì •ëœ ì‹œê°„ ë™ì•ˆ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
        while(millis() - start_time < duration_ms) {
            unsigned long op_start = micros();
            
            test_func();
            operations++;
            
            // ì´ˆë‹¹ ì²˜ë¦¬ëŸ‰ ê³„ì‚° (1ì´ˆë§ˆë‹¤)
            if(operations % 1000 == 0) {
                unsigned long elapsed = millis() - start_time;
                float current_tps = (float)operations * 1000.0 / elapsed;
                if(current_tps > max_tps) {
                    max_tps = current_tps;
                }
            }
        }
        
        unsigned long total_elapsed = millis() - start_time;
        float avg_tps = (float)operations * 1000.0 / total_elapsed;
        
        // ê²°ê³¼ ì €ì¥
        results[result_count] = {name, max_tps, avg_tps, duration_ms};
        result_count++;
    }
    
    void printBenchmarkResults() {
        Serial.println("=== Throughput Benchmark Results ===");
        for(int i = 0; i < result_count; i++) {
            BenchmarkResult* r = &results[i];
            Serial.printf("%s:\n", r->test_name);
            Serial.printf("  Max TPS: %.2f\n", r->max_throughput);
            Serial.printf("  Sustainable TPS: %.2f\n", r->sustainable_throughput);
            Serial.printf("  Test duration: %d ms\n\n", r->test_duration_ms);
        }
    }
    
private:
    static void testSimpleAddition() {
        volatile int a = 123, b = 456;
        volatile int result = a + b;
    }
    
    static void testFloatMath() {
        volatile float a = 3.14159, b = 2.71828;
        volatile float result = a * b + sqrt(a);
    }
    
    static void testMemoryCopy() {
        static uint8_t src[64], dst[64];
        memcpy(dst, src, 64);
    }
    
    static void testTrigonometry() {
        volatile float angle = 1.5708;
        volatile float result = sin(angle) + cos(angle);
    }
    
    static void testSorting() {
        static int arr[10] = {5, 2, 8, 1, 9, 3, 7, 4, 6, 0};
        // ê°„ë‹¨í•œ ì •ë ¬ (ì‹¤ì œë¡œëŠ” ë” ë³µì¡í•œ ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©)
        for(int i = 0; i < 9; i++) {
            if(arr[i] > arr[i+1]) {
                int temp = arr[i];
                arr[i] = arr[i+1];
                arr[i+1] = temp;
            }
        }
    }
};
```

---

## ğŸ”— ì—°ê²° ë¬¸ì„œ
- ìƒìœ„: [[ì‹¤ì‹œê°„ì œì–´]]
- ê´€ë ¨: [[ë°ë“œë¼ì¸]], [[ì§€í„°]], [[ë ˆì´í„´ì‹œ]]
- í•˜ë“œì›¨ì–´: [[ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬]], [[ì„¼ì„œì¸í„°í˜ì´ìŠ¤]]
- ìµœì í™”: [[ìš°ì„ ìˆœìœ„ìŠ¤ì¼€ì¤„ë§]], [[ì‹œë¶„í• ìŠ¤ì¼€ì¤„ë§]]

## ğŸ“š ì°¸ê³ ë¬¸í—Œ
- [AWS (2025). "Throughput vs Latency - Difference Between Computer Network Performances"](https://aws.amazon.com/compare/the-difference-between-throughput-and-latency/)
- [BrowserStack (2025). "What is Throughput in Performance Testing"](https://www.browserstack.com/guide/throughput-in-performance-testing)
- [Abstracta (2025). "What is Throughput in Performance Testing? A Complete Guide"](https://abstracta.us/blog/performance-testing/what-is-throughput-in-performance-testing/)
- [Equinix (2024). "Understanding Network Performance: Latency vs. Throughput"](https://deploy.equinix.com/blog/explaining-key-network-performance-metrics-latency-vs-throughput/)
