# 시분할스케줄링

> 상위: [[실시간제어]]

시간을 일정한 간격(타임 슬라이스)으로 나누어 여러 작업이 CPU를 공평하게 사용할 수 있도록 하는 스케줄링 기법입니다.

## 🔄 Round Robin 스케줄링

### 기본 원리
```
개념: 각 프로세스에게 동일한 시간 할당량(타임 퀀텀) 제공
순서: 순환 방식으로 프로세스 실행
특징: 선점형 스케줄링 (preemptive)

동작 방식:
1. 준비 큐에서 첫 번째 프로세스 선택
2. 타임 퀀텀 동안 실행
3. 완료되지 않으면 큐의 끝으로 이동
4. 다음 프로세스로 전환
```

### 구현 예시
```cpp
// Round Robin 스케줄러 구현
class RoundRobinScheduler {
private:
    struct Process {
        int id;
        int burst_time;
        int remaining_time;
        int arrival_time;
        int waiting_time;
        int turnaround_time;
        bool completed;
    };
    
    Process processes[MAX_PROCESSES];
    int process_count = 0;
    int time_quantum = 2;  // 기본 2ms
    int current_time = 0;
    
public:
    void addProcess(int id, int burst_time, int arrival_time = 0) {
        if(process_count < MAX_PROCESSES) {
            processes[process_count] = {
                id, burst_time, burst_time, arrival_time, 0, 0, false
            };
            process_count++;
        }
    }
    
    void setTimeQuantum(int quantum) {
        time_quantum = quantum;
        Serial.printf("Time quantum set to %d ms\n", quantum);
    }
    
    void executeRoundRobin() {
        Serial.println("=== Round Robin Scheduling ===");
        Serial.printf("Time Quantum: %d ms\n", time_quantum);
        
        bool all_completed = false;
        int queue_index = 0;
        
        while(!all_completed) {
            all_completed = true;
            
            // 모든 프로세스를 순환하며 실행
            for(int i = 0; i < process_count; i++) {
                Process* proc = &processes[i];
                
                // 도착하지 않았거나 완료된 프로세스 스킵
                if(current_time < proc->arrival_time || proc->completed) {
                    continue;
                }
                
                all_completed = false;
                
                // 실행 시간 계산 (타임 퀀텀 또는 남은 시간 중 작은 값)
                int execution_time = min(time_quantum, proc->remaining_time);
                
                Serial.printf("Time %d-%d: Process P%d executing (%d ms remaining)\n",
                             current_time, current_time + execution_time, 
                             proc->id, proc->remaining_time);
                
                // 프로세스 실행
                proc->remaining_time -= execution_time;
                current_time += execution_time;
                
                // 완료 확인
                if(proc->remaining_time == 0) {
                    proc->completed = true;
                    proc->turnaround_time = current_time - proc->arrival_time;
                    proc->waiting_time = proc->turnaround_time - proc->burst_time;
                    
                    Serial.printf("Process P%d completed at time %d\n", 
                                 proc->id, current_time);
                }
            }
        }
        
        printStatistics();
    }
    
private:
    void printStatistics() {
        Serial.println("\n=== Scheduling Results ===");
        Serial.println("Process | Burst | Waiting | Turnaround");
        Serial.println("--------|-------|---------|----------");
        
        float total_waiting = 0, total_turnaround = 0;
        
        for(int i = 0; i < process_count; i++) {
            Process* p = &processes[i];
            Serial.printf("   P%d   |   %d   |    %d    |     %d\n",
                         p->id, p->burst_time, p->waiting_time, p->turnaround_time);
            
            total_waiting += p->waiting_time;
            total_turnaround += p->turnaround_time;
        }
        
        Serial.println("--------|-------|---------|----------");
        Serial.printf("Average |       |  %.2f   |   %.2f\n",
                     total_waiting / process_count,
                     total_turnaround / process_count);
    }
};
```

## ⏱️ 타임 퀀텀 최적화

### 동적 타임 퀀텀 조정
```cpp
// 적응적 타임 퀀텀 스케줄러
class AdaptiveTimeQuantumScheduler {
private:
    int base_quantum = 4;
    int min_quantum = 1;
    int max_quantum = 20;
    float context_switch_overhead = 0.1;  // ms
    
    struct QuantumStats {
        int quantum_value;
        float avg_response_time;
        float context_switches_per_second;
        int processes_completed;
    };
    
    QuantumStats stats_history[10];
    int stats_count = 0;
    
public:
    int calculateOptimalQuantum(Process processes[], int n) {
        // Median-Average 방법을 사용한 동적 퀀텀
        int burst_times[MAX_PROCESSES];
        int valid_count = 0;
        
        // 완료되지 않은 프로세스들의 남은 실행시간 수집
        for(int i = 0; i < n; i++) {
            if(!processes[i].completed && processes[i].remaining_time > 0) {
                burst_times[valid_count++] = processes[i].remaining_time;
            }
        }
        
        if(valid_count == 0) return base_quantum;
        
        // 정렬
        sortArray(burst_times, valid_count);
        
        // 중간값 계산
        int median = (valid_count % 2 == 0) ? 
                    (burst_times[valid_count/2-1] + burst_times[valid_count/2]) / 2 :
                    burst_times[valid_count/2];
        
        // 평균값 계산
        int sum = 0;
        for(int i = 0; i < valid_count; i++) {
            sum += burst_times[i];
        }
        int average = sum / valid_count;
        
        // 동적 퀀텀 = (median + average) / 2
        int dynamic_quantum = (median + average) / 2;
        
        // 경계값 적용
        dynamic_quantum = max(min_quantum, min(max_quantum, dynamic_quantum));
        
        Serial.printf("Dynamic quantum calculated: median=%d, avg=%d, quantum=%d\n",
                     median, average, dynamic_quantum);
        
        return dynamic_quantum;
    }
    
    void optimizeQuantumForResponseTime(float target_response_ms) {
        // 응답시간 목표를 위한 퀀텀 조정
        
        if(stats_count < 2) {
            return;  // 충분한 데이터 없음
        }
        
        // 최근 통계 분석
        QuantumStats* recent = &stats_history[stats_count - 1];
        
        if(recent->avg_response_time > target_response_ms) {
            // 응답시간 개선 필요 - 퀀텀 감소
            base_quantum = max(min_quantum, base_quantum - 1);
            Serial.printf("Response time too high (%.2f ms), reducing quantum to %d\n",
                         recent->avg_response_time, base_quantum);
        } else if(recent->context_switches_per_second > 100) {
            // 컨텍스트 스위치 너무 많음 - 퀀텀 증가
            base_quantum = min(max_quantum, base_quantum + 1);
            Serial.printf("Too many context switches (%.1f/s), increasing quantum to %d\n",
                         recent->context_switches_per_second, base_quantum);
        }
    }
    
    void recordStats(int quantum, float response_time, 
                    float ctx_switches, int completed) {
        if(stats_count < 10) {
            stats_history[stats_count] = {
                quantum, response_time, ctx_switches, completed
            };
            stats_count++;
        } else {
            // 순환 버퍼
            for(int i = 0; i < 9; i++) {
                stats_history[i] = stats_history[i + 1];
            }
            stats_history[9] = {quantum, response_time, ctx_switches, completed};
        }
    }
    
private:
    void sortArray(int arr[], int n) {
        for(int i = 0; i < n-1; i++) {
            for(int j = i+1; j < n; j++) {
                if(arr[i] > arr[j]) {
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
            }
        }
    }
};
```

## 🎯 실시간 시스템에서의 시분할

### 우선순위 기반 Round Robin
```cpp
// 우선순위를 고려한 멀티레벨 Round Robin
class MultiLevelRoundRobin {
private:
    enum PriorityLevel {
        HIGH_PRIORITY = 0,
        MEDIUM_PRIORITY = 1,
        LOW_PRIORITY = 2,
        NUM_LEVELS = 3
    };
    
    struct PriorityQueue {
        Process processes[MAX_PROCESSES];
        int count;
        int time_quantum;
    };
    
    PriorityQueue queues[NUM_LEVELS];
    
public:
    MultiLevelRoundRobin() {
        // 각 우선순위 레벨별 타임 퀀텀 설정
        queues[HIGH_PRIORITY] = {{}, 0, 2};    // 짧은 퀀텀
        queues[MEDIUM_PRIORITY] = {{}, 0, 4};  // 중간 퀀텀
        queues[LOW_PRIORITY] = {{}, 0, 8};     // 긴 퀀텀
    }
    
    void addProcess(int id, int burst_time, PriorityLevel priority) {
        PriorityQueue* queue = &queues[priority];
        
        if(queue->count < MAX_PROCESSES) {
            queue->processes[queue->count] = {
                id, burst_time, burst_time, 0, 0, 0, false
            };
            queue->count++;
            
            Serial.printf("Process P%d added to priority level %d (quantum=%d)\n",
                         id, priority, queue->time_quantum);
        }
    }
    
    void executeMultiLevelRR() {
        int current_time = 0;
        bool system_idle = false;
        
        while(!system_idle) {
            system_idle = true;
            
            // 높은 우선순위부터 처리
            for(int level = 0; level < NUM_LEVELS; level++) {
                PriorityQueue* queue = &queues[level];
                
                bool level_active = false;
                
                // 현재 레벨의 모든 프로세스를 RR로 처리
                for(int i = 0; i < queue->count; i++) {
                    Process* proc = &queue->processes[i];
                    
                    if(proc->completed) continue;
                    
                    system_idle = false;
                    level_active = true;
                    
                    int exec_time = min(queue->time_quantum, proc->remaining_time);
                    
                    Serial.printf("Time %d: Level %d - P%d executing for %d ms\n",
                                 current_time, level, proc->id, exec_time);
                    
                    proc->remaining_time -= exec_time;
                    current_time += exec_time;
                    
                    if(proc->remaining_time == 0) {
                        proc->completed = true;
                        proc->turnaround_time = current_time;
                        proc->waiting_time = proc->turnaround_time - proc->burst_time;
                        
                        Serial.printf("P%d completed at time %d\n", 
                                     proc->id, current_time);
                    }
                    
                    // 더 높은 우선순위에 프로세스가 있는지 확인
                    if(hasHigherPriorityProcess(level)) {
                        Serial.println("Preempted by higher priority process");
                        break;
                    }
                }
                
                // 현재 레벨에 활성 프로세스가 있으면 하위 레벨은 처리하지 않음
                if(level_active) break;
            }
        }
    }
    
    // 에이징 메커니즘 - 기아 상태 방지
    void performAging() {
        for(int level = LOW_PRIORITY; level > HIGH_PRIORITY; level--) {
            PriorityQueue* current_queue = &queues[level];
            PriorityQueue* higher_queue = &queues[level - 1];
            
            for(int i = 0; i < current_queue->count; i++) {
                Process* proc = &current_queue->processes[i];
                
                // 대기 시간이 임계값을 초과하면 승격
                if(!proc->completed && proc->waiting_time > 20) {  // 20ms 임계값
                    
                    // 상위 큐로 이동
                    if(higher_queue->count < MAX_PROCESSES) {
                        higher_queue->processes[higher_queue->count] = *proc;
                        higher_queue->count++;
                        
                        // 현재 큐에서 제거
                        for(int j = i; j < current_queue->count - 1; j++) {
                            current_queue->processes[j] = current_queue->processes[j + 1];
                        }
                        current_queue->count--;
                        
                        Serial.printf("P%d promoted from level %d to %d (aging)\n",
                                     proc->id, level, level - 1);
                        
                        i--;  // 인덱스 조정
                    }
                }
            }
        }
    }
    
private:
    bool hasHigherPriorityProcess(int current_level) {
        for(int level = 0; level < current_level; level++) {
            PriorityQueue* queue = &queues[level];
            
            for(int i = 0; i < queue->count; i++) {
                if(!queue->processes[i].completed) {
                    return true;
                }
            }
        }
        return false;
    }
};
```

## 📊 성능 최적화

### 컨텍스트 스위치 최소화
```cpp
// 효율적인 컨텍스트 스위칭
class EfficientContextSwitcher {
private:
    struct TaskContext {
        uint32_t stack_pointer;
        uint32_t registers[16];  // ARM Cortex-M 레지스터
        uint32_t program_counter;
        uint32_t status_register;
    };
    
    TaskContext contexts[MAX_TASKS];
    int current_task = 0;
    unsigned long switch_count = 0;
    unsigned long total_switch_time = 0;
    
public:
    void performContextSwitch(int from_task, int to_task) {
        unsigned long start_time = micros();
        
        // 현재 태스크 컨텍스트 저장
        saveContext(from_task);
        
        // 새 태스크 컨텍스트 복원
        restoreContext(to_task);
        
        current_task = to_task;
        switch_count++;
        
        unsigned long switch_time = micros() - start_time;
        total_switch_time += switch_time;
        
        Serial.printf("Context switch: T%d -> T%d (%.2f μs)\n",
                     from_task, to_task, (float)switch_time);
    }
    
    // 빠른 컨텍스트 스위치 (레지스터 최소화)
    void fastContextSwitch(int to_task) {
        // 핵심 레지스터만 저장/복원
        asm volatile(
            "push {r4-r11}     \n"  // 범용 레지스터 저장
            "str  sp, [%0]     \n"  // 스택 포인터 저장
            "ldr  sp, [%1]     \n"  // 새 스택 포인터 로드
            "pop  {r4-r11}     \n"  // 범용 레지스터 복원
            :
            : "r" (&contexts[current_task].stack_pointer),
              "r" (&contexts[to_task].stack_pointer)
            : "memory"
        );
        
        current_task = to_task;
        switch_count++;
    }
    
    float getAverageContextSwitchTime() {
        return switch_count > 0 ? 
               (float)total_switch_time / switch_count : 0.0;
    }
    
    void printContextSwitchStats() {
        Serial.printf("Context switches: %lu\n", switch_count);
        Serial.printf("Average switch time: %.2f μs\n", 
                     getAverageContextSwitchTime());
        Serial.printf("Total overhead: %.2f ms\n", 
                     (float)total_switch_time / 1000.0);
    }
    
private:
    void saveContext(int task_id) {
        // ARM Cortex-M 컨텍스트 저장
        TaskContext* ctx = &contexts[task_id];
        
        // 스택 포인터와 레지스터 저장
        asm volatile(
            "str sp, [%0]      \n"  // 스택 포인터
            "stmia %1!, {r4-r11}\n" // 범용 레지스터
            :
            : "r" (&ctx->stack_pointer),
              "r" (ctx->registers)
            : "memory"
        );
    }
    
    void restoreContext(int task_id) {
        // ARM Cortex-M 컨텍스트 복원
        TaskContext* ctx = &contexts[task_id];
        
        asm volatile(
            "ldr sp, [%0]      \n"  // 스택 포인터 복원
            "ldmia %1!, {r4-r11}\n" // 범용 레지스터 복원
            :
            : "r" (&ctx->stack_pointer),
              "r" (ctx->registers)
            : "memory"
        );
    }
};
```

### 응답성 개선
```cpp
// 대화형 프로세스 우선 처리
class InteractiveOptimizedRR {
private:
    struct InteractiveProcess {
        Process base;
        bool is_interactive;
        int io_bursts;
        float cpu_usage_ratio;
        int bonus_quantum;
    };
    
    InteractiveProcess processes[MAX_PROCESSES];
    
public:
    void classifyProcesses() {
        for(int i = 0; i < process_count; i++) {
            InteractiveProcess* proc = &processes[i];
            
            // I/O 비율 기반 분류
            float io_ratio = (float)proc->io_bursts / 
                           (proc->base.burst_time + proc->io_bursts);
            
            if(io_ratio > 0.6 || proc->base.burst_time < 5) {
                // 대화형 프로세스로 분류
                proc->is_interactive = true;
                proc->bonus_quantum = 1;  // 추가 퀀텀
                
                Serial.printf("P%d classified as interactive (I/O ratio: %.2f)\n",
                             proc->base.id, io_ratio);
            } else {
                // CPU 집약적 프로세스
                proc->is_interactive = false;
                proc->bonus_quantum = 0;
                
                Serial.printf("P%d classified as CPU-intensive\n", proc->base.id);
            }
        }
    }
    
    int getEffectiveQuantum(int process_id) {
        InteractiveProcess* proc = findProcess(process_id);
        if(!proc) return time_quantum;
        
        if(proc->is_interactive) {
            // 대화형 프로세스는 더 짧은 퀀텀 사용
            return max(1, time_quantum / 2) + proc->bonus_quantum;
        } else {
            // CPU 집약적 프로세스는 더 긴 퀀텀 사용
            return time_quantum * 2;
        }
    }
    
    void updateInteractiveStatus(int process_id, bool had_io_operation) {
        InteractiveProcess* proc = findProcess(process_id);
        if(!proc) return;
        
        if(had_io_operation) {
            proc->io_bursts++;
            
            // 대화형 특성 강화
            if(!proc->is_interactive && proc->io_bursts > 3) {
                proc->is_interactive = true;
                Serial.printf("P%d promoted to interactive status\n", process_id);
            }
        }
        
        // CPU 사용률 업데이트
        proc->cpu_usage_ratio = 0.9 * proc->cpu_usage_ratio + 0.1 * 
                              (had_io_operation ? 0.0 : 1.0);
    }
    
private:
    InteractiveProcess* findProcess(int process_id) {
        for(int i = 0; i < process_count; i++) {
            if(processes[i].base.id == process_id) {
                return &processes[i];
            }
        }
        return nullptr;
    }
};
```

---

## 🔗 연결 문서
- 상위: [[실시간제어]]
- 관련: [[우선순위스케줄링]], [[데드라인]], [[레이턴시]]
- 구현: [[인터럽트처리]], [[마이크로컨트롤러]]
- 성능: [[지터]], [[처리량]]

## 📚 참고문헌
- [Wikipedia (2025). "Round-robin scheduling"](https://en.wikipedia.org/wiki/Round-robin_scheduling)
- [GeeksforGeeks (2025). "Round Robin Scheduling in Operating System"](https://www.geeksforgeeks.org/operating-systems/round-robin-scheduling-in-operating-system/)
- [Scaler (2022). "What is Round Robin Scheduling in OS?"](https://www.scaler.com/topics/round-robin-scheduling-in-os/)
- [ScienceDirect (2022). "A new median-average round Robin scheduling algorithm"](https://www.sciencedirect.com/science/article/pii/S1110016822002599)
- [Guru99 (2024). "Round Robin Scheduling Algorithm with Example"](https://www.guru99.com/round-robin-scheduling-example.html)
