# ì‹œë¶„í• ìŠ¤ì¼€ì¤„ë§

> ìƒìœ„: [[ì‹¤ì‹œê°„ì œì–´]]

ì‹œê°„ì„ ì¼ì •í•œ ê°„ê²©(íƒ€ì„ ìŠ¬ë¼ì´ìŠ¤)ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ì—¬ëŸ¬ ì‘ì—…ì´ CPUë¥¼ ê³µí‰í•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ìŠ¤ì¼€ì¤„ë§ ê¸°ë²•ì…ë‹ˆë‹¤.

## ğŸ”„ Round Robin ìŠ¤ì¼€ì¤„ë§

### ê¸°ë³¸ ì›ë¦¬
```
ê°œë…: ê° í”„ë¡œì„¸ìŠ¤ì—ê²Œ ë™ì¼í•œ ì‹œê°„ í• ë‹¹ëŸ‰(íƒ€ì„ í€€í…€) ì œê³µ
ìˆœì„œ: ìˆœí™˜ ë°©ì‹ìœ¼ë¡œ í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰
íŠ¹ì§•: ì„ ì í˜• ìŠ¤ì¼€ì¤„ë§ (preemptive)

ë™ì‘ ë°©ì‹:
1. ì¤€ë¹„ íì—ì„œ ì²« ë²ˆì§¸ í”„ë¡œì„¸ìŠ¤ ì„ íƒ
2. íƒ€ì„ í€€í…€ ë™ì•ˆ ì‹¤í–‰
3. ì™„ë£Œë˜ì§€ ì•Šìœ¼ë©´ íì˜ ëìœ¼ë¡œ ì´ë™
4. ë‹¤ìŒ í”„ë¡œì„¸ìŠ¤ë¡œ ì „í™˜
```

### êµ¬í˜„ ì˜ˆì‹œ
```cpp
// Round Robin ìŠ¤ì¼€ì¤„ëŸ¬ êµ¬í˜„
class RoundRobinScheduler {
private:
    struct Process {
        int id;
        int burst_time;
        int remaining_time;
        int arrival_time;
        int waiting_time;
        int turnaround_time;
        bool completed;
    };
    
    Process processes[MAX_PROCESSES];
    int process_count = 0;
    int time_quantum = 2;  // ê¸°ë³¸ 2ms
    int current_time = 0;
    
public:
    void addProcess(int id, int burst_time, int arrival_time = 0) {
        if(process_count < MAX_PROCESSES) {
            processes[process_count] = {
                id, burst_time, burst_time, arrival_time, 0, 0, false
            };
            process_count++;
        }
    }
    
    void setTimeQuantum(int quantum) {
        time_quantum = quantum;
        Serial.printf("Time quantum set to %d ms\n", quantum);
    }
    
    void executeRoundRobin() {
        Serial.println("=== Round Robin Scheduling ===");
        Serial.printf("Time Quantum: %d ms\n", time_quantum);
        
        bool all_completed = false;
        int queue_index = 0;
        
        while(!all_completed) {
            all_completed = true;
            
            // ëª¨ë“  í”„ë¡œì„¸ìŠ¤ë¥¼ ìˆœí™˜í•˜ë©° ì‹¤í–‰
            for(int i = 0; i < process_count; i++) {
                Process* proc = &processes[i];
                
                // ë„ì°©í•˜ì§€ ì•Šì•˜ê±°ë‚˜ ì™„ë£Œëœ í”„ë¡œì„¸ìŠ¤ ìŠ¤í‚µ
                if(current_time < proc->arrival_time || proc->completed) {
                    continue;
                }
                
                all_completed = false;
                
                // ì‹¤í–‰ ì‹œê°„ ê³„ì‚° (íƒ€ì„ í€€í…€ ë˜ëŠ” ë‚¨ì€ ì‹œê°„ ì¤‘ ì‘ì€ ê°’)
                int execution_time = min(time_quantum, proc->remaining_time);
                
                Serial.printf("Time %d-%d: Process P%d executing (%d ms remaining)\n",
                             current_time, current_time + execution_time, 
                             proc->id, proc->remaining_time);
                
                // í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰
                proc->remaining_time -= execution_time;
                current_time += execution_time;
                
                // ì™„ë£Œ í™•ì¸
                if(proc->remaining_time == 0) {
                    proc->completed = true;
                    proc->turnaround_time = current_time - proc->arrival_time;
                    proc->waiting_time = proc->turnaround_time - proc->burst_time;
                    
                    Serial.printf("Process P%d completed at time %d\n", 
                                 proc->id, current_time);
                }
            }
        }
        
        printStatistics();
    }
    
private:
    void printStatistics() {
        Serial.println("\n=== Scheduling Results ===");
        Serial.println("Process | Burst | Waiting | Turnaround");
        Serial.println("--------|-------|---------|----------");
        
        float total_waiting = 0, total_turnaround = 0;
        
        for(int i = 0; i < process_count; i++) {
            Process* p = &processes[i];
            Serial.printf("   P%d   |   %d   |    %d    |     %d\n",
                         p->id, p->burst_time, p->waiting_time, p->turnaround_time);
            
            total_waiting += p->waiting_time;
            total_turnaround += p->turnaround_time;
        }
        
        Serial.println("--------|-------|---------|----------");
        Serial.printf("Average |       |  %.2f   |   %.2f\n",
                     total_waiting / process_count,
                     total_turnaround / process_count);
    }
};
```

## â±ï¸ íƒ€ì„ í€€í…€ ìµœì í™”

### ë™ì  íƒ€ì„ í€€í…€ ì¡°ì •
```cpp
// ì ì‘ì  íƒ€ì„ í€€í…€ ìŠ¤ì¼€ì¤„ëŸ¬
class AdaptiveTimeQuantumScheduler {
private:
    int base_quantum = 4;
    int min_quantum = 1;
    int max_quantum = 20;
    float context_switch_overhead = 0.1;  // ms
    
    struct QuantumStats {
        int quantum_value;
        float avg_response_time;
        float context_switches_per_second;
        int processes_completed;
    };
    
    QuantumStats stats_history[10];
    int stats_count = 0;
    
public:
    int calculateOptimalQuantum(Process processes[], int n) {
        // Median-Average ë°©ë²•ì„ ì‚¬ìš©í•œ ë™ì  í€€í…€
        int burst_times[MAX_PROCESSES];
        int valid_count = 0;
        
        // ì™„ë£Œë˜ì§€ ì•Šì€ í”„ë¡œì„¸ìŠ¤ë“¤ì˜ ë‚¨ì€ ì‹¤í–‰ì‹œê°„ ìˆ˜ì§‘
        for(int i = 0; i < n; i++) {
            if(!processes[i].completed && processes[i].remaining_time > 0) {
                burst_times[valid_count++] = processes[i].remaining_time;
            }
        }
        
        if(valid_count == 0) return base_quantum;
        
        // ì •ë ¬
        sortArray(burst_times, valid_count);
        
        // ì¤‘ê°„ê°’ ê³„ì‚°
        int median = (valid_count % 2 == 0) ? 
                    (burst_times[valid_count/2-1] + burst_times[valid_count/2]) / 2 :
                    burst_times[valid_count/2];
        
        // í‰ê· ê°’ ê³„ì‚°
        int sum = 0;
        for(int i = 0; i < valid_count; i++) {
            sum += burst_times[i];
        }
        int average = sum / valid_count;
        
        // ë™ì  í€€í…€ = (median + average) / 2
        int dynamic_quantum = (median + average) / 2;
        
        // ê²½ê³„ê°’ ì ìš©
        dynamic_quantum = max(min_quantum, min(max_quantum, dynamic_quantum));
        
        Serial.printf("Dynamic quantum calculated: median=%d, avg=%d, quantum=%d\n",
                     median, average, dynamic_quantum);
        
        return dynamic_quantum;
    }
    
    void optimizeQuantumForResponseTime(float target_response_ms) {
        // ì‘ë‹µì‹œê°„ ëª©í‘œë¥¼ ìœ„í•œ í€€í…€ ì¡°ì •
        
        if(stats_count < 2) {
            return;  // ì¶©ë¶„í•œ ë°ì´í„° ì—†ìŒ
        }
        
        // ìµœê·¼ í†µê³„ ë¶„ì„
        QuantumStats* recent = &stats_history[stats_count - 1];
        
        if(recent->avg_response_time > target_response_ms) {
            // ì‘ë‹µì‹œê°„ ê°œì„  í•„ìš” - í€€í…€ ê°ì†Œ
            base_quantum = max(min_quantum, base_quantum - 1);
            Serial.printf("Response time too high (%.2f ms), reducing quantum to %d\n",
                         recent->avg_response_time, base_quantum);
        } else if(recent->context_switches_per_second > 100) {
            // ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹˜ ë„ˆë¬´ ë§ìŒ - í€€í…€ ì¦ê°€
            base_quantum = min(max_quantum, base_quantum + 1);
            Serial.printf("Too many context switches (%.1f/s), increasing quantum to %d\n",
                         recent->context_switches_per_second, base_quantum);
        }
    }
    
    void recordStats(int quantum, float response_time, 
                    float ctx_switches, int completed) {
        if(stats_count < 10) {
            stats_history[stats_count] = {
                quantum, response_time, ctx_switches, completed
            };
            stats_count++;
        } else {
            // ìˆœí™˜ ë²„í¼
            for(int i = 0; i < 9; i++) {
                stats_history[i] = stats_history[i + 1];
            }
            stats_history[9] = {quantum, response_time, ctx_switches, completed};
        }
    }
    
private:
    void sortArray(int arr[], int n) {
        for(int i = 0; i < n-1; i++) {
            for(int j = i+1; j < n; j++) {
                if(arr[i] > arr[j]) {
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
            }
        }
    }
};
```

## ğŸ¯ ì‹¤ì‹œê°„ ì‹œìŠ¤í…œì—ì„œì˜ ì‹œë¶„í• 

### ìš°ì„ ìˆœìœ„ ê¸°ë°˜ Round Robin
```cpp
// ìš°ì„ ìˆœìœ„ë¥¼ ê³ ë ¤í•œ ë©€í‹°ë ˆë²¨ Round Robin
class MultiLevelRoundRobin {
private:
    enum PriorityLevel {
        HIGH_PRIORITY = 0,
        MEDIUM_PRIORITY = 1,
        LOW_PRIORITY = 2,
        NUM_LEVELS = 3
    };
    
    struct PriorityQueue {
        Process processes[MAX_PROCESSES];
        int count;
        int time_quantum;
    };
    
    PriorityQueue queues[NUM_LEVELS];
    
public:
    MultiLevelRoundRobin() {
        // ê° ìš°ì„ ìˆœìœ„ ë ˆë²¨ë³„ íƒ€ì„ í€€í…€ ì„¤ì •
        queues[HIGH_PRIORITY] = {{}, 0, 2};    // ì§§ì€ í€€í…€
        queues[MEDIUM_PRIORITY] = {{}, 0, 4};  // ì¤‘ê°„ í€€í…€
        queues[LOW_PRIORITY] = {{}, 0, 8};     // ê¸´ í€€í…€
    }
    
    void addProcess(int id, int burst_time, PriorityLevel priority) {
        PriorityQueue* queue = &queues[priority];
        
        if(queue->count < MAX_PROCESSES) {
            queue->processes[queue->count] = {
                id, burst_time, burst_time, 0, 0, 0, false
            };
            queue->count++;
            
            Serial.printf("Process P%d added to priority level %d (quantum=%d)\n",
                         id, priority, queue->time_quantum);
        }
    }
    
    void executeMultiLevelRR() {
        int current_time = 0;
        bool system_idle = false;
        
        while(!system_idle) {
            system_idle = true;
            
            // ë†’ì€ ìš°ì„ ìˆœìœ„ë¶€í„° ì²˜ë¦¬
            for(int level = 0; level < NUM_LEVELS; level++) {
                PriorityQueue* queue = &queues[level];
                
                bool level_active = false;
                
                // í˜„ì¬ ë ˆë²¨ì˜ ëª¨ë“  í”„ë¡œì„¸ìŠ¤ë¥¼ RRë¡œ ì²˜ë¦¬
                for(int i = 0; i < queue->count; i++) {
                    Process* proc = &queue->processes[i];
                    
                    if(proc->completed) continue;
                    
                    system_idle = false;
                    level_active = true;
                    
                    int exec_time = min(queue->time_quantum, proc->remaining_time);
                    
                    Serial.printf("Time %d: Level %d - P%d executing for %d ms\n",
                                 current_time, level, proc->id, exec_time);
                    
                    proc->remaining_time -= exec_time;
                    current_time += exec_time;
                    
                    if(proc->remaining_time == 0) {
                        proc->completed = true;
                        proc->turnaround_time = current_time;
                        proc->waiting_time = proc->turnaround_time - proc->burst_time;
                        
                        Serial.printf("P%d completed at time %d\n", 
                                     proc->id, current_time);
                    }
                    
                    // ë” ë†’ì€ ìš°ì„ ìˆœìœ„ì— í”„ë¡œì„¸ìŠ¤ê°€ ìˆëŠ”ì§€ í™•ì¸
                    if(hasHigherPriorityProcess(level)) {
                        Serial.println("Preempted by higher priority process");
                        break;
                    }
                }
                
                // í˜„ì¬ ë ˆë²¨ì— í™œì„± í”„ë¡œì„¸ìŠ¤ê°€ ìˆìœ¼ë©´ í•˜ìœ„ ë ˆë²¨ì€ ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
                if(level_active) break;
            }
        }
    }
    
    // ì—ì´ì§• ë©”ì»¤ë‹ˆì¦˜ - ê¸°ì•„ ìƒíƒœ ë°©ì§€
    void performAging() {
        for(int level = LOW_PRIORITY; level > HIGH_PRIORITY; level--) {
            PriorityQueue* current_queue = &queues[level];
            PriorityQueue* higher_queue = &queues[level - 1];
            
            for(int i = 0; i < current_queue->count; i++) {
                Process* proc = &current_queue->processes[i];
                
                // ëŒ€ê¸° ì‹œê°„ì´ ì„ê³„ê°’ì„ ì´ˆê³¼í•˜ë©´ ìŠ¹ê²©
                if(!proc->completed && proc->waiting_time > 20) {  // 20ms ì„ê³„ê°’
                    
                    // ìƒìœ„ íë¡œ ì´ë™
                    if(higher_queue->count < MAX_PROCESSES) {
                        higher_queue->processes[higher_queue->count] = *proc;
                        higher_queue->count++;
                        
                        // í˜„ì¬ íì—ì„œ ì œê±°
                        for(int j = i; j < current_queue->count - 1; j++) {
                            current_queue->processes[j] = current_queue->processes[j + 1];
                        }
                        current_queue->count--;
                        
                        Serial.printf("P%d promoted from level %d to %d (aging)\n",
                                     proc->id, level, level - 1);
                        
                        i--;  // ì¸ë±ìŠ¤ ì¡°ì •
                    }
                }
            }
        }
    }
    
private:
    bool hasHigherPriorityProcess(int current_level) {
        for(int level = 0; level < current_level; level++) {
            PriorityQueue* queue = &queues[level];
            
            for(int i = 0; i < queue->count; i++) {
                if(!queue->processes[i].completed) {
                    return true;
                }
            }
        }
        return false;
    }
};
```

## ğŸ“Š ì„±ëŠ¥ ìµœì í™”

### ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹˜ ìµœì†Œí™”
```cpp
// íš¨ìœ¨ì ì¸ ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­
class EfficientContextSwitcher {
private:
    struct TaskContext {
        uint32_t stack_pointer;
        uint32_t registers[16];  // ARM Cortex-M ë ˆì§€ìŠ¤í„°
        uint32_t program_counter;
        uint32_t status_register;
    };
    
    TaskContext contexts[MAX_TASKS];
    int current_task = 0;
    unsigned long switch_count = 0;
    unsigned long total_switch_time = 0;
    
public:
    void performContextSwitch(int from_task, int to_task) {
        unsigned long start_time = micros();
        
        // í˜„ì¬ íƒœìŠ¤í¬ ì»¨í…ìŠ¤íŠ¸ ì €ì¥
        saveContext(from_task);
        
        // ìƒˆ íƒœìŠ¤í¬ ì»¨í…ìŠ¤íŠ¸ ë³µì›
        restoreContext(to_task);
        
        current_task = to_task;
        switch_count++;
        
        unsigned long switch_time = micros() - start_time;
        total_switch_time += switch_time;
        
        Serial.printf("Context switch: T%d -> T%d (%.2f Î¼s)\n",
                     from_task, to_task, (float)switch_time);
    }
    
    // ë¹ ë¥¸ ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹˜ (ë ˆì§€ìŠ¤í„° ìµœì†Œí™”)
    void fastContextSwitch(int to_task) {
        // í•µì‹¬ ë ˆì§€ìŠ¤í„°ë§Œ ì €ì¥/ë³µì›
        asm volatile(
            "push {r4-r11}     \n"  // ë²”ìš© ë ˆì§€ìŠ¤í„° ì €ì¥
            "str  sp, [%0]     \n"  // ìŠ¤íƒ í¬ì¸í„° ì €ì¥
            "ldr  sp, [%1]     \n"  // ìƒˆ ìŠ¤íƒ í¬ì¸í„° ë¡œë“œ
            "pop  {r4-r11}     \n"  // ë²”ìš© ë ˆì§€ìŠ¤í„° ë³µì›
            :
            : "r" (&contexts[current_task].stack_pointer),
              "r" (&contexts[to_task].stack_pointer)
            : "memory"
        );
        
        current_task = to_task;
        switch_count++;
    }
    
    float getAverageContextSwitchTime() {
        return switch_count > 0 ? 
               (float)total_switch_time / switch_count : 0.0;
    }
    
    void printContextSwitchStats() {
        Serial.printf("Context switches: %lu\n", switch_count);
        Serial.printf("Average switch time: %.2f Î¼s\n", 
                     getAverageContextSwitchTime());
        Serial.printf("Total overhead: %.2f ms\n", 
                     (float)total_switch_time / 1000.0);
    }
    
private:
    void saveContext(int task_id) {
        // ARM Cortex-M ì»¨í…ìŠ¤íŠ¸ ì €ì¥
        TaskContext* ctx = &contexts[task_id];
        
        // ìŠ¤íƒ í¬ì¸í„°ì™€ ë ˆì§€ìŠ¤í„° ì €ì¥
        asm volatile(
            "str sp, [%0]      \n"  // ìŠ¤íƒ í¬ì¸í„°
            "stmia %1!, {r4-r11}\n" // ë²”ìš© ë ˆì§€ìŠ¤í„°
            :
            : "r" (&ctx->stack_pointer),
              "r" (ctx->registers)
            : "memory"
        );
    }
    
    void restoreContext(int task_id) {
        // ARM Cortex-M ì»¨í…ìŠ¤íŠ¸ ë³µì›
        TaskContext* ctx = &contexts[task_id];
        
        asm volatile(
            "ldr sp, [%0]      \n"  // ìŠ¤íƒ í¬ì¸í„° ë³µì›
            "ldmia %1!, {r4-r11}\n" // ë²”ìš© ë ˆì§€ìŠ¤í„° ë³µì›
            :
            : "r" (&ctx->stack_pointer),
              "r" (ctx->registers)
            : "memory"
        );
    }
};
```

### ì‘ë‹µì„± ê°œì„ 
```cpp
// ëŒ€í™”í˜• í”„ë¡œì„¸ìŠ¤ ìš°ì„  ì²˜ë¦¬
class InteractiveOptimizedRR {
private:
    struct InteractiveProcess {
        Process base;
        bool is_interactive;
        int io_bursts;
        float cpu_usage_ratio;
        int bonus_quantum;
    };
    
    InteractiveProcess processes[MAX_PROCESSES];
    
public:
    void classifyProcesses() {
        for(int i = 0; i < process_count; i++) {
            InteractiveProcess* proc = &processes[i];
            
            // I/O ë¹„ìœ¨ ê¸°ë°˜ ë¶„ë¥˜
            float io_ratio = (float)proc->io_bursts / 
                           (proc->base.burst_time + proc->io_bursts);
            
            if(io_ratio > 0.6 || proc->base.burst_time < 5) {
                // ëŒ€í™”í˜• í”„ë¡œì„¸ìŠ¤ë¡œ ë¶„ë¥˜
                proc->is_interactive = true;
                proc->bonus_quantum = 1;  // ì¶”ê°€ í€€í…€
                
                Serial.printf("P%d classified as interactive (I/O ratio: %.2f)\n",
                             proc->base.id, io_ratio);
            } else {
                // CPU ì§‘ì•½ì  í”„ë¡œì„¸ìŠ¤
                proc->is_interactive = false;
                proc->bonus_quantum = 0;
                
                Serial.printf("P%d classified as CPU-intensive\n", proc->base.id);
            }
        }
    }
    
    int getEffectiveQuantum(int process_id) {
        InteractiveProcess* proc = findProcess(process_id);
        if(!proc) return time_quantum;
        
        if(proc->is_interactive) {
            // ëŒ€í™”í˜• í”„ë¡œì„¸ìŠ¤ëŠ” ë” ì§§ì€ í€€í…€ ì‚¬ìš©
            return max(1, time_quantum / 2) + proc->bonus_quantum;
        } else {
            // CPU ì§‘ì•½ì  í”„ë¡œì„¸ìŠ¤ëŠ” ë” ê¸´ í€€í…€ ì‚¬ìš©
            return time_quantum * 2;
        }
    }
    
    void updateInteractiveStatus(int process_id, bool had_io_operation) {
        InteractiveProcess* proc = findProcess(process_id);
        if(!proc) return;
        
        if(had_io_operation) {
            proc->io_bursts++;
            
            // ëŒ€í™”í˜• íŠ¹ì„± ê°•í™”
            if(!proc->is_interactive && proc->io_bursts > 3) {
                proc->is_interactive = true;
                Serial.printf("P%d promoted to interactive status\n", process_id);
            }
        }
        
        // CPU ì‚¬ìš©ë¥  ì—…ë°ì´íŠ¸
        proc->cpu_usage_ratio = 0.9 * proc->cpu_usage_ratio + 0.1 * 
                              (had_io_operation ? 0.0 : 1.0);
    }
    
private:
    InteractiveProcess* findProcess(int process_id) {
        for(int i = 0; i < process_count; i++) {
            if(processes[i].base.id == process_id) {
                return &processes[i];
            }
        }
        return nullptr;
    }
};
```

---

## ğŸ”— ì—°ê²° ë¬¸ì„œ
- ìƒìœ„: [[ì‹¤ì‹œê°„ì œì–´]]
- ê´€ë ¨: [[ìš°ì„ ìˆœìœ„ìŠ¤ì¼€ì¤„ë§]], [[ë°ë“œë¼ì¸]], [[ë ˆì´í„´ì‹œ]]
- êµ¬í˜„: [[ì¸í„°ëŸ½íŠ¸ì²˜ë¦¬]], [[ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬]]
- ì„±ëŠ¥: [[ì§€í„°]], [[ì²˜ë¦¬ëŸ‰]]

## ğŸ“š ì°¸ê³ ë¬¸í—Œ
- [Wikipedia (2025). "Round-robin scheduling"](https://en.wikipedia.org/wiki/Round-robin_scheduling)
- [GeeksforGeeks (2025). "Round Robin Scheduling in Operating System"](https://www.geeksforgeeks.org/operating-systems/round-robin-scheduling-in-operating-system/)
- [Scaler (2022). "What is Round Robin Scheduling in OS?"](https://www.scaler.com/topics/round-robin-scheduling-in-os/)
- [ScienceDirect (2022). "A new median-average round Robin scheduling algorithm"](https://www.sciencedirect.com/science/article/pii/S1110016822002599)
- [Guru99 (2024). "Round Robin Scheduling Algorithm with Example"](https://www.guru99.com/round-robin-scheduling-example.html)
