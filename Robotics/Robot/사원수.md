# 사원수

> 상위: [[회전표현]]
>
> 레퍼런스:
> - **Modern Robotics** - Lynch & Park (2017) - Chapter 3.2.4
> - **Wikipedia - Quaternions and spatial rotation** (2025년 8월)
> - **Mecharithm - Unit Quaternions to Express Orientations in Robotics** (2025년)
> - **Robot Academy - Quaternions representation of rotation in 3D** (QUT)
> - **Robotics Unveiled - Unit Quaternions** (2024년 4월)

4차원 복소수를 이용하여 3차원 회전을 컴팩트하고 안정적으로 표현하는 방법입니다.

## 🔢 기본 정의

### 수학적 구조
사원수(quaternion)는 4개의 실수 성분으로 구성된 수학적 객체입니다:
```
q = q₀ + q₁i + q₂j + q₃k = [q₀, q₁, q₂, q₃]ᵀ
```

여기서:
- **q₀**: 실수부 (scalar part)
- **q₁, q₂, q₃**: 허수부 (vector part)
- **i, j, k**: 기본 사원수 단위

### 대체 표기법
사원수는 여러 방식으로 표현 가능합니다:
```
q = [s, v] = [q₀, [q₁, q₂, q₃]ᵀ]    # 스칼라-벡터 형태
q = q₀ + q⃗                           # 실수부 + 벡터부
q = ⟨q₀, q₁, q₂, q₃⟩                  # 4-튜플 형태
```

### 기본 사원수 단위의 곱셈 규칙
Hamilton의 곱셈 규칙:
```
i² = j² = k² = ijk = -1
ij = k,  ji = -k
jk = i,  kj = -i  
ki = j,  ik = -j
```

---

## 🔄 단위사원수와 회전

### 단위사원수 정의
크기가 1인 사원수를 단위사원수라고 하며, 3차원 회전을 표현할 수 있습니다:
```
||q||² = q₀² + q₁² + q₂² + q₃² = 1
```

### 축각표현과의 관계
단위축 û와 회전각 θ를 가진 회전은 다음과 같이 사원수로 표현됩니다:
```
q = cos(θ/2) + sin(θ/2)[ux·i + uy·j + uz·k]
  = [cos(θ/2), sin(θ/2)·û]
```

### 오일러 공식과의 연관
사원수는 복소수의 오일러 공식을 3차원으로 확장한 형태입니다:
```
q = e^(θ/2·û) = cos(θ/2) + sin(θ/2)·û
```

---

## ⚙️ 사원수 연산

### 사원수 곱셈 (Hamilton Product)
두 사원수의 곱셈은 다음과 같이 계산됩니다:
```
q₁q₂ = [s₁s₂ - v₁·v₂, s₁v₂ + s₂v₁ + v₁×v₂]
```

상세 형태:
```
q₁q₂ = [q₁₀q₂₀ - q₁₁q₂₁ - q₁₂q₂₂ - q₁₃q₂₃]
       [q₁₀q₂₁ + q₁₁q₂₀ + q₁₂q₂₃ - q₁₃q₂₂]
       [q₁₀q₂₂ - q₁₁q₂₃ + q₁₂q₂₀ + q₁₃q₂₁]  
       [q₁₀q₂₃ + q₁₁q₂₂ - q₁₂q₂₁ + q₁₃q₂₀]
```

### 켤레사원수 (Conjugate)
사원수의 켤레는 벡터부의 부호를 바꾼 것입니다:
```
q* = q₀ - q₁i - q₂j - q₃k = [q₀, -q₁, -q₂, -q₃]ᵀ
```

### 역사원수 (Inverse)
단위사원수의 역원은 켤레와 같습니다:
```
q⁻¹ = q*/||q||² = q*  (단위사원수인 경우)
```

---

## 🔄 회전 적용

### 벡터 회전
3차원 벡터 p를 사원수 q로 회전시키는 공식:
```
p' = qpq*
```

여기서 p는 순수사원수 [0, p]로 표현됩니다.

### 회전 합성
두 연속 회전의 합성:
```
q_total = q₂q₁
```
- q₁: 첫 번째 회전
- q₂: 두 번째 회전  
- 순서 주의: 오른쪽부터 적용

### 이중 커버링 (Double Covering)
사원수와 그 음수는 동일한 회전을 나타냅니다:
```
q와 -q는 동일한 회전을 표현
```

---

## 🔄 회전행렬과의 변환

### 사원수 → 회전행렬
단위사원수 q = [q₀, q₁, q₂, q₃]에 대응하는 회전행렬:
```
R = [1-2(q₂²+q₃²)   2(q₁q₂-q₀q₃)   2(q₁q₃+q₀q₂)]
    [2(q₁q₂+q₀q₃)   1-2(q₁²+q₃²)   2(q₂q₃-q₀q₁)]
    [2(q₁q₃-q₀q₂)   2(q₂q₃+q₀q₁)   1-2(q₁²+q₂²)]
```

### 회전행렬 → 사원수
회전행렬 R에서 사원수 추출:
```
q₀ = ½√(1 + R₁₁ + R₂₂ + R₃₃)
q₁ = (R₃₂ - R₂₃)/(4q₀)
q₂ = (R₁₃ - R₃₁)/(4q₀)
q₃ = (R₂₁ - R₁₂)/(4q₀)
```

수치적 안정성을 위해 최대 대각성분을 기준으로 하는 방법이 권장됩니다.

---

## 🌐 구면 선형 보간 (SLERP)

### SLERP 공식
두 단위사원수 q₁과 q₂ 사이의 구면 선형 보간:
```
slerp(q₁, q₂, t) = sin((1-t)Ω)/sin(Ω) · q₁ + sin(tΩ)/sin(Ω) · q₂
```

여기서:
- **t ∈ [0,1]**: 보간 매개변수
- **Ω**: q₁과 q₂ 사이의 각도 (cos(Ω) = q₁·q₂)

### SLERP의 특징
- **최단 경로**: 단위구면 상의 최단 호를 따라 보간
- **각속도 일정**: 균등한 각속도로 회전
- **연속성**: 부드러운 회전 궤적 생성

### 실용적 구현
```python
def slerp(q1, q2, t):
    dot = np.dot(q1, q2)
    
    # 최단 경로 선택
    if dot < 0:
        q2 = -q2
        dot = -dot
        
    # 선형 보간 (각도가 작을 때)
    if dot > 0.95:
        return normalize(q1 + t * (q2 - q1))
    
    # 구면 선형 보간
    theta = np.arccos(np.abs(dot))
    sin_theta = np.sin(theta)
    
    return (np.sin((1-t)*theta)/sin_theta * q1 + 
            np.sin(t*theta)/sin_theta * q2)
```

---

## 💡 장단점 분석

### 장점

#### 1. 특이점 없음
- **짐벌락 회피**: 모든 회전에서 안정적 표현
- **전역적 표현**: 특이점 없는 완전한 커버리지

#### 2. 수치적 안정성
- **정규화 용이**: 단위 크기 유지 간단
- **연산 안정성**: 누적 오차에 강함

#### 3. 효율적 보간
- **SLERP**: 최적의 회전 경로 제공
- **부드러운 궤적**: 자연스러운 운동 생성

#### 4. 컴팩트함
- **4개 매개변수**: 회전행렬보다 적음
- **메모리 효율**: 저장 공간 절약

### 단점

#### 1. 직관성 부족
- **물리적 의미**: 각 성분의 의미가 불명확
- **사용자 인터페이스**: 직접 입력/편집 어려움

#### 2. 이중 표현
- **±q 문제**: 동일 회전의 두 표현
- **연속성 이슈**: 경로 계획 시 주의 필요

#### 3. 학습 곡선
- **수학적 복잡성**: 이해와 구현이 복잡
- **디버깅 어려움**: 시각적 확인 곤란

---

## 🎯 로봇공학 응용

### 주요 응용 분야

#### 1. 로봇 제어
- **말단효과기 자세 제어**: 부드러운 자세 변경
- **궤적 계획**: 연속적이고 자연스러운 경로
- **실시간 제어**: 빠른 연산과 안정성

#### 2. 센서 융합
- **IMU 데이터 처리**: 자이로/가속도계 융합
- **AHRS 시스템**: 자세 및 방향 추정
- **칼만 필터**: 상태 추정과 예측

#### 3. 컴퓨터 그래픽스
- **애니메이션**: 자연스러운 회전 애니메이션
- **카메라 제어**: 부드러운 시점 변경
- **게임 엔진**: 실시간 회전 처리

### 실무 구현 팁

#### 1. 정규화 관리
```python
def normalize_quaternion(q):
    """사원수 정규화"""
    norm = np.linalg.norm(q)
    if norm < 1e-8:
        return np.array([1, 0, 0, 0])
    return q / norm
```

#### 2. 연속성 보장
```python
def ensure_continuity(q_prev, q_curr):
    """연속성을 위한 부호 조정"""
    if np.dot(q_prev, q_curr) < 0:
        return -q_curr
    return q_curr
```

#### 3. 오일러각 변환
```python
def quaternion_to_euler(q):
    """사원수를 ZYX 오일러각으로 변환"""
    w, x, y, z = q
    
    roll = np.arctan2(2*(w*x + y*z), 1 - 2*(x*x + y*y))
    pitch = np.arcsin(2*(w*y - z*x))
    yaw = np.arctan2(2*(w*z + x*y), 1 - 2*(y*y + z*z))
    
    return np.array([roll, pitch, yaw])
```

---

## 🔗 다른 표현과의 비교

### vs 회전행렬
- **사원수**: 4개 매개변수, 특이점 없음, 직관성 부족
- **회전행렬**: 9개 매개변수, 특이점 없음, 직관적

### vs 오일러각  
- **사원수**: 특이점 없음, 보간 용이, 직관성 부족
- **오일러각**: 직관적, 짐벌락 발생, 3개 매개변수

### vs 축각표현
- **사원수**: 연속적, 보간 최적, 이중 표현
- **축각표현**: 직관적, 특이점 있음, 단일 표현

---

## 🔗 연결 분야
- 상위: [[회전표현]]
- 기초: [[복소수]], [[축각표현]]
- 응용: [[순기구학]], [[궤적계획]], [[센싱및인지]]
- 대안: [[회전행렬]], [[오일러각]]

---

## 📚 참고문헌
1. Lynch, K.M. & Park, F.C. (2017). *Modern Robotics: Mechanics, Planning, and Control*. Cambridge University Press. Chapter 3.2.4
2. Wikipedia Contributors. (2025). "Quaternions and spatial rotation." *Wikipedia*. Retrieved August 2025
3. Mecharithm. (2025). "Unit Quaternions to Express Orientations in Robotics." Educational Content
4. Corke, P. (2017). *Robotics, Vision and Control*. Springer. Chapter 2
5. Robotics Unveiled. (2024). "Representations of Orientation: Unit Quaternions." Retrieved April 2024
6. Shoemake, K. (1985). "Animating rotation with quaternion curves." *ACM SIGGRAPH*. pp. 245-254