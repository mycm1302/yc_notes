# 우선순위스케줄링

> 상위: [[실시간제어]]

실시간 시스템에서 작업의 중요도나 시간 제약에 따라 우선순위를 부여하여 스케줄링하는 기법입니다.

## 🎯 우선순위 할당 전략

### Rate Monotonic (RM) 스케줄링
```
원리: 주기가 짧은 작업일수록 높은 우선순위 할당
공식: Priority ∝ 1/Period

조건:
- 모든 작업이 주기적
- 데드라인 = 주기
- 작업 간 독립성
- 선점 가능

최적성: 고정우선순위 알고리즘 중 최적
```

### Deadline Monotonic (DM) 스케줄링
```
원리: 상대 데드라인이 짧은 작업일수록 높은 우선순위
공식: Priority ∝ 1/Relative_Deadline

장점:
- RM보다 일반적 (데드라인 ≠ 주기 허용)
- 여전히 최적성 보장
- 더 유연한 시스템 모델링
```

## ⚖️ 스케줄링 가능성 분석

### Liu-Layland 충분조건
```cpp
// Rate Monotonic 스케줄링 가능성 검사
class RMSchedulabilityTest {
private:
    struct Task {
        int period;
        int execution_time;
        int deadline;
        int priority;  // 낮은 값 = 높은 우선순위
    };
    
public:
    bool isSchedulableByUtilization(Task tasks[], int n) {
        float total_utilization = 0;
        
        // 총 이용률 계산
        for(int i = 0; i < n; i++) {
            total_utilization += (float)tasks[i].execution_time / tasks[i].period;
        }
        
        // Liu-Layland 충분조건
        float bound = n * (pow(2, 1.0/n) - 1);
        
        Serial.printf("Total utilization: %.3f\n", total_utilization);
        Serial.printf("Liu-Layland bound: %.3f\n", bound);
        
        if(total_utilization <= bound) {
            Serial.println("Schedulable by Liu-Layland bound");
            return true;
        }
        
        // 필요조건 검사
        if(total_utilization <= 1.0) {
            Serial.println("May be schedulable, need response time analysis");
            return performResponseTimeAnalysis(tasks, n);
        }
        
        Serial.println("Not schedulable - utilization > 100%");
        return false;
    }
    
    // 응답시간 분석 (정확한 검사)
    bool performResponseTimeAnalysis(Task tasks[], int n) {
        // 우선순위별 정렬 (RM 규칙)
        assignRMPriorities(tasks, n);
        
        for(int i = 0; i < n; i++) {
            int response_time = calculateWorstCaseResponseTime(tasks, n, i);
            
            if(response_time > tasks[i].deadline) {
                Serial.printf("Task %d misses deadline: R=%d, D=%d\n", 
                             i, response_time, tasks[i].deadline);
                return false;
            }
            
            Serial.printf("Task %d: R=%d, D=%d (OK)\n", 
                         i, response_time, tasks[i].deadline);
        }
        
        return true;
    }
    
private:
    void assignRMPriorities(Task tasks[], int n) {
        // 주기 기준 정렬 (짧은 주기 = 높은 우선순위)
        for(int i = 0; i < n-1; i++) {
            for(int j = i+1; j < n; j++) {
                if(tasks[i].period > tasks[j].period) {
                    Task temp = tasks[i];
                    tasks[i] = tasks[j];
                    tasks[j] = temp;
                }
            }
        }
        
        // 우선순위 할당
        for(int i = 0; i < n; i++) {
            tasks[i].priority = i;  // 0이 최고 우선순위
        }
    }
    
    int calculateWorstCaseResponseTime(Task tasks[], int n, int task_index) {
        int response_time = tasks[task_index].execution_time;
        int prev_response = 0;
        
        // 고정점 반복법
        while(response_time != prev_response && response_time <= tasks[task_index].deadline) {
            prev_response = response_time;
            int interference = 0;
            
            // 높은 우선순위 작업들의 간섭 계산
            for(int i = 0; i < task_index; i++) {
                interference += ceil((float)response_time / tasks[i].period) * 
                               tasks[i].execution_time;
            }
            
            response_time = tasks[task_index].execution_time + interference;
        }
        
        return response_time;
    }
};
```

### 하모닉 태스크 분석
```cpp
// 하모닉 태스크셋 최적화
class HarmonicTaskAnalyzer {
public:
    bool isHarmonicTaskSet(int periods[], int n) {
        // 주기 정렬
        sortPeriods(periods, n);
        
        // 각 주기가 이전 주기들의 배수인지 확인
        for(int i = 1; i < n; i++) {
            bool is_multiple = false;
            
            for(int j = 0; j < i; j++) {
                if(periods[i] % periods[j] == 0) {
                    is_multiple = true;
                    break;
                }
            }
            
            if(!is_multiple) {
                return false;
            }
        }
        
        return true;
    }
    
    float getHarmonicUtilizationBound(int n) {
        // 하모닉 태스크셋은 100% 이용률까지 스케줄링 가능
        return 1.0;
    }
    
    void optimizeToHarmonic(int periods[], int n) {
        Serial.println("Suggesting harmonic period optimization:");
        
        sortPeriods(periods, n);
        
        for(int i = 1; i < n; i++) {
            // 가장 가까운 하모닉 주기 찾기
            int base_period = periods[0];
            int multiple = round((float)periods[i] / base_period);
            int suggested_period = base_period * multiple;
            
            Serial.printf("Period[%d]: %d -> %d (×%d)\n", 
                         i, periods[i], suggested_period, multiple);
        }
    }
    
private:
    void sortPeriods(int arr[], int n) {
        for(int i = 0; i < n-1; i++) {
            for(int j = i+1; j < n; j++) {
                if(arr[i] > arr[j]) {
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
            }
        }
    }
};
```

## 🔄 동적 우선순위 스케줄링

### Earliest Deadline First (EDF)
```cpp
// EDF 스케줄링 구현
class EDFScheduler {
private:
    struct EDFTask {
        int id;
        int arrival_time;
        int execution_time;
        int absolute_deadline;
        int remaining_time;
        bool completed;
    };
    
    EDFTask ready_queue[MAX_TASKS];
    int queue_size = 0;
    
public:
    void addTask(int id, int arrival, int execution, int deadline) {
        if(queue_size < MAX_TASKS) {
            ready_queue[queue_size] = {
                id, arrival, execution, deadline, execution, false
            };
            queue_size++;
            
            // 데드라인 기준 정렬
            sortByDeadline();
        }
    }
    
    void scheduleEDF(int current_time) {
        // 완료된 작업 제거
        removeCompletedTasks();
        
        if(queue_size == 0) {
            Serial.printf("Time %d: No tasks ready\n", current_time);
            return;
        }
        
        // 가장 빠른 데드라인의 작업 실행
        EDFTask* current_task = &ready_queue[0];
        current_task->remaining_time--;
        
        Serial.printf("Time %d: Executing Task %d (deadline: %d, remaining: %d)\n",
                     current_time, current_task->id, 
                     current_task->absolute_deadline, current_task->remaining_time);
        
        // 작업 완료 확인
        if(current_task->remaining_time == 0) {
            current_task->completed = true;
            Serial.printf("Task %d completed at time %d\n", 
                         current_task->id, current_time + 1);
        }
        
        // 데드라인 위반 검사
        checkDeadlineMisses(current_time);
    }
    
    bool isSchedulableByEDF(EDFTask tasks[], int n) {
        float total_utilization = 0;
        
        for(int i = 0; i < n; i++) {
            int period = tasks[i].absolute_deadline;  // 주기적 태스크 가정
            total_utilization += (float)tasks[i].execution_time / period;
        }
        
        // EDF는 100% 이용률까지 최적
        return total_utilization <= 1.0;
    }
    
private:
    void sortByDeadline() {
        for(int i = 0; i < queue_size - 1; i++) {
            for(int j = i + 1; j < queue_size; j++) {
                if(ready_queue[i].absolute_deadline > ready_queue[j].absolute_deadline) {
                    EDFTask temp = ready_queue[i];
                    ready_queue[i] = ready_queue[j];
                    ready_queue[j] = temp;
                }
            }
        }
    }
    
    void removeCompletedTasks() {
        int write_index = 0;
        for(int read_index = 0; read_index < queue_size; read_index++) {
            if(!ready_queue[read_index].completed) {
                ready_queue[write_index] = ready_queue[read_index];
                write_index++;
            }
        }
        queue_size = write_index;
    }
    
    void checkDeadlineMisses(int current_time) {
        for(int i = 0; i < queue_size; i++) {
            if(current_time >= ready_queue[i].absolute_deadline && 
               !ready_queue[i].completed) {
                Serial.printf("DEADLINE MISS: Task %d at time %d\n", 
                             ready_queue[i].id, current_time);
            }
        }
    }
};
```

## 🛡️ 우선순위 역전 문제 해결

### Priority Inheritance Protocol (PIP)
```cpp
// 우선순위 상속 프로토콜
class PriorityInheritanceManager {
private:
    struct Task {
        int id;
        int base_priority;
        int current_priority;
        int blocked_by_task;
        bool holds_resource;
    };
    
    struct Resource {
        int id;
        int owner_task;
        bool is_locked;
        int ceiling_priority;
    };
    
    Task tasks[MAX_TASKS];
    Resource resources[MAX_RESOURCES];
    int task_count = 0;
    int resource_count = 0;
    
public:
    void addTask(int id, int priority) {
        if(task_count < MAX_TASKS) {
            tasks[task_count] = {id, priority, priority, -1, false};
            task_count++;
        }
    }
    
    void addResource(int id, int ceiling_priority) {
        if(resource_count < MAX_RESOURCES) {
            resources[resource_count] = {id, -1, false, ceiling_priority};
            resource_count++;
        }
    }
    
    bool requestResource(int task_id, int resource_id) {
        Task* task = findTask(task_id);
        Resource* resource = findResource(resource_id);
        
        if(!task || !resource) return false;
        
        if(!resource->is_locked) {
            // 자원 할당
            resource->is_locked = true;
            resource->owner_task = task_id;
            task->holds_resource = true;
            
            Serial.printf("Task %d acquired resource %d\n", task_id, resource_id);
            return true;
        } else {
            // 자원이 잠겨있음 - 우선순위 상속 적용
            Task* owner = findTask(resource->owner_task);
            if(owner && task->current_priority < owner->current_priority) {
                
                Serial.printf("Priority inheritance: Task %d priority %d -> %d\n",
                             owner->id, owner->current_priority, task->current_priority);
                
                owner->current_priority = task->current_priority;
            }
            
            task->blocked_by_task = resource->owner_task;
            Serial.printf("Task %d blocked by Task %d on resource %d\n",
                         task_id, resource->owner_task, resource_id);
            return false;
        }
    }
    
    void releaseResource(int task_id, int resource_id) {
        Task* task = findTask(task_id);
        Resource* resource = findResource(resource_id);
        
        if(!task || !resource || resource->owner_task != task_id) return;
        
        // 자원 해제
        resource->is_locked = false;
        resource->owner_task = -1;
        task->holds_resource = false;
        
        // 우선순위 복원
        task->current_priority = task->base_priority;
        
        // 대기 중인 태스크들의 블록 해제
        for(int i = 0; i < task_count; i++) {
            if(tasks[i].blocked_by_task == task_id) {
                tasks[i].blocked_by_task = -1;
                Serial.printf("Task %d unblocked\n", tasks[i].id);
            }
        }
        
        Serial.printf("Task %d released resource %d, priority restored to %d\n",
                     task_id, resource_id, task->base_priority);
    }
    
private:
    Task* findTask(int task_id) {
        for(int i = 0; i < task_count; i++) {
            if(tasks[i].id == task_id) return &tasks[i];
        }
        return nullptr;
    }
    
    Resource* findResource(int resource_id) {
        for(int i = 0; i < resource_count; i++) {
            if(resources[i].id == resource_id) return &resources[i];
        }
        return nullptr;
    }
};
```

### Priority Ceiling Protocol (PCP)
```cpp
// 우선순위 천장 프로토콜
class PriorityCeilingProtocol {
private:
    int system_ceiling = INT_MAX;  // 현재 시스템 천장
    
public:
    bool requestResourceWithPCP(int task_id, int resource_id) {
        Task* task = findTask(task_id);
        Resource* resource = findResource(resource_id);
        
        if(!task || !resource) return false;
        
        // PCP 조건 검사: 태스크 우선순위 > 시스템 천장
        if(task->current_priority <= system_ceiling && 
           !resource->is_locked) {
            
            Serial.printf("Task %d blocked by ceiling protocol\n", task_id);
            return false;
        }
        
        if(!resource->is_locked) {
            // 자원 할당 및 시스템 천장 업데이트
            resource->is_locked = true;
            resource->owner_task = task_id;
            
            if(resource->ceiling_priority < system_ceiling) {
                system_ceiling = resource->ceiling_priority;
            }
            
            Serial.printf("Task %d acquired resource %d, ceiling: %d\n",
                         task_id, resource_id, system_ceiling);
            return true;
        }
        
        return false;
    }
    
    void releaseResourceWithPCP(int task_id, int resource_id) {
        // 자원 해제 후 시스템 천장 재계산
        releaseResource(task_id, resource_id);
        updateSystemCeiling();
    }
    
private:
    void updateSystemCeiling() {
        system_ceiling = INT_MAX;
        
        for(int i = 0; i < resource_count; i++) {
            if(resources[i].is_locked && 
               resources[i].ceiling_priority < system_ceiling) {
                system_ceiling = resources[i].ceiling_priority;
            }
        }
        
        Serial.printf("System ceiling updated to: %d\n", system_ceiling);
    }
};
```

## 📊 실시간 성능 모니터링

### 스케줄링 성능 메트릭
```cpp
// 실시간 스케줄링 성능 분석
class SchedulingPerformanceMonitor {
private:
    struct TaskMetrics {
        int task_id;
        int executions;
        int deadline_misses;
        unsigned long total_response_time;
        unsigned long worst_response_time;
        int preemptions;
    };
    
    TaskMetrics metrics[MAX_TASKS];
    int metric_count = 0;
    unsigned long scheduling_overhead = 0;
    
public:
    void recordTaskExecution(int task_id, unsigned long response_time, 
                           bool deadline_met, int preemption_count) {
        TaskMetrics* metric = findOrCreateMetric(task_id);
        
        metric->executions++;
        metric->total_response_time += response_time;
        metric->preemptions += preemption_count;
        
        if(response_time > metric->worst_response_time) {
            metric->worst_response_time = response_time;
        }
        
        if(!deadline_met) {
            metric->deadline_misses++;
        }
    }
    
    void recordSchedulingOverhead(unsigned long overhead_us) {
        scheduling_overhead += overhead_us;
    }
    
    void printPerformanceReport() {
        Serial.println("=== Scheduling Performance Report ===");
        
        for(int i = 0; i < metric_count; i++) {
            TaskMetrics* m = &metrics[i];
            float avg_response = (float)m->total_response_time / m->executions;
            float miss_ratio = (float)m->deadline_misses * 100.0 / m->executions;
            
            Serial.printf("Task %d:\n", m->task_id);
            Serial.printf("  Executions: %d\n", m->executions);
            Serial.printf("  Deadline miss ratio: %.2f%%\n", miss_ratio);
            Serial.printf("  Avg response time: %.2f μs\n", avg_response);
            Serial.printf("  Worst response time: %lu μs\n", m->worst_response_time);
            Serial.printf("  Total preemptions: %d\n\n", m->preemptions);
        }
        
        Serial.printf("Total scheduling overhead: %lu μs\n", scheduling_overhead);
    }
    
    float calculateSchedulingEfficiency() {
        int total_executions = 0;
        int total_misses = 0;
        
        for(int i = 0; i < metric_count; i++) {
            total_executions += metrics[i].executions;
            total_misses += metrics[i].deadline_misses;
        }
        
        return (float)(total_executions - total_misses) * 100.0 / total_executions;
    }
    
private:
    TaskMetrics* findOrCreateMetric(int task_id) {
        // 기존 메트릭 검색
        for(int i = 0; i < metric_count; i++) {
            if(metrics[i].task_id == task_id) {
                return &metrics[i];
            }
        }
        
        // 새 메트릭 생성
        if(metric_count < MAX_TASKS) {
            metrics[metric_count] = {task_id, 0, 0, 0, 0, 0};
            return &metrics[metric_count++];
        }
        
        return nullptr;
    }
};
```

---

## 🔗 연결 문서
- 상위: [[실시간제어]]
- 관련: [[데드라인]], [[지터]], [[레이턴시]], [[처리량]]
- 구현: [[시분할스케줄링]], [[인터럽트처리]]
- 하드웨어: [[마이크로컨트롤러]]

## 📚 참고문헌
- [Liu & Layland (1973). "Scheduling Algorithms for Multiprogramming in a Hard Real-Time Environment"](https://en.wikipedia.org/wiki/Rate-monotonic_scheduling)
- [Wikipedia (2024). "Rate-monotonic scheduling"](https://en.wikipedia.org/wiki/Rate-monotonic_scheduling)
- [Wikipedia (2023). "Deadline-monotonic scheduling"](https://en.wikipedia.org/wiki/Deadline-monotonic_scheduling) 
- [ScienceDirect (2024). "Rate Monotonic Scheduling - an overview"](https://www.sciencedirect.com/topics/computer-science/rate-monotonic-scheduling)
- [Barr Group (2024). "Introduction to Rate Monotonic Scheduling"](https://barrgroup.com/blog/introduction-rate-monotonic-scheduling)
