# ìš°ì„ ìˆœìœ„ìŠ¤ì¼€ì¤„ë§

> ìƒìœ„: [[ì‹¤ì‹œê°„ì œì–´]]

ì‹¤ì‹œê°„ ì‹œìŠ¤í…œì—ì„œ ì‘ì—…ì˜ ì¤‘ìš”ë„ë‚˜ ì‹œê°„ ì œì•½ì— ë”°ë¼ ìš°ì„ ìˆœìœ„ë¥¼ ë¶€ì—¬í•˜ì—¬ ìŠ¤ì¼€ì¤„ë§í•˜ëŠ” ê¸°ë²•ì…ë‹ˆë‹¤.

## ğŸ¯ ìš°ì„ ìˆœìœ„ í• ë‹¹ ì „ëµ

### Rate Monotonic (RM) ìŠ¤ì¼€ì¤„ë§
```
ì›ë¦¬: ì£¼ê¸°ê°€ ì§§ì€ ì‘ì—…ì¼ìˆ˜ë¡ ë†’ì€ ìš°ì„ ìˆœìœ„ í• ë‹¹
ê³µì‹: Priority âˆ 1/Period

ì¡°ê±´:
- ëª¨ë“  ì‘ì—…ì´ ì£¼ê¸°ì 
- ë°ë“œë¼ì¸ = ì£¼ê¸°
- ì‘ì—… ê°„ ë…ë¦½ì„±
- ì„ ì  ê°€ëŠ¥

ìµœì ì„±: ê³ ì •ìš°ì„ ìˆœìœ„ ì•Œê³ ë¦¬ì¦˜ ì¤‘ ìµœì 
```

### Deadline Monotonic (DM) ìŠ¤ì¼€ì¤„ë§
```
ì›ë¦¬: ìƒëŒ€ ë°ë“œë¼ì¸ì´ ì§§ì€ ì‘ì—…ì¼ìˆ˜ë¡ ë†’ì€ ìš°ì„ ìˆœìœ„
ê³µì‹: Priority âˆ 1/Relative_Deadline

ì¥ì :
- RMë³´ë‹¤ ì¼ë°˜ì  (ë°ë“œë¼ì¸ â‰  ì£¼ê¸° í—ˆìš©)
- ì—¬ì „íˆ ìµœì ì„± ë³´ì¥
- ë” ìœ ì—°í•œ ì‹œìŠ¤í…œ ëª¨ë¸ë§
```

## âš–ï¸ ìŠ¤ì¼€ì¤„ë§ ê°€ëŠ¥ì„± ë¶„ì„

### Liu-Layland ì¶©ë¶„ì¡°ê±´
```cpp
// Rate Monotonic ìŠ¤ì¼€ì¤„ë§ ê°€ëŠ¥ì„± ê²€ì‚¬
class RMSchedulabilityTest {
private:
    struct Task {
        int period;
        int execution_time;
        int deadline;
        int priority;  // ë‚®ì€ ê°’ = ë†’ì€ ìš°ì„ ìˆœìœ„
    };
    
public:
    bool isSchedulableByUtilization(Task tasks[], int n) {
        float total_utilization = 0;
        
        // ì´ ì´ìš©ë¥  ê³„ì‚°
        for(int i = 0; i < n; i++) {
            total_utilization += (float)tasks[i].execution_time / tasks[i].period;
        }
        
        // Liu-Layland ì¶©ë¶„ì¡°ê±´
        float bound = n * (pow(2, 1.0/n) - 1);
        
        Serial.printf("Total utilization: %.3f\n", total_utilization);
        Serial.printf("Liu-Layland bound: %.3f\n", bound);
        
        if(total_utilization <= bound) {
            Serial.println("Schedulable by Liu-Layland bound");
            return true;
        }
        
        // í•„ìš”ì¡°ê±´ ê²€ì‚¬
        if(total_utilization <= 1.0) {
            Serial.println("May be schedulable, need response time analysis");
            return performResponseTimeAnalysis(tasks, n);
        }
        
        Serial.println("Not schedulable - utilization > 100%");
        return false;
    }
    
    // ì‘ë‹µì‹œê°„ ë¶„ì„ (ì •í™•í•œ ê²€ì‚¬)
    bool performResponseTimeAnalysis(Task tasks[], int n) {
        // ìš°ì„ ìˆœìœ„ë³„ ì •ë ¬ (RM ê·œì¹™)
        assignRMPriorities(tasks, n);
        
        for(int i = 0; i < n; i++) {
            int response_time = calculateWorstCaseResponseTime(tasks, n, i);
            
            if(response_time > tasks[i].deadline) {
                Serial.printf("Task %d misses deadline: R=%d, D=%d\n", 
                             i, response_time, tasks[i].deadline);
                return false;
            }
            
            Serial.printf("Task %d: R=%d, D=%d (OK)\n", 
                         i, response_time, tasks[i].deadline);
        }
        
        return true;
    }
    
private:
    void assignRMPriorities(Task tasks[], int n) {
        // ì£¼ê¸° ê¸°ì¤€ ì •ë ¬ (ì§§ì€ ì£¼ê¸° = ë†’ì€ ìš°ì„ ìˆœìœ„)
        for(int i = 0; i < n-1; i++) {
            for(int j = i+1; j < n; j++) {
                if(tasks[i].period > tasks[j].period) {
                    Task temp = tasks[i];
                    tasks[i] = tasks[j];
                    tasks[j] = temp;
                }
            }
        }
        
        // ìš°ì„ ìˆœìœ„ í• ë‹¹
        for(int i = 0; i < n; i++) {
            tasks[i].priority = i;  // 0ì´ ìµœê³  ìš°ì„ ìˆœìœ„
        }
    }
    
    int calculateWorstCaseResponseTime(Task tasks[], int n, int task_index) {
        int response_time = tasks[task_index].execution_time;
        int prev_response = 0;
        
        // ê³ ì •ì  ë°˜ë³µë²•
        while(response_time != prev_response && response_time <= tasks[task_index].deadline) {
            prev_response = response_time;
            int interference = 0;
            
            // ë†’ì€ ìš°ì„ ìˆœìœ„ ì‘ì—…ë“¤ì˜ ê°„ì„­ ê³„ì‚°
            for(int i = 0; i < task_index; i++) {
                interference += ceil((float)response_time / tasks[i].period) * 
                               tasks[i].execution_time;
            }
            
            response_time = tasks[task_index].execution_time + interference;
        }
        
        return response_time;
    }
};
```

### í•˜ëª¨ë‹‰ íƒœìŠ¤í¬ ë¶„ì„
```cpp
// í•˜ëª¨ë‹‰ íƒœìŠ¤í¬ì…‹ ìµœì í™”
class HarmonicTaskAnalyzer {
public:
    bool isHarmonicTaskSet(int periods[], int n) {
        // ì£¼ê¸° ì •ë ¬
        sortPeriods(periods, n);
        
        // ê° ì£¼ê¸°ê°€ ì´ì „ ì£¼ê¸°ë“¤ì˜ ë°°ìˆ˜ì¸ì§€ í™•ì¸
        for(int i = 1; i < n; i++) {
            bool is_multiple = false;
            
            for(int j = 0; j < i; j++) {
                if(periods[i] % periods[j] == 0) {
                    is_multiple = true;
                    break;
                }
            }
            
            if(!is_multiple) {
                return false;
            }
        }
        
        return true;
    }
    
    float getHarmonicUtilizationBound(int n) {
        // í•˜ëª¨ë‹‰ íƒœìŠ¤í¬ì…‹ì€ 100% ì´ìš©ë¥ ê¹Œì§€ ìŠ¤ì¼€ì¤„ë§ ê°€ëŠ¥
        return 1.0;
    }
    
    void optimizeToHarmonic(int periods[], int n) {
        Serial.println("Suggesting harmonic period optimization:");
        
        sortPeriods(periods, n);
        
        for(int i = 1; i < n; i++) {
            // ê°€ì¥ ê°€ê¹Œìš´ í•˜ëª¨ë‹‰ ì£¼ê¸° ì°¾ê¸°
            int base_period = periods[0];
            int multiple = round((float)periods[i] / base_period);
            int suggested_period = base_period * multiple;
            
            Serial.printf("Period[%d]: %d -> %d (Ã—%d)\n", 
                         i, periods[i], suggested_period, multiple);
        }
    }
    
private:
    void sortPeriods(int arr[], int n) {
        for(int i = 0; i < n-1; i++) {
            for(int j = i+1; j < n; j++) {
                if(arr[i] > arr[j]) {
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
            }
        }
    }
};
```

## ğŸ”„ ë™ì  ìš°ì„ ìˆœìœ„ ìŠ¤ì¼€ì¤„ë§

### Earliest Deadline First (EDF)
```cpp
// EDF ìŠ¤ì¼€ì¤„ë§ êµ¬í˜„
class EDFScheduler {
private:
    struct EDFTask {
        int id;
        int arrival_time;
        int execution_time;
        int absolute_deadline;
        int remaining_time;
        bool completed;
    };
    
    EDFTask ready_queue[MAX_TASKS];
    int queue_size = 0;
    
public:
    void addTask(int id, int arrival, int execution, int deadline) {
        if(queue_size < MAX_TASKS) {
            ready_queue[queue_size] = {
                id, arrival, execution, deadline, execution, false
            };
            queue_size++;
            
            // ë°ë“œë¼ì¸ ê¸°ì¤€ ì •ë ¬
            sortByDeadline();
        }
    }
    
    void scheduleEDF(int current_time) {
        // ì™„ë£Œëœ ì‘ì—… ì œê±°
        removeCompletedTasks();
        
        if(queue_size == 0) {
            Serial.printf("Time %d: No tasks ready\n", current_time);
            return;
        }
        
        // ê°€ì¥ ë¹ ë¥¸ ë°ë“œë¼ì¸ì˜ ì‘ì—… ì‹¤í–‰
        EDFTask* current_task = &ready_queue[0];
        current_task->remaining_time--;
        
        Serial.printf("Time %d: Executing Task %d (deadline: %d, remaining: %d)\n",
                     current_time, current_task->id, 
                     current_task->absolute_deadline, current_task->remaining_time);
        
        // ì‘ì—… ì™„ë£Œ í™•ì¸
        if(current_task->remaining_time == 0) {
            current_task->completed = true;
            Serial.printf("Task %d completed at time %d\n", 
                         current_task->id, current_time + 1);
        }
        
        // ë°ë“œë¼ì¸ ìœ„ë°˜ ê²€ì‚¬
        checkDeadlineMisses(current_time);
    }
    
    bool isSchedulableByEDF(EDFTask tasks[], int n) {
        float total_utilization = 0;
        
        for(int i = 0; i < n; i++) {
            int period = tasks[i].absolute_deadline;  // ì£¼ê¸°ì  íƒœìŠ¤í¬ ê°€ì •
            total_utilization += (float)tasks[i].execution_time / period;
        }
        
        // EDFëŠ” 100% ì´ìš©ë¥ ê¹Œì§€ ìµœì 
        return total_utilization <= 1.0;
    }
    
private:
    void sortByDeadline() {
        for(int i = 0; i < queue_size - 1; i++) {
            for(int j = i + 1; j < queue_size; j++) {
                if(ready_queue[i].absolute_deadline > ready_queue[j].absolute_deadline) {
                    EDFTask temp = ready_queue[i];
                    ready_queue[i] = ready_queue[j];
                    ready_queue[j] = temp;
                }
            }
        }
    }
    
    void removeCompletedTasks() {
        int write_index = 0;
        for(int read_index = 0; read_index < queue_size; read_index++) {
            if(!ready_queue[read_index].completed) {
                ready_queue[write_index] = ready_queue[read_index];
                write_index++;
            }
        }
        queue_size = write_index;
    }
    
    void checkDeadlineMisses(int current_time) {
        for(int i = 0; i < queue_size; i++) {
            if(current_time >= ready_queue[i].absolute_deadline && 
               !ready_queue[i].completed) {
                Serial.printf("DEADLINE MISS: Task %d at time %d\n", 
                             ready_queue[i].id, current_time);
            }
        }
    }
};
```

## ğŸ›¡ï¸ ìš°ì„ ìˆœìœ„ ì—­ì „ ë¬¸ì œ í•´ê²°

### Priority Inheritance Protocol (PIP)
```cpp
// ìš°ì„ ìˆœìœ„ ìƒì† í”„ë¡œí† ì½œ
class PriorityInheritanceManager {
private:
    struct Task {
        int id;
        int base_priority;
        int current_priority;
        int blocked_by_task;
        bool holds_resource;
    };
    
    struct Resource {
        int id;
        int owner_task;
        bool is_locked;
        int ceiling_priority;
    };
    
    Task tasks[MAX_TASKS];
    Resource resources[MAX_RESOURCES];
    int task_count = 0;
    int resource_count = 0;
    
public:
    void addTask(int id, int priority) {
        if(task_count < MAX_TASKS) {
            tasks[task_count] = {id, priority, priority, -1, false};
            task_count++;
        }
    }
    
    void addResource(int id, int ceiling_priority) {
        if(resource_count < MAX_RESOURCES) {
            resources[resource_count] = {id, -1, false, ceiling_priority};
            resource_count++;
        }
    }
    
    bool requestResource(int task_id, int resource_id) {
        Task* task = findTask(task_id);
        Resource* resource = findResource(resource_id);
        
        if(!task || !resource) return false;
        
        if(!resource->is_locked) {
            // ìì› í• ë‹¹
            resource->is_locked = true;
            resource->owner_task = task_id;
            task->holds_resource = true;
            
            Serial.printf("Task %d acquired resource %d\n", task_id, resource_id);
            return true;
        } else {
            // ìì›ì´ ì ê²¨ìˆìŒ - ìš°ì„ ìˆœìœ„ ìƒì† ì ìš©
            Task* owner = findTask(resource->owner_task);
            if(owner && task->current_priority < owner->current_priority) {
                
                Serial.printf("Priority inheritance: Task %d priority %d -> %d\n",
                             owner->id, owner->current_priority, task->current_priority);
                
                owner->current_priority = task->current_priority;
            }
            
            task->blocked_by_task = resource->owner_task;
            Serial.printf("Task %d blocked by Task %d on resource %d\n",
                         task_id, resource->owner_task, resource_id);
            return false;
        }
    }
    
    void releaseResource(int task_id, int resource_id) {
        Task* task = findTask(task_id);
        Resource* resource = findResource(resource_id);
        
        if(!task || !resource || resource->owner_task != task_id) return;
        
        // ìì› í•´ì œ
        resource->is_locked = false;
        resource->owner_task = -1;
        task->holds_resource = false;
        
        // ìš°ì„ ìˆœìœ„ ë³µì›
        task->current_priority = task->base_priority;
        
        // ëŒ€ê¸° ì¤‘ì¸ íƒœìŠ¤í¬ë“¤ì˜ ë¸”ë¡ í•´ì œ
        for(int i = 0; i < task_count; i++) {
            if(tasks[i].blocked_by_task == task_id) {
                tasks[i].blocked_by_task = -1;
                Serial.printf("Task %d unblocked\n", tasks[i].id);
            }
        }
        
        Serial.printf("Task %d released resource %d, priority restored to %d\n",
                     task_id, resource_id, task->base_priority);
    }
    
private:
    Task* findTask(int task_id) {
        for(int i = 0; i < task_count; i++) {
            if(tasks[i].id == task_id) return &tasks[i];
        }
        return nullptr;
    }
    
    Resource* findResource(int resource_id) {
        for(int i = 0; i < resource_count; i++) {
            if(resources[i].id == resource_id) return &resources[i];
        }
        return nullptr;
    }
};
```

### Priority Ceiling Protocol (PCP)
```cpp
// ìš°ì„ ìˆœìœ„ ì²œì¥ í”„ë¡œí† ì½œ
class PriorityCeilingProtocol {
private:
    int system_ceiling = INT_MAX;  // í˜„ì¬ ì‹œìŠ¤í…œ ì²œì¥
    
public:
    bool requestResourceWithPCP(int task_id, int resource_id) {
        Task* task = findTask(task_id);
        Resource* resource = findResource(resource_id);
        
        if(!task || !resource) return false;
        
        // PCP ì¡°ê±´ ê²€ì‚¬: íƒœìŠ¤í¬ ìš°ì„ ìˆœìœ„ > ì‹œìŠ¤í…œ ì²œì¥
        if(task->current_priority <= system_ceiling && 
           !resource->is_locked) {
            
            Serial.printf("Task %d blocked by ceiling protocol\n", task_id);
            return false;
        }
        
        if(!resource->is_locked) {
            // ìì› í• ë‹¹ ë° ì‹œìŠ¤í…œ ì²œì¥ ì—…ë°ì´íŠ¸
            resource->is_locked = true;
            resource->owner_task = task_id;
            
            if(resource->ceiling_priority < system_ceiling) {
                system_ceiling = resource->ceiling_priority;
            }
            
            Serial.printf("Task %d acquired resource %d, ceiling: %d\n",
                         task_id, resource_id, system_ceiling);
            return true;
        }
        
        return false;
    }
    
    void releaseResourceWithPCP(int task_id, int resource_id) {
        // ìì› í•´ì œ í›„ ì‹œìŠ¤í…œ ì²œì¥ ì¬ê³„ì‚°
        releaseResource(task_id, resource_id);
        updateSystemCeiling();
    }
    
private:
    void updateSystemCeiling() {
        system_ceiling = INT_MAX;
        
        for(int i = 0; i < resource_count; i++) {
            if(resources[i].is_locked && 
               resources[i].ceiling_priority < system_ceiling) {
                system_ceiling = resources[i].ceiling_priority;
            }
        }
        
        Serial.printf("System ceiling updated to: %d\n", system_ceiling);
    }
};
```

## ğŸ“Š ì‹¤ì‹œê°„ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

### ìŠ¤ì¼€ì¤„ë§ ì„±ëŠ¥ ë©”íŠ¸ë¦­
```cpp
// ì‹¤ì‹œê°„ ìŠ¤ì¼€ì¤„ë§ ì„±ëŠ¥ ë¶„ì„
class SchedulingPerformanceMonitor {
private:
    struct TaskMetrics {
        int task_id;
        int executions;
        int deadline_misses;
        unsigned long total_response_time;
        unsigned long worst_response_time;
        int preemptions;
    };
    
    TaskMetrics metrics[MAX_TASKS];
    int metric_count = 0;
    unsigned long scheduling_overhead = 0;
    
public:
    void recordTaskExecution(int task_id, unsigned long response_time, 
                           bool deadline_met, int preemption_count) {
        TaskMetrics* metric = findOrCreateMetric(task_id);
        
        metric->executions++;
        metric->total_response_time += response_time;
        metric->preemptions += preemption_count;
        
        if(response_time > metric->worst_response_time) {
            metric->worst_response_time = response_time;
        }
        
        if(!deadline_met) {
            metric->deadline_misses++;
        }
    }
    
    void recordSchedulingOverhead(unsigned long overhead_us) {
        scheduling_overhead += overhead_us;
    }
    
    void printPerformanceReport() {
        Serial.println("=== Scheduling Performance Report ===");
        
        for(int i = 0; i < metric_count; i++) {
            TaskMetrics* m = &metrics[i];
            float avg_response = (float)m->total_response_time / m->executions;
            float miss_ratio = (float)m->deadline_misses * 100.0 / m->executions;
            
            Serial.printf("Task %d:\n", m->task_id);
            Serial.printf("  Executions: %d\n", m->executions);
            Serial.printf("  Deadline miss ratio: %.2f%%\n", miss_ratio);
            Serial.printf("  Avg response time: %.2f Î¼s\n", avg_response);
            Serial.printf("  Worst response time: %lu Î¼s\n", m->worst_response_time);
            Serial.printf("  Total preemptions: %d\n\n", m->preemptions);
        }
        
        Serial.printf("Total scheduling overhead: %lu Î¼s\n", scheduling_overhead);
    }
    
    float calculateSchedulingEfficiency() {
        int total_executions = 0;
        int total_misses = 0;
        
        for(int i = 0; i < metric_count; i++) {
            total_executions += metrics[i].executions;
            total_misses += metrics[i].deadline_misses;
        }
        
        return (float)(total_executions - total_misses) * 100.0 / total_executions;
    }
    
private:
    TaskMetrics* findOrCreateMetric(int task_id) {
        // ê¸°ì¡´ ë©”íŠ¸ë¦­ ê²€ìƒ‰
        for(int i = 0; i < metric_count; i++) {
            if(metrics[i].task_id == task_id) {
                return &metrics[i];
            }
        }
        
        // ìƒˆ ë©”íŠ¸ë¦­ ìƒì„±
        if(metric_count < MAX_TASKS) {
            metrics[metric_count] = {task_id, 0, 0, 0, 0, 0};
            return &metrics[metric_count++];
        }
        
        return nullptr;
    }
};
```

---

## ğŸ”— ì—°ê²° ë¬¸ì„œ
- ìƒìœ„: [[ì‹¤ì‹œê°„ì œì–´]]
- ê´€ë ¨: [[ë°ë“œë¼ì¸]], [[ì§€í„°]], [[ë ˆì´í„´ì‹œ]], [[ì²˜ë¦¬ëŸ‰]]
- êµ¬í˜„: [[ì‹œë¶„í• ìŠ¤ì¼€ì¤„ë§]], [[ì¸í„°ëŸ½íŠ¸ì²˜ë¦¬]]
- í•˜ë“œì›¨ì–´: [[ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬]]

## ğŸ“š ì°¸ê³ ë¬¸í—Œ
- [Liu & Layland (1973). "Scheduling Algorithms for Multiprogramming in a Hard Real-Time Environment"](https://en.wikipedia.org/wiki/Rate-monotonic_scheduling)
- [Wikipedia (2024). "Rate-monotonic scheduling"](https://en.wikipedia.org/wiki/Rate-monotonic_scheduling)
- [Wikipedia (2023). "Deadline-monotonic scheduling"](https://en.wikipedia.org/wiki/Deadline-monotonic_scheduling) 
- [ScienceDirect (2024). "Rate Monotonic Scheduling - an overview"](https://www.sciencedirect.com/topics/computer-science/rate-monotonic-scheduling)
- [Barr Group (2024). "Introduction to Rate Monotonic Scheduling"](https://barrgroup.com/blog/introduction-rate-monotonic-scheduling)
