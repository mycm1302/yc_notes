# 벡터계산

> 상위: [[선형대수]]  
> 관련: [[선형대수및기하학]], [[행렬이론]]

로봇공학에서 위치, 속도, 힘 등을 표현하고 계산하는 기본 도구인 벡터 계산입니다. 3차원 공간에서의 기하학적 관계를 정확히 다룰 수 있게 해줍니다.

## 🎯 벡터의 기본 개념

### 벡터의 정의
```
벡터 v: 크기(magnitude)와 방향(direction)을 모두 갖는 수학적 객체

표기법:
- 굵은 글씨: v, a, b
- 화살표: v⃗, a⃗, b⃗ 
- 성분 표현: v = [v₁, v₂, v₃]ᵀ ∈ ℝ³
```

### 스칼라 vs 벡터
```
스칼라: 크기만 갖는 양 (온도, 질량, 거리)
벡터: 크기와 방향을 갖는 양 (위치, 속도, 힘)

로봇공학 예시:
- 관절각: 스칼라 (θ₁, θ₂, ...)
- 말단장치 위치: 벡터 p = [x, y, z]ᵀ
- 관절 토크: 벡터 τ = [τ₁, τ₂, ..., τₙ]ᵀ
```

### 벡터의 기하학적 표현
```
원점에서 점까지: 위치벡터
점에서 점까지: 변위벡터
크기: ||v|| = √(v₁² + v₂² + v₃²)
방향: 단위벡터 v̂ = v/||v||
```

## 🔧 기본 벡터 연산

### 1. 벡터 덧셈과 뺄셈
```
덧셈: a + b = [a₁ + b₁, a₂ + b₂, a₃ + b₃]ᵀ
뺄셈: a - b = [a₁ - b₁, a₂ - b₂, a₃ - b₃]ᵀ

기하학적 의미:
- 덧셈: 평행사변형 법칙
- 뺄셈: b에서 a로의 벡터

로봇공학 응용:
상대 위치: p_AB = p_B - p_A
속도 합성: v_total = v_robot + v_conveyor
```

### 2. 스칼라 곱셈
```
스칼라 곱: ka = [ka₁, ka₂, ka₃]ᵀ

성질:
- k > 0: 방향 유지, 크기 k배
- k < 0: 방향 반대, 크기 |k|배
- k = 0: 영벡터

응용:
힘의 증폭: F_amplified = gain × F_input
단위벡터: û = v/||v||
```

### 3. 내적 (Dot Product)
```
정의: a · b = a₁b₁ + a₂b₂ + a₃b₃ = ||a|| ||b|| cos(θ)

기하학적 의미:
- θ: 두 벡터 사이의 각도
- 한 벡터의 다른 벡터로의 투영

성질:
- a · b = b · a (교환법칙)
- a · (b + c) = a · b + a · c (분배법칙)
- a · a = ||a||² (크기의 제곱)
```

#### 로봇공학 응용
```
작업과 에너지: W = F · d
속도와 각속도: v = ω × r에서 중심축 성분
직교성 판단: a ⊥ b ⟺ a · b = 0
관절 한계 검사: q · q_limit ≥ threshold
```

### 4. 외적 (Cross Product)
```
정의: a × b = [a₂b₃ - a₃b₂, a₃b₁ - a₁b₃, a₁b₂ - a₂b₁]ᵀ

크기: ||a × b|| = ||a|| ||b|| sin(θ)
방향: 오른손 법칙 (a, b, a×b 순서)

성질:
- a × b = -(b × a) (반교환법칙)
- a × (b + c) = a × b + a × c
- a × a = 0 (평행벡터의 외적은 영벡터)
```

#### 기하학적 의미
```
면적: 평행사변형의 넓이 = ||a × b||
수직벡터: a × b는 a, b에 모두 수직
회전축: 각속도 벡터의 방향
```

#### 로봇공학 응용
```
토크 계산: τ = r × F
각속도와 선속도: v = ω × r
법선벡터: 두 변의 외적으로 면의 법선 구함
자코비안 계산: 회전 관절의 기여도
```

## 📐 고급 벡터 연산

### 1. 삼중곱 (Triple Products)
```
스칼라 삼중곱: a · (b × c) = det([a b c])
- 기하학적 의미: 평행육면체의 부피
- 세 벡터의 공면성 판단: = 0이면 공면

벡터 삼중곱: a × (b × c) = b(a·c) - c(a·b)
- BAC-CAB 규칙
- 벡터의 성분 분해에 활용
```

### 2. 벡터의 미분
```
시간에 대한 미분: dv/dt = [dv₁/dt, dv₂/dt, dv₃/dt]ᵀ

곱의 미분:
d/dt(a · b) = da/dt · b + a · db/dt
d/dt(a × b) = da/dt × b + a × db/dt

로봇공학 응용:
위치 → 속도: v = dp/dt
속도 → 가속도: a = dv/dt
각속도와 회전: dR/dt = ω̂R (반대칭 행렬)
```

### 3. 곡선과 벡터함수
```
매개변수 곡선: r(t) = [x(t), y(t), z(t)]ᵀ

접선벡터: T = dr/dt
단위 접선벡터: T̂ = T/||T||
법선벡터: N = dT̂/dt / ||dT̂/dt||
종법선벡터: B = T̂ × N̂

곡률: κ = ||dr/dt × d²r/dt²|| / ||dr/dt||³
비틀림: τ = (dr/dt × d²r/dt²) · d³r/dt³ / ||dr/dt × d²r/dt²||²
```

## 🤖 로봇공학 특수 응용

### 1. 위치와 방향 표현
```
위치벡터: p = [x, y, z]ᵀ
방향 단위벡터들:
- x축: i = [1, 0, 0]ᵀ
- y축: j = [0, 1, 0]ᵀ  
- z축: k = [0, 0, 1]ᵀ

좌표계: {O; i, j, k}
직교 정규 기저: i·j = j·k = k·i = 0, ||i|| = ||j|| = ||k|| = 1
```

### 2. 회전과 각속도
```
각속도 벡터: ω = [ωₓ, ωᵧ, ωᵧ]ᵀ
- 크기: 회전 속도 (rad/s)
- 방향: 회전축 (오른손 법칙)

선속도와의 관계: v = ω × r
각운동량: L = r × p = r × mv

반대칭 행렬 표현:
ω̂ = [ 0   -ωᵧ  ωᵧ ]
    [ ωᵧ   0  -ωₓ]
    [-ωᵧ  ωₓ   0 ]
```

### 3. 힘과 토크
```
힘 벡터: F = [Fₓ, Fᵧ, Fᵧ]ᵀ
토크 벡터: τ = r × F

결과력: F_total = ΣFᵢ  
결과토크: τ_total = Στᵢ + Σ(rᵢ × Fᵢ)

평형 조건:
ΣF = 0 (힘의 평형)
Στ = 0 (토크의 평형)
```

### 4. 자코비안과 속도 관계
```
말단장치 속도: v = [vₓ, vᵧ, vᵧ, ωₓ, ωᵧ, ωᵧ]ᵀ ∈ ℝ⁶
관절 속도: q̇ = [q̇₁, q̇₂, ..., q̇ₙ]ᵀ ∈ ℝⁿ

자코비안 관계: v = J(q)q̇
- J의 각 열: 해당 관절의 기여도 벡터
- 선속도 부분: 위치 미분
- 각속도 부분: 방향 미분
```

## 🔬 수치적 고려사항

### 1. 부동소수점 오차
```
영벡터 판정: ||v|| < ε (ε = 1e-12)
정규화: v̂ = v/max(||v||, ε)
직교성 검사: |a·b| < ε

안전한 외적 계산:
if ||a|| < ε or ||b|| < ε:
    return zero_vector
else:
    return a × b
```

### 2. 각도 계산
```
내적을 이용한 각도:
θ = arccos(clamp(a·b/(||a||||b||), -1, 1))

외적을 이용한 부호있는 각도:
sign = (a × b) · n  # n: 회전축
θ = atan2(||(a × b)||, a · b)
if sign < 0: θ = -θ
```

### 3. 특이점 처리
```
단위벡터 계산:
if ||v|| < ε:
    return default_direction
else:
    return v / ||v||

회전축 계산:
if sin(θ) < ε:  # θ ≈ 0 or π
    return special_case_handling()
else:
    return (a × b) / sin(θ)
```

## 🔧 구현 예제

### MATLAB
```matlab
% 벡터 연산 함수들
function result = vec_dot(a, b)
    result = sum(a .* b);
end

function result = vec_cross(a, b)
    result = [a(2)*b(3) - a(3)*b(2);
              a(3)*b(1) - a(1)*b(3);
              a(1)*b(2) - a(2)*b(1)];
end

function result = vec_normalize(v)
    norm_v = norm(v);
    if norm_v < 1e-12
        result = [1; 0; 0];  % 기본 방향
    else
        result = v / norm_v;
    end
end

% 각속도를 반대칭 행렬로
function omega_hat = skew(omega)
    omega_hat = [0 -omega(3) omega(2);
                 omega(3) 0 -omega(1);
                 -omega(2) omega(1) 0];
end
```

### Python (NumPy)
```python
import numpy as np

class VectorOps:
    @staticmethod
    def dot(a, b):
        """내적 계산"""
        return np.dot(a, b)
    
    @staticmethod
    def cross(a, b):
        """외적 계산"""
        return np.cross(a, b)
    
    @staticmethod
    def normalize(v, default_dir=None):
        """안전한 정규화"""
        norm = np.linalg.norm(v)
        if norm < 1e-12:
            return default_dir if default_dir is not None else np.array([1, 0, 0])
        return v / norm
    
    @staticmethod
    def angle_between(a, b):
        """두 벡터 사이의 각도"""
        cos_angle = np.clip(np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b)), -1, 1)
        return np.arccos(cos_angle)
    
    @staticmethod
    def skew_symmetric(omega):
        """각속도의 반대칭 행렬 표현"""
        return np.array([[0, -omega[2], omega[1]],
                         [omega[2], 0, -omega[0]],
                         [-omega[1], omega[0], 0]])
    
    @staticmethod
    def rodrigues_rotation(axis, angle):
        """로드리게스 회전 공식"""
        axis = VectorOps.normalize(axis)
        K = VectorOps.skew_symmetric(axis)
        R = np.eye(3) + np.sin(angle) * K + (1 - np.cos(angle)) * K @ K
        return R

# 사용 예제
if __name__ == "__main__":
    # 두 벡터 정의
    a = np.array([1, 2, 3])
    b = np.array([4, 5, 6])
    
    # 기본 연산
    print(f"내적: {VectorOps.dot(a, b)}")
    print(f"외적: {VectorOps.cross(a, b)}")
    print(f"각도: {np.degrees(VectorOps.angle_between(a, b)):.2f}도")
    
    # 회전 예제
    axis = np.array([0, 0, 1])  # z축
    angle = np.pi/4  # 45도
    R = VectorOps.rodrigues_rotation(axis, angle)
    print(f"회전된 벡터: {R @ a}")
```

## 🎯 실제 문제 예시

### 1. 로봇 팔 말단 속도
```
문제: 3-DOF 로봇팔의 말단장치 속도 계산

주어진 정보:
- 관절 위치: q = [θ₁, θ₂, θ₃]ᵀ
- 관절 속도: q̇ = [θ̇₁, θ̇₂, θ̇₃]ᵀ
- 링크 길이: L₁, L₂, L₃

해법:
1. 각 관절의 회전축 벡터 구하기
2. 말단까지의 위치벡터 계산
3. 속도 기여도 벡터 계산: vᵢ = ωᵢ × rᵢ
4. 총 속도: v = Σvᵢ
```

### 2. 충돌 감지
```
문제: 두 로봇 간 최소 거리 계산

방법:
1. 각 로봇의 링크를 선분으로 모델링
2. 선분 간 최단거리 알고리즘:
   - 방향벡터: d₁ = P₁ - P₀, d₂ = Q₁ - Q₀
   - 수직벡터: n = d₁ × d₂
   - 거리: |((Q₀ - P₀) · n)| / ||n||
```

### 3. 힘 제어
```
문제: 원하는 방향으로 힘 가하기

주어진:
- 목표 힘: F_desired
- 현재 말단 방향: R_current
- 센서 측정 힘: F_measured

제어:
1. 오차 계산: F_error = F_desired - F_measured  
2. 관절공간 변환: τ = Jᵀ F_error
3. 방향 보정: 적절한 좌표계 변환
```

## 🎯 학습 가이드

1. **기본 연산** (1-2주)
   - 내적, 외적의 기하학적 의미
   - 손으로 계산 연습

2. **응용** (2-3주)
   - 로봇 기구학에서의 활용
   - 힘과 토크 계산

3. **고급 주제** (2-3주)
   - 미분과 적분
   - 곡선의 기하학적 성질

4. **수치 구현** (1-2주)
   - 안정적인 계산 방법
   - 특이점 처리

---
*참고: Vector Calculus (Marsden & Tromba), Introduction to Robotics (Craig), Modern Robotics (Lynch & Park)*