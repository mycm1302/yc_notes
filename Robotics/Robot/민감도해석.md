# ë¯¼ê°ë„í•´ì„

> ìƒìœ„: [[ìµœì í™”ì„¤ê³„]]

ì„¤ê³„ë³€ìˆ˜ì˜ ë³€í™”ê°€ ëª©ì í•¨ìˆ˜ì™€ ì œì•½ì¡°ê±´ì— ë¯¸ì¹˜ëŠ” ì˜í–¥ì„ ì •ëŸ‰ì ìœ¼ë¡œ ë¶„ì„í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤. ì‰½ê²Œ ë§í•´ "ì–´ë–¤ ì„¤ê³„ë³€ìˆ˜ê°€ ì„±ëŠ¥ì— ê°€ì¥ í° ì˜í–¥ì„ ì£¼ëŠ”ê°€?"ë¥¼ ìˆ˜ì¹˜ì ìœ¼ë¡œ ê³„ì‚°í•˜ëŠ” ê¸°ë²•ì…ë‹ˆë‹¤.

## ğŸ” ê¸°ë³¸ ê°œë…

### ì™œ ë¯¼ê°ë„í•´ì„ì´ í•„ìš”í•œê°€?

**ì‹¤ì œ ì„¤ê³„ ìƒí™©:**
- ì„¤ê³„ë³€ìˆ˜ê°€ ìˆ˜ì‹­~ìˆ˜ë°± ê°œ
- ì–´ë–¤ ë³€ìˆ˜ê°€ ì¤‘ìš”í•œì§€ ëª¨ë¦„
- ì œí•œëœ ì‹œê°„ê³¼ ìì›
- íš¨ìœ¨ì ì¸ ì„¤ê³„ ê°œì„  í•„ìš”

**ë¯¼ê°ë„í•´ì„ì˜ ì—­í• :**
1. **ì¤‘ìš” ë³€ìˆ˜ ì‹ë³„**: ì„±ëŠ¥ì— í° ì˜í–¥ì„ ì£¼ëŠ” ë³€ìˆ˜ ì°¾ê¸°
2. **ì„¤ê³„ ë°©í–¥ ê²°ì •**: ì–´ë–¤ ë°©í–¥ìœ¼ë¡œ ë³€ê²½í•´ì•¼ ì„±ëŠ¥ í–¥ìƒë˜ëŠ”ì§€
3. **ê³µì°¨ ì„¤ì •**: ì œì¡° ì˜¤ì°¨ì— ë¯¼ê°í•œ ë³€ìˆ˜ íŒŒì•…
4. **ìµœì í™” íš¨ìœ¨**: ì¤‘ìš”í•œ ë³€ìˆ˜ë¶€í„° ìš°ì„  ìµœì í™”

### ìˆ˜í•™ì  ì •ì˜

**1ì°¨ ë¯¼ê°ë„ (First-order Sensitivity):**
```
Sâ‚áµ¢ = âˆ‚f/âˆ‚xáµ¢
```

**ì •ê·œí™”ëœ ë¯¼ê°ë„:**
```
Sâ‚áµ¢â¿áµ’Ê³áµ = (xáµ¢/f) Ã— (âˆ‚f/âˆ‚xáµ¢) = âˆ‚(ln f)/âˆ‚(ln xáµ¢)
```

**2ì°¨ ë¯¼ê°ë„ (Second-order Sensitivity):**
```
Sâ‚‚áµ¢â±¼ = âˆ‚Â²f/âˆ‚xáµ¢âˆ‚xâ±¼
```

### ë¬¼ë¦¬ì  ì˜ë¯¸

**ë¯¼ê°ë„ í¬ê¸° í•´ì„:**
- |Sâ‚áµ¢| í´ìˆ˜ë¡: xáµ¢ ë³€í™”ê°€ fì— í° ì˜í–¥
- Sâ‚áµ¢ > 0: xáµ¢ ì¦ê°€ ì‹œ f ì¦ê°€ (ì–‘ì˜ ìƒê´€ê´€ê³„)
- Sâ‚áµ¢ < 0: xáµ¢ ì¦ê°€ ì‹œ f ê°ì†Œ (ìŒì˜ ìƒê´€ê´€ê³„)

**ì˜ˆì‹œ: ìº”í‹¸ë ˆë²„ ë³´ì˜ ì²˜ì§**
```
Î´ = (PLÂ³)/(3EI) = (PLÂ³)/(3E) Ã— (12/bhÂ³)

ë¯¼ê°ë„:
âˆ‚Î´/âˆ‚L = 3PLÂ²/(3EI) = 3Î´/L  â† ê¸¸ì´ì— ë§¤ìš° ë¯¼ê°
âˆ‚Î´/âˆ‚h = -3PLÂ³/(Ebhâ´) = -3Î´/h â† ë†’ì´ì— ë§¤ìš° ë¯¼ê° (3ì œê³±)
âˆ‚Î´/âˆ‚b = -PLÂ³/(EbÂ²hÂ³) = -Î´/b  â† í­ì— ìƒëŒ€ì ìœ¼ë¡œ ëœ ë¯¼ê°
```

---

## ğŸ§® ê³„ì‚° ë°©ë²•

### 1. ìˆ˜ì¹˜ ë¯¸ë¶„ë²• (Numerical Differentiation)

#### ì „ì§„ì°¨ë¶„ (Forward Difference)
```
âˆ‚f/âˆ‚xáµ¢ â‰ˆ [f(x + Î”xáµ¢eáµ¢) - f(x)]/Î”xáµ¢
```

**ì¥ì :**
- êµ¬í˜„ ê°„ë‹¨
- í•¨ìˆ˜ê°’ë§Œ í•„ìš” (ë¸”ë™ë°•ìŠ¤ ëª¨ë¸ ì ìš© ê°€ëŠ¥)

**ë‹¨ì :**
- ì˜¤ì°¨ ë°œìƒ (O(Î”x))
- ìŠ¤í… í¬ê¸° ì„ íƒ ì–´ë ¤ì›€

**êµ¬í˜„ ì˜ˆì‹œ:**
```matlab
function sensitivity = forward_difference(func, x, delta)
    n = length(x);
    sensitivity = zeros(n, 1);
    f0 = func(x);
    
    for i = 1:n
        x_pert = x;
        x_pert(i) = x_pert(i) + delta;
        f_pert = func(x_pert);
        sensitivity(i) = (f_pert - f0) / delta;
    end
end

% ì‚¬ìš© ì˜ˆ
x = [1, 2, 3];
delta = 1e-6;
sens = forward_difference(@my_function, x, delta);
```

#### ì¤‘ì•™ì°¨ë¶„ (Central Difference)
```
âˆ‚f/âˆ‚xáµ¢ â‰ˆ [f(x + Î”xáµ¢eáµ¢) - f(x - Î”xáµ¢eáµ¢)]/(2Î”xáµ¢)
```

**ì¥ì :**
- ë” ë†’ì€ ì •í™•ë„ (O(Î”xÂ²))
- ëŒ€ì¹­ì  ì˜¤ì°¨

**ë‹¨ì :**
- ê³„ì‚°ëŸ‰ 2ë°°
- ê²½ê³„ ê·¼ì²˜ì—ì„œ ë¬¸ì œ

**ì •í™•ë„ ë¹„êµ:**
```matlab
% í…ŒìŠ¤íŠ¸ í•¨ìˆ˜: f(x) = xÂ³
x = 2; true_derivative = 3*x^2; % = 12

% ì „ì§„ì°¨ë¶„
h_values = [1e-2, 1e-4, 1e-6, 1e-8];
for h = h_values
    forward_approx = (x+h)^3 - x^3) / h;
    error = abs(forward_approx - true_derivative);
    fprintf('h=%e, error=%e\n', h, error);
end

% ì¤‘ì•™ì°¨ë¶„
for h = h_values
    central_approx = ((x+h)^3 - (x-h)^3) / (2*h);
    error = abs(central_approx - true_derivative);
    fprintf('h=%e, error=%e\n', h, error);
end
```

#### ë³µì†Œìˆ˜ ë‹¨ê³„ë²• (Complex Step Method)
```
âˆ‚f/âˆ‚xáµ¢ â‰ˆ Im[f(x + ihÎµáµ¢)]/h
```

**ì¥ì :**
- ë§¤ìš° ë†’ì€ ì •í™•ë„
- ìŠ¤í… í¬ê¸°ì— ëœ ë¯¼ê°
- ì†Œê±° ì˜¤ì°¨ ì—†ìŒ

**ë‹¨ì :**
- ë³µì†Œìˆ˜ ì—°ì‚° í•„ìš”
- ì¼ë¶€ í•¨ìˆ˜ì— ì ìš© ë¶ˆê°€

```matlab
function sensitivity = complex_step(func, x, h)
    n = length(x);
    sensitivity = zeros(n, 1);
    
    for i = 1:n
        x_complex = complex(x);
        x_complex(i) = x_complex(i) + 1i*h;
        f_complex = func(x_complex);
        sensitivity(i) = imag(f_complex) / h;
    end
end
```

### 2. í•´ì„ì  ë¯¸ë¶„ë²• (Analytical Differentiation)

#### ì§ì ‘ ë¯¸ë¶„
í•¨ìˆ˜ì˜ í•´ì„ì  í˜•íƒœë¥¼ ì•Œ ë•Œ ì§ì ‘ ë¯¸ë¶„

**ì˜ˆì‹œ: íŠ¸ëŸ¬ìŠ¤ êµ¬ì¡°**
```
ì§ˆëŸ‰: m = âˆ‘ Ïáµ¢Aáµ¢Láµ¢
ë¯¼ê°ë„: âˆ‚m/âˆ‚Aáµ¢ = Ïáµ¢Láµ¢

ì‘ë ¥: Ïƒáµ¢ = Fáµ¢/Aáµ¢
ë¯¼ê°ë„: âˆ‚Ïƒáµ¢/âˆ‚Aáµ¢ = -Fáµ¢/Aáµ¢Â²
```

#### ì—°ì‡„ë²•ì¹™ (Chain Rule)
ë³µí•©í•¨ìˆ˜ì˜ ë¯¼ê°ë„ ê³„ì‚°

```
f(x) = g(h(x))ì¸ ê²½ìš°:
âˆ‚f/âˆ‚xáµ¢ = (âˆ‚g/âˆ‚h) Ã— (âˆ‚h/âˆ‚xáµ¢)
```

**ìœ í•œìš”ì†Œ í•´ì„ ì˜ˆì‹œ:**
```
ë³€ìœ„: u = Kâ»Â¹F
ì‘ë ¥: Ïƒ = DBu
ì»´í”Œë¼ì´ì–¸ìŠ¤: c = F^T u = F^T Kâ»Â¹F

ë¯¼ê°ë„: âˆ‚c/âˆ‚xáµ¢ = -F^T Kâ»Â¹ (âˆ‚K/âˆ‚xáµ¢) Kâ»Â¹F
```

### 3. ìë™ ë¯¸ë¶„ë²• (Automatic Differentiation)

#### ì „ì§„ ëª¨ë“œ (Forward Mode)
```
ê° ë³€ìˆ˜ì— ëŒ€í•´ ì´ì¤‘ìˆ˜(dual number) ì‚¬ìš©:
x = a + bÎµ, where ÎµÂ² = 0

f(x) = f(a) + f'(a)bÎµ
```

**êµ¬í˜„ ì˜ˆì‹œ (Python):**
```python
import numpy as np

class DualNumber:
    def __init__(self, real, dual=0):
        self.real = real
        self.dual = dual
    
    def __add__(self, other):
        if isinstance(other, DualNumber):
            return DualNumber(self.real + other.real, 
                            self.dual + other.dual)
        return DualNumber(self.real + other, self.dual)
    
    def __mul__(self, other):
        if isinstance(other, DualNumber):
            return DualNumber(self.real * other.real,
                            self.real * other.dual + 
                            self.dual * other.real)
        return DualNumber(self.real * other, self.dual * other)

# ì‚¬ìš© ì˜ˆ
def f(x, y):
    return x*x + x*y + y*y

# xì— ëŒ€í•œ í¸ë¯¸ë¶„
x_dual = DualNumber(2, 1)  # x=2, dx=1
y_dual = DualNumber(3, 0)  # y=3, dy=0
result = f(x_dual, y_dual)
print(f"f(2,3) = {result.real}")
print(f"âˆ‚f/âˆ‚x|_(2,3) = {result.dual}")
```

#### í›„ì§„ ëª¨ë“œ (Reverse Mode)
- ê³„ì‚° ê·¸ë˜í”„ì˜ ì—­ë°©í–¥ ìˆœíšŒ
- ë‹¤ìˆ˜ ì¶œë ¥, ì ì€ ì…ë ¥ì— íš¨ìœ¨ì 
- ì‹ ê²½ë§ ì—­ì „íŒŒì™€ ë™ì¼ ì›ë¦¬

### 4. ìˆ˜ë°˜ë³€ìˆ˜ë²• (Adjoint Variable Method)

ì œì•½ì´ ìˆëŠ” ìµœì í™” ë¬¸ì œì˜ ë¯¼ê°ë„ ê³„ì‚°ì— íŠ¹íˆ ìœ ìš©

**ë¬¸ì œ ì„¤ì •:**
```
ìµœì†Œí™”: f(x,u)
ì œì•½ì¡°ê±´: g(x,u) = 0
```

**ë¼ê·¸ë‘ì§€ì•ˆ:**
```
L = f(x,u) + Î»áµ€g(x,u)
```

**ìˆ˜ë°˜ë°©ì •ì‹:**
```
âˆ‚L/âˆ‚u = âˆ‚f/âˆ‚u + Î»áµ€âˆ‚g/âˆ‚u = 0
```

**ë¯¼ê°ë„:**
```
df/dx = âˆ‚L/âˆ‚x = âˆ‚f/âˆ‚x + Î»áµ€âˆ‚g/âˆ‚x
```

**ì¥ì :**
- ì œì•½ì¡°ê±´ ìˆ˜ì— ë¬´ê´€í•˜ê²Œ íš¨ìœ¨ì 
- ëŒ€ê·œëª¨ ì‹œìŠ¤í…œì— ì í•©

**ìœ í•œìš”ì†Œ êµ¬í˜„:**
```matlab
function sensitivity = adjoint_method(K, F, dK_dx)
    % ì •í•´ì„: Ku = F
    u = K \ F;
    
    % ìˆ˜ë°˜í•´ì„: K^T Î» = âˆ‚c/âˆ‚u = F
    lambda = K' \ F;  % Kê°€ ëŒ€ì¹­ì´ë©´ K = K'
    
    % ë¯¼ê°ë„: dc/dx = -Î»^T dK/dx u
    sensitivity = -lambda' * dK_dx * u;
end
```

---

## ğŸ“Š êµ¬ì¡°í•´ì„ì—ì„œì˜ ì‘ìš©

### ì •ì  í•´ì„ ë¯¼ê°ë„

#### ë³€ìœ„ ë¯¼ê°ë„
**ì§€ë°°ë°©ì •ì‹:**
```
K u = F
```

**ë³€ìœ„ ë¯¼ê°ë„:**
```
âˆ‚u/âˆ‚xáµ¢ = Kâ»Â¹(âˆ‚F/âˆ‚xáµ¢ - âˆ‚K/âˆ‚xáµ¢ u)
```

**êµ¬í˜„:**
```matlab
function du_dx = displacement_sensitivity(K, F, u, dK_dx, dF_dx)
    rhs = dF_dx - dK_dx * u;
    du_dx = K \ rhs;
end
```

#### ì‘ë ¥ ë¯¼ê°ë„
**ì‘ë ¥-ë³€ìœ„ ê´€ê³„:**
```
Ïƒ = D B u
```

**ì‘ë ¥ ë¯¼ê°ë„:**
```
âˆ‚Ïƒ/âˆ‚xáµ¢ = D B âˆ‚u/âˆ‚xáµ¢
```

#### ì»´í”Œë¼ì´ì–¸ìŠ¤ ë¯¼ê°ë„
**ì»´í”Œë¼ì´ì–¸ìŠ¤:**
```
c = uáµ€F = uáµ€Ku
```

**ë¯¼ê°ë„:**
```
âˆ‚c/âˆ‚xáµ¢ = 2uáµ€âˆ‚K/âˆ‚xáµ¢ u - uáµ€âˆ‚F/âˆ‚xáµ¢
```

### ë™ì  í•´ì„ ë¯¼ê°ë„

#### ê³ ìœ ì§„ë™ìˆ˜ ë¯¼ê°ë„
**ê³ ìœ ê°’ ë¬¸ì œ:**
```
K Ï†áµ¢ = Î»áµ¢ M Ï†áµ¢
```

**ì§„ë™ìˆ˜ ë¯¼ê°ë„:**
```
âˆ‚Ï‰áµ¢/âˆ‚x = (1/2Ï‰áµ¢) Ã— Ï†áµ¢áµ€(âˆ‚K/âˆ‚x - Ï‰áµ¢Â²âˆ‚M/âˆ‚x)Ï†áµ¢ / (Ï†áµ¢áµ€MÏ†áµ¢)
```

**ì‹¤ìŠµ ì˜ˆì œ:**
```matlab
% ìº”í‹¸ë ˆë²„ ë³´ì˜ ê³ ìœ ì§„ë™ìˆ˜ ë¯¼ê°ë„
function [omega, domega_dL] = cantilever_frequency_sensitivity(E, rho, L, b, h)
    % 1ì°¨ ê³ ìœ ì§„ë™ìˆ˜
    I = b*h^3/12;
    A = b*h;
    omega = 1.875^2 * sqrt(E*I/(rho*A*L^4));
    
    % ê¸¸ì´ì— ëŒ€í•œ ë¯¼ê°ë„
    domega_dL = -2 * omega / L;
end
```

### ì¢Œêµ´í•´ì„ ë¯¼ê°ë„

**ì¢Œêµ´ ê³ ìœ ê°’ ë¬¸ì œ:**
```
(K + Î»cr Kg) Ï† = 0
```

**ì¢Œêµ´í•˜ì¤‘ ë¯¼ê°ë„:**
```
âˆ‚Î»cr/âˆ‚x = -Ï†áµ€(âˆ‚K/âˆ‚x + Î»cr âˆ‚Kg/âˆ‚x)Ï† / (Ï†áµ€KgÏ†)
```

---

## ğŸ”§ ì‹¤ë¬´ ì‘ìš© ì‚¬ë¡€

### ì‚¬ë¡€ 1: í•­ê³µê¸° ë‚ ê°œ êµ¬ì¡° ìµœì í™”

**ì„¤ê³„ë³€ìˆ˜:**
- ìŠ¤í‚¨ ë‘ê»˜ (20ê°œ)
- ìŠ¤íŠ¸ë§ê±° ì¹˜ìˆ˜ (15ê°œ)  
- ë¦¬ë¸Œ ë‘ê»˜ (10ê°œ)
- ì´ 45ê°œ ë³€ìˆ˜

**ëª©ì í•¨ìˆ˜:**
- êµ¬ì¡° ì¤‘ëŸ‰ ìµœì†Œí™”

**ì œì•½ì¡°ê±´:**
- ì‘ë ¥ ì œì•½ (1000ê°œ+)
- ì¢Œêµ´ ì œì•½ (500ê°œ+)
- ë³€ìœ„ ì œì•½ (100ê°œ+)

**ë¯¼ê°ë„í•´ì„ ê²°ê³¼:**
```
ì¤‘ìš”ë„ ìˆœìœ„:
1. ìƒë¶€ ìŠ¤í‚¨ ë‘ê»˜ (ë¯¼ê°ë„: -2.34)
2. ì£¼ ìŠ¤íŒŒ ì›¹ ë‘ê»˜ (ë¯¼ê°ë„: -1.87)
3. ì£¼ ìŠ¤íŠ¸ë§ê±° ë†’ì´ (ë¯¼ê°ë„: -1.23)
â‹®
43. ë³´ì¡° ë¦¬ë¸Œ ë‘ê»˜ (ë¯¼ê°ë„: -0.03)
```

**ì„¤ê³„ ì „ëµ:**
- ìƒìœ„ 10ê°œ ë³€ìˆ˜ì— ì§‘ì¤‘
- í•˜ìœ„ ë³€ìˆ˜ëŠ” ê³ ì •í•˜ì—¬ ì°¨ì› ì¶•ì†Œ
- ë‹¨ê³„ì  ìµœì í™” ìˆ˜í–‰

### ì‚¬ë¡€ 2: ìë™ì°¨ í¬ë˜ì‹œ ë°•ìŠ¤ ì„¤ê³„

**ì„¤ê³„ë³€ìˆ˜:**
- ë²½ ë‘ê»˜ (8ê°œ êµ¬ê°„)
- í¬ëŸ¬ì‹œ ì¡´ ê¸¸ì´
- í´ë”© íŒ¨í„´

**ëª©ì í•¨ìˆ˜:**
- ì—ë„ˆì§€ í¡ìˆ˜ëŸ‰ ìµœëŒ€í™”
- ìµœëŒ€ ì¶©ê²©ë ¥ ì œí•œ

**íŠ¹ì§•:**
- ë¹„ì„ í˜• ë™ì  í•´ì„ í•„ìš”
- ìœ í•œì°¨ë¶„ë²•ìœ¼ë¡œ ë¯¼ê°ë„ ê³„ì‚°
- ê³„ì‚° ë¹„ìš© ë†’ìŒ (1íšŒ í•´ì„ = 30ë¶„)

**ìµœì í™” ì „ëµ:**
```matlab
% ìŠ¤í¬ë¦¬ë‹ ë‹¨ê³„
n_vars = 10;
delta = 0.05;  % 5% ë³€í™”
for i = 1:n_vars
    % ê¸°ì¤€ ì„¤ê³„
    energy_base = crash_analysis(x_base);
    
    % ë³€ìˆ˜ ië¥¼ 5% ì¦ê°€
    x_pert = x_base;
    x_pert(i) = x_pert(i) * (1 + delta);
    energy_pert = crash_analysis(x_pert);
    
    % ì •ê·œí™”ëœ ë¯¼ê°ë„
    sensitivity(i) = (energy_pert - energy_base) / energy_base / delta;
end

% ì¤‘ìš”í•œ ë³€ìˆ˜ë§Œ ì„ íƒ
important_vars = find(abs(sensitivity) > threshold);
```

### ì‚¬ë¡€ 3: ë¡œë´‡ ë§í¬ ê²½ëŸ‰í™”

**ì„¤ê³„ë³€ìˆ˜:**
- ë§í¬ ë‹¨ë©´ í˜•ìƒ (ì¤‘ê³µ ì›í˜•, ì‚¬ê°í˜•)
- ì¬ë£Œ ë‘ê»˜ ë¶„í¬
- ë³´ê°•ì¬ ìœ„ì¹˜

**ëª©ì í•¨ìˆ˜:**
- ì§ˆëŸ‰ ìµœì†Œí™”
- ê°•ì„± ìµœëŒ€í™” (ë‹¤ëª©ì )

**ë¯¼ê°ë„ ê¸°ë°˜ í˜•ìƒ ìµœì í™”:**
```matlab
% ì‘ë ¥ ê¸°ë°˜ ì¬ë£Œ ì¬ë°°ì¹˜
function new_thickness = stress_based_redistribution(thickness, stress, target_stress)
    % von Mises ì‘ë ¥ ê¸°ë°˜ ë¯¼ê°ë„
    sensitivity = 2 * stress / target_stress;
    
    % ì¬ë£Œ ì¬ë°°ì¹˜ (ì²´ì  ë³´ì¡´)
    total_volume = sum(thickness);
    new_thickness = thickness .* sensitivity.^0.5;
    new_thickness = new_thickness * total_volume / sum(new_thickness);
end
```

---

## ğŸ’» ì†Œí”„íŠ¸ì›¨ì–´ êµ¬í˜„

### MATLAB ë¯¼ê°ë„í•´ì„ ë„êµ¬ìƒì

```matlab
classdef SensitivityAnalyzer < handle
    properties
        method          % 'finite_diff', 'complex_step', 'analytical'
        step_size       % ì°¨ë¶„ ìŠ¤í… í¬ê¸°
        tolerance       % ìˆ˜ë ´ íŒì • ê¸°ì¤€
    end
    
    methods
        function obj = SensitivityAnalyzer(method, step_size)
            obj.method = method;
            obj.step_size = step_size;
        end
        
        function sens = compute(obj, func, x)
            switch obj.method
                case 'finite_diff'
                    sens = obj.finite_difference(func, x);
                case 'complex_step'
                    sens = obj.complex_step(func, x);
                case 'analytical'
                    sens = obj.analytical(func, x);
            end
        end
        
        function sens = finite_difference(obj, func, x)
            n = length(x);
            sens = zeros(n, 1);
            f0 = func(x);
            
            for i = 1:n
                x_pert = x;
                x_pert(i) = x_pert(i) + obj.step_size;
                f_pert = func(x_pert);
                sens(i) = (f_pert - f0) / obj.step_size;
            end
        end
        
        function sens = complex_step(obj, func, x)
            n = length(x);
            sens = zeros(n, 1);
            
            for i = 1:n
                x_complex = complex(x);
                x_complex(i) = x_complex(i) + 1i * obj.step_size;
                f_complex = func(x_complex);
                sens(i) = imag(f_complex) / obj.step_size;
            end
        end
    end
end

% ì‚¬ìš© ì˜ˆì œ
analyzer = SensitivityAnalyzer('complex_step', 1e-12);
sensitivity = analyzer.compute(@my_objective, design_vars);

% ê²°ê³¼ ì‹œê°í™”
figure;
bar(sensitivity);
xlabel('Design Variable Index');
ylabel('Sensitivity');
title('Sensitivity Analysis Results');
```

### Python êµ¬í˜„ (JAX ì‚¬ìš©)

```python
import jax
import jax.numpy as jnp
from jax import grad, jacfwd, jacrev

# ìë™ ë¯¸ë¶„ì„ ì´ìš©í•œ ë¯¼ê°ë„ ê³„ì‚°
def objective_function(x):
    """ì˜ˆì œ ëª©ì í•¨ìˆ˜"""
    return jnp.sum(x**2) + jnp.prod(x)

# ê·¸ë˜ë””ì–¸íŠ¸ ê³„ì‚°
gradient_func = grad(objective_function)

# í—¤ì‹œì•ˆ ê³„ì‚°
hessian_func = jacfwd(jacrev(objective_function))

# ì‚¬ìš© ì˜ˆì œ
x = jnp.array([1.0, 2.0, 3.0])

# 1ì°¨ ë¯¼ê°ë„
first_order = gradient_func(x)
print(f"Gradient: {first_order}")

# 2ì°¨ ë¯¼ê°ë„
second_order = hessian_func(x)
print(f"Hessian:\n{second_order}")

# ë²¡í„°í™”ëœ ê³„ì‚° (ì—¬ëŸ¬ ì ì—ì„œ ë™ì‹œ ê³„ì‚°)
x_batch = jnp.array([[1.0, 2.0, 3.0],
                     [2.0, 3.0, 4.0],
                     [3.0, 4.0, 5.0]])

batch_gradient = jax.vmap(gradient_func)(x_batch)
print(f"Batch gradients:\n{batch_gradient}")
```

---

## ğŸ“ˆ ê³ ê¸‰ ì£¼ì œ

### í™•ë¥ ë¡ ì  ë¯¼ê°ë„í•´ì„

ë¶ˆí™•ì‹¤ì„±ì´ ìˆëŠ” ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•œ ë¯¼ê°ë„

**Sobol ë¯¼ê°ë„ ì§€ìˆ˜:**
```
Sâ‚áµ¢ = Var(E[Y|Xáµ¢]) / Var(Y)  â† 1ì°¨ íš¨ê³¼
STáµ¢ = 1 - Var(E[Y|Xâ‚‹áµ¢]) / Var(Y)  â† ì´ íš¨ê³¼
```

**Morris ë°©ë²•:**
- êµ­ì†Œ ë¯¼ê°ë„ì˜ í‰ê· ê³¼ í‘œì¤€í¸ì°¨
- ì ì€ ê³„ì‚°ëŸ‰ìœ¼ë¡œ ìŠ¤í¬ë¦¬ë‹ ê°€ëŠ¥

```python
import numpy as np
from SALib.sample import morris
from SALib.analyze import morris as morris_analyze

# ë¬¸ì œ ì •ì˜
problem = {
    'num_vars': 3,
    'names': ['x1', 'x2', 'x3'],
    'bounds': [[-3.14, 3.14]] * 3
}

# ìƒ˜í”Œ ìƒì„±
param_values = morris.sample(problem, N=1000)

# ëª¨ë¸ í‰ê°€
Y = np.array([model(x) for x in param_values])

# ë¯¼ê°ë„ ë¶„ì„
Si = morris_analyze.analyze(problem, param_values, Y)
print(Si)
```

### ì‹œê°„ ì˜ì¡´ ë¯¼ê°ë„

ë™ì  ì‹œìŠ¤í…œì—ì„œ ì‹œê°„ì— ë”°ë¥¸ ë¯¼ê°ë„ ë³€í™”

**ê¶¤ì  ë¯¼ê°ë„:**
```
âˆ‚y(t)/âˆ‚p = âˆ«â‚€áµ— Î¦(t,Ï„) âˆ‚f/âˆ‚p|_(Ï„) dÏ„
```

ì—¬ê¸°ì„œ Î¦(t,Ï„): ìƒíƒœ ì „ì´ í–‰ë ¬

### ë‹¤ë¶„ì•¼ ë¯¼ê°ë„í•´ì„

ì—¬ëŸ¬ ë¬¼ë¦¬ í˜„ìƒì´ ì—°ì„±ëœ ì‹œìŠ¤í…œ

**ì—´-êµ¬ì¡° ì—°ì„±:**
```
êµ¬ì¡°: K_s u = F_s + F_thermal
ì—´ì „ë„: K_h T = Q + Q_convection
ì—°ì„±: F_thermal = Î± âˆ« B^T D Î±_T T dV
```

**ë¯¼ê°ë„:**
```
âˆ‚u/âˆ‚x = K_s^(-1)[âˆ‚F_s/âˆ‚x + âˆ‚F_thermal/âˆ‚x - âˆ‚K_s/âˆ‚x u]
```

---

## ğŸ“ í•™ìŠµ ë¡œë“œë§µ

### ì´ˆê¸‰ (1-2ê°œì›”)

**1ì£¼ì°¨: ê¸°ë³¸ ê°œë…**
- í¸ë¯¸ë¶„ ë³µìŠµ
- ë¬¼ë¦¬ì  ì§ê´€ ì´í•´
- ê°„ë‹¨í•œ í•¨ìˆ˜ë¡œ ì†ê³„ì‚°

**ì‹¤ìŠµ 1:**
```matlab
% ê°„ë‹¨í•œ í•¨ìˆ˜ì˜ ë¯¼ê°ë„ ë¶„ì„
f = @(x) x(1)^2 + x(1)*x(2) + x(2)^2;
x0 = [2; 3];

% í•´ì„í•´
analytical = [2*x0(1) + x0(2); x0(1) + 2*x0(2)];

% ìˆ˜ì¹˜í•´
h = 1e-6;
numerical = [(f(x0 + [h;0]) - f(x0))/h;
             (f(x0 + [0;h]) - f(x0))/h];

% ë¹„êµ
error = abs(analytical - numerical);
```

**2ì£¼ì°¨: ìˆ˜ì¹˜ ë¯¸ë¶„**
- ì „ì§„/í›„ì§„/ì¤‘ì•™ì°¨ë¶„ êµ¬í˜„
- ìŠ¤í… í¬ê¸° ì˜í–¥ ë¶„ì„
- ë³µì†Œìˆ˜ ë‹¨ê³„ë²• í•™ìŠµ

**3-4ì£¼ì°¨: êµ¬ì¡°í•´ì„ ì ìš©**
- íŠ¸ëŸ¬ìŠ¤ êµ¬ì¡° ë¯¼ê°ë„
- ë³´ êµ¬ì¡° ë¯¼ê°ë„
- ìœ í•œìš”ì†Œ ê¸°ë³¸

### ì¤‘ê¸‰ (3-4ê°œì›”)

**5-8ì£¼ì°¨: ìˆ˜ë°˜ë³€ìˆ˜ë²•**
- ë¼ê·¸ë‘ì§€ ìŠ¹ìˆ˜ë²• ë³µìŠµ
- ì œì•½ì´ ìˆëŠ” ìµœì í™”
- ìˆ˜ë°˜ë°©ì •ì‹ ìœ ë„

**9-12ì£¼ì°¨: ë™ì  ë¯¼ê°ë„**
- ê³ ìœ ê°’ ë¯¼ê°ë„
- ì£¼íŒŒìˆ˜ ì‘ë‹µ ë¯¼ê°ë„
- ê³¼ë„ ì‘ë‹µ ë¯¼ê°ë„

**13-16ì£¼ì°¨: ì‹¤ë¬´ í”„ë¡œì íŠ¸**
- ì‹¤ì œ êµ¬ì¡°ë¬¼ í•´ì„
- ì†Œí”„íŠ¸ì›¨ì–´ í™œìš©
- ê²°ê³¼ í•´ì„ ë° ê²€ì¦

### ê³ ê¸‰ (6ê°œì›”+)

**ê³ ê¸‰ ì£¼ì œ:**
- í™•ë¥ ë¡ ì  ë¯¼ê°ë„
- ë‹¤ë¶„ì•¼ ë¯¼ê°ë„
- ìœ„ìƒ ë¯¼ê°ë„
- ì œì¡° ë¯¼ê°ë„

**ì—°êµ¬ í”„ë¡œì íŠ¸:**
- ìƒˆë¡œìš´ ë¯¼ê°ë„ ê³„ì‚°ë²• ê°œë°œ
- ëŒ€ê·œëª¨ ì‹œìŠ¤í…œ ì ìš©
- ë³‘ë ¬ ê³„ì‚° êµ¬í˜„

---

## ğŸ”§ ì‹¤ìš©ì  íŒ

### ìŠ¤í… í¬ê¸° ì„ íƒ

**ê²½í—˜ì  ê³µì‹:**
```
h_optimal â‰ˆ âˆš(Îµ_machine) Ã— |x|
```
ì—¬ê¸°ì„œ Îµ_machine: ê¸°ê³„ ì •ë°€ë„ (â‰ˆ 2.22 Ã— 10^-16)

**ì ì‘ì  ìŠ¤í… í¬ê¸°:**
```matlab
function h_opt = adaptive_step_size(func, x, i)
    h_base = sqrt(eps) * max(abs(x(i)), 1);
    
    % ì—¬ëŸ¬ ìŠ¤í… í¬ê¸°ë¡œ í…ŒìŠ¤íŠ¸
    h_values = h_base * [0.1, 1, 10];
    derivatives = zeros(size(h_values));
    
    for j = 1:length(h_values)
        h = h_values(j);
        x_pert = x; x_pert(i) = x_pert(i) + h;
        derivatives(j) = (func(x_pert) - func(x)) / h;
    end
    
    % ê°€ì¥ ì¼ê´€ëœ ê²°ê³¼ë¥¼ ì£¼ëŠ” ìŠ¤í… í¬ê¸° ì„ íƒ
    [~, idx] = min(std(derivatives));
    h_opt = h_values(idx);
end
```

### ê³„ì‚° íš¨ìœ¨ì„±

**ë³‘ë ¬ ê³„ì‚°:**
```matlab
% ì—¬ëŸ¬ ë³€ìˆ˜ì˜ ë¯¼ê°ë„ë¥¼ ë³‘ë ¬ë¡œ ê³„ì‚°
function sens = parallel_sensitivity(func, x, h)
    n = length(x);
    sens = zeros(n, 1);
    
    parfor i = 1:n
        x_pert = x;
        x_pert(i) = x_pert(i) + h;
        sens(i) = (func(x_pert) - func(x)) / h;
    end
end
```

**ê³„ì‚° ì¬ì‚¬ìš©:**
```matlab
% ê¸°ì¤€ê°’ í•œ ë²ˆë§Œ ê³„ì‚°
f0 = func(x);
for i = 1:n
    x_pert = x; x_pert(i) = x_pert(i) + h;
    sens(i) = (func(x_pert) - f0) / h;  % f0 ì¬ì‚¬ìš©
end
```

### ê²°ê³¼ ê²€ì¦

**ìˆ˜ë ´ì„± í™•ì¸:**
```matlab
h_values = 10.^(-2:-1:-12);
for h = h_values
    sens = finite_difference(func, x, h);
    % ìŠ¤í… í¬ê¸°ì— ë”°ë¥¸ ë¯¼ê°ë„ ë³€í™” ê´€ì°°
end
```

**ë‹¤ë¥¸ ë°©ë²•ê³¼ ë¹„êµ:**
```matlab
sens_fd = finite_difference(func, x, h);
sens_cs = complex_step(func, x, h);
sens_ad = auto_diff(func, x);

% ìƒëŒ€ ì˜¤ì°¨ ê³„ì‚°
error_cs = abs(sens_cs - sens_ad) ./ abs(sens_ad);
error_fd = abs(sens_fd - sens_ad) ./ abs(sens_ad);
```

---

**ì°¸ê³ ë¬¸í—Œ:**
- Haftka, R.T. & GÃ¼rdal, Z. (2012). *Elements of Structural Optimization*. Springer.
- Tortorelli, D.A. & Michaleris, P. (1994). Design sensitivity analysis: Overview and review. *Inverse Problems in Engineering*, 1(1), 71-105.
- Griewank, A. & Walther, A. (2008). *Evaluating Derivatives: Principles and Techniques of Algorithmic Differentiation*. SIAM.
- Martins, J.R.R.A. & Hwang, J.T. (2013). Review and unification of methods for computing derivatives of multidisciplinary computational models. *AIAA Journal*, 51(11), 2582-2599.