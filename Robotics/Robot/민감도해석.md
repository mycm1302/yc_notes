# 민감도해석

> 상위: [[최적화설계]]

설계변수의 변화가 목적함수와 제약조건에 미치는 영향을 정량적으로 분석하는 방법입니다. 쉽게 말해 "어떤 설계변수가 성능에 가장 큰 영향을 주는가?"를 수치적으로 계산하는 기법입니다.

## 🔍 기본 개념

### 왜 민감도해석이 필요한가?

**실제 설계 상황:**
- 설계변수가 수십~수백 개
- 어떤 변수가 중요한지 모름
- 제한된 시간과 자원
- 효율적인 설계 개선 필요

**민감도해석의 역할:**
1. **중요 변수 식별**: 성능에 큰 영향을 주는 변수 찾기
2. **설계 방향 결정**: 어떤 방향으로 변경해야 성능 향상되는지
3. **공차 설정**: 제조 오차에 민감한 변수 파악
4. **최적화 효율**: 중요한 변수부터 우선 최적화

### 수학적 정의

**1차 민감도 (First-order Sensitivity):**
```
S₁ᵢ = ∂f/∂xᵢ
```

**정규화된 민감도:**
```
S₁ᵢⁿᵒʳᵐ = (xᵢ/f) × (∂f/∂xᵢ) = ∂(ln f)/∂(ln xᵢ)
```

**2차 민감도 (Second-order Sensitivity):**
```
S₂ᵢⱼ = ∂²f/∂xᵢ∂xⱼ
```

### 물리적 의미

**민감도 크기 해석:**
- |S₁ᵢ| 클수록: xᵢ 변화가 f에 큰 영향
- S₁ᵢ > 0: xᵢ 증가 시 f 증가 (양의 상관관계)
- S₁ᵢ < 0: xᵢ 증가 시 f 감소 (음의 상관관계)

**예시: 캔틸레버 보의 처짐**
```
δ = (PL³)/(3EI) = (PL³)/(3E) × (12/bh³)

민감도:
∂δ/∂L = 3PL²/(3EI) = 3δ/L  ← 길이에 매우 민감
∂δ/∂h = -3PL³/(Ebh⁴) = -3δ/h ← 높이에 매우 민감 (3제곱)
∂δ/∂b = -PL³/(Eb²h³) = -δ/b  ← 폭에 상대적으로 덜 민감
```

---

## 🧮 계산 방법

### 1. 수치 미분법 (Numerical Differentiation)

#### 전진차분 (Forward Difference)
```
∂f/∂xᵢ ≈ [f(x + Δxᵢeᵢ) - f(x)]/Δxᵢ
```

**장점:**
- 구현 간단
- 함수값만 필요 (블랙박스 모델 적용 가능)

**단점:**
- 오차 발생 (O(Δx))
- 스텝 크기 선택 어려움

**구현 예시:**
```matlab
function sensitivity = forward_difference(func, x, delta)
    n = length(x);
    sensitivity = zeros(n, 1);
    f0 = func(x);
    
    for i = 1:n
        x_pert = x;
        x_pert(i) = x_pert(i) + delta;
        f_pert = func(x_pert);
        sensitivity(i) = (f_pert - f0) / delta;
    end
end

% 사용 예
x = [1, 2, 3];
delta = 1e-6;
sens = forward_difference(@my_function, x, delta);
```

#### 중앙차분 (Central Difference)
```
∂f/∂xᵢ ≈ [f(x + Δxᵢeᵢ) - f(x - Δxᵢeᵢ)]/(2Δxᵢ)
```

**장점:**
- 더 높은 정확도 (O(Δx²))
- 대칭적 오차

**단점:**
- 계산량 2배
- 경계 근처에서 문제

**정확도 비교:**
```matlab
% 테스트 함수: f(x) = x³
x = 2; true_derivative = 3*x^2; % = 12

% 전진차분
h_values = [1e-2, 1e-4, 1e-6, 1e-8];
for h = h_values
    forward_approx = (x+h)^3 - x^3) / h;
    error = abs(forward_approx - true_derivative);
    fprintf('h=%e, error=%e\n', h, error);
end

% 중앙차분
for h = h_values
    central_approx = ((x+h)^3 - (x-h)^3) / (2*h);
    error = abs(central_approx - true_derivative);
    fprintf('h=%e, error=%e\n', h, error);
end
```

#### 복소수 단계법 (Complex Step Method)
```
∂f/∂xᵢ ≈ Im[f(x + ihεᵢ)]/h
```

**장점:**
- 매우 높은 정확도
- 스텝 크기에 덜 민감
- 소거 오차 없음

**단점:**
- 복소수 연산 필요
- 일부 함수에 적용 불가

```matlab
function sensitivity = complex_step(func, x, h)
    n = length(x);
    sensitivity = zeros(n, 1);
    
    for i = 1:n
        x_complex = complex(x);
        x_complex(i) = x_complex(i) + 1i*h;
        f_complex = func(x_complex);
        sensitivity(i) = imag(f_complex) / h;
    end
end
```

### 2. 해석적 미분법 (Analytical Differentiation)

#### 직접 미분
함수의 해석적 형태를 알 때 직접 미분

**예시: 트러스 구조**
```
질량: m = ∑ ρᵢAᵢLᵢ
민감도: ∂m/∂Aᵢ = ρᵢLᵢ

응력: σᵢ = Fᵢ/Aᵢ
민감도: ∂σᵢ/∂Aᵢ = -Fᵢ/Aᵢ²
```

#### 연쇄법칙 (Chain Rule)
복합함수의 민감도 계산

```
f(x) = g(h(x))인 경우:
∂f/∂xᵢ = (∂g/∂h) × (∂h/∂xᵢ)
```

**유한요소 해석 예시:**
```
변위: u = K⁻¹F
응력: σ = DBu
컴플라이언스: c = F^T u = F^T K⁻¹F

민감도: ∂c/∂xᵢ = -F^T K⁻¹ (∂K/∂xᵢ) K⁻¹F
```

### 3. 자동 미분법 (Automatic Differentiation)

#### 전진 모드 (Forward Mode)
```
각 변수에 대해 이중수(dual number) 사용:
x = a + bε, where ε² = 0

f(x) = f(a) + f'(a)bε
```

**구현 예시 (Python):**
```python
import numpy as np

class DualNumber:
    def __init__(self, real, dual=0):
        self.real = real
        self.dual = dual
    
    def __add__(self, other):
        if isinstance(other, DualNumber):
            return DualNumber(self.real + other.real, 
                            self.dual + other.dual)
        return DualNumber(self.real + other, self.dual)
    
    def __mul__(self, other):
        if isinstance(other, DualNumber):
            return DualNumber(self.real * other.real,
                            self.real * other.dual + 
                            self.dual * other.real)
        return DualNumber(self.real * other, self.dual * other)

# 사용 예
def f(x, y):
    return x*x + x*y + y*y

# x에 대한 편미분
x_dual = DualNumber(2, 1)  # x=2, dx=1
y_dual = DualNumber(3, 0)  # y=3, dy=0
result = f(x_dual, y_dual)
print(f"f(2,3) = {result.real}")
print(f"∂f/∂x|_(2,3) = {result.dual}")
```

#### 후진 모드 (Reverse Mode)
- 계산 그래프의 역방향 순회
- 다수 출력, 적은 입력에 효율적
- 신경망 역전파와 동일 원리

### 4. 수반변수법 (Adjoint Variable Method)

제약이 있는 최적화 문제의 민감도 계산에 특히 유용

**문제 설정:**
```
최소화: f(x,u)
제약조건: g(x,u) = 0
```

**라그랑지안:**
```
L = f(x,u) + λᵀg(x,u)
```

**수반방정식:**
```
∂L/∂u = ∂f/∂u + λᵀ∂g/∂u = 0
```

**민감도:**
```
df/dx = ∂L/∂x = ∂f/∂x + λᵀ∂g/∂x
```

**장점:**
- 제약조건 수에 무관하게 효율적
- 대규모 시스템에 적합

**유한요소 구현:**
```matlab
function sensitivity = adjoint_method(K, F, dK_dx)
    % 정해석: Ku = F
    u = K \ F;
    
    % 수반해석: K^T λ = ∂c/∂u = F
    lambda = K' \ F;  % K가 대칭이면 K = K'
    
    % 민감도: dc/dx = -λ^T dK/dx u
    sensitivity = -lambda' * dK_dx * u;
end
```

---

## 📊 구조해석에서의 응용

### 정적 해석 민감도

#### 변위 민감도
**지배방정식:**
```
K u = F
```

**변위 민감도:**
```
∂u/∂xᵢ = K⁻¹(∂F/∂xᵢ - ∂K/∂xᵢ u)
```

**구현:**
```matlab
function du_dx = displacement_sensitivity(K, F, u, dK_dx, dF_dx)
    rhs = dF_dx - dK_dx * u;
    du_dx = K \ rhs;
end
```

#### 응력 민감도
**응력-변위 관계:**
```
σ = D B u
```

**응력 민감도:**
```
∂σ/∂xᵢ = D B ∂u/∂xᵢ
```

#### 컴플라이언스 민감도
**컴플라이언스:**
```
c = uᵀF = uᵀKu
```

**민감도:**
```
∂c/∂xᵢ = 2uᵀ∂K/∂xᵢ u - uᵀ∂F/∂xᵢ
```

### 동적 해석 민감도

#### 고유진동수 민감도
**고유값 문제:**
```
K φᵢ = λᵢ M φᵢ
```

**진동수 민감도:**
```
∂ωᵢ/∂x = (1/2ωᵢ) × φᵢᵀ(∂K/∂x - ωᵢ²∂M/∂x)φᵢ / (φᵢᵀMφᵢ)
```

**실습 예제:**
```matlab
% 캔틸레버 보의 고유진동수 민감도
function [omega, domega_dL] = cantilever_frequency_sensitivity(E, rho, L, b, h)
    % 1차 고유진동수
    I = b*h^3/12;
    A = b*h;
    omega = 1.875^2 * sqrt(E*I/(rho*A*L^4));
    
    % 길이에 대한 민감도
    domega_dL = -2 * omega / L;
end
```

### 좌굴해석 민감도

**좌굴 고유값 문제:**
```
(K + λcr Kg) φ = 0
```

**좌굴하중 민감도:**
```
∂λcr/∂x = -φᵀ(∂K/∂x + λcr ∂Kg/∂x)φ / (φᵀKgφ)
```

---

## 🔧 실무 응용 사례

### 사례 1: 항공기 날개 구조 최적화

**설계변수:**
- 스킨 두께 (20개)
- 스트링거 치수 (15개)  
- 리브 두께 (10개)
- 총 45개 변수

**목적함수:**
- 구조 중량 최소화

**제약조건:**
- 응력 제약 (1000개+)
- 좌굴 제약 (500개+)
- 변위 제약 (100개+)

**민감도해석 결과:**
```
중요도 순위:
1. 상부 스킨 두께 (민감도: -2.34)
2. 주 스파 웹 두께 (민감도: -1.87)
3. 주 스트링거 높이 (민감도: -1.23)
⋮
43. 보조 리브 두께 (민감도: -0.03)
```

**설계 전략:**
- 상위 10개 변수에 집중
- 하위 변수는 고정하여 차원 축소
- 단계적 최적화 수행

### 사례 2: 자동차 크래시 박스 설계

**설계변수:**
- 벽 두께 (8개 구간)
- 크러시 존 길이
- 폴딩 패턴

**목적함수:**
- 에너지 흡수량 최대화
- 최대 충격력 제한

**특징:**
- 비선형 동적 해석 필요
- 유한차분법으로 민감도 계산
- 계산 비용 높음 (1회 해석 = 30분)

**최적화 전략:**
```matlab
% 스크리닝 단계
n_vars = 10;
delta = 0.05;  % 5% 변화
for i = 1:n_vars
    % 기준 설계
    energy_base = crash_analysis(x_base);
    
    % 변수 i를 5% 증가
    x_pert = x_base;
    x_pert(i) = x_pert(i) * (1 + delta);
    energy_pert = crash_analysis(x_pert);
    
    % 정규화된 민감도
    sensitivity(i) = (energy_pert - energy_base) / energy_base / delta;
end

% 중요한 변수만 선택
important_vars = find(abs(sensitivity) > threshold);
```

### 사례 3: 로봇 링크 경량화

**설계변수:**
- 링크 단면 형상 (중공 원형, 사각형)
- 재료 두께 분포
- 보강재 위치

**목적함수:**
- 질량 최소화
- 강성 최대화 (다목적)

**민감도 기반 형상 최적화:**
```matlab
% 응력 기반 재료 재배치
function new_thickness = stress_based_redistribution(thickness, stress, target_stress)
    % von Mises 응력 기반 민감도
    sensitivity = 2 * stress / target_stress;
    
    % 재료 재배치 (체적 보존)
    total_volume = sum(thickness);
    new_thickness = thickness .* sensitivity.^0.5;
    new_thickness = new_thickness * total_volume / sum(new_thickness);
end
```

---

## 💻 소프트웨어 구현

### MATLAB 민감도해석 도구상자

```matlab
classdef SensitivityAnalyzer < handle
    properties
        method          % 'finite_diff', 'complex_step', 'analytical'
        step_size       % 차분 스텝 크기
        tolerance       % 수렴 판정 기준
    end
    
    methods
        function obj = SensitivityAnalyzer(method, step_size)
            obj.method = method;
            obj.step_size = step_size;
        end
        
        function sens = compute(obj, func, x)
            switch obj.method
                case 'finite_diff'
                    sens = obj.finite_difference(func, x);
                case 'complex_step'
                    sens = obj.complex_step(func, x);
                case 'analytical'
                    sens = obj.analytical(func, x);
            end
        end
        
        function sens = finite_difference(obj, func, x)
            n = length(x);
            sens = zeros(n, 1);
            f0 = func(x);
            
            for i = 1:n
                x_pert = x;
                x_pert(i) = x_pert(i) + obj.step_size;
                f_pert = func(x_pert);
                sens(i) = (f_pert - f0) / obj.step_size;
            end
        end
        
        function sens = complex_step(obj, func, x)
            n = length(x);
            sens = zeros(n, 1);
            
            for i = 1:n
                x_complex = complex(x);
                x_complex(i) = x_complex(i) + 1i * obj.step_size;
                f_complex = func(x_complex);
                sens(i) = imag(f_complex) / obj.step_size;
            end
        end
    end
end

% 사용 예제
analyzer = SensitivityAnalyzer('complex_step', 1e-12);
sensitivity = analyzer.compute(@my_objective, design_vars);

% 결과 시각화
figure;
bar(sensitivity);
xlabel('Design Variable Index');
ylabel('Sensitivity');
title('Sensitivity Analysis Results');
```

### Python 구현 (JAX 사용)

```python
import jax
import jax.numpy as jnp
from jax import grad, jacfwd, jacrev

# 자동 미분을 이용한 민감도 계산
def objective_function(x):
    """예제 목적함수"""
    return jnp.sum(x**2) + jnp.prod(x)

# 그래디언트 계산
gradient_func = grad(objective_function)

# 헤시안 계산
hessian_func = jacfwd(jacrev(objective_function))

# 사용 예제
x = jnp.array([1.0, 2.0, 3.0])

# 1차 민감도
first_order = gradient_func(x)
print(f"Gradient: {first_order}")

# 2차 민감도
second_order = hessian_func(x)
print(f"Hessian:\n{second_order}")

# 벡터화된 계산 (여러 점에서 동시 계산)
x_batch = jnp.array([[1.0, 2.0, 3.0],
                     [2.0, 3.0, 4.0],
                     [3.0, 4.0, 5.0]])

batch_gradient = jax.vmap(gradient_func)(x_batch)
print(f"Batch gradients:\n{batch_gradient}")
```

---

## 📈 고급 주제

### 확률론적 민감도해석

불확실성이 있는 매개변수에 대한 민감도

**Sobol 민감도 지수:**
```
S₁ᵢ = Var(E[Y|Xᵢ]) / Var(Y)  ← 1차 효과
STᵢ = 1 - Var(E[Y|X₋ᵢ]) / Var(Y)  ← 총 효과
```

**Morris 방법:**
- 국소 민감도의 평균과 표준편차
- 적은 계산량으로 스크리닝 가능

```python
import numpy as np
from SALib.sample import morris
from SALib.analyze import morris as morris_analyze

# 문제 정의
problem = {
    'num_vars': 3,
    'names': ['x1', 'x2', 'x3'],
    'bounds': [[-3.14, 3.14]] * 3
}

# 샘플 생성
param_values = morris.sample(problem, N=1000)

# 모델 평가
Y = np.array([model(x) for x in param_values])

# 민감도 분석
Si = morris_analyze.analyze(problem, param_values, Y)
print(Si)
```

### 시간 의존 민감도

동적 시스템에서 시간에 따른 민감도 변화

**궤적 민감도:**
```
∂y(t)/∂p = ∫₀ᵗ Φ(t,τ) ∂f/∂p|_(τ) dτ
```

여기서 Φ(t,τ): 상태 전이 행렬

### 다분야 민감도해석

여러 물리 현상이 연성된 시스템

**열-구조 연성:**
```
구조: K_s u = F_s + F_thermal
열전도: K_h T = Q + Q_convection
연성: F_thermal = α ∫ B^T D α_T T dV
```

**민감도:**
```
∂u/∂x = K_s^(-1)[∂F_s/∂x + ∂F_thermal/∂x - ∂K_s/∂x u]
```

---

## 🎓 학습 로드맵

### 초급 (1-2개월)

**1주차: 기본 개념**
- 편미분 복습
- 물리적 직관 이해
- 간단한 함수로 손계산

**실습 1:**
```matlab
% 간단한 함수의 민감도 분석
f = @(x) x(1)^2 + x(1)*x(2) + x(2)^2;
x0 = [2; 3];

% 해석해
analytical = [2*x0(1) + x0(2); x0(1) + 2*x0(2)];

% 수치해
h = 1e-6;
numerical = [(f(x0 + [h;0]) - f(x0))/h;
             (f(x0 + [0;h]) - f(x0))/h];

% 비교
error = abs(analytical - numerical);
```

**2주차: 수치 미분**
- 전진/후진/중앙차분 구현
- 스텝 크기 영향 분석
- 복소수 단계법 학습

**3-4주차: 구조해석 적용**
- 트러스 구조 민감도
- 보 구조 민감도
- 유한요소 기본

### 중급 (3-4개월)

**5-8주차: 수반변수법**
- 라그랑지 승수법 복습
- 제약이 있는 최적화
- 수반방정식 유도

**9-12주차: 동적 민감도**
- 고유값 민감도
- 주파수 응답 민감도
- 과도 응답 민감도

**13-16주차: 실무 프로젝트**
- 실제 구조물 해석
- 소프트웨어 활용
- 결과 해석 및 검증

### 고급 (6개월+)

**고급 주제:**
- 확률론적 민감도
- 다분야 민감도
- 위상 민감도
- 제조 민감도

**연구 프로젝트:**
- 새로운 민감도 계산법 개발
- 대규모 시스템 적용
- 병렬 계산 구현

---

## 🔧 실용적 팁

### 스텝 크기 선택

**경험적 공식:**
```
h_optimal ≈ √(ε_machine) × |x|
```
여기서 ε_machine: 기계 정밀도 (≈ 2.22 × 10^-16)

**적응적 스텝 크기:**
```matlab
function h_opt = adaptive_step_size(func, x, i)
    h_base = sqrt(eps) * max(abs(x(i)), 1);
    
    % 여러 스텝 크기로 테스트
    h_values = h_base * [0.1, 1, 10];
    derivatives = zeros(size(h_values));
    
    for j = 1:length(h_values)
        h = h_values(j);
        x_pert = x; x_pert(i) = x_pert(i) + h;
        derivatives(j) = (func(x_pert) - func(x)) / h;
    end
    
    % 가장 일관된 결과를 주는 스텝 크기 선택
    [~, idx] = min(std(derivatives));
    h_opt = h_values(idx);
end
```

### 계산 효율성

**병렬 계산:**
```matlab
% 여러 변수의 민감도를 병렬로 계산
function sens = parallel_sensitivity(func, x, h)
    n = length(x);
    sens = zeros(n, 1);
    
    parfor i = 1:n
        x_pert = x;
        x_pert(i) = x_pert(i) + h;
        sens(i) = (func(x_pert) - func(x)) / h;
    end
end
```

**계산 재사용:**
```matlab
% 기준값 한 번만 계산
f0 = func(x);
for i = 1:n
    x_pert = x; x_pert(i) = x_pert(i) + h;
    sens(i) = (func(x_pert) - f0) / h;  % f0 재사용
end
```

### 결과 검증

**수렴성 확인:**
```matlab
h_values = 10.^(-2:-1:-12);
for h = h_values
    sens = finite_difference(func, x, h);
    % 스텝 크기에 따른 민감도 변화 관찰
end
```

**다른 방법과 비교:**
```matlab
sens_fd = finite_difference(func, x, h);
sens_cs = complex_step(func, x, h);
sens_ad = auto_diff(func, x);

% 상대 오차 계산
error_cs = abs(sens_cs - sens_ad) ./ abs(sens_ad);
error_fd = abs(sens_fd - sens_ad) ./ abs(sens_ad);
```

---

**참고문헌:**
- Haftka, R.T. & Gürdal, Z. (2012). *Elements of Structural Optimization*. Springer.
- Tortorelli, D.A. & Michaleris, P. (1994). Design sensitivity analysis: Overview and review. *Inverse Problems in Engineering*, 1(1), 71-105.
- Griewank, A. & Walther, A. (2008). *Evaluating Derivatives: Principles and Techniques of Algorithmic Differentiation*. SIAM.
- Martins, J.R.R.A. & Hwang, J.T. (2013). Review and unification of methods for computing derivatives of multidisciplinary computational models. *AIAA Journal*, 51(11), 2582-2599.