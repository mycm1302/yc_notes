# 행렬이론

> 상위: [[선형대수]]  
> 관련: [[벡터계산]], [[선형대수및기하학]]

로봇공학의 핵심 수학적 도구인 행렬의 이론적 기초와 실용적 활용법입니다. 선형변환, 좌표변환, 시스템 해석에 필수적인 개념들을 다룹니다.

## 🎯 행렬의 기본 정의

### 행렬의 구조
```
m×n 행렬 A: m개 행, n개 열을 가진 수들의 직사각형 배열

A = [a₁₁ a₁₂ ... a₁ₙ]
    [a₂₁ a₂₂ ... a₂ₙ]  ∈ ℝᵐˣⁿ
    [ ⋮   ⋮   ⋱   ⋮ ]
    [aₘ₁ aₘ₂ ... aₘₙ]

원소 표기: A = (aᵢⱼ) 또는 A = [aᵢⱼ]
```

### 특수한 행렬들
```
정방행렬: m = n (Square matrix)
단위행렬: I = diag(1,1,...,1)
영행렬: O = [0]
대각행렬: aᵢⱼ = 0 (i ≠ j)
상삼각행렬: aᵢⱼ = 0 (i > j)
하삼각행렬: aᵢⱼ = 0 (i < j)
```

### 로봇공학에서의 행렬
```
변환행렬: 좌표계 간 변환 (3×3, 4×4)
자코비안: 속도 관계 (6×n)
관성행렬: 질량 분포 (n×n)
강성행렬: 탄성 특성 (n×n)
제어이득: 제어기 매개변수 (n×m)
```

## 🔧 기본 행렬 연산

### 1. 행렬 덧셈과 뺄셈
```
조건: 같은 크기의 행렬만 가능
A ± B = [aᵢⱼ ± bᵢⱼ]

성질:
- 교환법칙: A + B = B + A
- 결합법칙: (A + B) + C = A + (B + C)
- 영행렬: A + O = A

로봇 응용:
강성 행렬 합성: K_total = K₁ + K₂
오차 누적: error_total = Σ error_i
```

### 2. 스칼라 곱셈
```
kA = [k·aᵢⱼ]

성질:
- (k₁ + k₂)A = k₁A + k₂A
- k(A + B) = kA + kB
- k₁(k₂A) = (k₁k₂)A

응용:
이득 조정: A_scaled = gain × A
정규화: A_normalized = A / max_value
```

### 3. 행렬 곱셈
```
조건: A(m×p), B(p×n) → AB(m×n)
(AB)ᵢⱼ = Σₖ aᵢₖbₖⱼ

성질:
- 결합법칙: (AB)C = A(BC)
- 분배법칙: A(B + C) = AB + AC
- 비교환성: AB ≠ BA (일반적으로)

기하학적 의미: 연속된 선형변환의 합성
```

#### 로봇공학에서의 행렬 곱셈
```
변환 합성: T₁₃ = T₁₂ T₂₃
속도 변환: v₂ = J₁₂ v₁
시스템 결합: G_total = G₂ G₁
```

### 4. 전치행렬 (Transpose)
```
Aᵀ = [aⱼᵢ] (행과 열 교환)

성질:
- (Aᵀ)ᵀ = A
- (A + B)ᵀ = Aᵀ + Bᵀ  
- (AB)ᵀ = BᵀAᵀ
- (kA)ᵀ = kAᵀ

기하학적 의미: 좌표축 반사 또는 변환 방향 반전
```

## 📊 특수 행렬들

### 1. 대칭행렬 (Symmetric Matrix)
```
정의: A = Aᵀ ⟺ aᵢⱼ = aⱼᵢ

성질:
- 모든 고유값이 실수
- 서로 다른 고유값의 고유벡터는 직교
- 직교 대각화 가능

로봇 응용:
관성행렬: M(q) = Mᵀ(q)
강성행렬: K = Kᵀ
```

### 2. 반대칭행렬 (Skew-Symmetric Matrix)
```
정의: A = -Aᵀ ⟺ aᵢⱼ = -aⱼᵢ

성질:
- 대각성분은 모두 0
- 고유값은 순허수 또는 0
- det(A) = 0 (홀수 차원에서)

로봇 응용:
각속도 행렬: ω̂ = -ω̂ᵀ
리군의 생성원: so(3), se(3)
```

### 3. 직교행렬 (Orthogonal Matrix)
```
정의: QᵀQ = QQᵀ = I ⟺ Q⁻¹ = Qᵀ

성질:
- |det(Q)| = 1
- 열벡터들이 정규직교기저
- 거리와 각도 보존 (등거리 변환)

로봇 응용:
회전행렬: R ∈ SO(3)
좌표계 변환: 순수 회전
```

### 4. 양정치행렬 (Positive Definite Matrix)
```
정의: xᵀAx > 0 (모든 x ≠ 0에 대해)

판정법:
- 모든 고유값 > 0
- 모든 주도부행렬식 > 0
- A = BᵀB (어떤 가역행렬 B에 대해)

로봇 응용:
관성행렬: M(q) > 0
리아푸노프 함수: V(x) = xᵀPx
제어 안정성 분석
```

## 🎯 행렬식 (Determinant)

### 정의와 계산
```
2×2: det(A) = a₁₁a₂₂ - a₁₂a₂₁

3×3: 여인수 전개
det(A) = a₁₁(a₂₂a₃₃ - a₂₃a₃₂) - a₁₂(a₂₁a₃₃ - a₂₃a₃₁) + a₁₃(a₂₁a₃₂ - a₂₂a₃₁)

일반: det(A) = Σ (-1)ⁱ⁺ʲ aᵢⱼ det(Aᵢⱼ)
```

### 기하학적 의미
```
2×2: 평행사변형의 넓이
3×3: 평행육면체의 부피
부호: 방향성 (양수면 오른손 좌표계)
```

### 성질
```
det(AB) = det(A)det(B)
det(Aᵀ) = det(A)
det(kA) = kⁿdet(A) (n×n 행렬)
det(A⁻¹) = 1/det(A)

특별한 경우:
det(I) = 1
det(직교행렬) = ±1
det(0) = 0
```

### 로봇공학 응용
```
가역성 판단: det(A) ≠ 0 ⟺ A 가역
특이점 분석: det(J) = 0에서 특이점
부피 변화율: 변환에 의한 공간 변화
방향성 보존: det > 0이면 방향 유지
```

## 🔄 역행렬 (Inverse Matrix)

### 정의
```
A⁻¹: AA⁻¹ = A⁻¹A = I를 만족하는 행렬
존재 조건: det(A) ≠ 0 (비특이행렬)
```

### 계산 방법

**1. 2×2 행렬**
```
A⁻¹ = 1/det(A) [ a₂₂  -a₁₂]
                [-a₂₁   a₁₁]
```

**2. 여인수 행렬 방법**
```
A⁻¹ = 1/det(A) adj(A)
adj(A) = (여인수 행렬)ᵀ
```

**3. 가우스-요르단 소거법**
```
[A | I] → [I | A⁻¹] (행 연산 적용)
```

**4. LU 분해**
```
A = LU → A⁻¹ = U⁻¹L⁻¹
삼각행렬의 역행렬은 쉽게 계산
```

### 성질
```
(A⁻¹)⁻¹ = A
(AB)⁻¹ = B⁻¹A⁻¹
(Aᵀ)⁻¹ = (A⁻¹)ᵀ
det(A⁻¹) = 1/det(A)
```

### 로봇공학 응용
```
역기구학: q = f⁻¹(x)
좌표 변환: x₁ = T₁₂⁻¹ x₂
시스템 역해석: u = G⁻¹y
```

## 🎯 고유값과 고유벡터

### 정의
```
Av = λv (v ≠ 0)
λ: 고유값 (eigenvalue)
v: 고유벡터 (eigenvector)

특성방정식: det(A - λI) = 0
특성다항식: p(λ) = det(A - λI)
```

### 계산 과정
```
1. 특성방정식 해결: λ₁, λ₂, ..., λₙ
2. 각 λᵢ에 대해 (A - λᵢI)v = 0 해결
3. 고유벡터 vᵢ 구하기
4. 정규화: v̂ᵢ = vᵢ/||vᵢ||
```

### 기하학적 의미
```
고유벡터: 변환 후에도 방향이 불변인 방향
고유값: 해당 방향으로의 확대/축소 비율
- λ > 1: 확대
- 0 < λ < 1: 축소
- λ < 0: 반전 + 크기 변화
```

### 대각화
```
A = PDP⁻¹
P: 고유벡터 행렬
D: 고유값 대각행렬

조건: n개의 선형독립 고유벡터 존재
```

## 🔧 행렬 분해

### 1. LU 분해
```
A = LU
L: 하삼각행렬 (Lower triangular)
U: 상삼각행렬 (Upper triangular)

용도:
- 연립방정식 해결
- 행렬식 계산: det(A) = det(L)det(U)
- 역행렬 계산
```

### 2. QR 분해
```
A = QR  
Q: 직교행렬
R: 상삼각행렬

그람-슈미트 과정:
정규직교기저 생성
```

### 3. 특이값 분해 (SVD)
```
A = UΣVᵀ
U, V: 직교행렬
Σ: 대각행렬 (특이값)

모든 행렬에 적용 가능
의사역행렬 계산의 기초
```

### 4. 촐레스키 분해
```
A = LLᵀ (A가 양정치일 때)
L: 하삼각행렬

장점: 대칭성 활용, 계산 효율
용도: 최적화, 확률론적 계산
```

## 🤖 로봇공학에서의 행렬 응용

### 1. 변환 행렬
```
동차좌표: [x', y', z', 1]ᵀ = T [x, y, z, 1]ᵀ

T = [R p] ∈ SE(3)
    [0 1]

R: 회전행렬 (3×3)
p: 평행이동 (3×1)
```

### 2. 자코비안 행렬
```
속도 관계: v = J(q)q̇
v ∈ ℝ⁶: 말단장치 속도
q̇ ∈ ℝⁿ: 관절속도
J ∈ ℝ⁶ˣⁿ: 자코비안

특이점: rank(J) < min(6,n)
가조작성: 조건수 κ(J) = σₘₐₓ/σₘᵢₙ
```

### 3. 동역학 행렬
```
운동방정식: M(q)q̈ + C(q,q̇)q̇ + G(q) = τ

M(q): 관성행렬 (대칭, 양정치)
C(q,q̇): 코리올리/원심력 행렬
G(q): 중력벡터
τ: 관절토크
```

### 4. 제어 시스템 행렬
```
상태공간 모델: ẋ = Ax + Bu
                y = Cx + Du

A: 시스템 행렬
B: 입력 행렬
C: 출력 행렬
D: 전달 행렬

안정성: A의 고유값이 모두 좌반평면에 위치
```

## 🔬 수치적 고려사항

### 1. 조건수 (Condition Number)
```
κ(A) = ||A|| ||A⁻¹|| = σₘₐₓ/σₘᵢₙ

해석:
- κ ≈ 1: 잘 조건화됨
- κ >> 1: 나쁘게 조건화됨 (ill-conditioned)
- κ = ∞: 특이행렬

영향: 수치적 오차 증폭
```

### 2. 수치적 안정성
```
피봇팅: 큰 원소를 대각선으로
스케일링: 행렬 원소 크기 정규화
정규화: 반복 과정에서 정규직교성 유지

예시:
if abs(A[i,i]) < epsilon:
    swap_rows(A, i, find_max_pivot(A, i))
```

### 3. 메모리 효율성
```
희소행렬: 0이 많은 행렬의 특수 저장
대칭행렬: 상삼각 부분만 저장
블록 행렬: 큰 행렬을 작은 블록으로 분할
```

## 🔧 구현 예제

### MATLAB
```matlab
% 기본 행렬 연산
A = [1 2; 3 4];
B = [5 6; 7 8];

% 기본 연산
C = A + B;          % 덧셈
D = A * B;          % 곱셈
E = A';             % 전치
F = inv(A);         % 역행렬
det_A = det(A);     % 행렬식

% 고유값 분해
[V, D] = eig(A);    % V: 고유벡터, D: 고유값
eigenvals = diag(D);

% 특이값 분해
[U, S, V] = svd(A); % U, V: 직교행렬, S: 특이값

% 조건수
cond_A = cond(A);   % 조건수
rank_A = rank(A);   % 계수

% 로봇공학 예제: 동차변환행렬
theta = pi/4;
R = [cos(theta) -sin(theta) 0;
     sin(theta)  cos(theta) 0;
     0           0          1];
p = [1; 2; 3];
T = [R p; 0 0 0 1];
T_inv = inv(T);     % 역변환
```

### Python (NumPy)
```python
import numpy as np
from scipy.linalg import inv, det, eig, svd

class MatrixOps:
    @staticmethod
    def is_symmetric(A, tol=1e-12):
        """대칭행렬 판정"""
        return np.allclose(A, A.T, atol=tol)
    
    @staticmethod
    def is_orthogonal(Q, tol=1e-12):
        """직교행렬 판정"""
        return np.allclose(Q @ Q.T, np.eye(Q.shape[0]), atol=tol)
    
    @staticmethod
    def is_positive_definite(A):
        """양정치행렬 판정"""
        try:
            np.linalg.cholesky(A)
            return True
        except np.linalg.LinAlgError:
            return False
    
    @staticmethod
    def condition_number(A):
        """조건수 계산"""
        return np.linalg.cond(A)
    
    @staticmethod
    def safe_inverse(A, threshold=1e-12):
        """안전한 역행렬 계산"""
        if abs(det(A)) < threshold:
            print("Warning: Matrix is nearly singular")
            return np.linalg.pinv(A)  # 의사역행렬 사용
        else:
            return inv(A)
    
    @staticmethod
    def homogeneous_transform(R, p):
        """동차변환행렬 생성"""
        T = np.eye(4)
        T[:3, :3] = R
        T[:3, 3] = p
        return T
    
    @staticmethod
    def inverse_transform(T):
        """동차변환의 역변환"""
        R = T[:3, :3]
        p = T[:3, 3]
        T_inv = np.eye(4)
        T_inv[:3, :3] = R.T
        T_inv[:3, 3] = -R.T @ p
        return T_inv

# 사용 예제
if __name__ == "__main__":
    # 행렬 생성
    A = np.array([[4, 2], [2, 3]])
    
    # 기본 검사
    print(f"대칭행렬: {MatrixOps.is_symmetric(A)}")
    print(f"양정치: {MatrixOps.is_positive_definite(A)}")
    print(f"조건수: {MatrixOps.condition_number(A):.2f}")
    
    # 고유값 분해
    eigenvals, eigenvecs = eig(A)
    print(f"고유값: {eigenvals}")
    
    # 로봇공학 예제
    theta = np.pi/4
    R = np.array([[np.cos(theta), -np.sin(theta), 0],
                  [np.sin(theta),  np.cos(theta), 0],
                  [0,              0,             1]])
    p = np.array([1, 2, 3])
    T = MatrixOps.homogeneous_transform(R, p)
    T_inv = MatrixOps.inverse_transform(T)
    
    print("동차변환행렬:")
    print(T)
    print("역변환:")
    print(T_inv)
```

## 🎯 실제 문제 해결

### 1. 로봇 보정 (Calibration)
```
문제: Hand-Eye 보정
AX = XB

A, B: 측정된 변환행렬들
X: 구하고자 하는 변환

해법:
1. 최소제곱법으로 선형화
2. 특이값 분해 활용
3. 직교성 제약 만족
```

### 2. 특이점 회피
```
자코비안 J의 특이점에서:
det(J) ≈ 0 → 조건수 κ(J) → ∞

해법:
1. 감쇠 최소제곱법: J†_DLS
2. 특이값 필터링
3. 다중해 활용
```

### 3. 최적 제어
```
LQR 문제: min ∫(xᵀQx + uᵀRu)dt
subject to: ẋ = Ax + Bu

해법:
1. 리카티 방정식: AᵀP + PA - PBR⁻¹BᵀP + Q = 0
2. 최적 이득: K = R⁻¹BᵀP
3. 폐루프 시스템: ẋ = (A - BK)x
```

## 🎯 학습 가이드

1. **기본 연산** (2-3주)
   - 행렬 덧셈, 곱셈, 전치
   - 행렬식과 역행렬

2. **특수 행렬** (2-3주)
   - 대칭, 직교, 양정치 행렬
   - 각각의 성질과 응용

3. **분해 기법** (3-4주)
   - LU, QR, SVD 분해
   - 고유값 분해와 대각화

4. **로봇 응용** (3-4주)
   - 변환행렬과 자코비안
   - 동역학과 제어 시스템

5. **수치 구현** (2-3주)
   - 안정성과 조건수
   - 효율적인 알고리즘

---
*참고: Matrix Analysis (Horn & Johnson), Linear Algebra (Strang), Introduction to Applied Linear Algebra (Boyd & Vandenberghe), Modern Robotics (Lynch & Park)*