# 자코비안 (Jacobian)

> 상위: [[휴머노이드 연구기술]]

## 정의

자코비안(Jacobian) 행렬은 다변수 벡터 함수의 1차 편미분으로 구성된 행렬로, 로봇공학에서는 관절 공간(Joint Space)과 작업 공간(Task Space) 사이의 미분 관계를 나타내는 핵심 도구입니다.

## 수학적 정의

### 일반적 정의
n차원 입력 벡터 **q**를 m차원 출력 벡터 **x**로 변환하는 함수 f에 대해:

```
x = f(q) = [f₁(q₁, q₂, ..., qₙ)]
           [f₂(q₁, q₂, ..., qₙ)]
           [        ⋮          ]
           [fₘ(q₁, q₂, ..., qₙ)]
```

자코비안 행렬 J는:

```
J = ∂f/∂q = [∂f₁/∂q₁  ∂f₁/∂q₂  ...  ∂f₁/∂qₙ]
            [∂f₂/∂q₁  ∂f₂/∂q₂  ...  ∂f₂/∂qₙ]
            [   ⋮        ⋮      ⋱     ⋮   ]
            [∂fₘ/∂q₁  ∂fₘ/∂q₂  ...  ∂fₘ/∂qₙ]
```

### 로봇공학에서의 의미

#### 속도 관계
```
ẋ = J(q) × q̇

여기서:
- ẋ: 엔드 이펙터 속도 (선속도 + 각속도)
- q̇: 관절 각속도 벡터
- J(q): 구성에 따라 변하는 자코비안 행렬
```

#### 미소 변위 관계
```
δx = J(q) × δq

여기서:
- δx: 엔드 이펙터 미소 변위
- δq: 관절 미소 변위
```

## 기하학적 자코비안

### 구성 요소

#### 선속도 자코비안 (Jᵥ)
각 관절이 엔드 이펙터의 선속도에 기여하는 정도:

```python
def compute_linear_velocity_jacobian(q, link_positions):
    """
    선속도 자코비안 계산
    """
    n_joints = len(q)
    Jv = np.zeros((3, n_joints))
    
    end_effector_pos = link_positions[-1]
    
    for i in range(n_joints):
        if joint_type[i] == 'revolute':
            # 회전 관절: zi-1 × (pe - pi-1)
            z_axis = get_z_axis(i-1, q)
            r_vector = end_effector_pos - link_positions[i-1]
            Jv[:, i] = np.cross(z_axis, r_vector)
        elif joint_type[i] == 'prismatic':
            # 직선 관절: zi-1
            Jv[:, i] = get_z_axis(i-1, q)
    
    return Jv
```

#### 각속도 자코비안 (Jω)
각 관절이 엔드 이펙터의 각속도에 기여하는 정도:

```python
def compute_angular_velocity_jacobian(q):
    """
    각속도 자코비안 계산
    """
    n_joints = len(q)
    Jw = np.zeros((3, n_joints))
    
    for i in range(n_joints):
        if joint_type[i] == 'revolute':
            # 회전 관절: zi-1
            Jw[:, i] = get_z_axis(i-1, q)
        elif joint_type[i] == 'prismatic':
            # 직선 관절: 0
            Jw[:, i] = np.zeros(3)
    
    return Jw
```

#### 전체 자코비안
```python
def compute_geometric_jacobian(q):
    """
    기하학적 자코비안 계산
    """
    Jv = compute_linear_velocity_jacobian(q)
    Jw = compute_angular_velocity_jacobian(q)
    
    # 6×n 자코비안 (선속도 + 각속도)
    J = np.vstack([Jv, Jw])
    
    return J
```

## 해석적 자코비안

### DH Parameter 기반 계산

```python
def compute_analytical_jacobian(q, dh_params):
    """
    DH Parameter를 이용한 해석적 자코비안 계산
    """
    n = len(q)
    J = np.zeros((6, n))
    
    # 현재 구성에서의 변환 행렬들
    T = [np.eye(4)]
    for i in range(n):
        Ti = dh_transform(dh_params[i], q[i])
        T.append(T[-1] @ Ti)
    
    # 엔드 이펙터 위치
    pe = T[-1][:3, 3]
    
    for i in range(n):
        if dh_params[i]['type'] == 'revolute':
            # 회전축 (z축)
            zi = T[i][:3, 2]
            
            # 관절에서 엔드 이펙터로의 벡터
            pi = T[i][:3, 3]
            r = pe - pi
            
            # 선속도 성분
            J[:3, i] = np.cross(zi, r)
            # 각속도 성분
            J[3:, i] = zi
            
        elif dh_params[i]['type'] == 'prismatic':
            # 이동축 (z축)
            zi = T[i][:3, 2]
            
            # 선속도 성분
            J[:3, i] = zi
            # 각속도 성분 (0)
            J[3:, i] = 0
    
    return J
```

### 수치적 자코비안

```python
def compute_numerical_jacobian(q, forward_kinematics_func, epsilon=1e-6):
    """
    수치 미분을 이용한 자코비안 계산
    """
    n = len(q)
    x0 = forward_kinematics_func(q)
    m = len(x0)
    
    J = np.zeros((m, n))
    
    for i in range(n):
        # q[i]에 대한 편미분
        q_plus = q.copy()
        q_plus[i] += epsilon
        
        q_minus = q.copy()
        q_minus[i] -= epsilon
        
        x_plus = forward_kinematics_func(q_plus)
        x_minus = forward_kinematics_func(q_minus)
        
        # 중앙 차분
        J[:, i] = (x_plus - x_minus) / (2 * epsilon)
    
    return J
```

## 자코비안의 응용

### 1. 역기구학

#### 반복적 해법
```python
def jacobian_inverse_kinematics(target_pose, initial_q, max_iter=100, tolerance=1e-6):
    """
    자코비안을 이용한 반복적 역기구학
    """
    q = initial_q.copy()
    
    for iteration in range(max_iter):
        # 현재 엔드 이펙터 위치
        current_pose = forward_kinematics(q)
        error = target_pose - current_pose
        
        # 수렴 확인
        if np.linalg.norm(error) < tolerance:
            return q, True
        
        # 자코비안 계산
        J = compute_jacobian(q)
        
        # 관절 각도 업데이트
        try:
            delta_q = np.linalg.solve(J, error)
        except np.linalg.LinAlgError:
            # 특이점에서 의사역행렬 사용
            delta_q = np.linalg.pinv(J) @ error
        
        # 스텝 크기 조절
        alpha = 0.5
        q += alpha * delta_q
    
    return q, False
```

#### 감쇠 최소제곱법
```python
def damped_least_squares_ik(target_pose, current_q, lambda_damping=0.01):
    """
    감쇠 최소제곱법을 이용한 안정적 역기구학
    """
    current_pose = forward_kinematics(current_q)
    error = target_pose - current_pose
    
    J = compute_jacobian(current_q)
    
    # 감쇠된 의사역행렬
    A = J @ J.T + lambda_damping**2 * np.eye(J.shape[0])
    J_damped = J.T @ np.linalg.inv(A)
    
    delta_q = J_damped @ error
    
    return current_q + delta_q
```

### 2. 속도 제어

#### 직교 속도 제어
```python
def cartesian_velocity_control(desired_velocity, current_q):
    """
    직교 좌표계에서의 속도 제어
    """
    J = compute_jacobian(current_q)
    
    # 의사역행렬로 관절 속도 계산
    joint_velocity = np.linalg.pinv(J) @ desired_velocity
    
    return joint_velocity

def execute_velocity_control(robot, desired_velocity, current_q, dt):
    """
    속도 제어 실행
    """
    joint_velocity = cartesian_velocity_control(desired_velocity, current_q)
    
    # 관절 속도 제한 적용
    max_joint_velocity = robot.joint_velocity_limits
    joint_velocity = np.clip(joint_velocity, -max_joint_velocity, max_joint_velocity)
    
    # 관절 위치 업데이트
    new_q = current_q + joint_velocity * dt
    
    return new_q, joint_velocity
```

### 3. 힘 제어

#### 정적 힘 변환
```python
def force_transformation(joint_torques, current_q):
    """
    관절 토크를 엔드 이펙터 힘으로 변환
    """
    J = compute_jacobian(current_q)
    
    # 이중성 원리: F = J^(-T) * τ
    try:
        end_effector_force = np.linalg.solve(J.T, joint_torques)
    except np.linalg.LinAlgError:
        end_effector_force = np.linalg.pinv(J.T) @ joint_torques
    
    return end_effector_force

def cartesian_force_control(desired_force, current_q):
    """
    직교좌표계 힘을 관절 토크로 변환
    """
    J = compute_jacobian(current_q)
    
    # τ = J^T * F
    joint_torques = J.T @ desired_force
    
    return joint_torques
```

### 4. 다중 태스크 제어

#### 우선순위 기반 제어
```python
def prioritized_multitask_control(tasks, current_q):
    """
    우선순위 기반 다중 태스크 제어
    """
    q_dot = np.zeros(len(current_q))
    N = np.eye(len(current_q))  # 널 공간 투영자
    
    for task in sorted(tasks, key=lambda x: x.priority):
        # 태스크 자코비안
        J_task = compute_task_jacobian(current_q, task)
        
        # 널 공간으로 투영된 자코비안
        J_proj = J_task @ N
        
        # 태스크 오차
        error = compute_task_error(current_q, task)
        
        # 태스크 해결
        if np.linalg.matrix_rank(J_proj) > 0:
            J_proj_pinv = np.linalg.pinv(J_proj)
            q_dot_task = J_proj_pinv @ error
            
            # 전체 해에 추가
            q_dot += N @ q_dot_task
            
            # 널 공간 업데이트
            N = N - J_proj_pinv @ J_proj
    
    return q_dot
```

#### 가중 다중 태스크
```python
def weighted_multitask_control(tasks, current_q):
    """
    가중치 기반 다중 태스크 제어
    """
    # 복합 자코비안과 오차 구성
    J_combined = []
    error_combined = []
    weights = []
    
    for task in tasks:
        J_task = compute_task_jacobian(current_q, task)
        error_task = compute_task_error(current_q, task)
        
        J_combined.append(np.sqrt(task.weight) * J_task)
        error_combined.append(np.sqrt(task.weight) * error_task)
    
    J_combined = np.vstack(J_combined)
    error_combined = np.concatenate(error_combined)
    
    # 가중 최소제곱 해
    q_dot = np.linalg.pinv(J_combined) @ error_combined
    
    return q_dot
```

## 특이점 분석

### 1. 특이점 정의

#### 수학적 조건
```python
def analyze_singularity(q):
    """
    특이점 분석
    """
    J = compute_jacobian(q)
    
    # 정사각 자코비안인 경우
    if J.shape[0] == J.shape[1]:
        det_J = np.linalg.det(J)
        condition_number = np.linalg.cond(J)
        
        return {
            'determinant': det_J,
            'condition_number': condition_number,
            'is_singular': abs(det_J) < 1e-6,
            'is_ill_conditioned': condition_number > 1e6
        }
    
    # 직사각 자코비안인 경우
    else:
        singular_values = np.linalg.svd(J, compute_uv=False)
        min_sv = np.min(singular_values)
        condition_number = np.max(singular_values) / min_sv
        
        return {
            'singular_values': singular_values,
            'min_singular_value': min_sv,
            'condition_number': condition_number,
            'is_singular': min_sv < 1e-6,
            'rank': np.sum(singular_values > 1e-6)
        }
```

### 2. 특이점 유형

#### 운동학적 특이점
```python
def classify_kinematic_singularity(q, robot_model):
    """
    운동학적 특이점 분류
    """
    J = compute_jacobian(q)
    
    # 특이값 분해
    U, s, Vt = np.linalg.svd(J)
    
    # 영 공간과 치역 분석
    null_space_dim = len(s) - np.sum(s > 1e-6)
    
    if null_space_dim > 0:
        # 특이점 유형 판별
        if is_boundary_singularity(q, robot_model):
            return "Boundary Singularity"
        elif is_internal_singularity(q, robot_model):
            return "Internal Singularity"
        else:
            return "Unknown Singularity"
    
    return "Regular Configuration"

def is_boundary_singularity(q, robot_model):
    """
    경계 특이점 확인 (작업공간 경계)
    """
    end_effector_pos = forward_kinematics(q)[:3]
    max_reach = sum(robot_model.link_lengths)
    distance_from_origin = np.linalg.norm(end_effector_pos)
    
    return abs(distance_from_origin - max_reach) < 0.01

def is_internal_singularity(q, robot_model):
    """
    내부 특이점 확인 (관절 정렬)
    """
    # 연속된 관절축이 정렬된 경우 등
    # 구체적 구현은 로봇 구조에 따라 다름
    return False
```

### 3. 특이점 회피

#### 가조작도 (Manipulability) 기반
```python
def manipulability_measure(q):
    """
    가조작도 계산
    """
    J = compute_jacobian(q)
    
    if J.shape[0] == J.shape[1]:
        # 정사각 자코비안: |det(J)|
        return abs(np.linalg.det(J))
    else:
        # 직사각 자코비안: √det(JJ^T)
        return np.sqrt(np.linalg.det(J @ J.T))

def singularity_avoidance_control(target_velocity, current_q, threshold=0.1):
    """
    특이점 회피 제어
    """
    J = compute_jacobian(current_q)
    manipulability = manipulability_measure(current_q)
    
    if manipulability < threshold:
        # 특이점 근처에서 회피 동작
        
        # 가조작도 기울기 계산
        grad_manipulability = compute_manipulability_gradient(current_q)
        
        # 주 태스크와 회피 태스크 결합
        primary_task = np.linalg.pinv(J) @ target_velocity
        avoidance_task = (threshold - manipulability) * grad_manipulability
        
        # 널 공간 투영으로 결합
        N = np.eye(len(current_q)) - np.linalg.pinv(J) @ J
        
        joint_velocity = primary_task + N @ avoidance_task
        
    else:
        # 일반적인 제어
        joint_velocity = np.linalg.pinv(J) @ target_velocity
    
    return joint_velocity
```

## 중복 자유도 활용

### 1. 널 공간 활용

#### 부차 태스크 수행
```python
def null_space_control(primary_task_velocity, secondary_objective, current_q):
    """
    널 공간을 이용한 부차 태스크 수행
    """
    J = compute_jacobian(current_q)
    J_pinv = np.linalg.pinv(J)
    
    # 주 태스크 해
    q_dot_primary = J_pinv @ primary_task_velocity
    
    # 널 공간 투영자
    N = np.eye(len(current_q)) - J_pinv @ J
    
    # 부차 목적의 기울기
    if secondary_objective == 'joint_limits':
        grad_secondary = joint_limit_avoidance_gradient(current_q)
    elif secondary_objective == 'manipulability':
        grad_secondary = compute_manipulability_gradient(current_q)
    elif secondary_objective == 'energy':
        grad_secondary = energy_minimization_gradient(current_q)
    else:
        grad_secondary = np.zeros_like(current_q)
    
    # 부차 태스크 해 (널 공간에 투영)
    q_dot_secondary = N @ grad_secondary
    
    # 전체 해
    q_dot_total = q_dot_primary + q_dot_secondary
    
    return q_dot_total

def joint_limit_avoidance_gradient(q):
    """
    관절 한계 회피를 위한 기울기
    """
    gradient = np.zeros_like(q)
    
    for i, qi in enumerate(q):
        q_min, q_max = joint_limits[i]
        q_mid = (q_min + q_max) / 2
        
        # 중점으로 향하는 기울기
        gradient[i] = q_mid - qi
    
    return gradient
```

### 2. 가중 제어

#### 관절별 가중치
```python
def weighted_control(target_velocity, current_q, joint_weights):
    """
    관절별 가중치를 고려한 제어
    """
    J = compute_jacobian(current_q)
    W = np.diag(joint_weights)
    
    # 가중 의사역행렬
    W_inv = np.linalg.inv(W)
    J_weighted_pinv = W_inv @ J.T @ np.linalg.inv(J @ W_inv @ J.T)
    
    joint_velocity = J_weighted_pinv @ target_velocity
    
    return joint_velocity

def adaptive_weighting(current_q):
    """
    적응적 가중치 계산
    """
    weights = np.ones(len(current_q))
    
    for i, qi in enumerate(current_q):
        q_min, q_max = joint_limits[i]
        
        # 관절 한계에 가까울수록 가중치 증가
        dist_to_min = qi - q_min
        dist_to_max = q_max - qi
        min_dist = min(dist_to_min, dist_to_max)
        
        # 한계에 가까우면 가중치 증가 (움직이기 어렵게)
        if min_dist < 0.1:
            weights[i] = 10.0
        elif min_dist < 0.2:
            weights[i] = 2.0
    
    return weights
```

## 자코비안 변환

### 1. 좌표계 변환

#### 다른 기준점으로의 변환
```python
def transform_jacobian_to_point(J_original, current_q, new_reference_point):
    """
    자코비안을 다른 기준점으로 변환
    """
    # 현재 엔드 이펙터 위치
    current_ee_pos = forward_kinematics(current_q)[:3]
    
    # 새 기준점으로의 벡터
    r = new_reference_point - current_ee_pos
    
    # 변환 행렬
    Ad = np.zeros((6, 6))
    Ad[:3, :3] = np.eye(3)
    Ad[3:, 3:] = np.eye(3)
    Ad[:3, 3:] = skew_symmetric(r)
    
    # 변환된 자코비안
    J_transformed = Ad @ J_original
    
    return J_transformed

def skew_symmetric(v):
    """
    벡터의 반대칭 행렬
    """
    return np.array([[0, -v[2], v[1]],
                     [v[2], 0, -v[0]],
                     [-v[1], v[0], 0]])
```

#### 좌표계 회전
```python
def rotate_jacobian(J_original, rotation_matrix):
    """
    자코비안을 회전된 좌표계로 변환
    """
    R = rotation_matrix
    Ad_R = np.zeros((6, 6))
    Ad_R[:3, :3] = R
    Ad_R[3:, 3:] = R
    
    J_rotated = Ad_R @ J_original
    
    return J_rotated
```

### 2. 속도 표현 변환

#### 각속도 표현 변환
```python
def convert_angular_velocity_representation(J_geometric, current_orientation):
    """
    기하학적 자코비안을 해석적 자코비안으로 변환
    (각속도 벡터 → 오일러각 미분)
    """
    # 오일러각에서 각속도로의 변환 행렬
    T_omega = compute_omega_transformation_matrix(current_orientation)
    
    # 변환 행렬 구성
    T = np.zeros((6, 6))
    T[:3, :3] = np.eye(3)  # 선속도는 그대로
    T[3:, 3:] = T_omega    # 각속도 변환
    
    J_analytical = T @ J_geometric
    
    return J_analytical

def compute_omega_transformation_matrix(euler_angles):
    """
    오일러각 미분을 각속도로 변환하는 행렬
    """
    phi, theta, psi = euler_angles  # Roll, Pitch, Yaw
    
    T = np.array([
        [1, 0, -np.sin(theta)],
        [0, np.cos(phi), np.cos(theta)*np.sin(phi)],
        [0, -np.sin(phi), np.cos(theta)*np.cos(phi)]
    ])
    
    return T
```

## 계산 최적화

### 1. 효율적 계산

#### 재귀적 계산
```python
def recursive_jacobian_computation(q, dh_params):
    """
    재귀적 자코비안 계산 (O(n) 복잡도)
    """
    n = len(q)
    J = np.zeros((6, n))
    
    # 전방향 재귀: 변환 행렬들 계산
    T = [np.eye(4)]
    for i in range(n):
        Ti = dh_transform(dh_params[i], q[i])
        T.append(T[-1] @ Ti)
    
    # 엔드 이펙터 위치
    pe = T[-1][:3, 3]
    
    # 각 관절에 대한 자코비안 열 계산
    for i in range(n):
        # 관절 i의 축과 위치
        zi = T[i][:3, 2]
        pi = T[i][:3, 3]
        
        # 자코비안 i번째 열
        if dh_params[i]['type'] == 'revolute':
            J[:3, i] = np.cross(zi, pe - pi)
            J[3:, i] = zi
        else:  # prismatic
            J[:3, i] = zi
            J[3:, i] = 0
    
    return J
```

#### 스파스 구조 활용
```python
def sparse_jacobian_update(J_prev, q_change, changed_joint_index):
    """
    일부 관절만 변경되었을 때 자코비안 업데이트
    """
    J_new = J_prev.copy()
    
    # 변경된 관절 이후의 모든 열을 재계산
    for i in range(changed_joint_index, J_prev.shape[1]):
        J_new[:, i] = compute_jacobian_column(q_change, i)
    
    return J_new
```

### 2. 수치적 안정성

#### 조건수 모니터링
```python
def stable_jacobian_inversion(J, condition_threshold=1e6):
    """
    수치적으로 안정한 자코비안 역산
    """
    # SVD 분해
    U, s, Vt = np.linalg.svd(J)
    
    # 조건수 확인
    condition_number = s[0] / s[-1] if s[-1] > 0 else np.inf
    
    if condition_number > condition_threshold:
        # 특이값 임계화
        s_filtered = np.where(s > s[0]/condition_threshold, s, 0)
        
        # 필터링된 의사역행렬
        s_inv = np.where(s_filtered > 0, 1/s_filtered, 0)
        J_pinv = Vt.T @ np.diag(s_inv) @ U.T
        
        return J_pinv, True  # 필터링됨
    else:
        # 일반 의사역행렬
        J_pinv = Vt.T @ np.diag(1/s) @ U.T
        return J_pinv, False  # 필터링 안됨
```

## 실시간 응용

### 1. 실시간 자코비안 계산

#### 하드웨어 최적화
```python
class RealTimeJacobianComputer:
    def __init__(self, robot_model):
        self.robot = robot_model
        self.prev_q = None
        self.prev_J = None
        self.update_threshold = 0.01  # rad
    
    def compute(self, current_q):
        """
        실시간 자코비안 계산
        """
        # 이전 계산 결과 재사용 검사
        if (self.prev_q is not None and 
            np.linalg.norm(current_q - self.prev_q) < self.update_threshold):
            return self.prev_J
        
        # 새로 계산
        J = self.fast_jacobian_computation(current_q)
        
        # 캐시 업데이트
        self.prev_q = current_q.copy()
        self.prev_J = J.copy()
        
        return J
    
    def fast_jacobian_computation(self, q):
        """
        최적화된 자코비안 계산
        """
        # 구체적 로봇에 특화된 빠른 계산
        return compute_jacobian_optimized(q, self.robot)
```

### 2. 병렬 처리

#### 다중 태스크 병렬 계산
```python
import concurrent.futures

def parallel_multi_jacobian_computation(q, tasks):
    """
    여러 태스크의 자코비안을 병렬로 계산
    """
    with concurrent.futures.ThreadPoolExecutor() as executor:
        futures = []
        
        for task in tasks:
            future = executor.submit(compute_task_jacobian, q, task)
            futures.append(future)
        
        # 결과 수집
        jacobians = []
        for future in concurrent.futures.as_completed(futures):
            jacobians.append(future.result())
    
    return jacobians
```

## 연결 문서

### 관련 기술
- **상위**: [[휴머노이드 연구기술]]
- **기구학**: [[순기구학]], [[역기구학]]
- **제어**: [[속도제어]], [[힘제어]]

### 수학적 기반
- **미적분**: [[편미분]], [[연쇄법칙]]
- **선형대수**: [[의사역행렬]], [[특이값분해]], [[널공간]]
- **최적화**: [[최소제곱법]], [[제약최적화]]

### 응용 분야
- **휴머노이드**: [[전신제어기법]], [[다중태스크제어]]
- **로봇제어**: [[실시간제어]], [[특이점회피]]
- **경로계획**: [[궤적최적화]], [[모션계획]]

## 태그

#자코비안 #기구학 #속도제어 #역기구학 #특이점 #중복자유도 #다중태스크 #실시간제어 #로봇제어