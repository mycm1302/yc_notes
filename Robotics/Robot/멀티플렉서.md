# ë©€í‹°í”Œë ‰ì„œ

> ìƒìœ„: [[ì „ìíšŒë¡œì„¤ê³„]]

ë‹¤ì¤‘ ì„¼ì„œ ì‹ í˜¸ë¥¼ í•˜ë‚˜ì˜ ADCë¡œ ì²˜ë¦¬í•˜ê¸° ìœ„í•œ ë©€í‹°í”Œë ‰ì„œ íšŒë¡œì…ë‹ˆë‹¤.

## ğŸ”„ ì•„ë‚ ë¡œê·¸ ë©€í‹°í”Œë ‰ì„œ

### CD4051 8ì±„ë„ ë©€í‹°í”Œë ‰ì„œ
```
ì„¼ì„œ1 â”€â”
ì„¼ì„œ2 â”€â”¤
ì„¼ì„œ3 â”€â”¤ CD4051 â”€â”€â”€ ADC ì…ë ¥
ì„¼ì„œ4 â”€â”¤  MUX
ì„¼ì„œ5 â”€â”¤
ì„¼ì„œ6 â”€â”˜

ì œì–´ì‹ í˜¸: A0, A1, A2 (3bit = 8ì±„ë„)
```

### íšŒë¡œ ì—°ê²°
```cpp
// ESP32 ë©€í‹°í”Œë ‰ì„œ ì œì–´
#define MUX_A0 25
#define MUX_A1 26  
#define MUX_A2 27
#define MUX_SIG 34  // ADC ì…ë ¥

void selectChannel(int channel) {
    digitalWrite(MUX_A0, channel & 0x01);
    digitalWrite(MUX_A1, (channel >> 1) & 0x01);
    digitalWrite(MUX_A2, (channel >> 2) & 0x01);
    delayMicroseconds(10);  // ì•ˆì •í™” ì‹œê°„
}

float readSensor(int channel) {
    selectChannel(channel);
    return analogRead(MUX_SIG) * 3.3 / 4095.0;
}
```
## ğŸ”§ ì‹¤ë¬´ í™œìš© ì˜ˆì‹œ

### ë¡œë´‡ ì„¼ì„œ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ
```cpp
// 8ê°œ ì„¼ì„œ ìˆœì°¨ ìŠ¤ìº”
typedef struct {
    float temperature[4];  // ì˜¨ë„ ì„¼ì„œ 4ê°œ
    float pressure[2];     // ì••ë ¥ ì„¼ì„œ 2ê°œ  
    float voltage[2];      // ì „ì•• ëª¨ë‹ˆí„° 2ê°œ
} SensorData_t;

void scanAllSensors(SensorData_t* data) {
    // ì˜¨ë„ ì„¼ì„œë“¤ (ì±„ë„ 0-3)
    for(int i = 0; i < 4; i++) {
        data->temperature[i] = readSensor(i);
    }
    
    // ì••ë ¥ ì„¼ì„œë“¤ (ì±„ë„ 4-5)
    for(int i = 0; i < 2; i++) {
        data->pressure[i] = readSensor(4 + i);
    }
    
    // ì „ì•• ëª¨ë‹ˆí„° (ì±„ë„ 6-7)
    for(int i = 0; i < 2; i++) {
        data->voltage[i] = readSensor(6 + i);
    }
}
```

### ê³ ì† ë©€í‹°í”Œë ‰ì‹±
```cpp
// DG508A 8ì±„ë„ ê³ ì† MUX (STM32ìš©)
void setupHighSpeedMux() {
    // 3bit ì£¼ì†Œ ì‹ í˜¸ ì„¤ì •
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_RESET);  // A0
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_PIN_RESET);  // A1  
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_2, GPIO_PIN_RESET);  // A2
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_RESET);  // EN
}

// 1MHz ìƒ˜í”Œë§ìœ¼ë¡œ 8ì±„ë„ ìŠ¤ìº”
void fastSensorScan() {
    for(int ch = 0; ch < 8; ch++) {
        setMuxChannel(ch);
        HAL_Delay_us(1);  // 1Î¼s ì•ˆì •í™”
        HAL_ADC_Start(&hadc1);
        HAL_ADC_PollForConversion(&hadc1, 1);
        sensorData[ch] = HAL_ADC_GetValue(&hadc1);
    }
}
```

## ğŸ“Š ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­

### ìŠ¤ìœ„ì¹­ ì‹œê°„
```
CD4051: ~250ns (ì¼ë°˜ìš©)
DG508A: ~85ns (ê³ ì†ìš©)  
ADG508: ~40ns (ì´ˆê³ ì†ìš©)

ì•ˆì •í™” ì‹œê°„:
- ì €ì„í”¼ë˜ìŠ¤ ì†ŒìŠ¤: 1-10Î¼s
- ê³ ì„í”¼ë˜ìŠ¤ ì†ŒìŠ¤: 10-100Î¼s
```

### í¬ë¡œìŠ¤í† í¬ ë° ì˜¤í”„ì…‹
- **í¬ë¡œìŠ¤í† í¬**: -80dB ì´í•˜ (CD4051)
- **ì˜¨ ì €í•­**: 80Î© (CD4051), 4Î© (DG508A)  
- **ëˆ„ì„¤ì „ë¥˜**: 1nA ì´í•˜

---

## ğŸ”— ì—°ê²° ë¬¸ì„œ
- ìƒìœ„: [[ì „ìíšŒë¡œì„¤ê³„]]
- ê´€ë ¨: [[ADC]], [[ì„¼ì„œì¸í„°í˜ì´ìŠ¤]]
- ì‘ìš©: [[ì‹ í˜¸ì¡°ì ˆ]]