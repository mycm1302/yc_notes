# ê°•ê±´ì„¤ê³„

> ìƒìœ„: [[ìµœì í™”ì„¤ê³„]]

ë¶ˆí™•ì‹¤ì„±ê³¼ ë³€ë™ì„±ì´ ìˆëŠ” í™˜ê²½ì—ì„œë„ ì•ˆì •ì ì¸ ì„±ëŠ¥ì„ ë³´ì¥í•˜ëŠ” ì„¤ê³„ ë°©ë²•ë¡ ì…ë‹ˆë‹¤. ì‰½ê²Œ ë§í•´ "ì˜ˆìƒì¹˜ ëª»í•œ ìƒí™©ì—ì„œë„ ì˜ ì‘ë™í•˜ëŠ” ì„¤ê³„"ë¥¼ ë§Œë“œëŠ” ê¸°ìˆ ì…ë‹ˆë‹¤.

## ğŸ›¡ï¸ ê¸°ë³¸ ê°œë…

### ê°•ê±´ì„¤ê³„ê°€ ì™œ í•„ìš”í•œê°€?

**í˜„ì‹¤ì  ë¬¸ì œë“¤:**
```
ì´ë¡ ì  ì„¤ê³„ vs ì‹¤ì œ ì œì‘í’ˆ:
- ì„¤ê³„ê°’: ê°•ë„ 100MPa â†’ ì‹¤ì œ: 95~105MPa (Â±5% ë³€ë™)
- ì„¤ê³„ê°’: ì¹˜ìˆ˜ 10mm â†’ ì‹¤ì œ: 9.95~10.05mm (ê°€ê³µ ê³µì°¨)
- ìš´ì˜í™˜ê²½: 20Â°C â†’ ì‹¤ì œ: -10Â°C~50Â°C (ê³„ì ˆë³„ ë³€í™”)
```

**ì „í†µì  ì„¤ê³„ì˜ í•œê³„:**
```matlab
% ì „í†µì  ì ‘ê·¼: ê³ ì •ê°’ìœ¼ë¡œ ì„¤ê³„
material_strength = 250e6;  % Pa (ì¹´íƒˆë¡œê·¸ ê°’)
operating_temp = 20;        % Â°C (ì„¤ê³„ ì˜¨ë„)
load = 10000;              % N (ì •ê²© í•˜ì¤‘)

% ì‹¤ì œ ìƒí™©: ëª¨ë“  ê°’ì´ í™•ë¥ ë¶„í¬
material_strength_real = normrnd(250e6, 25e6);  % í‰ê· Â±10%
operating_temp_real = normrnd(20, 15);          % Â±15Â°C ë³€ë™
load_real = normrnd(10000, 2000);              % Â±20% ë³€ë™
```

### ë¶ˆí™•ì‹¤ì„±ì˜ ë¶„ë¥˜

#### 1. ì•Œë ˆí† ë¦¬ ë¶ˆí™•ì‹¤ì„± (Aleatory Uncertainty)
**ë³¸ì§ˆì , ë¬´ì‘ìœ„ì  ë³€ë™ì„±**
```matlab
% ì˜ˆì‹œ: ì¬ë£Œ ê°•ë„ì˜ ìì—°ì  ë³€ë™
% í†µê³„ì  ë¶„í¬ë¡œ ëª¨ë¸ë§ ê°€ëŠ¥
material_strength = normrnd(mu_strength, sigma_strength, [1000, 1]);
histogram(material_strength);
xlabel('Material Strength [Pa]');
ylabel('Frequency');
title('Aleatory Uncertainty in Material Properties');
```

#### 2. ì¸ì‹ë¡ ì  ë¶ˆí™•ì‹¤ì„± (Epistemic Uncertainty)  
**ì§€ì‹ ë¶€ì¡±ìœ¼ë¡œ ì¸í•œ ë¶ˆí™•ì‹¤ì„±**
```matlab
% ì˜ˆì‹œ: í•˜ì¤‘ ëª¨ë¸ì˜ ë¶ˆì™„ì „ì„±
% êµ¬ê°„ ë¶ˆí™•ì‹¤ì„±ìœ¼ë¡œ ëª¨ë¸ë§
load_nominal = 10000;  % N
load_uncertainty = 0.3;  % Â±30%
load_interval = [load_nominal*(1-load_uncertainty), ...
                load_nominal*(1+load_uncertainty)];
```

### ê°•ê±´ì„± ì§€í‘œ

#### ì„±ëŠ¥ ë³€ë™ì„±
```matlab
function [performance_mean, performance_std] = evaluate_performance_variation(design_vars, uncertainty_params)
    n_samples = 1000;
    performance_samples = zeros(n_samples, 1);
    
    for i = 1:n_samples
        % ë¶ˆí™•ì‹¤ì„± ìƒ˜í”Œë§
        uncertain_vars = sample_uncertainties(uncertainty_params);
        
        % ì„±ëŠ¥ í‰ê°€
        performance_samples(i) = system_performance(design_vars, uncertain_vars);
    end
    
    performance_mean = mean(performance_samples);
    performance_std = std(performance_samples);
end
```

#### ì‹ í˜¸-ì¡ìŒë¹„ (Signal-to-Noise Ratio)
```matlab
function snr = signal_to_noise_ratio(performance_data, objective_type)
    mu = mean(performance_data);
    sigma = std(performance_data);
    
    switch objective_type
        case 'larger_is_better'
            % í° ê°’ì´ ì¢‹ì€ ê²½ìš° (ì¶œë ¥, íš¨ìœ¨ ë“±)
            snr = -10 * log10(mean(1./performance_data.^2));
            
        case 'smaller_is_better'  
            % ì‘ì€ ê°’ì´ ì¢‹ì€ ê²½ìš° (ê²°í•¨ë¥ , ì†ŒìŒ ë“±)
            snr = -10 * log10(mean(performance_data.^2));
            
        case 'nominal_is_best'
            % ëª©í‘œê°’ì´ ìˆëŠ” ê²½ìš°
            target_value = 100;  % ì˜ˆì‹œ
            snr = -10 * log10(mean((performance_data - target_value).^2));
    end
end
```

---

## ğŸ“Š ê°•ê±´ì„¤ê³„ ì ‘ê·¼ë²•

### 1. ë‹¤êµ¬ì¹˜ ë°©ë²• (Taguchi Method)

#### ì§êµë°°ì—´í‘œë¥¼ ì´ìš©í•œ ì‹¤í—˜ì„¤ê³„

**L9 ì§êµë°°ì—´ ì˜ˆì‹œ (3ìˆ˜ì¤€, 4ì¸ì):**
```matlab
% ì„¤ê³„ì¸ì (ì œì–´ ê°€ëŠ¥)
factors = {
    'material_grade', [1, 2, 3];           % ì¬ë£Œ ë“±ê¸‰
    'heat_treatment_temp', [800, 850, 900]; % ì—´ì²˜ë¦¬ ì˜¨ë„ [Â°C]
    'cooling_rate', [10, 20, 30];          % ëƒ‰ê°ì†ë„ [Â°C/min]
    'surface_finish', [1, 2, 3]            % í‘œë©´ì²˜ë¦¬ ìˆ˜ì¤€
};

% L9 ì§êµë°°ì—´í‘œ
L9_array = [
    1, 1, 1, 1;
    1, 2, 2, 2;
    1, 3, 3, 3;
    2, 1, 2, 3;
    2, 2, 3, 1;
    2, 3, 1, 2;
    3, 1, 3, 2;
    3, 2, 1, 3;
    3, 3, 2, 1
];

% ê° ì‹¤í—˜ì¡°ê±´ì—ì„œ ì„±ëŠ¥ í‰ê°€
for i = 1:size(L9_array, 1)
    experiment_condition = L9_array(i, :);
    performance(i) = evaluate_design_performance(experiment_condition, factors);
end
```

#### ì¡ìŒì¸ì ê³ ë ¤í•œ ë‚´ì™¸ì¸¡ ë°°ì—´

```matlab
function robust_design_experiment()
    % ë‚´ì¸¡ ë°°ì—´ (ì œì–´ì¸ì)
    control_factors = L9_array;  % 9ê°œ ì„¤ê³„ì¡°ê±´
    
    % ì™¸ì¸¡ ë°°ì—´ (ì¡ìŒì¸ì)
    noise_factors = [
        1, 1;  % ì €ì˜¨, ì €ìŠµ
        1, 2;  % ì €ì˜¨, ê³ ìŠµ  
        2, 1;  % ê³ ì˜¨, ì €ìŠµ
        2, 2   % ê³ ì˜¨, ê³ ìŠµ
    ];
    
    % ì „ì²´ ì‹¤í—˜ (9Ã—4 = 36íšŒ)
    results = zeros(size(control_factors, 1), size(noise_factors, 1));
    
    for i = 1:size(control_factors, 1)
        for j = 1:size(noise_factors, 1)
            % ì œì–´ì¸ì + ì¡ìŒì¸ì ì¡°í•©
            control_condition = control_factors(i, :);
            noise_condition = noise_factors(j, :);
            
            results(i, j) = system_response(control_condition, noise_condition);
        end
    end
    
    % ê° ì„¤ê³„ì¡°ê±´ë³„ S/N ë¹„ ê³„ì‚°
    snr_values = zeros(size(control_factors, 1), 1);
    for i = 1:size(control_factors, 1)
        snr_values(i) = signal_to_noise_ratio(results(i, :), 'larger_is_better');
    end
    
    % ìµœì  ì¡°ê±´ ì„ íƒ
    [max_snr, best_condition_idx] = max(snr_values);
    optimal_design = control_factors(best_condition_idx, :);
    
    fprintf('Optimal design condition: [%d, %d, %d, %d]\n', optimal_design);
    fprintf('Maximum S/N ratio: %.2f dB\n', max_snr);
end
```

#### í’ˆì§ˆ ì†ì‹¤ í•¨ìˆ˜

```matlab
function quality_loss = taguchi_loss_function(actual_values, target_value, loss_coefficient)
    % 2ì°¨ ì†ì‹¤í•¨ìˆ˜: L = k(y - m)Â²
    % k: ì†ì‹¤ê³„ìˆ˜, y: ì‹¤ì œê°’, m: ëª©í‘œê°’
    
    quality_loss = loss_coefficient * (actual_values - target_value).^2;
end

% ì†ì‹¤ê³„ìˆ˜ ê²°ì •
function k = determine_loss_coefficient(tolerance, cost_at_tolerance)
    % ê³µì°¨ í•œê³„ì—ì„œì˜ ë¹„ìš©ìœ¼ë¡œë¶€í„° ì†ì‹¤ê³„ìˆ˜ ê³„ì‚°
    % L = k * Î”Â²
    k = cost_at_tolerance / tolerance^2;
end

% ì˜ˆì‹œ: ì¹˜ìˆ˜ ì •ë°€ë„ ë¬¸ì œ
target_dimension = 100.0;    % mm
tolerance = 0.1;             % Â±0.1mm
rework_cost = 50;           % ê³µì°¨ ì´ˆê³¼ ì‹œ ì¬ì‘ì—… ë¹„ìš©

k = determine_loss_coefficient(tolerance, rework_cost);
actual_dimensions = normrnd(100, 0.05, [1000, 1]);  % ì‹¤ì œ ì œì‘ ì¹˜ìˆ˜
total_quality_loss = sum(taguchi_loss_function(actual_dimensions, target_dimension, k));
```

### 2. 6ì‹œê·¸ë§ˆ ì„¤ê³„

#### DMAIC í”„ë¡œì„¸ìŠ¤ êµ¬í˜„

```matlab
function six_sigma_design_process()
    %% Define (ì •ì˜)
    fprintf('=== DEFINE PHASE ===\n');
    
    % CTQ (Critical to Quality) íŠ¹ì„± ì •ì˜
    ctq_characteristics = {
        'dimensional_accuracy', 'target', 100, 'tolerance', 0.1;
        'surface_roughness', 'smaller_is_better', [], 'spec_limit', 1.6;
        'tensile_strength', 'larger_is_better', [], 'min_spec', 500
    };
    
    %% Measure (ì¸¡ì •)
    fprintf('=== MEASURE PHASE ===\n');
    
    % í˜„ì¬ ê³µì • ëŠ¥ë ¥ ì¸¡ì •
    current_data = collect_current_process_data();
    process_capability = calculate_process_capability(current_data, ctq_characteristics);
    
    %% Analyze (ë¶„ì„)  
    fprintf('=== ANALYZE PHASE ===\n');
    
    % ì£¼ìš” ì¸ì ì‹ë³„ (DOE)
    significant_factors = design_of_experiments_analysis();
    
    %% Improve (ê°œì„ )
    fprintf('=== IMPROVE PHASE ===\n');
    
    % ê°•ê±´ì„¤ê³„ ìµœì í™”
    optimal_settings = robust_parameter_optimization(significant_factors);
    
    %% Control (ê´€ë¦¬)
    fprintf('=== CONTROL PHASE ===\n');
    
    % í†µê³„ì  ê³µì •ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬ì¶•
    control_charts = setup_statistical_process_control(optimal_settings);
end

function cp = calculate_process_capability(data, spec_limits)
    % Cp, Cpk ê³„ì‚°
    mu = mean(data);
    sigma = std(data);
    
    USL = spec_limits.upper;  % ìƒí•œ ê·œê²©
    LSL = spec_limits.lower;  % í•˜í•œ ê·œê²©
    
    % ê³µì •ëŠ¥ë ¥ì§€ìˆ˜
    cp = (USL - LSL) / (6 * sigma);
    
    % ê³µì •ì„±ëŠ¥ì§€ìˆ˜
    cpu = (USL - mu) / (3 * sigma);
    cpl = (mu - LSL) / (3 * sigma);
    cpk = min(cpu, cpl);
    
    fprintf('Cp = %.3f, Cpk = %.3f\n', cp, cpk);
    
    % 6ì‹œê·¸ë§ˆ ìˆ˜ì¤€ í‰ê°€
    if cpk >= 2.0
        fprintf('Process is at 6-sigma level\n');
    elseif cpk >= 1.67
        fprintf('Process is at 5-sigma level\n'); 
    elseif cpk >= 1.33
        fprintf('Process is at 4-sigma level\n');
    else
        fprintf('Process needs improvement\n');
    end
end
```

#### ê²°í•¨ë¥  ì˜ˆì¸¡ ë° ê´€ë¦¬

```matlab
function defect_rate = predict_defect_rate(process_mean, process_std, spec_limits)
    % ì •ê·œë¶„í¬ ê°€ì •í•˜ì— ê²°í•¨ë¥  ê³„ì‚°
    
    % ìƒí•œ ì´ˆê³¼ í™•ë¥ 
    prob_above_usl = 1 - normcdf(spec_limits.upper, process_mean, process_std);
    
    % í•˜í•œ ë¯¸ë‹¬ í™•ë¥   
    prob_below_lsl = normcdf(spec_limits.lower, process_mean, process_std);
    
    % ì´ ê²°í•¨ë¥ 
    defect_rate = prob_above_usl + prob_below_lsl;
    
    % ppm (parts per million) ë³€í™˜
    defect_ppm = defect_rate * 1e6;
    
    fprintf('Predicted defect rate: %.2e (%.1f ppm)\n', defect_rate, defect_ppm);
    
    % ì‹œê·¸ë§ˆ ìˆ˜ì¤€ ê³„ì‚°
    if defect_rate > 0
        sigma_level = -norminv(defect_rate/2);
        fprintf('Equivalent sigma level: %.2f\n', sigma_level);
    end
end

% 6ì‹œê·¸ë§ˆ ëª©í‘œ (3.4 ppm) ë‹¬ì„±ì„ ìœ„í•œ ìš”êµ¬ì‚¬í•­
target_defect_ppm = 3.4;
target_defect_rate = target_defect_ppm / 1e6;

% í•„ìš”í•œ ê³µì • í‘œì¤€í¸ì°¨ ê³„ì‚°
function required_sigma = calculate_required_process_sigma(spec_width, target_defect_rate)
    % ì–‘ì¸¡ ê·œê²©ì˜ ê²½ìš°
    z_value = norminv(1 - target_defect_rate/2);
    required_sigma = spec_width / (2 * z_value);
end
```

### 3. í™•ë¥ ì  ê°•ê±´ì„¤ê³„

#### ëª¬í…Œì¹´ë¥´ë¡œ ì‹œë®¬ë ˆì´ì…˜

```matlab
function [robust_design, performance_stats] = monte_carlo_robust_design(design_space, uncertainty_model)
    % ì„¤ê³„ê³µê°„ íƒìƒ‰
    n_design_candidates = 100;
    n_monte_carlo_samples = 1000;
    
    design_candidates = generate_design_candidates(design_space, n_design_candidates);
    
    % ê° ì„¤ê³„ í›„ë³´ì— ëŒ€í•œ ê°•ê±´ì„± í‰ê°€
    robustness_metrics = zeros(n_design_candidates, 3);  % [mean, std, failure_prob]
    
    for i = 1:n_design_candidates
        design = design_candidates(i, :);
        performance_samples = zeros(n_monte_carlo_samples, 1);
        
        % ëª¬í…Œì¹´ë¥´ë¡œ ìƒ˜í”Œë§
        for j = 1:n_monte_carlo_samples
            % ë¶ˆí™•ì‹¤ì„± ìƒ˜í”Œ ìƒì„±
            uncertain_params = sample_uncertainties(uncertainty_model);
            
            % ì„±ëŠ¥ í‰ê°€
            performance_samples(j) = evaluate_system_performance(design, uncertain_params);
        end
        
        % ê°•ê±´ì„± ì§€í‘œ ê³„ì‚°
        robustness_metrics(i, 1) = mean(performance_samples);           % í‰ê·  ì„±ëŠ¥
        robustness_metrics(i, 2) = std(performance_samples);            % ì„±ëŠ¥ ë³€ë™ì„±
        robustness_metrics(i, 3) = mean(performance_samples < 0);       % íŒŒì† í™•ë¥ 
    end
    
    % ë‹¤ëª©ì  ìµœì í™” (ì„±ëŠ¥ ìµœëŒ€í™”, ë³€ë™ì„± ìµœì†Œí™”, íŒŒì†í™•ë¥  ìµœì†Œí™”)
    [pareto_front, pareto_indices] = find_pareto_optimal_designs(robustness_metrics);
    
    % ìµœì¢… ì„¤ê³„ ì„ íƒ (ì˜ì‚¬ê²°ì •ì ì„ í˜¸ë„ ë°˜ì˜)
    robust_design = select_final_design(design_candidates(pareto_indices, :), robustness_metrics(pareto_indices, :));
    
    performance_stats.mean = robustness_metrics(robust_design, 1);
    performance_stats.std = robustness_metrics(robust_design, 2);
    performance_stats.failure_prob = robustness_metrics(robust_design, 3);
end

function uncertain_params = sample_uncertainties(uncertainty_model)
    % ë‹¤ì–‘í•œ ë¶ˆí™•ì‹¤ì„± ëª¨ë¸ ì²˜ë¦¬
    uncertain_params = struct();
    
    for field = fieldnames(uncertainty_model)'
        param = uncertainty_model.(field{1});
        
        switch param.type
            case 'normal'
                uncertain_params.(field{1}) = normrnd(param.mean, param.std);
                
            case 'uniform'
                uncertain_params.(field{1}) = unifrnd(param.lower, param.upper);
                
            case 'lognormal'
                uncertain_params.(field{1}) = lognrnd(param.mu, param.sigma);
                
            case 'interval'
                % ìµœì•…ì˜ ê²½ìš° ì‹œë‚˜ë¦¬ì˜¤
                if rand < 0.5
                    uncertain_params.(field{1}) = param.lower;
                else
                    uncertain_params.(field{1}) = param.upper;
                end
        end
    end
end
```

#### ì‹ ë¢°ì„± ê¸°ë°˜ ì„¤ê³„ìµœì í™” (RBDO)

```matlab
function [x_optimal, reliability] = reliability_based_design_optimization(objective_func, constraints, reliability_requirements)
    % RBDO ë¬¸ì œ ì •ì‹í™”:
    % min f(x)
    % s.t. P[gi(x,Î¾) â‰¤ 0] â‰¥ Î²i, i = 1,...,m
    
    % ì´ˆê¸° ì„¤ê³„
    x0 = [1.0, 0.5, 2.0];  % ì˜ˆì‹œ ì´ˆê¸°ê°’
    
    % ì‹ ë¢°ì„± ì œì•½ì¡°ê±´ì„ deterministic equivalentë¡œ ë³€í™˜
    deterministic_constraints = @(x) convert_reliability_constraints(x, constraints, reliability_requirements);
    
    % ìµœì í™” ì‹¤í–‰
    options = optimoptions('fmincon', 'Display', 'iter', 'Algorithm', 'sqp');
    [x_optimal, fval, exitflag] = fmincon(objective_func, x0, [], [], [], [], [], [], deterministic_constraints, options);
    
    % ìµœì  ì„¤ê³„ì˜ ì‹ ë¢°ì„± ê²€ì¦
    reliability = verify_reliability(x_optimal, constraints, reliability_requirements);
    
    fprintf('Optimal design: [%.3f, %.3f, %.3f]\n', x_optimal);
    fprintf('Objective value: %.6f\n', fval);
    fprintf('Reliability levels: ');
    fprintf('%.4f ', reliability);
    fprintf('\n');
end

function [c, ceq] = convert_reliability_constraints(x, original_constraints, beta_required)
    % First-Order Reliability Method (FORM) ì‚¬ìš©
    n_constraints = length(original_constraints);
    c = zeros(n_constraints, 1);
    ceq = [];
    
    for i = 1:n_constraints
        % ì‹ ë¢°ì„± ì§€ìˆ˜ë¥¼ deterministic ì œì•½ì¡°ê±´ìœ¼ë¡œ ë³€í™˜
        [beta_current, u_star] = form_analysis(x, original_constraints{i});
        
        % ì œì•½ì¡°ê±´: Î²_current â‰¥ Î²_required
        c(i) = beta_required(i) - beta_current;
    end
end

function [beta, u_star] = form_analysis(x, constraint_func)
    % First-Order Reliability Method êµ¬í˜„
    
    % í™•ë¥ ë³€ìˆ˜ ì •ë³´ (ì˜ˆì‹œ)
    uncertain_vars = struct();
    uncertain_vars.load = struct('mean', 10000, 'std', 2000);      % í•˜ì¤‘ [N]
    uncertain_vars.strength = struct('mean', 250e6, 'std', 25e6);  % ê°•ë„ [Pa]
    uncertain_vars.dimension = struct('mean', 0.01, 'std', 0.001); % ì¹˜ìˆ˜ [m]
    
    % í‘œì¤€ì •ê·œê³µê°„ìœ¼ë¡œ ë³€í™˜
    [u_star, beta] = find_design_point(x, constraint_func, uncertain_vars);
end
```

---

## ğŸ”§ ì‹¤ì œ ì ìš© ì‚¬ë¡€

### ì‚¬ë¡€ 1: ìë™ì°¨ ì—”ì§„ ë¶€í’ˆ ì„¤ê³„

**ë¶ˆí™•ì‹¤ì„± ìš”ì¸ë“¤:**
```matlab
% ì—”ì§„ í”¼ìŠ¤í†¤ ê°•ê±´ì„¤ê³„
uncertainty_sources = struct();

% ì¬ë£Œ íŠ¹ì„± ë³€ë™
uncertainty_sources.elastic_modulus = struct('type', 'normal', 'mean', 200e9, 'std', 10e9);
uncertainty_sources.yield_strength = struct('type', 'normal', 'mean', 350e6, 'std', 35e6);

% ìš´ì˜ ì¡°ê±´ ë³€ë™
uncertainty_sources.operating_temp = struct('type', 'uniform', 'lower', -40, 'upper', 120);
uncertainty_sources.pressure = struct('type', 'lognormal', 'mu', log(2e6), 'sigma', 0.2);

% ì œì¡° ê³µì°¨
uncertainty_sources.diameter = struct('type', 'normal', 'mean', 0.08, 'std', 0.0005);
uncertainty_sources.length = struct('type', 'normal', 'mean', 0.15, 'std', 0.001);

function performance = piston_performance(design_vars, uncertain_vars)
    % ì„¤ê³„ë³€ìˆ˜: [wall_thickness, crown_thickness, skirt_length]
    wall_thickness = design_vars(1);
    crown_thickness = design_vars(2);
    skirt_length = design_vars(3);
    
    % ë¶ˆí™•ì‹¤ì„± ë³€ìˆ˜ ì¶”ì¶œ
    E = uncertain_vars.elastic_modulus;
    sigma_y = uncertain_vars.yield_strength;
    T = uncertain_vars.operating_temp;
    P = uncertain_vars.pressure;
    D = uncertain_vars.diameter;
    L = uncertain_vars.length;
    
    % ì—´ì‘ë ¥ ê³„ì‚°
    alpha = 12e-6;  % ì—´íŒ½ì°½ê³„ìˆ˜ [1/K]
    thermal_stress = E * alpha * (T - 20);  % 20Â°C ê¸°ì¤€
    
    % ì••ë ¥ ì‘ë ¥ ê³„ì‚°
    pressure_stress = P * D / (2 * wall_thickness);
    
    % ì´ ì‘ë ¥
    total_stress = pressure_stress + thermal_stress;
    
    % ì•ˆì „ê³„ìˆ˜
    safety_factor = sigma_y / total_stress;
    
    % ì„±ëŠ¥ ì§€í‘œ (ì•ˆì „ê³„ìˆ˜ê°€ í´ìˆ˜ë¡ ì¢‹ìŒ)
    performance = safety_factor;
end

% ê°•ê±´ì„¤ê³„ ì‹¤í–‰
robust_piston_design = monte_carlo_robust_design(...
    struct('wall_thickness', [0.005, 0.015], 'crown_thickness', [0.01, 0.03], 'skirt_length', [0.08, 0.12]), ...
    uncertainty_sources);
```

### ì‚¬ë¡€ 2: í•­ê³µê¸° êµ¬ì¡° ë¶€í’ˆ

**ë‹¤ì¤‘ ì‹¤íŒ¨ ëª¨ë“œ ê³ ë ¤:**
```matlab
function [design_optimal, reliability_levels] = aircraft_component_robust_design()
    % ë³µí•©ì¬ë£Œ í•­ê³µê¸° íŒ¨ë„ ì„¤ê³„
    
    % ì„¤ê³„ë³€ìˆ˜: [ply_thickness, fiber_angle, stacking_sequence]
    design_bounds = [
        0.125, 0.250;    % í”Œë¼ì´ ë‘ê»˜ [mm]
        0, 90;           % ì„¬ìœ ê°ë„ [ë„]
        1, 4             % ì ì¸µ ìˆœì„œ ì˜µì…˜
    ];
    
    % ë¶ˆí™•ì‹¤ì„± ëª¨ë¸
    uncertainties = struct();
    uncertainties.load_factor = struct('type', 'normal', 'mean', 2.5, 'std', 0.5);  % í•˜ì¤‘ê³„ìˆ˜
    uncertainties.material_E11 = struct('type', 'normal', 'mean', 150e9, 'std', 15e9);  % ì¢…ë°©í–¥ íƒ„ì„±ê³„ìˆ˜
    uncertainties.material_E22 = struct('type', 'normal', 'mean', 10e9, 'std', 2e9);    % íš¡ë°©í–¥ íƒ„ì„±ê³„ìˆ˜
    uncertainties.temperature = struct('type', 'uniform', 'lower', -55, 'upper', 125);   % ìš´ì˜ì˜¨ë„ [Â°C]
    
    % ë‹¤ì¤‘ ì‹¤íŒ¨ ëª¨ë“œ
    failure_modes = {
        @(design, uncertain) fiber_failure_criterion(design, uncertain);
        @(design, uncertain) matrix_failure_criterion(design, uncertain);
        @(design, uncertain) buckling_failure_criterion(design, uncertain);
        @(design, uncertain) fatigue_failure_criterion(design, uncertain)
    };
    
    % ìš”êµ¬ ì‹ ë¢°ì„± ìˆ˜ì¤€
    required_reliability = [0.999, 0.995, 0.99, 0.95];  % ê° ì‹¤íŒ¨ëª¨ë“œë³„
    
    % ë‹¤ëª©ì  ê°•ê±´ì„¤ê³„ ìµœì í™”
    [design_optimal, reliability_levels] = multi_failure_mode_rbdo(design_bounds, uncertainties, failure_modes, required_reliability);
    
    % ê²°ê³¼ ì¶œë ¥
    fprintf('Optimal design:\n');
    fprintf('  Ply thickness: %.3f mm\n', design_optimal(1));
    fprintf('  Fiber angle: %.1f degrees\n', design_optimal(2));
    fprintf('  Stacking sequence: %d\n', round(design_optimal(3)));
    
    fprintf('Achieved reliability levels:\n');
    for i = 1:length(reliability_levels)
        fprintf('  Failure mode %d: %.6f\n', i, reliability_levels(i));
    end
end

function margin = fiber_failure_criterion(design, uncertain)
    % Tsai-Wu íŒŒì† ê¸°ì¤€
    ply_thickness = design(1);
    fiber_angle = design(2);
    
    % ì‘ë ¥ ê³„ì‚° (ê°„ì†Œí™”ëœ ëª¨ë¸)
    load = uncertain.load_factor * 1000;  % ê¸°ì¤€í•˜ì¤‘ 1000N
    stress = load / (ply_thickness * 0.1);  % ì‘ë ¥ [Pa]
    
    % ì˜¨ë„ ë³´ì •
    temp_factor = 1 - 0.001 * (uncertain.temperature - 20);
    effective_strength = uncertain.material_E11 * 0.01 * temp_factor;  % ê°„ì†Œí™”ëœ ê°•ë„
    
    % ì•ˆì „ì—¬ìœ 
    margin = effective_strength - stress;
end
```

### ì‚¬ë¡€ 3: ë¡œë´‡ ì œì–´ ì‹œìŠ¤í…œ

**ë§¤ê°œë³€ìˆ˜ ë³€ë™ì— ê°•ê±´í•œ ì œì–´ê¸° ì„¤ê³„:**
```matlab
function robust_controller = robust_robot_control_design()
    % ë¡œë´‡ ë§¤ë‹ˆí“°ë ˆì´í„° ê°•ê±´ ì œì–´
    
    % ê³µì¹­ í”ŒëœíŠ¸ ëª¨ë¸
    s = tf('s');
    nominal_plant = 100 / (s^2 + 10*s + 100);
    
    % ë¶ˆí™•ì‹¤ì„± ëª¨ë¸ (ë§¤ê°œë³€ìˆ˜ ë³€ë™)
    uncertainty_params = struct();
    uncertainty_params.inertia_variation = 0.3;      % Â±30% ê´€ì„± ë³€ë™
    uncertainty_params.damping_variation = 0.5;      % Â±50% ëŒí•‘ ë³€ë™
    uncertainty_params.payload_variation = [0, 2];   % 0-2kg í˜ì´ë¡œë“œ ë³€ë™
    
    % Hâˆ ê°•ê±´ ì œì–´ê¸° ì„¤ê³„
    [robust_controller, gamma_opt] = hinf_robust_design(nominal_plant, uncertainty_params);
    
    % ì„±ëŠ¥ ê²€ì¦
    validate_robust_performance(robust_controller, nominal_plant, uncertainty_params);
end

function [controller, gamma] = hinf_robust_design(plant, uncertainty)
    % Hâˆ ë£¨í”„ ì„±í˜• ë°©ë²•
    
    % ê°€ì¤‘í•¨ìˆ˜ ì„¤ì •
    % ì„±ëŠ¥ ê°€ì¤‘í•¨ìˆ˜ (ì¶”ì  ì„±ëŠ¥)
    Wp = tf([1, 1], [1, 0.01]);  % ì €ì£¼íŒŒì—ì„œ ë†’ì€ ì„±ëŠ¥ ìš”êµ¬
    
    % ì œì–´ ê°€ì¤‘í•¨ìˆ˜ (ì•¡ì¶”ì—ì´í„° ì œí•œ)
    Wu = tf([1, 100], [1, 1000]); % ê³ ì£¼íŒŒì—ì„œ ì œì–´ ì‹ í˜¸ ì œí•œ
    
    % ê°•ê±´ì„± ê°€ì¤‘í•¨ìˆ˜
    Wt = tf([1, 10], [1, 1]);   % ëª¨ë¸ ë¶ˆí™•ì‹¤ì„±
    
    % í™•ì¥ëœ í”ŒëœíŠ¸ êµ¬ì„±
    P = augmented_plant(plant, Wp, Wu, Wt);
    
    % Hâˆ ìµœì í™”
    [controller, ~, gamma] = hinfsyn(P, 1, 1);
    
    fprintf('H-infinity norm: %.3f\n', gamma);
end

function validate_robust_performance(controller, nominal_plant, uncertainty)
    % ëª¬í…Œì¹´ë¥´ë¡œ ê²€ì¦
    n_tests = 1000;
    settling_times = zeros(n_tests, 1);
    overshoots = zeros(n_tests, 1);
    
    for i = 1:n_tests
        % ë¶ˆí™•ì‹¤ì„± ìƒ˜í”Œë§
        inertia_factor = 1 + uncertainty.inertia_variation * (2*rand - 1);
        damping_factor = 1 + uncertainty.damping_variation * (2*rand - 1);
        
        % ë³€ë™ëœ í”ŒëœíŠ¸
        varied_plant = nominal_plant * inertia_factor;
        % ëŒí•‘ ë³€ë™ ë°˜ì˜ (ê°„ì†Œí™”)
        
        % íë£¨í”„ ì‹œìŠ¤í…œ
        closed_loop = feedback(controller * varied_plant, 1);
        
        % ë‹¨ìœ„ê³„ë‹¨ì‘ë‹µ íŠ¹ì„±
        step_info = stepinfo(closed_loop);
        settling_times(i) = step_info.SettlingTime;
        overshoots(i) = step_info.Overshoot;
    end
    
    % í†µê³„ ë¶„ì„
    fprintf('Settling time: %.3f Â± %.3f seconds\n', mean(settling_times), std(settling_times));
    fprintf('Overshoot: %.1f Â± %.1f %%\n', mean(overshoots), std(overshoots));
    
    % ì‚¬ì–‘ ë§Œì¡±ë„ í™•ì¸
    spec_settling_time = 2.0;  % 2ì´ˆ ì´ë‚´
    spec_overshoot = 10;       % 10% ì´ë‚´
    
    prob_settling_ok = mean(settling_times <= spec_settling_time);
    prob_overshoot_ok = mean(overshoots <= spec_overshoot);
    
    fprintf('Probability of meeting settling time spec: %.3f\n', prob_settling_ok);
    fprintf('Probability of meeting overshoot spec: %.3f\n', prob_overshoot_ok);
end
```

---

## ğŸ’» ê³ ê¸‰ êµ¬í˜„ ë„êµ¬

### ì ì‘ì  ìƒ˜í”Œë§ ê¸°ë²•

```matlab
classdef AdaptiveSampling < handle
    properties
        sample_points
        sample_values
        uncertainty_model
        surrogate_model
        refinement_criteria
    end
    
    methods
        function obj = AdaptiveSampling(initial_samples, uncertainty_model)
            obj.sample_points = initial_samples.points;
            obj.sample_values = initial_samples.values;
            obj.uncertainty_model = uncertainty_model;
            obj.build_surrogate_model();
        end
        
        function build_surrogate_model(obj)
            % í¬ë¦¬ê¹… ë˜ëŠ” ë‹¤í•­ì‹ íšŒê·€ ëª¨ë¸ êµ¬ì¶•
            obj.surrogate_model = fitrgp(obj.sample_points, obj.sample_values);
        end
        
        function new_samples = adaptive_refinement(obj, n_new_samples)
            % ë¶ˆí™•ì‹¤ì„±ì´ ë†’ì€ ì˜ì—­ì— ìƒˆë¡œìš´ ìƒ˜í”Œ ì¶”ê°€
            candidate_points = obj.generate_candidate_points(1000);
            
            % ì˜ˆì¸¡ ë¶ˆí™•ì‹¤ì„± í‰ê°€
            [~, prediction_std] = predict(obj.surrogate_model, candidate_points);
            
            % ë†’ì€ ë¶ˆí™•ì‹¤ì„±ì„ ê°€ì§„ ì ë“¤ ì„ íƒ
            [~, sorted_indices] = sort(prediction_std, 'descend');
            selected_indices = sorted_indices(1:n_new_samples);
            
            new_samples.points = candidate_points(selected_indices, :);
            
            % ì‹¤ì œ í•¨ìˆ˜ í‰ê°€
            new_samples.values = zeros(n_new_samples, 1);
            for i = 1:n_new_samples
                new_samples.values(i) = obj.evaluate_expensive_function(new_samples.points(i, :));
            end
            
            % ìƒ˜í”Œ ë°ì´í„°ë² ì´ìŠ¤ ì—…ë°ì´íŠ¸
            obj.sample_points = [obj.sample_points; new_samples.points];
            obj.sample_values = [obj.sample_values; new_samples.values];
            
            % ëŒ€ë¦¬ëª¨ë¸ ì¬êµ¬ì¶•
            obj.build_surrogate_model();
        end
        
        function candidates = generate_candidate_points(obj, n_candidates)
            % ë¶ˆí™•ì‹¤ì„± ë¶„í¬ì— ë”°ë¥¸ í›„ë³´ì  ìƒì„±
            candidates = zeros(n_candidates, length(fieldnames(obj.uncertainty_model)));
            
            param_names = fieldnames(obj.uncertainty_model);
            for i = 1:length(param_names)
                param = obj.uncertainty_model.(param_names{i});
                
                switch param.type
                    case 'normal'
                        candidates(:, i) = normrnd(param.mean, param.std, [n_candidates, 1]);
                    case 'uniform'
                        candidates(:, i) = unifrnd(param.lower, param.upper, [n_candidates, 1]);
                end
            end
        end
        
        function value = evaluate_expensive_function(obj, design_point)
            % ì‹¤ì œ ë¹„ìš©ì´ ë†’ì€ í•¨ìˆ˜ í‰ê°€ (ìœ í•œìš”ì†Œí•´ì„ ë“±)
            value = expensive_system_analysis(design_point);
        end
    end
end
```

---

**ì°¸ê³ ë¬¸í—Œ:**
- Taguchi, G., Chowdhury, S. & Wu, Y. (2004). *Taguchi's Quality Engineering Handbook*. Wiley.
- Beyer, H.G. & Sendhoff, B. (2007). Robust optimizationâ€“a comprehensive survey. *Computer Methods in Applied Mechanics and Engineering*, 196(33-34), 3190-3218.
- Ben-Tal, A., El Ghaoui, L. & Nemirovski, A. (2009). *Robust Optimization*. Princeton University Press.
- Phadke, M.S. (1989). *Quality Engineering Using Robust Design*. Prentice Hall.
---

## ğŸ“ í•™ìŠµ ë‹¨ê³„ë³„ ê°€ì´ë“œ

### ì´ˆê¸‰ (1-2ê°œì›”)

**1ì£¼ì°¨: ë¶ˆí™•ì‹¤ì„± ì´í•´**
```matlab
% ê°„ë‹¨í•œ í™•ë¥ ë¶„í¬ ì²´í—˜
mu = 100; sigma = 10;
samples = normrnd(mu, sigma, [1000, 1]);

figure;
subplot(1,2,1);
histogram(samples, 30);
title('Random Samples');
xlabel('Value'); ylabel('Frequency');

subplot(1,2,2);
plot(samples);
title('Sample Sequence');
xlabel('Sample Number'); ylabel('Value');

% í†µê³„ëŸ‰ ê³„ì‚°
fprintf('Theoretical: Î¼=%.1f, Ïƒ=%.1f\n', mu, sigma);
fprintf('Empirical: Î¼=%.1f, Ïƒ=%.1f\n', mean(samples), std(samples));
```

**2ì£¼ì°¨: ì„±ëŠ¥ ë³€ë™ì„± ë¶„ì„**
```matlab
% ê°„ë‹¨í•œ êµ¬ì¡°ë¬¼ì˜ ì„±ëŠ¥ ë³€ë™
function deflection = simple_beam_deflection(load, length, moment_of_inertia, elastic_modulus)
    deflection = load * length^3 / (3 * elastic_modulus * moment_of_inertia);
end

% ëª…ëª©ê°’
P_nominal = 1000;    % N
L_nominal = 1;       % m  
I_nominal = 8.33e-6; % m^4 (10cm x 10cm ì‚¬ê° ë‹¨ë©´)
E_nominal = 200e9;   % Pa

% ë¶ˆí™•ì‹¤ì„±
n_samples = 1000;
P_samples = normrnd(P_nominal, 0.1*P_nominal, [n_samples, 1]);  % Â±10%
E_samples = normrnd(E_nominal, 0.05*E_nominal, [n_samples, 1]); % Â±5%

deflections = zeros(n_samples, 1);
for i = 1:n_samples
    deflections(i) = simple_beam_deflection(P_samples(i), L_nominal, I_nominal, E_samples(i));
end

% ê²°ê³¼ ë¶„ì„
fprintf('Deflection statistics:\n');
fprintf('  Mean: %.2e m\n', mean(deflections));
fprintf('  Std:  %.2e m\n', std(deflections));
fprintf('  CV:   %.1f%%\n', 100*std(deflections)/mean(deflections));
```

**3-4ì£¼ì°¨: ë‹¤êµ¬ì¹˜ ë°©ë²• ê¸°ì´ˆ**
```matlab
% L4 ì§êµë°°ì—´ ì‹¤ìŠµ
factors = {
    'A', [1, 2];      % ì¸ì A (2ìˆ˜ì¤€)
    'B', [1, 2];      % ì¸ì B (2ìˆ˜ì¤€)  
    'C', [1, 2]       % ì¸ì C (2ìˆ˜ì¤€)
};

% L4 = 2^3 ì§êµë°°ì—´
L4_array = [
    1, 1, 1;
    1, 2, 2;
    2, 1, 2;
    2, 2, 1
];

% ê° ì‹¤í—˜ì˜ ì‘ë‹µê°’ (ì˜ˆì‹œ)
responses = [
    [20, 18, 22, 19];   % ì‹¤í—˜ 1: 4ê°œ ë°˜ë³µ
    [25, 23, 27, 24];   % ì‹¤í—˜ 2
    [15, 17, 14, 16];   % ì‹¤í—˜ 3
    [30, 28, 32, 29]    % ì‹¤í—˜ 4
];

% S/N ë¹„ ê³„ì‚° (í° ê°’ì´ ì¢‹ì€ ê²½ìš°)
snr = zeros(4, 1);
for i = 1:4
    snr(i) = -10 * log10(mean(1./responses(i,:).^2));
end

% ì£¼íš¨ê³¼ ë¶„ì„
effect_A = mean(snr([1,2])) - mean(snr([3,4]));  % Aì˜ 1ìˆ˜ì¤€ vs 2ìˆ˜ì¤€
effect_B = mean(snr([1,3])) - mean(snr([2,4]));  % Bì˜ 1ìˆ˜ì¤€ vs 2ìˆ˜ì¤€  
effect_C = mean(snr([1,4])) - mean(snr([2,3]));  % Cì˜ 1ìˆ˜ì¤€ vs 2ìˆ˜ì¤€

fprintf('Main effects on S/N ratio:\n');
fprintf('  Factor A: %.2f dB\n', effect_A);
fprintf('  Factor B: %.2f dB\n', effect_B);
fprintf('  Factor C: %.2f dB\n', effect_C);

% ìµœì  ì¡°í•© ê²°ì •
[~, best_A] = max([mean(snr([1,2])), mean(snr([3,4]))]);
[~, best_B] = max([mean(snr([1,3])), mean(snr([2,4]))]);
[~, best_C] = max([mean(snr([1,4])), mean(snr([2,3]))]);

fprintf('Optimal factor levels: A%d-B%d-C%d\n', best_A, best_B, best_C);
```

### ì¤‘ê¸‰ (3-4ê°œì›”)

**5-8ì£¼ì°¨: 6ì‹œê·¸ë§ˆ ë°©ë²•ë¡ **
```matlab
% ê³µì •ëŠ¥ë ¥ ë¶„ì„ ì‹¤ìŠµ
function process_capability_study()
    % ì‹¤ì œ ìƒì‚° ë°ì´í„° ì‹œë®¬ë ˆì´ì…˜
    true_mean = 100.2;    % ê³µì • í‰ê·  (ì•½ê°„ í¸í–¥)
    true_std = 1.5;       % ê³µì • í‘œì¤€í¸ì°¨
    n_samples = 100;      % ìƒ˜í”Œ í¬ê¸°
    
    production_data = normrnd(true_mean, true_std, [n_samples, 1]);
    
    % ê·œê²©í•œê³„
    LSL = 95;   % í•˜í•œ ê·œê²©
    USL = 105;  % ìƒí•œ ê·œê²©
    target = 100; % ëª©í‘œê°’
    
    % í†µê³„ëŸ‰ ê³„ì‚°
    x_bar = mean(production_data);
    s = std(production_data);
    
    % ê³µì •ëŠ¥ë ¥ì§€ìˆ˜
    Cp = (USL - LSL) / (6 * s);
    Cpu = (USL - x_bar) / (3 * s);
    Cpl = (x_bar - LSL) / (3 * s);
    Cpk = min(Cpu, Cpl);
    
    % ê³µì •ì„±ëŠ¥ì§€ìˆ˜ (ëª©í‘œê°’ ê³ ë ¤)
    Cpm = (USL - LSL) / (6 * sqrt(s^2 + (x_bar - target)^2));
    
    % ê²°í•¨ë¥  ì¶”ì •
    defect_rate_lower = normcdf(LSL, x_bar, s);
    defect_rate_upper = 1 - normcdf(USL, x_bar, s);
    total_defect_rate = defect_rate_lower + defect_rate_upper;
    defect_ppm = total_defect_rate * 1e6;
    
    % ê²°ê³¼ ì¶œë ¥
    fprintf('=== Process Capability Study ===\n');
    fprintf('Sample statistics: Î¼Ì‚=%.2f, ÏƒÌ‚=%.2f\n', x_bar, s);
    fprintf('Capability indices:\n');
    fprintf('  Cp  = %.3f\n', Cp);
    fprintf('  Cpk = %.3f\n', Cpk);
    fprintf('  Cpm = %.3f\n', Cpm);
    fprintf('Estimated defect rate: %.1f ppm\n', defect_ppm);
    
    % ì‹œê·¸ë§ˆ ìˆ˜ì¤€ í‰ê°€
    if Cpk >= 2.0
        sigma_level = 6;
    elseif Cpk >= 1.67
        sigma_level = 5;
    elseif Cpk >= 1.33
        sigma_level = 4;
    else
        sigma_level = 3;
    end
    fprintf('Approximate sigma level: %d\n', sigma_level);
    
    % ê·¸ë˜í”„ ìƒì„±
    figure;
    x_range = min(production_data)-3*s:0.1:max(production_data)+3*s;
    pdf_values = normpdf(x_range, x_bar, s);
    
    plot(x_range, pdf_values, 'b-', 'LineWidth', 2);
    hold on;
    xline(LSL, 'r--', 'LSL', 'LineWidth', 2);
    xline(USL, 'r--', 'USL', 'LineWidth', 2);
    xline(target, 'g--', 'Target', 'LineWidth', 2);
    xline(x_bar, 'b:', 'Process Mean', 'LineWidth', 1);
    
    % ê·œê²© ì™¸ ì˜ì—­ ìŒì˜
    x_defect_lower = x_range(x_range <= LSL);
    y_defect_lower = normpdf(x_defect_lower, x_bar, s);
    x_defect_upper = x_range(x_range >= USL);  
    y_defect_upper = normpdf(x_defect_upper, x_bar, s);
    
    fill([x_defect_lower, LSL], [y_defect_lower, 0], 'r', 'FaceAlpha', 0.3);
    fill([USL, x_defect_upper], [0, y_defect_upper], 'r', 'FaceAlpha', 0.3);
    
    xlabel('Measurement Value');
    ylabel('Probability Density');
    title('Process Capability Analysis');
    legend('Process Distribution', 'Specification Limits', '', 'Target', 'Process Mean', 'Defect Areas');
    grid on;
end

process_capability_study();
```

**9-12ì£¼ì°¨: ì‹ ë¢°ì„± ê¸°ë°˜ ì„¤ê³„**
```matlab
% ì‹ ë¢°ì„± í•´ì„ ì‹¤ìŠµ
function reliability_analysis_example()
    % êµ¬ì¡° ë¶€ì¬ì˜ ì‹ ë¢°ì„± í•´ì„
    
    % í™•ë¥ ë³€ìˆ˜ ì •ì˜
    load_mean = 50000;     % í‰ê·  í•˜ì¤‘ [N]
    load_std = 10000;      % í•˜ì¤‘ í‘œì¤€í¸ì°¨
    strength_mean = 80000; % í‰ê·  ê°•ë„ [N]  
    strength_std = 8000;   % ê°•ë„ í‘œì¤€í¸ì°¨
    
    % ì•ˆì „ì—¬ìœ  ë¶„í¬
    safety_margin_mean = strength_mean - load_mean;
    safety_margin_std = sqrt(strength_std^2 + load_std^2);
    
    % íŒŒì†í™•ë¥  (í•´ì„í•´)
    beta = safety_margin_mean / safety_margin_std;  % ì‹ ë¢°ì„± ì§€ìˆ˜
    pf_analytical = normcdf(-beta);
    reliability_analytical = 1 - pf_analytical;
    
    % ëª¬í…Œì¹´ë¥´ë¡œ ì‹œë®¬ë ˆì´ì…˜ ê²€ì¦
    n_mc = 100000;
    load_samples = normrnd(load_mean, load_std, [n_mc, 1]);
    strength_samples = normrnd(strength_mean, strength_std, [n_mc, 1]);
    
    failures = load_samples > strength_samples;
    pf_mc = mean(failures);
    reliability_mc = 1 - pf_mc;
    
    % ê²°ê³¼ ë¹„êµ
    fprintf('=== Reliability Analysis ===\n');
    fprintf('Analytical approach:\n');
    fprintf('  Reliability index Î² = %.3f\n', beta);
    fprintf('  Failure probability = %.2e\n', pf_analytical);
    fprintf('  Reliability = %.6f\n', reliability_analytical);
    
    fprintf('Monte Carlo simulation (%d samples):\n', n_mc);
    fprintf('  Failure probability = %.2e\n', pf_mc);
    fprintf('  Reliability = %.6f\n', reliability_mc);
    
    % ë¯¼ê°ë„ ë¶„ì„
    fprintf('\nSensitivity analysis:\n');
    alpha_load = -load_std / safety_margin_std;
    alpha_strength = strength_std / safety_margin_std;
    fprintf('  Load importance factor Î±_R = %.3f\n', alpha_load);
    fprintf('  Strength importance factor Î±_S = %.3f\n', alpha_strength);
    
    % ì‹œê°í™”
    figure;
    x_range = 0:1000:150000;
    
    % í•˜ì¤‘ê³¼ ê°•ë„ ë¶„í¬
    subplot(2,1,1);
    plot(x_range, normpdf(x_range, load_mean, load_std), 'r-', 'LineWidth', 2);
    hold on;
    plot(x_range, normpdf(x_range, strength_mean, strength_std), 'b-', 'LineWidth', 2);
    xlabel('Value [N]');
    ylabel('Probability Density');
    title('Load and Strength Distributions');
    legend('Load', 'Strength');
    grid on;
    
    % ì•ˆì „ì—¬ìœ  ë¶„í¬
    subplot(2,1,2);
    margin_range = -40000:1000:80000;
    plot(margin_range, normpdf(margin_range, safety_margin_mean, safety_margin_std), 'g-', 'LineWidth', 2);
    hold on;
    xline(0, 'k--', 'Failure Boundary', 'LineWidth', 2);
    
    % íŒŒì† ì˜ì—­ ìŒì˜
    failure_region = margin_range(margin_range <= 0);
    failure_pdf = normpdf(failure_region, safety_margin_mean, safety_margin_std);
    fill([failure_region, 0], [failure_pdf, 0], 'r', 'FaceAlpha', 0.3);
    
    xlabel('Safety Margin [N]');
    ylabel('Probability Density'); 
    title('Safety Margin Distribution');
    legend('Safety Margin', 'Failure Boundary', 'Failure Region');
    grid on;
end

reliability_analysis_example();
```

### ê³ ê¸‰ (6ê°œì›”+)

**ê³ ê¸‰ ì£¼ì œ:**
- ë‹¤ë¶„ì•¼ ë¶ˆí™•ì‹¤ì„± ì „íŒŒ
- ë² ì´ì§€ì•ˆ ì—…ë°ì´íŠ¸ë¥¼ í†µí•œ ì ì‘ì  ê°•ê±´ì„¤ê³„
- ê¸°ê³„í•™ìŠµ ê¸°ë°˜ ëŒ€ë¦¬ëª¨ë¸ í™œìš©
- ì‹¤ì‹œê°„ ê°•ê±´ì œì–´

**ì‹¤ë¬´ í”„ë¡œì íŠ¸:**
- ë³µì¡í•œ ì‹œìŠ¤í…œì˜ ê°•ê±´ì„¤ê³„
- ìƒì‚° ê³µì • ìµœì í™”
- í’ˆì§ˆê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬ì¶•

---

## ğŸ”§ ì‹¤ë¬´ ì ìš© íŒ

### ë¶ˆí™•ì‹¤ì„± ëª¨ë¸ë§

**ë°ì´í„° ê¸°ë°˜ ë¶„í¬ ì¶”ì •:**
```matlab
function best_distribution = fit_uncertainty_distribution(data)
    % ì—¬ëŸ¬ ë¶„í¬ì— ëŒ€í•œ ì í•©ë„ ê²€ì •
    distributions = {'normal', 'lognormal', 'weibull', 'gamma'};
    
    best_aic = Inf;
    best_distribution = struct();
    
    for i = 1:length(distributions)
        try
            pd = fitdist(data, distributions{i});
            
            % AIC (Akaike Information Criterion) ê³„ì‚°
            log_likelihood = sum(log(pdf(pd, data)));
            k = numel(pd.ParameterValues);  % ë§¤ê°œë³€ìˆ˜ ê°œìˆ˜
            aic = 2*k - 2*log_likelihood;
            
            if aic < best_aic
                best_aic = aic;
                best_distribution.type = distributions{i};
                best_distribution.parameters = pd.ParameterValues;
                best_distribution.fitted_object = pd;
                best_distribution.aic = aic;
            end
            
        catch
            % ì í•©ì— ì‹¤íŒ¨í•œ ë¶„í¬ëŠ” ë¬´ì‹œ
            continue;
        end
    end
    
    fprintf('Best fitting distribution: %s (AIC = %.2f)\n', ...
            best_distribution.type, best_distribution.aic);
end
```

**ì „ë¬¸ê°€ ì§€ì‹ í†µí•©:**
```matlab
function combined_uncertainty = expert_knowledge_integration(data, expert_opinions)
    % ë°ì´í„°ì™€ ì „ë¬¸ê°€ ì˜ê²¬ì„ ë² ì´ì§€ì•ˆ ë°©ì‹ìœ¼ë¡œ ê²°í•©
    
    % ë°ì´í„° ê¸°ë°˜ ìš°ë„í•¨ìˆ˜
    data_mean = mean(data);
    data_std = std(data);
    
    % ì „ë¬¸ê°€ ì˜ê²¬ (ì‚¬ì „ë¶„í¬)
    expert_mean = expert_opinions.mean;
    expert_confidence = expert_opinions.confidence;  % ë‚®ì„ìˆ˜ë¡ ë¶„ì‚° í¼
    expert_std = expert_opinions.std / sqrt(expert_confidence);
    
    % ë² ì´ì§€ì•ˆ ì—…ë°ì´íŠ¸
    precision_data = 1 / data_std^2;
    precision_expert = 1 / expert_std^2;
    
    posterior_precision = precision_data + precision_expert;
    posterior_mean = (precision_data * data_mean + precision_expert * expert_mean) / posterior_precision;
    posterior_std = 1 / sqrt(posterior_precision);
    
    combined_uncertainty = struct();
    combined_uncertainty.mean = posterior_mean;
    combined_uncertainty.std = posterior_std;
    combined_uncertainty.confidence_interval = [
        posterior_mean - 1.96*posterior_std, 
        posterior_mean + 1.96*posterior_std
    ];
    
    fprintf('Combined uncertainty estimate:\n');
    fprintf('  Mean: %.3f\n', posterior_mean);
    fprintf('  Std: %.3f\n', posterior_std);
    fprintf('  95%% CI: [%.3f, %.3f]\n', combined_uncertainty.confidence_interval);
end
```

### ê³„ì‚° íš¨ìœ¨ì„± ê°œì„ 

**ì ì‘ì  ìƒ˜í”Œë§:**
```matlab
function efficient_robust_design = adaptive_robust_optimization(objective, constraints, initial_budget)
    % ì œí•œëœ í•¨ìˆ˜ í‰ê°€ íšŸìˆ˜ë¡œ íš¨ìœ¨ì  ê°•ê±´ì„¤ê³„
    
    current_budget = initial_budget;
    batch_size = 10;
    
    % ì´ˆê¸° íƒìƒ‰ì  ìƒ˜í”Œë§
    initial_samples = latin_hypercube_sampling(batch_size);
    sample_database = struct('points', initial_samples, 'values', []);
    
    % ì´ˆê¸° í‰ê°€
    for i = 1:size(initial_samples, 1)
        sample_database.values(i) = expensive_robust_evaluation(initial_samples(i, :));
        current_budget = current_budget - 1;
    end
    
    iteration = 1;
    while current_budget > 0
        fprintf('Iteration %d: Remaining budget = %d\n', iteration, current_budget);
        
        % ëŒ€ë¦¬ëª¨ë¸ êµ¬ì¶•
        surrogate = fitrgp(sample_database.points, sample_database.values);
        
        % ë‹¤ìŒ í‰ê°€ì  ì„ íƒ (Expected Improvement ê¸°ì¤€)
        candidate_points = latin_hypercube_sampling(1000);
        [~, ei_values] = expected_improvement(surrogate, candidate_points, sample_database);
        
        [~, best_candidate_idx] = max(ei_values);
        next_point = candidate_points(best_candidate_idx, :);
        
        % ìƒˆë¡œìš´ ì  í‰ê°€
        next_value = expensive_robust_evaluation(next_point);
        
        % ë°ì´í„°ë² ì´ìŠ¤ ì—…ë°ì´íŠ¸
        sample_database.points(end+1, :) = next_point;
        sample_database.values(end+1) = next_value;
        
        current_budget = current_budget - 1;
        iteration = iteration + 1;
    end
    
    % ìµœì¢… ìµœì í•´ ì„ íƒ
    [~, best_idx] = min(sample_database.values);
    efficient_robust_design = sample_database.points(best_idx, :);
end

function [mean_pred, ei] = expected_improvement(surrogate, candidates, current_best)
    [mean_pred, std_pred] = predict(surrogate, candidates);
    
    f_min = min(current_best.values);
    improvement = f_min - mean_pred;
    
    % Expected Improvement ê³„ì‚°
    z = improvement ./ std_pred;
    ei = improvement .* normcdf(z) + std_pred .* normpdf(z);
    
    % ë¶„ì‚°ì´ 0ì¸ ì ë“¤ ì²˜ë¦¬
    ei(std_pred == 0) = 0;
end
```

### ë‹¤ë‹¨ê³„ ê°•ê±´ì„¤ê³„

```matlab
function hierarchical_robust_design = multi_level_robust_optimization()
    % ì‹œìŠ¤í…œ ë ˆë²¨ê³¼ ì»´í¬ë„ŒíŠ¸ ë ˆë²¨ì˜ ê³„ì¸µì  ê°•ê±´ì„¤ê³„
    
    % 1ë‹¨ê³„: ì‹œìŠ¤í…œ ë ˆë²¨ ê°œë…ì„¤ê³„
    system_level_design = system_concept_optimization();
    
    % 2ë‹¨ê³„: ì„œë¸Œì‹œìŠ¤í…œ ë ˆë²¨ ìƒì„¸ì„¤ê³„
    subsystem_designs = cell(3, 1);  % 3ê°œ ì„œë¸Œì‹œìŠ¤í…œ
    
    for i = 1:3
        subsystem_designs{i} = subsystem_robust_design(system_level_design, i);
    end
    
    % 3ë‹¨ê³„: ì‹œìŠ¤í…œ í†µí•© ë° ê²€ì¦
    integrated_design = system_integration(system_level_design, subsystem_designs);
    
    % 4ë‹¨ê³„: ì „ì²´ ì‹œìŠ¤í…œ ê°•ê±´ì„± ê²€ì¦
    system_robustness = validate_system_robustness(integrated_design);
    
    hierarchical_robust_design = struct();
    hierarchical_robust_design.system_level = system_level_design;
    hierarchical_robust_design.subsystem_level = subsystem_designs;
    hierarchical_robust_design.integrated = integrated_design;
    hierarchical_robust_design.robustness_metrics = system_robustness;
end

function design = subsystem_robust_design(system_requirements, subsystem_id)
    % ì„œë¸Œì‹œìŠ¤í…œë³„ ê°•ê±´ì„¤ê³„
    
    % ì‹œìŠ¤í…œ ìš”êµ¬ì‚¬í•­ì„ ì„œë¸Œì‹œìŠ¤í…œ ì‚¬ì–‘ìœ¼ë¡œ ë¶„í•´
    local_requirements = decompose_requirements(system_requirements, subsystem_id);
    
    % ì„œë¸Œì‹œìŠ¤í…œ ë¶ˆí™•ì‹¤ì„± ëª¨ë¸
    local_uncertainties = define_local_uncertainties(subsystem_id);
    
    % ì„œë¸Œì‹œìŠ¤í…œ ê°•ê±´ìµœì í™”
    design = robust_optimization_with_constraints(local_requirements, local_uncertainties);
    
    % ìƒìœ„ ì‹œìŠ¤í…œìœ¼ë¡œì˜ ë¶ˆí™•ì‹¤ì„± ì „íŒŒ
    propagated_uncertainty = uncertainty_propagation(design, local_uncertainties);
    design.uncertainty_contribution = propagated_uncertainty;
end
```

---

## ğŸ“ˆ ìµœì‹  ì—°êµ¬ ë™í–¥

### ê¸°ê³„í•™ìŠµ ê¸°ë°˜ ê°•ê±´ì„¤ê³„

```matlab
% ë”¥ëŸ¬ë‹ì„ í™œìš©í•œ ê³ ì°¨ì› ë¶ˆí™•ì‹¤ì„± ì²˜ë¦¬
function ml_robust_design = machine_learning_robust_optimization()
    % ì‹ ê²½ë§ ê¸°ë°˜ ëŒ€ë¦¬ëª¨ë¸ì„ í™œìš©í•œ ê°•ê±´ì„¤ê³„
    
    % í›ˆë ¨ ë°ì´í„° ìƒì„±
    training_data = generate_high_dimensional_training_data(1000);
    
    % ë”¥ ê°€ìš°ì‹œì•ˆ í”„ë¡œì„¸ìŠ¤ ëª¨ë¸ êµ¬ì¶•
    surrogate_model = train_deep_gaussian_process(training_data);
    
    % ë¶ˆí™•ì‹¤ì„± ì •ëŸ‰í™”ë¥¼ í¬í•¨í•œ ìµœì í™”
    [optimal_design, uncertainty_bounds] = bayesian_robust_optimization(surrogate_model);
    
    ml_robust_design = struct();
    ml_robust_design.optimal_point = optimal_design;
    ml_robust_design.uncertainty_quantification = uncertainty_bounds;
    ml_robust_design.model_confidence = evaluate_model_confidence(surrogate_model, optimal_design);
end
```

### ì ì‘ì  ê°•ê±´ì œì–´

```matlab
% ì‹¤ì‹œê°„ ì‹œìŠ¤í…œ ì‹ë³„ê³¼ ì œì–´ê¸° ì ì‘
function adaptive_controller = real_time_robust_adaptation()
    % ì˜¨ë¼ì¸ ì‹œìŠ¤í…œ ì‹ë³„
    system_identifier = recursive_least_squares_with_forgetting();
    
    % ì ì‘ì  ê°•ê±´ì œì–´ê¸°
    robust_controller = adaptive_h_infinity_controller();
    
    % ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë° ì¬ì„¤ê³„ íŠ¸ë¦¬ê±°
    performance_monitor = statistical_change_detection();
    
    adaptive_controller = struct();
    adaptive_controller.identifier = system_identifier;
    adaptive_controller.controller = robust_controller;
    adaptive_controller.monitor = performance_monitor;
end
```

---

## ğŸ† ì„±ê³µì ì¸ ê°•ê±´ì„¤ê³„ë¥¼ ìœ„í•œ ì²´í¬ë¦¬ìŠ¤íŠ¸

### í”„ë¡œì íŠ¸ ì‹œì‘ ë‹¨ê³„
- [ ] ì£¼ìš” ë¶ˆí™•ì‹¤ì„± ìš”ì¸ ì‹ë³„ ì™„ë£Œ
- [ ] ë¶ˆí™•ì‹¤ì„± ë°ì´í„° ìˆ˜ì§‘ ê³„íš ìˆ˜ë¦½
- [ ] ì„±ëŠ¥ ì§€í‘œì™€ í—ˆìš© ë³€ë™ ë²”ìœ„ ì •ì˜
- [ ] ê³„ì‚° ìì›ê³¼ ì‹œê°„ ì˜ˆì‚° ì„¤ì •

### ì„¤ê³„ ë‹¨ê³„
- [ ] ì ì ˆí•œ ê°•ê±´ì„¤ê³„ ë°©ë²•ë¡  ì„ íƒ
- [ ] ë¶ˆí™•ì‹¤ì„± ëª¨ë¸ì˜ íƒ€ë‹¹ì„± ê²€ì¦
- [ ] ë‹¤ì–‘í•œ ì‹œë‚˜ë¦¬ì˜¤ì—ì„œì˜ ì„±ëŠ¥ í‰ê°€
- [ ] ì œì¡° ë° ìš´ì˜ ì œì•½ì¡°ê±´ ë°˜ì˜

### ê²€ì¦ ë‹¨ê³„
- [ ] ì‹¤í—˜ ë˜ëŠ” ì‹œë®¬ë ˆì´ì…˜ì„ í†µí•œ ê°•ê±´ì„± í™•ì¸
- [ ] ë¯¼ê°ë„ ë¶„ì„ ìˆ˜í–‰
- [ ] ìµœì•…ì˜ ê²½ìš° ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸
- [ ] ë¹„ìš©-íš¨ê³¼ ë¶„ì„ ì™„ë£Œ

### êµ¬í˜„ ë‹¨ê³„  
- [ ] ìƒì‚° ê³µì •ì˜ ê°•ê±´ì„± í™•ë³´
- [ ] í’ˆì§ˆê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬ì¶•
- [ ] ì§€ì†ì  ëª¨ë‹ˆí„°ë§ ì²´ê³„ ë§ˆë ¨
- [ ] í”¼ë“œë°± ë£¨í”„ ì„¤ê³„

---

**ìµœì¢… ì •ë¦¬:**

ê°•ê±´ì„¤ê³„ëŠ” í˜„ì‹¤ì ì¸ ë¶ˆí™•ì‹¤ì„±ì„ ê³ ë ¤í•˜ì—¬ ì•ˆì •ì ì´ê³  ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ì œí’ˆì„ ë§Œë“œëŠ” í•µì‹¬ ê¸°ìˆ ì…ë‹ˆë‹¤. ë‹¤êµ¬ì¹˜ ë°©ë²•, 6ì‹œê·¸ë§ˆ, í™•ë¥ ì  ìµœì í™” ë“± ë‹¤ì–‘í•œ ì ‘ê·¼ë²•ì„ ìƒí™©ì— ë§ê²Œ ì„ íƒí•˜ê³  ì¡°í•©í•˜ì—¬ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.

ì„±ê³µì ì¸ ê°•ê±´ì„¤ê³„ë¥¼ ìœ„í•´ì„œëŠ”:
1. **ì²´ê³„ì ì¸ ë¶ˆí™•ì‹¤ì„± ë¶„ì„**
2. **ì ì ˆí•œ ë°©ë²•ë¡  ì„ íƒ**  
3. **ì¶©ë¶„í•œ ê²€ì¦ê³¼ í…ŒìŠ¤íŠ¸**
4. **ì§€ì†ì ì¸ ê°œì„ **

ì´ ë„¤ ê°€ì§€ ìš”ì†Œê°€ ê· í˜•ìˆê²Œ ê°–ì¶°ì ¸ì•¼ í•©ë‹ˆë‹¤.

---

**ì°¸ê³ ë¬¸í—Œ:**
- Taguchi, G., Chowdhury, S. & Wu, Y. (2004). *Taguchi's Quality Engineering Handbook*. Wiley.
- Beyer, H.G. & Sendhoff, B. (2007). Robust optimizationâ€“a comprehensive survey. *Computer Methods in Applied Mechanics and Engineering*, 196(33-34), 3190-3218.
- Ben-Tal, A., El Ghaoui, L. & Nemirovski, A. (2009). *Robust Optimization*. Princeton University Press.
- Phadke, M.S. (1989). *Quality Engineering Using Robust Design*. Prentice Hall.
- Du, X. & Chen, W. (2004). Sequential optimization and reliability assessment method for efficient probabilistic design. *Journal of Mechanical Design*, 126(2), 225-233.