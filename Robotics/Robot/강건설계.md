# 강건설계

> 상위: [[최적화설계]]

불확실성과 변동성이 있는 환경에서도 안정적인 성능을 보장하는 설계 방법론입니다. 쉽게 말해 "예상치 못한 상황에서도 잘 작동하는 설계"를 만드는 기술입니다.

## 🛡️ 기본 개념

### 강건설계가 왜 필요한가?

**현실적 문제들:**
```
이론적 설계 vs 실제 제작품:
- 설계값: 강도 100MPa → 실제: 95~105MPa (±5% 변동)
- 설계값: 치수 10mm → 실제: 9.95~10.05mm (가공 공차)
- 운영환경: 20°C → 실제: -10°C~50°C (계절별 변화)
```

**전통적 설계의 한계:**
```matlab
% 전통적 접근: 고정값으로 설계
material_strength = 250e6;  % Pa (카탈로그 값)
operating_temp = 20;        % °C (설계 온도)
load = 10000;              % N (정격 하중)

% 실제 상황: 모든 값이 확률분포
material_strength_real = normrnd(250e6, 25e6);  % 평균±10%
operating_temp_real = normrnd(20, 15);          % ±15°C 변동
load_real = normrnd(10000, 2000);              % ±20% 변동
```

### 불확실성의 분류

#### 1. 알레토리 불확실성 (Aleatory Uncertainty)
**본질적, 무작위적 변동성**
```matlab
% 예시: 재료 강도의 자연적 변동
% 통계적 분포로 모델링 가능
material_strength = normrnd(mu_strength, sigma_strength, [1000, 1]);
histogram(material_strength);
xlabel('Material Strength [Pa]');
ylabel('Frequency');
title('Aleatory Uncertainty in Material Properties');
```

#### 2. 인식론적 불확실성 (Epistemic Uncertainty)  
**지식 부족으로 인한 불확실성**
```matlab
% 예시: 하중 모델의 불완전성
% 구간 불확실성으로 모델링
load_nominal = 10000;  % N
load_uncertainty = 0.3;  % ±30%
load_interval = [load_nominal*(1-load_uncertainty), ...
                load_nominal*(1+load_uncertainty)];
```

### 강건성 지표

#### 성능 변동성
```matlab
function [performance_mean, performance_std] = evaluate_performance_variation(design_vars, uncertainty_params)
    n_samples = 1000;
    performance_samples = zeros(n_samples, 1);
    
    for i = 1:n_samples
        % 불확실성 샘플링
        uncertain_vars = sample_uncertainties(uncertainty_params);
        
        % 성능 평가
        performance_samples(i) = system_performance(design_vars, uncertain_vars);
    end
    
    performance_mean = mean(performance_samples);
    performance_std = std(performance_samples);
end
```

#### 신호-잡음비 (Signal-to-Noise Ratio)
```matlab
function snr = signal_to_noise_ratio(performance_data, objective_type)
    mu = mean(performance_data);
    sigma = std(performance_data);
    
    switch objective_type
        case 'larger_is_better'
            % 큰 값이 좋은 경우 (출력, 효율 등)
            snr = -10 * log10(mean(1./performance_data.^2));
            
        case 'smaller_is_better'  
            % 작은 값이 좋은 경우 (결함률, 소음 등)
            snr = -10 * log10(mean(performance_data.^2));
            
        case 'nominal_is_best'
            % 목표값이 있는 경우
            target_value = 100;  % 예시
            snr = -10 * log10(mean((performance_data - target_value).^2));
    end
end
```

---

## 📊 강건설계 접근법

### 1. 다구치 방법 (Taguchi Method)

#### 직교배열표를 이용한 실험설계

**L9 직교배열 예시 (3수준, 4인자):**
```matlab
% 설계인자 (제어 가능)
factors = {
    'material_grade', [1, 2, 3];           % 재료 등급
    'heat_treatment_temp', [800, 850, 900]; % 열처리 온도 [°C]
    'cooling_rate', [10, 20, 30];          % 냉각속도 [°C/min]
    'surface_finish', [1, 2, 3]            % 표면처리 수준
};

% L9 직교배열표
L9_array = [
    1, 1, 1, 1;
    1, 2, 2, 2;
    1, 3, 3, 3;
    2, 1, 2, 3;
    2, 2, 3, 1;
    2, 3, 1, 2;
    3, 1, 3, 2;
    3, 2, 1, 3;
    3, 3, 2, 1
];

% 각 실험조건에서 성능 평가
for i = 1:size(L9_array, 1)
    experiment_condition = L9_array(i, :);
    performance(i) = evaluate_design_performance(experiment_condition, factors);
end
```

#### 잡음인자 고려한 내외측 배열

```matlab
function robust_design_experiment()
    % 내측 배열 (제어인자)
    control_factors = L9_array;  % 9개 설계조건
    
    % 외측 배열 (잡음인자)
    noise_factors = [
        1, 1;  % 저온, 저습
        1, 2;  % 저온, 고습  
        2, 1;  % 고온, 저습
        2, 2   % 고온, 고습
    ];
    
    % 전체 실험 (9×4 = 36회)
    results = zeros(size(control_factors, 1), size(noise_factors, 1));
    
    for i = 1:size(control_factors, 1)
        for j = 1:size(noise_factors, 1)
            % 제어인자 + 잡음인자 조합
            control_condition = control_factors(i, :);
            noise_condition = noise_factors(j, :);
            
            results(i, j) = system_response(control_condition, noise_condition);
        end
    end
    
    % 각 설계조건별 S/N 비 계산
    snr_values = zeros(size(control_factors, 1), 1);
    for i = 1:size(control_factors, 1)
        snr_values(i) = signal_to_noise_ratio(results(i, :), 'larger_is_better');
    end
    
    % 최적 조건 선택
    [max_snr, best_condition_idx] = max(snr_values);
    optimal_design = control_factors(best_condition_idx, :);
    
    fprintf('Optimal design condition: [%d, %d, %d, %d]\n', optimal_design);
    fprintf('Maximum S/N ratio: %.2f dB\n', max_snr);
end
```

#### 품질 손실 함수

```matlab
function quality_loss = taguchi_loss_function(actual_values, target_value, loss_coefficient)
    % 2차 손실함수: L = k(y - m)²
    % k: 손실계수, y: 실제값, m: 목표값
    
    quality_loss = loss_coefficient * (actual_values - target_value).^2;
end

% 손실계수 결정
function k = determine_loss_coefficient(tolerance, cost_at_tolerance)
    % 공차 한계에서의 비용으로부터 손실계수 계산
    % L = k * Δ²
    k = cost_at_tolerance / tolerance^2;
end

% 예시: 치수 정밀도 문제
target_dimension = 100.0;    % mm
tolerance = 0.1;             % ±0.1mm
rework_cost = 50;           % 공차 초과 시 재작업 비용

k = determine_loss_coefficient(tolerance, rework_cost);
actual_dimensions = normrnd(100, 0.05, [1000, 1]);  % 실제 제작 치수
total_quality_loss = sum(taguchi_loss_function(actual_dimensions, target_dimension, k));
```

### 2. 6시그마 설계

#### DMAIC 프로세스 구현

```matlab
function six_sigma_design_process()
    %% Define (정의)
    fprintf('=== DEFINE PHASE ===\n');
    
    % CTQ (Critical to Quality) 특성 정의
    ctq_characteristics = {
        'dimensional_accuracy', 'target', 100, 'tolerance', 0.1;
        'surface_roughness', 'smaller_is_better', [], 'spec_limit', 1.6;
        'tensile_strength', 'larger_is_better', [], 'min_spec', 500
    };
    
    %% Measure (측정)
    fprintf('=== MEASURE PHASE ===\n');
    
    % 현재 공정 능력 측정
    current_data = collect_current_process_data();
    process_capability = calculate_process_capability(current_data, ctq_characteristics);
    
    %% Analyze (분석)  
    fprintf('=== ANALYZE PHASE ===\n');
    
    % 주요 인자 식별 (DOE)
    significant_factors = design_of_experiments_analysis();
    
    %% Improve (개선)
    fprintf('=== IMPROVE PHASE ===\n');
    
    % 강건설계 최적화
    optimal_settings = robust_parameter_optimization(significant_factors);
    
    %% Control (관리)
    fprintf('=== CONTROL PHASE ===\n');
    
    % 통계적 공정관리 시스템 구축
    control_charts = setup_statistical_process_control(optimal_settings);
end

function cp = calculate_process_capability(data, spec_limits)
    % Cp, Cpk 계산
    mu = mean(data);
    sigma = std(data);
    
    USL = spec_limits.upper;  % 상한 규격
    LSL = spec_limits.lower;  % 하한 규격
    
    % 공정능력지수
    cp = (USL - LSL) / (6 * sigma);
    
    % 공정성능지수
    cpu = (USL - mu) / (3 * sigma);
    cpl = (mu - LSL) / (3 * sigma);
    cpk = min(cpu, cpl);
    
    fprintf('Cp = %.3f, Cpk = %.3f\n', cp, cpk);
    
    % 6시그마 수준 평가
    if cpk >= 2.0
        fprintf('Process is at 6-sigma level\n');
    elseif cpk >= 1.67
        fprintf('Process is at 5-sigma level\n'); 
    elseif cpk >= 1.33
        fprintf('Process is at 4-sigma level\n');
    else
        fprintf('Process needs improvement\n');
    end
end
```

#### 결함률 예측 및 관리

```matlab
function defect_rate = predict_defect_rate(process_mean, process_std, spec_limits)
    % 정규분포 가정하에 결함률 계산
    
    % 상한 초과 확률
    prob_above_usl = 1 - normcdf(spec_limits.upper, process_mean, process_std);
    
    % 하한 미달 확률  
    prob_below_lsl = normcdf(spec_limits.lower, process_mean, process_std);
    
    % 총 결함률
    defect_rate = prob_above_usl + prob_below_lsl;
    
    % ppm (parts per million) 변환
    defect_ppm = defect_rate * 1e6;
    
    fprintf('Predicted defect rate: %.2e (%.1f ppm)\n', defect_rate, defect_ppm);
    
    % 시그마 수준 계산
    if defect_rate > 0
        sigma_level = -norminv(defect_rate/2);
        fprintf('Equivalent sigma level: %.2f\n', sigma_level);
    end
end

% 6시그마 목표 (3.4 ppm) 달성을 위한 요구사항
target_defect_ppm = 3.4;
target_defect_rate = target_defect_ppm / 1e6;

% 필요한 공정 표준편차 계산
function required_sigma = calculate_required_process_sigma(spec_width, target_defect_rate)
    % 양측 규격의 경우
    z_value = norminv(1 - target_defect_rate/2);
    required_sigma = spec_width / (2 * z_value);
end
```

### 3. 확률적 강건설계

#### 몬테카르로 시뮬레이션

```matlab
function [robust_design, performance_stats] = monte_carlo_robust_design(design_space, uncertainty_model)
    % 설계공간 탐색
    n_design_candidates = 100;
    n_monte_carlo_samples = 1000;
    
    design_candidates = generate_design_candidates(design_space, n_design_candidates);
    
    % 각 설계 후보에 대한 강건성 평가
    robustness_metrics = zeros(n_design_candidates, 3);  % [mean, std, failure_prob]
    
    for i = 1:n_design_candidates
        design = design_candidates(i, :);
        performance_samples = zeros(n_monte_carlo_samples, 1);
        
        % 몬테카르로 샘플링
        for j = 1:n_monte_carlo_samples
            % 불확실성 샘플 생성
            uncertain_params = sample_uncertainties(uncertainty_model);
            
            % 성능 평가
            performance_samples(j) = evaluate_system_performance(design, uncertain_params);
        end
        
        % 강건성 지표 계산
        robustness_metrics(i, 1) = mean(performance_samples);           % 평균 성능
        robustness_metrics(i, 2) = std(performance_samples);            % 성능 변동성
        robustness_metrics(i, 3) = mean(performance_samples < 0);       % 파손 확률
    end
    
    % 다목적 최적화 (성능 최대화, 변동성 최소화, 파손확률 최소화)
    [pareto_front, pareto_indices] = find_pareto_optimal_designs(robustness_metrics);
    
    % 최종 설계 선택 (의사결정자 선호도 반영)
    robust_design = select_final_design(design_candidates(pareto_indices, :), robustness_metrics(pareto_indices, :));
    
    performance_stats.mean = robustness_metrics(robust_design, 1);
    performance_stats.std = robustness_metrics(robust_design, 2);
    performance_stats.failure_prob = robustness_metrics(robust_design, 3);
end

function uncertain_params = sample_uncertainties(uncertainty_model)
    % 다양한 불확실성 모델 처리
    uncertain_params = struct();
    
    for field = fieldnames(uncertainty_model)'
        param = uncertainty_model.(field{1});
        
        switch param.type
            case 'normal'
                uncertain_params.(field{1}) = normrnd(param.mean, param.std);
                
            case 'uniform'
                uncertain_params.(field{1}) = unifrnd(param.lower, param.upper);
                
            case 'lognormal'
                uncertain_params.(field{1}) = lognrnd(param.mu, param.sigma);
                
            case 'interval'
                % 최악의 경우 시나리오
                if rand < 0.5
                    uncertain_params.(field{1}) = param.lower;
                else
                    uncertain_params.(field{1}) = param.upper;
                end
        end
    end
end
```

#### 신뢰성 기반 설계최적화 (RBDO)

```matlab
function [x_optimal, reliability] = reliability_based_design_optimization(objective_func, constraints, reliability_requirements)
    % RBDO 문제 정식화:
    % min f(x)
    % s.t. P[gi(x,ξ) ≤ 0] ≥ βi, i = 1,...,m
    
    % 초기 설계
    x0 = [1.0, 0.5, 2.0];  % 예시 초기값
    
    % 신뢰성 제약조건을 deterministic equivalent로 변환
    deterministic_constraints = @(x) convert_reliability_constraints(x, constraints, reliability_requirements);
    
    % 최적화 실행
    options = optimoptions('fmincon', 'Display', 'iter', 'Algorithm', 'sqp');
    [x_optimal, fval, exitflag] = fmincon(objective_func, x0, [], [], [], [], [], [], deterministic_constraints, options);
    
    % 최적 설계의 신뢰성 검증
    reliability = verify_reliability(x_optimal, constraints, reliability_requirements);
    
    fprintf('Optimal design: [%.3f, %.3f, %.3f]\n', x_optimal);
    fprintf('Objective value: %.6f\n', fval);
    fprintf('Reliability levels: ');
    fprintf('%.4f ', reliability);
    fprintf('\n');
end

function [c, ceq] = convert_reliability_constraints(x, original_constraints, beta_required)
    % First-Order Reliability Method (FORM) 사용
    n_constraints = length(original_constraints);
    c = zeros(n_constraints, 1);
    ceq = [];
    
    for i = 1:n_constraints
        % 신뢰성 지수를 deterministic 제약조건으로 변환
        [beta_current, u_star] = form_analysis(x, original_constraints{i});
        
        % 제약조건: β_current ≥ β_required
        c(i) = beta_required(i) - beta_current;
    end
end

function [beta, u_star] = form_analysis(x, constraint_func)
    % First-Order Reliability Method 구현
    
    % 확률변수 정보 (예시)
    uncertain_vars = struct();
    uncertain_vars.load = struct('mean', 10000, 'std', 2000);      % 하중 [N]
    uncertain_vars.strength = struct('mean', 250e6, 'std', 25e6);  % 강도 [Pa]
    uncertain_vars.dimension = struct('mean', 0.01, 'std', 0.001); % 치수 [m]
    
    % 표준정규공간으로 변환
    [u_star, beta] = find_design_point(x, constraint_func, uncertain_vars);
end
```

---

## 🔧 실제 적용 사례

### 사례 1: 자동차 엔진 부품 설계

**불확실성 요인들:**
```matlab
% 엔진 피스톤 강건설계
uncertainty_sources = struct();

% 재료 특성 변동
uncertainty_sources.elastic_modulus = struct('type', 'normal', 'mean', 200e9, 'std', 10e9);
uncertainty_sources.yield_strength = struct('type', 'normal', 'mean', 350e6, 'std', 35e6);

% 운영 조건 변동
uncertainty_sources.operating_temp = struct('type', 'uniform', 'lower', -40, 'upper', 120);
uncertainty_sources.pressure = struct('type', 'lognormal', 'mu', log(2e6), 'sigma', 0.2);

% 제조 공차
uncertainty_sources.diameter = struct('type', 'normal', 'mean', 0.08, 'std', 0.0005);
uncertainty_sources.length = struct('type', 'normal', 'mean', 0.15, 'std', 0.001);

function performance = piston_performance(design_vars, uncertain_vars)
    % 설계변수: [wall_thickness, crown_thickness, skirt_length]
    wall_thickness = design_vars(1);
    crown_thickness = design_vars(2);
    skirt_length = design_vars(3);
    
    % 불확실성 변수 추출
    E = uncertain_vars.elastic_modulus;
    sigma_y = uncertain_vars.yield_strength;
    T = uncertain_vars.operating_temp;
    P = uncertain_vars.pressure;
    D = uncertain_vars.diameter;
    L = uncertain_vars.length;
    
    % 열응력 계산
    alpha = 12e-6;  % 열팽창계수 [1/K]
    thermal_stress = E * alpha * (T - 20);  % 20°C 기준
    
    % 압력 응력 계산
    pressure_stress = P * D / (2 * wall_thickness);
    
    % 총 응력
    total_stress = pressure_stress + thermal_stress;
    
    % 안전계수
    safety_factor = sigma_y / total_stress;
    
    % 성능 지표 (안전계수가 클수록 좋음)
    performance = safety_factor;
end

% 강건설계 실행
robust_piston_design = monte_carlo_robust_design(...
    struct('wall_thickness', [0.005, 0.015], 'crown_thickness', [0.01, 0.03], 'skirt_length', [0.08, 0.12]), ...
    uncertainty_sources);
```

### 사례 2: 항공기 구조 부품

**다중 실패 모드 고려:**
```matlab
function [design_optimal, reliability_levels] = aircraft_component_robust_design()
    % 복합재료 항공기 패널 설계
    
    % 설계변수: [ply_thickness, fiber_angle, stacking_sequence]
    design_bounds = [
        0.125, 0.250;    % 플라이 두께 [mm]
        0, 90;           % 섬유각도 [도]
        1, 4             % 적층 순서 옵션
    ];
    
    % 불확실성 모델
    uncertainties = struct();
    uncertainties.load_factor = struct('type', 'normal', 'mean', 2.5, 'std', 0.5);  % 하중계수
    uncertainties.material_E11 = struct('type', 'normal', 'mean', 150e9, 'std', 15e9);  % 종방향 탄성계수
    uncertainties.material_E22 = struct('type', 'normal', 'mean', 10e9, 'std', 2e9);    % 횡방향 탄성계수
    uncertainties.temperature = struct('type', 'uniform', 'lower', -55, 'upper', 125);   % 운영온도 [°C]
    
    % 다중 실패 모드
    failure_modes = {
        @(design, uncertain) fiber_failure_criterion(design, uncertain);
        @(design, uncertain) matrix_failure_criterion(design, uncertain);
        @(design, uncertain) buckling_failure_criterion(design, uncertain);
        @(design, uncertain) fatigue_failure_criterion(design, uncertain)
    };
    
    % 요구 신뢰성 수준
    required_reliability = [0.999, 0.995, 0.99, 0.95];  % 각 실패모드별
    
    % 다목적 강건설계 최적화
    [design_optimal, reliability_levels] = multi_failure_mode_rbdo(design_bounds, uncertainties, failure_modes, required_reliability);
    
    % 결과 출력
    fprintf('Optimal design:\n');
    fprintf('  Ply thickness: %.3f mm\n', design_optimal(1));
    fprintf('  Fiber angle: %.1f degrees\n', design_optimal(2));
    fprintf('  Stacking sequence: %d\n', round(design_optimal(3)));
    
    fprintf('Achieved reliability levels:\n');
    for i = 1:length(reliability_levels)
        fprintf('  Failure mode %d: %.6f\n', i, reliability_levels(i));
    end
end

function margin = fiber_failure_criterion(design, uncertain)
    % Tsai-Wu 파손 기준
    ply_thickness = design(1);
    fiber_angle = design(2);
    
    % 응력 계산 (간소화된 모델)
    load = uncertain.load_factor * 1000;  % 기준하중 1000N
    stress = load / (ply_thickness * 0.1);  % 응력 [Pa]
    
    % 온도 보정
    temp_factor = 1 - 0.001 * (uncertain.temperature - 20);
    effective_strength = uncertain.material_E11 * 0.01 * temp_factor;  % 간소화된 강도
    
    % 안전여유
    margin = effective_strength - stress;
end
```

### 사례 3: 로봇 제어 시스템

**매개변수 변동에 강건한 제어기 설계:**
```matlab
function robust_controller = robust_robot_control_design()
    % 로봇 매니퓰레이터 강건 제어
    
    % 공칭 플랜트 모델
    s = tf('s');
    nominal_plant = 100 / (s^2 + 10*s + 100);
    
    % 불확실성 모델 (매개변수 변동)
    uncertainty_params = struct();
    uncertainty_params.inertia_variation = 0.3;      % ±30% 관성 변동
    uncertainty_params.damping_variation = 0.5;      % ±50% 댐핑 변동
    uncertainty_params.payload_variation = [0, 2];   % 0-2kg 페이로드 변동
    
    % H∞ 강건 제어기 설계
    [robust_controller, gamma_opt] = hinf_robust_design(nominal_plant, uncertainty_params);
    
    % 성능 검증
    validate_robust_performance(robust_controller, nominal_plant, uncertainty_params);
end

function [controller, gamma] = hinf_robust_design(plant, uncertainty)
    % H∞ 루프 성형 방법
    
    % 가중함수 설정
    % 성능 가중함수 (추적 성능)
    Wp = tf([1, 1], [1, 0.01]);  % 저주파에서 높은 성능 요구
    
    % 제어 가중함수 (액추에이터 제한)
    Wu = tf([1, 100], [1, 1000]); % 고주파에서 제어 신호 제한
    
    % 강건성 가중함수
    Wt = tf([1, 10], [1, 1]);   % 모델 불확실성
    
    % 확장된 플랜트 구성
    P = augmented_plant(plant, Wp, Wu, Wt);
    
    % H∞ 최적화
    [controller, ~, gamma] = hinfsyn(P, 1, 1);
    
    fprintf('H-infinity norm: %.3f\n', gamma);
end

function validate_robust_performance(controller, nominal_plant, uncertainty)
    % 몬테카르로 검증
    n_tests = 1000;
    settling_times = zeros(n_tests, 1);
    overshoots = zeros(n_tests, 1);
    
    for i = 1:n_tests
        % 불확실성 샘플링
        inertia_factor = 1 + uncertainty.inertia_variation * (2*rand - 1);
        damping_factor = 1 + uncertainty.damping_variation * (2*rand - 1);
        
        % 변동된 플랜트
        varied_plant = nominal_plant * inertia_factor;
        % 댐핑 변동 반영 (간소화)
        
        % 폐루프 시스템
        closed_loop = feedback(controller * varied_plant, 1);
        
        % 단위계단응답 특성
        step_info = stepinfo(closed_loop);
        settling_times(i) = step_info.SettlingTime;
        overshoots(i) = step_info.Overshoot;
    end
    
    % 통계 분석
    fprintf('Settling time: %.3f ± %.3f seconds\n', mean(settling_times), std(settling_times));
    fprintf('Overshoot: %.1f ± %.1f %%\n', mean(overshoots), std(overshoots));
    
    % 사양 만족도 확인
    spec_settling_time = 2.0;  % 2초 이내
    spec_overshoot = 10;       % 10% 이내
    
    prob_settling_ok = mean(settling_times <= spec_settling_time);
    prob_overshoot_ok = mean(overshoots <= spec_overshoot);
    
    fprintf('Probability of meeting settling time spec: %.3f\n', prob_settling_ok);
    fprintf('Probability of meeting overshoot spec: %.3f\n', prob_overshoot_ok);
end
```

---

## 💻 고급 구현 도구

### 적응적 샘플링 기법

```matlab
classdef AdaptiveSampling < handle
    properties
        sample_points
        sample_values
        uncertainty_model
        surrogate_model
        refinement_criteria
    end
    
    methods
        function obj = AdaptiveSampling(initial_samples, uncertainty_model)
            obj.sample_points = initial_samples.points;
            obj.sample_values = initial_samples.values;
            obj.uncertainty_model = uncertainty_model;
            obj.build_surrogate_model();
        end
        
        function build_surrogate_model(obj)
            % 크리깅 또는 다항식 회귀 모델 구축
            obj.surrogate_model = fitrgp(obj.sample_points, obj.sample_values);
        end
        
        function new_samples = adaptive_refinement(obj, n_new_samples)
            % 불확실성이 높은 영역에 새로운 샘플 추가
            candidate_points = obj.generate_candidate_points(1000);
            
            % 예측 불확실성 평가
            [~, prediction_std] = predict(obj.surrogate_model, candidate_points);
            
            % 높은 불확실성을 가진 점들 선택
            [~, sorted_indices] = sort(prediction_std, 'descend');
            selected_indices = sorted_indices(1:n_new_samples);
            
            new_samples.points = candidate_points(selected_indices, :);
            
            % 실제 함수 평가
            new_samples.values = zeros(n_new_samples, 1);
            for i = 1:n_new_samples
                new_samples.values(i) = obj.evaluate_expensive_function(new_samples.points(i, :));
            end
            
            % 샘플 데이터베이스 업데이트
            obj.sample_points = [obj.sample_points; new_samples.points];
            obj.sample_values = [obj.sample_values; new_samples.values];
            
            % 대리모델 재구축
            obj.build_surrogate_model();
        end
        
        function candidates = generate_candidate_points(obj, n_candidates)
            % 불확실성 분포에 따른 후보점 생성
            candidates = zeros(n_candidates, length(fieldnames(obj.uncertainty_model)));
            
            param_names = fieldnames(obj.uncertainty_model);
            for i = 1:length(param_names)
                param = obj.uncertainty_model.(param_names{i});
                
                switch param.type
                    case 'normal'
                        candidates(:, i) = normrnd(param.mean, param.std, [n_candidates, 1]);
                    case 'uniform'
                        candidates(:, i) = unifrnd(param.lower, param.upper, [n_candidates, 1]);
                end
            end
        end
        
        function value = evaluate_expensive_function(obj, design_point)
            % 실제 비용이 높은 함수 평가 (유한요소해석 등)
            value = expensive_system_analysis(design_point);
        end
    end
end
```

---

**참고문헌:**
- Taguchi, G., Chowdhury, S. & Wu, Y. (2004). *Taguchi's Quality Engineering Handbook*. Wiley.
- Beyer, H.G. & Sendhoff, B. (2007). Robust optimization–a comprehensive survey. *Computer Methods in Applied Mechanics and Engineering*, 196(33-34), 3190-3218.
- Ben-Tal, A., El Ghaoui, L. & Nemirovski, A. (2009). *Robust Optimization*. Princeton University Press.
- Phadke, M.S. (1989). *Quality Engineering Using Robust Design*. Prentice Hall.
---

## 🎓 학습 단계별 가이드

### 초급 (1-2개월)

**1주차: 불확실성 이해**
```matlab
% 간단한 확률분포 체험
mu = 100; sigma = 10;
samples = normrnd(mu, sigma, [1000, 1]);

figure;
subplot(1,2,1);
histogram(samples, 30);
title('Random Samples');
xlabel('Value'); ylabel('Frequency');

subplot(1,2,2);
plot(samples);
title('Sample Sequence');
xlabel('Sample Number'); ylabel('Value');

% 통계량 계산
fprintf('Theoretical: μ=%.1f, σ=%.1f\n', mu, sigma);
fprintf('Empirical: μ=%.1f, σ=%.1f\n', mean(samples), std(samples));
```

**2주차: 성능 변동성 분석**
```matlab
% 간단한 구조물의 성능 변동
function deflection = simple_beam_deflection(load, length, moment_of_inertia, elastic_modulus)
    deflection = load * length^3 / (3 * elastic_modulus * moment_of_inertia);
end

% 명목값
P_nominal = 1000;    % N
L_nominal = 1;       % m  
I_nominal = 8.33e-6; % m^4 (10cm x 10cm 사각 단면)
E_nominal = 200e9;   % Pa

% 불확실성
n_samples = 1000;
P_samples = normrnd(P_nominal, 0.1*P_nominal, [n_samples, 1]);  % ±10%
E_samples = normrnd(E_nominal, 0.05*E_nominal, [n_samples, 1]); % ±5%

deflections = zeros(n_samples, 1);
for i = 1:n_samples
    deflections(i) = simple_beam_deflection(P_samples(i), L_nominal, I_nominal, E_samples(i));
end

% 결과 분석
fprintf('Deflection statistics:\n');
fprintf('  Mean: %.2e m\n', mean(deflections));
fprintf('  Std:  %.2e m\n', std(deflections));
fprintf('  CV:   %.1f%%\n', 100*std(deflections)/mean(deflections));
```

**3-4주차: 다구치 방법 기초**
```matlab
% L4 직교배열 실습
factors = {
    'A', [1, 2];      % 인자 A (2수준)
    'B', [1, 2];      % 인자 B (2수준)  
    'C', [1, 2]       % 인자 C (2수준)
};

% L4 = 2^3 직교배열
L4_array = [
    1, 1, 1;
    1, 2, 2;
    2, 1, 2;
    2, 2, 1
];

% 각 실험의 응답값 (예시)
responses = [
    [20, 18, 22, 19];   % 실험 1: 4개 반복
    [25, 23, 27, 24];   % 실험 2
    [15, 17, 14, 16];   % 실험 3
    [30, 28, 32, 29]    % 실험 4
];

% S/N 비 계산 (큰 값이 좋은 경우)
snr = zeros(4, 1);
for i = 1:4
    snr(i) = -10 * log10(mean(1./responses(i,:).^2));
end

% 주효과 분석
effect_A = mean(snr([1,2])) - mean(snr([3,4]));  % A의 1수준 vs 2수준
effect_B = mean(snr([1,3])) - mean(snr([2,4]));  % B의 1수준 vs 2수준  
effect_C = mean(snr([1,4])) - mean(snr([2,3]));  % C의 1수준 vs 2수준

fprintf('Main effects on S/N ratio:\n');
fprintf('  Factor A: %.2f dB\n', effect_A);
fprintf('  Factor B: %.2f dB\n', effect_B);
fprintf('  Factor C: %.2f dB\n', effect_C);

% 최적 조합 결정
[~, best_A] = max([mean(snr([1,2])), mean(snr([3,4]))]);
[~, best_B] = max([mean(snr([1,3])), mean(snr([2,4]))]);
[~, best_C] = max([mean(snr([1,4])), mean(snr([2,3]))]);

fprintf('Optimal factor levels: A%d-B%d-C%d\n', best_A, best_B, best_C);
```

### 중급 (3-4개월)

**5-8주차: 6시그마 방법론**
```matlab
% 공정능력 분석 실습
function process_capability_study()
    % 실제 생산 데이터 시뮬레이션
    true_mean = 100.2;    % 공정 평균 (약간 편향)
    true_std = 1.5;       % 공정 표준편차
    n_samples = 100;      % 샘플 크기
    
    production_data = normrnd(true_mean, true_std, [n_samples, 1]);
    
    % 규격한계
    LSL = 95;   % 하한 규격
    USL = 105;  % 상한 규격
    target = 100; % 목표값
    
    % 통계량 계산
    x_bar = mean(production_data);
    s = std(production_data);
    
    % 공정능력지수
    Cp = (USL - LSL) / (6 * s);
    Cpu = (USL - x_bar) / (3 * s);
    Cpl = (x_bar - LSL) / (3 * s);
    Cpk = min(Cpu, Cpl);
    
    % 공정성능지수 (목표값 고려)
    Cpm = (USL - LSL) / (6 * sqrt(s^2 + (x_bar - target)^2));
    
    % 결함률 추정
    defect_rate_lower = normcdf(LSL, x_bar, s);
    defect_rate_upper = 1 - normcdf(USL, x_bar, s);
    total_defect_rate = defect_rate_lower + defect_rate_upper;
    defect_ppm = total_defect_rate * 1e6;
    
    % 결과 출력
    fprintf('=== Process Capability Study ===\n');
    fprintf('Sample statistics: μ̂=%.2f, σ̂=%.2f\n', x_bar, s);
    fprintf('Capability indices:\n');
    fprintf('  Cp  = %.3f\n', Cp);
    fprintf('  Cpk = %.3f\n', Cpk);
    fprintf('  Cpm = %.3f\n', Cpm);
    fprintf('Estimated defect rate: %.1f ppm\n', defect_ppm);
    
    % 시그마 수준 평가
    if Cpk >= 2.0
        sigma_level = 6;
    elseif Cpk >= 1.67
        sigma_level = 5;
    elseif Cpk >= 1.33
        sigma_level = 4;
    else
        sigma_level = 3;
    end
    fprintf('Approximate sigma level: %d\n', sigma_level);
    
    % 그래프 생성
    figure;
    x_range = min(production_data)-3*s:0.1:max(production_data)+3*s;
    pdf_values = normpdf(x_range, x_bar, s);
    
    plot(x_range, pdf_values, 'b-', 'LineWidth', 2);
    hold on;
    xline(LSL, 'r--', 'LSL', 'LineWidth', 2);
    xline(USL, 'r--', 'USL', 'LineWidth', 2);
    xline(target, 'g--', 'Target', 'LineWidth', 2);
    xline(x_bar, 'b:', 'Process Mean', 'LineWidth', 1);
    
    % 규격 외 영역 음영
    x_defect_lower = x_range(x_range <= LSL);
    y_defect_lower = normpdf(x_defect_lower, x_bar, s);
    x_defect_upper = x_range(x_range >= USL);  
    y_defect_upper = normpdf(x_defect_upper, x_bar, s);
    
    fill([x_defect_lower, LSL], [y_defect_lower, 0], 'r', 'FaceAlpha', 0.3);
    fill([USL, x_defect_upper], [0, y_defect_upper], 'r', 'FaceAlpha', 0.3);
    
    xlabel('Measurement Value');
    ylabel('Probability Density');
    title('Process Capability Analysis');
    legend('Process Distribution', 'Specification Limits', '', 'Target', 'Process Mean', 'Defect Areas');
    grid on;
end

process_capability_study();
```

**9-12주차: 신뢰성 기반 설계**
```matlab
% 신뢰성 해석 실습
function reliability_analysis_example()
    % 구조 부재의 신뢰성 해석
    
    % 확률변수 정의
    load_mean = 50000;     % 평균 하중 [N]
    load_std = 10000;      % 하중 표준편차
    strength_mean = 80000; % 평균 강도 [N]  
    strength_std = 8000;   % 강도 표준편차
    
    % 안전여유 분포
    safety_margin_mean = strength_mean - load_mean;
    safety_margin_std = sqrt(strength_std^2 + load_std^2);
    
    % 파손확률 (해석해)
    beta = safety_margin_mean / safety_margin_std;  % 신뢰성 지수
    pf_analytical = normcdf(-beta);
    reliability_analytical = 1 - pf_analytical;
    
    % 몬테카르로 시뮬레이션 검증
    n_mc = 100000;
    load_samples = normrnd(load_mean, load_std, [n_mc, 1]);
    strength_samples = normrnd(strength_mean, strength_std, [n_mc, 1]);
    
    failures = load_samples > strength_samples;
    pf_mc = mean(failures);
    reliability_mc = 1 - pf_mc;
    
    % 결과 비교
    fprintf('=== Reliability Analysis ===\n');
    fprintf('Analytical approach:\n');
    fprintf('  Reliability index β = %.3f\n', beta);
    fprintf('  Failure probability = %.2e\n', pf_analytical);
    fprintf('  Reliability = %.6f\n', reliability_analytical);
    
    fprintf('Monte Carlo simulation (%d samples):\n', n_mc);
    fprintf('  Failure probability = %.2e\n', pf_mc);
    fprintf('  Reliability = %.6f\n', reliability_mc);
    
    % 민감도 분석
    fprintf('\nSensitivity analysis:\n');
    alpha_load = -load_std / safety_margin_std;
    alpha_strength = strength_std / safety_margin_std;
    fprintf('  Load importance factor α_R = %.3f\n', alpha_load);
    fprintf('  Strength importance factor α_S = %.3f\n', alpha_strength);
    
    % 시각화
    figure;
    x_range = 0:1000:150000;
    
    % 하중과 강도 분포
    subplot(2,1,1);
    plot(x_range, normpdf(x_range, load_mean, load_std), 'r-', 'LineWidth', 2);
    hold on;
    plot(x_range, normpdf(x_range, strength_mean, strength_std), 'b-', 'LineWidth', 2);
    xlabel('Value [N]');
    ylabel('Probability Density');
    title('Load and Strength Distributions');
    legend('Load', 'Strength');
    grid on;
    
    % 안전여유 분포
    subplot(2,1,2);
    margin_range = -40000:1000:80000;
    plot(margin_range, normpdf(margin_range, safety_margin_mean, safety_margin_std), 'g-', 'LineWidth', 2);
    hold on;
    xline(0, 'k--', 'Failure Boundary', 'LineWidth', 2);
    
    % 파손 영역 음영
    failure_region = margin_range(margin_range <= 0);
    failure_pdf = normpdf(failure_region, safety_margin_mean, safety_margin_std);
    fill([failure_region, 0], [failure_pdf, 0], 'r', 'FaceAlpha', 0.3);
    
    xlabel('Safety Margin [N]');
    ylabel('Probability Density'); 
    title('Safety Margin Distribution');
    legend('Safety Margin', 'Failure Boundary', 'Failure Region');
    grid on;
end

reliability_analysis_example();
```

### 고급 (6개월+)

**고급 주제:**
- 다분야 불확실성 전파
- 베이지안 업데이트를 통한 적응적 강건설계
- 기계학습 기반 대리모델 활용
- 실시간 강건제어

**실무 프로젝트:**
- 복잡한 시스템의 강건설계
- 생산 공정 최적화
- 품질관리 시스템 구축

---

## 🔧 실무 적용 팁

### 불확실성 모델링

**데이터 기반 분포 추정:**
```matlab
function best_distribution = fit_uncertainty_distribution(data)
    % 여러 분포에 대한 적합도 검정
    distributions = {'normal', 'lognormal', 'weibull', 'gamma'};
    
    best_aic = Inf;
    best_distribution = struct();
    
    for i = 1:length(distributions)
        try
            pd = fitdist(data, distributions{i});
            
            % AIC (Akaike Information Criterion) 계산
            log_likelihood = sum(log(pdf(pd, data)));
            k = numel(pd.ParameterValues);  % 매개변수 개수
            aic = 2*k - 2*log_likelihood;
            
            if aic < best_aic
                best_aic = aic;
                best_distribution.type = distributions{i};
                best_distribution.parameters = pd.ParameterValues;
                best_distribution.fitted_object = pd;
                best_distribution.aic = aic;
            end
            
        catch
            % 적합에 실패한 분포는 무시
            continue;
        end
    end
    
    fprintf('Best fitting distribution: %s (AIC = %.2f)\n', ...
            best_distribution.type, best_distribution.aic);
end
```

**전문가 지식 통합:**
```matlab
function combined_uncertainty = expert_knowledge_integration(data, expert_opinions)
    % 데이터와 전문가 의견을 베이지안 방식으로 결합
    
    % 데이터 기반 우도함수
    data_mean = mean(data);
    data_std = std(data);
    
    % 전문가 의견 (사전분포)
    expert_mean = expert_opinions.mean;
    expert_confidence = expert_opinions.confidence;  % 낮을수록 분산 큼
    expert_std = expert_opinions.std / sqrt(expert_confidence);
    
    % 베이지안 업데이트
    precision_data = 1 / data_std^2;
    precision_expert = 1 / expert_std^2;
    
    posterior_precision = precision_data + precision_expert;
    posterior_mean = (precision_data * data_mean + precision_expert * expert_mean) / posterior_precision;
    posterior_std = 1 / sqrt(posterior_precision);
    
    combined_uncertainty = struct();
    combined_uncertainty.mean = posterior_mean;
    combined_uncertainty.std = posterior_std;
    combined_uncertainty.confidence_interval = [
        posterior_mean - 1.96*posterior_std, 
        posterior_mean + 1.96*posterior_std
    ];
    
    fprintf('Combined uncertainty estimate:\n');
    fprintf('  Mean: %.3f\n', posterior_mean);
    fprintf('  Std: %.3f\n', posterior_std);
    fprintf('  95%% CI: [%.3f, %.3f]\n', combined_uncertainty.confidence_interval);
end
```

### 계산 효율성 개선

**적응적 샘플링:**
```matlab
function efficient_robust_design = adaptive_robust_optimization(objective, constraints, initial_budget)
    % 제한된 함수 평가 횟수로 효율적 강건설계
    
    current_budget = initial_budget;
    batch_size = 10;
    
    % 초기 탐색적 샘플링
    initial_samples = latin_hypercube_sampling(batch_size);
    sample_database = struct('points', initial_samples, 'values', []);
    
    % 초기 평가
    for i = 1:size(initial_samples, 1)
        sample_database.values(i) = expensive_robust_evaluation(initial_samples(i, :));
        current_budget = current_budget - 1;
    end
    
    iteration = 1;
    while current_budget > 0
        fprintf('Iteration %d: Remaining budget = %d\n', iteration, current_budget);
        
        % 대리모델 구축
        surrogate = fitrgp(sample_database.points, sample_database.values);
        
        % 다음 평가점 선택 (Expected Improvement 기준)
        candidate_points = latin_hypercube_sampling(1000);
        [~, ei_values] = expected_improvement(surrogate, candidate_points, sample_database);
        
        [~, best_candidate_idx] = max(ei_values);
        next_point = candidate_points(best_candidate_idx, :);
        
        % 새로운 점 평가
        next_value = expensive_robust_evaluation(next_point);
        
        % 데이터베이스 업데이트
        sample_database.points(end+1, :) = next_point;
        sample_database.values(end+1) = next_value;
        
        current_budget = current_budget - 1;
        iteration = iteration + 1;
    end
    
    % 최종 최적해 선택
    [~, best_idx] = min(sample_database.values);
    efficient_robust_design = sample_database.points(best_idx, :);
end

function [mean_pred, ei] = expected_improvement(surrogate, candidates, current_best)
    [mean_pred, std_pred] = predict(surrogate, candidates);
    
    f_min = min(current_best.values);
    improvement = f_min - mean_pred;
    
    % Expected Improvement 계산
    z = improvement ./ std_pred;
    ei = improvement .* normcdf(z) + std_pred .* normpdf(z);
    
    % 분산이 0인 점들 처리
    ei(std_pred == 0) = 0;
end
```

### 다단계 강건설계

```matlab
function hierarchical_robust_design = multi_level_robust_optimization()
    % 시스템 레벨과 컴포넌트 레벨의 계층적 강건설계
    
    % 1단계: 시스템 레벨 개념설계
    system_level_design = system_concept_optimization();
    
    % 2단계: 서브시스템 레벨 상세설계
    subsystem_designs = cell(3, 1);  % 3개 서브시스템
    
    for i = 1:3
        subsystem_designs{i} = subsystem_robust_design(system_level_design, i);
    end
    
    % 3단계: 시스템 통합 및 검증
    integrated_design = system_integration(system_level_design, subsystem_designs);
    
    % 4단계: 전체 시스템 강건성 검증
    system_robustness = validate_system_robustness(integrated_design);
    
    hierarchical_robust_design = struct();
    hierarchical_robust_design.system_level = system_level_design;
    hierarchical_robust_design.subsystem_level = subsystem_designs;
    hierarchical_robust_design.integrated = integrated_design;
    hierarchical_robust_design.robustness_metrics = system_robustness;
end

function design = subsystem_robust_design(system_requirements, subsystem_id)
    % 서브시스템별 강건설계
    
    % 시스템 요구사항을 서브시스템 사양으로 분해
    local_requirements = decompose_requirements(system_requirements, subsystem_id);
    
    % 서브시스템 불확실성 모델
    local_uncertainties = define_local_uncertainties(subsystem_id);
    
    % 서브시스템 강건최적화
    design = robust_optimization_with_constraints(local_requirements, local_uncertainties);
    
    % 상위 시스템으로의 불확실성 전파
    propagated_uncertainty = uncertainty_propagation(design, local_uncertainties);
    design.uncertainty_contribution = propagated_uncertainty;
end
```

---

## 📈 최신 연구 동향

### 기계학습 기반 강건설계

```matlab
% 딥러닝을 활용한 고차원 불확실성 처리
function ml_robust_design = machine_learning_robust_optimization()
    % 신경망 기반 대리모델을 활용한 강건설계
    
    % 훈련 데이터 생성
    training_data = generate_high_dimensional_training_data(1000);
    
    % 딥 가우시안 프로세스 모델 구축
    surrogate_model = train_deep_gaussian_process(training_data);
    
    % 불확실성 정량화를 포함한 최적화
    [optimal_design, uncertainty_bounds] = bayesian_robust_optimization(surrogate_model);
    
    ml_robust_design = struct();
    ml_robust_design.optimal_point = optimal_design;
    ml_robust_design.uncertainty_quantification = uncertainty_bounds;
    ml_robust_design.model_confidence = evaluate_model_confidence(surrogate_model, optimal_design);
end
```

### 적응적 강건제어

```matlab
% 실시간 시스템 식별과 제어기 적응
function adaptive_controller = real_time_robust_adaptation()
    % 온라인 시스템 식별
    system_identifier = recursive_least_squares_with_forgetting();
    
    % 적응적 강건제어기
    robust_controller = adaptive_h_infinity_controller();
    
    % 성능 모니터링 및 재설계 트리거
    performance_monitor = statistical_change_detection();
    
    adaptive_controller = struct();
    adaptive_controller.identifier = system_identifier;
    adaptive_controller.controller = robust_controller;
    adaptive_controller.monitor = performance_monitor;
end
```

---

## 🏆 성공적인 강건설계를 위한 체크리스트

### 프로젝트 시작 단계
- [ ] 주요 불확실성 요인 식별 완료
- [ ] 불확실성 데이터 수집 계획 수립
- [ ] 성능 지표와 허용 변동 범위 정의
- [ ] 계산 자원과 시간 예산 설정

### 설계 단계
- [ ] 적절한 강건설계 방법론 선택
- [ ] 불확실성 모델의 타당성 검증
- [ ] 다양한 시나리오에서의 성능 평가
- [ ] 제조 및 운영 제약조건 반영

### 검증 단계
- [ ] 실험 또는 시뮬레이션을 통한 강건성 확인
- [ ] 민감도 분석 수행
- [ ] 최악의 경우 시나리오 테스트
- [ ] 비용-효과 분석 완료

### 구현 단계  
- [ ] 생산 공정의 강건성 확보
- [ ] 품질관리 시스템 구축
- [ ] 지속적 모니터링 체계 마련
- [ ] 피드백 루프 설계

---

**최종 정리:**

강건설계는 현실적인 불확실성을 고려하여 안정적이고 신뢰할 수 있는 제품을 만드는 핵심 기술입니다. 다구치 방법, 6시그마, 확률적 최적화 등 다양한 접근법을 상황에 맞게 선택하고 조합하여 사용하는 것이 중요합니다.

성공적인 강건설계를 위해서는:
1. **체계적인 불확실성 분석**
2. **적절한 방법론 선택**  
3. **충분한 검증과 테스트**
4. **지속적인 개선**

이 네 가지 요소가 균형있게 갖춰져야 합니다.

---

**참고문헌:**
- Taguchi, G., Chowdhury, S. & Wu, Y. (2004). *Taguchi's Quality Engineering Handbook*. Wiley.
- Beyer, H.G. & Sendhoff, B. (2007). Robust optimization–a comprehensive survey. *Computer Methods in Applied Mechanics and Engineering*, 196(33-34), 3190-3218.
- Ben-Tal, A., El Ghaoui, L. & Nemirovski, A. (2009). *Robust Optimization*. Princeton University Press.
- Phadke, M.S. (1989). *Quality Engineering Using Robust Design*. Prentice Hall.
- Du, X. & Chen, W. (2004). Sequential optimization and reliability assessment method for efficient probabilistic design. *Journal of Mechanical Design*, 126(2), 225-233.