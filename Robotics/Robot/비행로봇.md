# ë¹„í–‰ë¡œë´‡ (Aerial Robots)

## ğŸ“– ì£¼ìš” ì°¸ê³ ë¬¸í—Œ
> **í•µì‹¬ êµê³¼ì„œ**: *Introduction to Autonomous Aerial Vehicles* (Beard & McLain), *Quadrotor Dynamics and Control* (Bouabdallah)
> **ì£¼ìš” ì—°êµ¬ê¸°ê´€**: ETH Zurich, MIT, University of Pennsylvania GRASP Lab
> **ì°¸ê³ ì„œì **: *Multirotor Aerial Vehicles* (Pounds), *Unmanned Aircraft Systems* (Austin)

## ğŸ¯ ì •ì˜ ë° íŠ¹ì§•

**ë¹„í–‰ë¡œë´‡**ì€ ê³µì¤‘ì—ì„œ ììœ¨ì ìœ¼ë¡œ ë¹„í–‰í•˜ë©° ë‹¤ì–‘í•œ ì„ë¬´ë¥¼ ìˆ˜í–‰í•˜ëŠ” ë¬´ì¸í•­ê³µê¸°(UAV)ë¡œ, íšŒì „ìµê³¼ ê³ ì •ìµ í˜•íƒœë¡œ êµ¬ë¶„ë©ë‹ˆë‹¤.

### âœˆï¸ êµ¬ì¡°ì  ë¶„ë¥˜

#### íšŒì „ìµ (Rotorcraft)
```
ì¿¼ë“œì½¥í„° (Quadcopter):
- 4ê°œ ë¡œí„°, X ë˜ëŠ” + ë°°ì¹˜
- ê°€ì¥ ì¼ë°˜ì ì¸ í˜•íƒœ
- ìš°ìˆ˜í•œ í˜¸ë²„ë§ ì„±ëŠ¥

í—¥ì‚¬ì½¥í„°/ì˜¥í† ì½¥í„°:
- 6ê°œ/8ê°œ ë¡œí„°
- ë†’ì€ ì¤‘ë³µì„±ê³¼ ì•ˆì „ì„±
- ëŒ€í˜• í˜ì´ë¡œë“œ ê°€ëŠ¥

ì‹±ê¸€ ë¡œí„°:
- 1ê°œ ë©”ì¸ ë¡œí„° + í…Œì¼ ë¡œí„°
- ì „í†µì  í—¬ë¦¬ì½¥í„° í˜•íƒœ
- ë†’ì€ íš¨ìœ¨ì„±
```

#### ê³ ì •ìµ (Fixed-Wing)
```
ì „í†µì  ê³ ì •ìµ:
- ë™ì²´ + ë‚ ê°œ + ê¼¬ë¦¬ë‚ ê°œ
- ë†’ì€ ì†ë„ì™€ í•­ì†ê±°ë¦¬
- í™œì£¼ë¡œ í•„ìš”

í‹¸íŠ¸ë¡œí„°:
- íšŒì „ ê°€ëŠ¥í•œ ë¡œí„°
- ìˆ˜ì§ì´ì°©ë¥™ + ê³ ì†ìˆœí•­
- ë³µì¡í•œ ì œì–´ ì‹œìŠ¤í…œ
```

### âš¡ ì¥ì 
- **3ì°¨ì› ê¸°ë™ì„±**: ì „ ë°©í–¥ ì´ë™ ê°€ëŠ¥
- **ì ‘ê·¼ì„±**: ì§€ìƒ ì ‘ê·¼ ë¶ˆê°€ ì§€ì—­ ë„ë‹¬
- **ì‹ ì†ì„±**: ë¹ ë¥¸ ë°°ì¹˜ì™€ ì´ë™
- **ì•ˆì „ì„±**: ì¸ëª… ìœ„í—˜ ìµœì†Œí™”

### âš ï¸ ì œì•½ ì‚¬í•­
- **ì—ë„ˆì§€ ì œí•œ**: ì œí•œëœ ë°°í„°ë¦¬ ìš©ëŸ‰
- **í˜ì´ë¡œë“œ ì œí•œ**: ì¤‘ëŸ‰ ëŒ€ë¹„ ë‚®ì€ íƒ‘ì¬ëŸ‰
- **ë‚ ì”¨ ì˜ì¡´ì„±**: í’ì†, ê°•ìˆ˜ëŸ‰ ì˜í–¥
- **ë²•ì  ì œì•½**: í•­ê³µë²•, ë¹„í–‰ê¸ˆì§€êµ¬ì—­

## ğŸ”§ ê³µê¸°ì—­í•™ ê¸°ì´ˆ

### 1. ë¡œí„° ê³µê¸°ì—­í•™

#### ìš´ë™ëŸ‰ ì´ë¡  (Momentum Theory)
```python
def rotor_thrust_momentum_theory(disk_area, air_density, induced_velocity):
    """ìš´ë™ëŸ‰ ì´ë¡ ì„ ì´ìš©í•œ ë¡œí„° ì¶”ë ¥ ê³„ì‚°"""
    
    # ì¶”ë ¥ = ì§ˆëŸ‰ìœ ëŸ‰ Ã— ì†ë„ ë³€í™”
    mass_flow_rate = air_density * disk_area * induced_velocity
    thrust = mass_flow_rate * induced_velocity
    
    # ì´ìƒì  ìœ ë„ì†ë„
    # T = Ï * A * vÂ² = 2 * Ï * A * v * v/2
    ideal_induced_velocity = np.sqrt(thrust / (2 * air_density * disk_area))
    
    return thrust, ideal_induced_velocity
```

#### ë¸”ë ˆì´ë“œ ìš”ì†Œ ì´ë¡  (Blade Element Theory)
```python
class BladeElement:
    """ë¸”ë ˆì´ë“œ ìš”ì†Œ í•´ì„"""
    
    def __init__(self, chord, twist_angle, airfoil_data):
        self.chord = chord
        self.twist = twist_angle
        self.airfoil = airfoil_data
    
    def compute_forces(self, radius, rpm, collective_pitch, air_density):
        """ë¸”ë ˆì´ë“œ ìš”ì†Œ í˜ ê³„ì‚°"""
        
        # íšŒì „ ì†ë„
        omega = rpm * 2 * np.pi / 60
        
        # ë¸”ë ˆì´ë“œ ì†ë„
        blade_velocity = omega * radius
        
        # ìœ íš¨ ë°›ìŒê°
        effective_aoa = collective_pitch + self.twist
        
        # ì–‘ë ¥ ê³„ìˆ˜ (ì—ì–´í¬ì¼ ë°ì´í„°ë¡œë¶€í„°)
        cl = self.airfoil.get_lift_coefficient(effective_aoa)
        cd = self.airfoil.get_drag_coefficient(effective_aoa)
        
        # ë™ì  ì••ë ¥
        dynamic_pressure = 0.5 * air_density * blade_velocity**2
        
        # í˜ ê³„ì‚°
        lift = cl * dynamic_pressure * self.chord
        drag = cd * dynamic_pressure * self.chord
        
        return lift, drag
```

### 2. ê³ ì •ìµ ê³µê¸°ì—­í•™

#### ì–‘ë ¥ ìƒì„±
```python
def wing_lift_calculation(wing_area, air_density, airspeed, angle_of_attack, cl_alpha):
    """ê³ ì •ìµ ì–‘ë ¥ ê³„ì‚°"""
    
    # ì–‘ë ¥ ê³„ìˆ˜
    cl = cl_alpha * angle_of_attack
    
    # ë™ì  ì••ë ¥
    dynamic_pressure = 0.5 * air_density * airspeed**2
    
    # ì–‘ë ¥
    lift = cl * dynamic_pressure * wing_area
    
    return lift, cl
```

#### í•­ë ¥ êµ¬ì„±
```python
def total_drag_calculation(wing_area, air_density, airspeed, cd0, k, cl):
    """ì´ í•­ë ¥ ê³„ì‚°"""
    
    # ë™ì  ì••ë ¥
    q = 0.5 * air_density * airspeed**2
    
    # ì˜ì  ì–‘ë ¥ í•­ë ¥ (ë§ˆì°° í•­ë ¥)
    parasite_drag = cd0 * q * wing_area
    
    # ìœ ë„ í•­ë ¥
    induced_drag = k * cl**2 * q * wing_area
    
    # ì´ í•­ë ¥
    total_drag = parasite_drag + induced_drag
    
    return total_drag, parasite_drag, induced_drag
```

## âš™ï¸ ë¹„í–‰ ë™ì—­í•™

### 1. ì¿¼ë“œì½¥í„° ë™ì—­í•™

#### ìš´ë™ ë°©ì •ì‹
```python
class QuadcopterDynamics:
    """ì¿¼ë“œì½¥í„° ë™ì—­í•™ ëª¨ë¸"""
    
    def __init__(self, mass, inertia_matrix, arm_length):
        self.m = mass
        self.I = inertia_matrix
        self.L = arm_length  # ì•” ê¸¸ì´
        self.g = 9.81
    
    def equations_of_motion(self, state, control_inputs):
        """6DOF ìš´ë™ ë°©ì •ì‹"""
        
        # ìƒíƒœ ë³€ìˆ˜ ì¶”ì¶œ
        position = state[:3]  # [x, y, z]
        velocity = state[3:6]  # [vx, vy, vz]
        orientation = state[6:9]  # [phi, theta, psi] (roll, pitch, yaw)
        angular_velocity = state[9:12]  # [p, q, r]
        
        # ì œì–´ ì…ë ¥ (ë¡œí„° ì¶”ë ¥)
        T1, T2, T3, T4 = control_inputs
        
        # ì´ ì¶”ë ¥
        total_thrust = T1 + T2 + T3 + T4
        
        # ëª¨ë©˜íŠ¸ ê³„ì‚°
        tau_x = self.L * (T2 - T4)  # ë¡¤ ëª¨ë©˜íŠ¸
        tau_y = self.L * (T3 - T1)  # í”¼ì¹˜ ëª¨ë©˜íŠ¸
        tau_z = 0.1 * (T1 - T2 + T3 - T4)  # ìš” ëª¨ë©˜íŠ¸ (í† í¬ ì°¨ì´)
        
        # íšŒì „í–‰ë ¬ (body â†’ inertial)
        phi, theta, psi = orientation
        R = self.rotation_matrix(phi, theta, psi)
        
        # í˜ ë°©ì •ì‹ (ë‰´í„´ 2ë²•ì¹™)
        thrust_body = np.array([0, 0, total_thrust])
        thrust_inertial = R @ thrust_body
        weight = np.array([0, 0, -self.m * self.g])
        
        acceleration = (thrust_inertial + weight) / self.m
        
        # ëª¨ë©˜íŠ¸ ë°©ì •ì‹ (ì˜¤ì¼ëŸ¬ ë°©ì •ì‹)
        torque = np.array([tau_x, tau_y, tau_z])
        angular_acceleration = np.linalg.inv(self.I) @ (
            torque - np.cross(angular_velocity, self.I @ angular_velocity))
        
        # ìì„¸ ë³€í™”ìœ¨ (ì˜¤ì¼ëŸ¬ê° â†’ ê°ì†ë„ ë³€í™˜)
        euler_rate_matrix = self.euler_rate_matrix(phi, theta)
        euler_rates = euler_rate_matrix @ angular_velocity
        
        # ìƒíƒœ ë¯¸ë¶„
        state_dot = np.concatenate([
            velocity,           # ìœ„ì¹˜ ë³€í™”ìœ¨
            acceleration,       # ì†ë„ ë³€í™”ìœ¨  
            euler_rates,        # ìì„¸ ë³€í™”ìœ¨
            angular_acceleration # ê°ì†ë„ ë³€í™”ìœ¨
        ])
        
        return state_dot
    
    def rotation_matrix(self, phi, theta, psi):
        """ì˜¤ì¼ëŸ¬ê°ìœ¼ë¡œë¶€í„° íšŒì „í–‰ë ¬"""
        
        R_x = np.array([[1, 0, 0],
                       [0, np.cos(phi), -np.sin(phi)],
                       [0, np.sin(phi), np.cos(phi)]])
        
        R_y = np.array([[np.cos(theta), 0, np.sin(theta)],
                       [0, 1, 0],
                       [-np.sin(theta), 0, np.cos(theta)]])
        
        R_z = np.array([[np.cos(psi), -np.sin(psi), 0],
                       [np.sin(psi), np.cos(psi), 0],
                       [0, 0, 1]])
        
        return R_z @ R_y @ R_x
```

### 2. ê³ ì •ìµ ë™ì—­í•™

#### 6DOF í•­ê³µê¸° ë™ì—­í•™
```python
class FixedWingDynamics:
    """ê³ ì •ìµ í•­ê³µê¸° ë™ì—­í•™"""
    
    def __init__(self, mass, inertia, aerodynamic_coeffs):
        self.m = mass
        self.I = inertia
        self.aero = aerodynamic_coeffs
    
    def aerodynamic_forces_moments(self, state, control_surfaces):
        """ê³µê¸°ì—­í•™ì  í˜ê³¼ ëª¨ë©˜íŠ¸"""
        
        # ìƒíƒœ ë³€ìˆ˜
        V, alpha, beta = state['airspeed'], state['aoa'], state['sideslip']
        p, q, r = state['angular_rates']
        
        # ì¡°ì¢…ë©´ ê°ë„
        elevator, aileron, rudder = control_surfaces
        
        # ë™ì  ì••ë ¥
        q_bar = 0.5 * self.aero['rho'] * V**2
        
        # í˜ ê³„ìˆ˜
        CL = self.aero['CL0'] + self.aero['CLalpha'] * alpha + self.aero['CLde'] * elevator
        CD = self.aero['CD0'] + self.aero['CDalpha'] * alpha**2
        CY = self.aero['CYbeta'] * beta + self.aero['CYdr'] * rudder
        
        # ëª¨ë©˜íŠ¸ ê³„ìˆ˜
        Cl = self.aero['Clbeta'] * beta + self.aero['Clda'] * aileron + self.aero['Clp'] * p
        Cm = self.aero['Cm0'] + self.aero['Cmalpha'] * alpha + self.aero['Cmde'] * elevator + self.aero['Cmq'] * q
        Cn = self.aero['Cnbeta'] * beta + self.aero['Cndr'] * rudder + self.aero['Cnr'] * r
        
        # í˜ê³¼ ëª¨ë©˜íŠ¸
        S = self.aero['wing_area']
        b = self.aero['wingspan']
        c = self.aero['chord']
        
        forces = q_bar * S * np.array([-CD, CY, -CL])
        moments = q_bar * S * np.array([Cl * b, Cm * c, Cn * b])
        
        return forces, moments
```

## ğŸ¯ ë¹„í–‰ ì œì–´ ì‹œìŠ¤í…œ

### 1. ì¿¼ë“œì½¥í„° ì œì–´

#### ê³„ì¸µì  ì œì–´ êµ¬ì¡°
```python
class QuadcopterController:
    """ì¿¼ë“œì½¥í„° ê³„ì¸µì  ì œì–´ê¸°"""
    
    def __init__(self):
        # ìœ„ì¹˜ ì œì–´ê¸° ê²Œì¸
        self.kp_pos = np.diag([1.0, 1.0, 2.0])
        self.kd_pos = np.diag([0.5, 0.5, 1.0])
        
        # ìì„¸ ì œì–´ê¸° ê²Œì¸
        self.kp_att = np.diag([5.0, 5.0, 2.0])
        self.kd_att = np.diag([1.0, 1.0, 0.5])
    
    def position_controller(self, desired_pos, current_pos, desired_vel, current_vel):
        """ì™¸ë¶€ ë£¨í”„: ìœ„ì¹˜ ì œì–´"""
        
        # ìœ„ì¹˜ ì˜¤ì°¨
        pos_error = desired_pos - current_pos
        vel_error = desired_vel - current_vel
        
        # PD ì œì–´
        desired_acceleration = (self.kp_pos @ pos_error + 
                              self.kd_pos @ vel_error)
        
        # ì¤‘ë ¥ ë³´ìƒ
        desired_acceleration[2] += 9.81
        
        # ì›í•˜ëŠ” ì¶”ë ¥ í¬ê¸°
        desired_thrust = np.linalg.norm(desired_acceleration)
        
        # ì›í•˜ëŠ” ìì„¸ (ì¶”ë ¥ ë°©í–¥ìœ¼ë¡œë¶€í„° ê³„ì‚°)
        thrust_direction = desired_acceleration / desired_thrust
        
        # ìš” ê°ì€ ë³„ë„ ì§€ì •
        desired_yaw = 0.0
        
        # ì¶”ë ¥ ë°©í–¥ìœ¼ë¡œë¶€í„° ë¡¤, í”¼ì¹˜ ê³„ì‚°
        desired_pitch = np.arcsin(-thrust_direction[0])
        desired_roll = np.arctan2(thrust_direction[1], thrust_direction[2])
        
        desired_attitude = np.array([desired_roll, desired_pitch, desired_yaw])
        
        return desired_thrust, desired_attitude
    
    def attitude_controller(self, desired_att, current_att, desired_rates, current_rates):
        """ë‚´ë¶€ ë£¨í”„: ìì„¸ ì œì–´"""
        
        # ìì„¸ ì˜¤ì°¨
        att_error = desired_att - current_att
        rate_error = desired_rates - current_rates
        
        # PD ì œì–´ë¡œ ì›í•˜ëŠ” ê°ê°€ì†ë„
        desired_angular_acc = (self.kp_att @ att_error + 
                             self.kd_att @ rate_error)
        
        return desired_angular_acc
    
    def control_allocation(self, total_thrust, desired_moments):
        """ì œì–´ í• ë‹¹: ì¶”ë ¥/ëª¨ë©˜íŠ¸ â†’ ë¡œí„° ì¶”ë ¥"""
        
        # í• ë‹¹ í–‰ë ¬
        # [T ]   [1  1  1  1 ] [T1]
        # [Ï„x] = [0  L  0 -L ] [T2]  
        # [Ï„y]   [-L 0  L  0 ] [T3]
        # [Ï„z]   [d -d  d -d ] [T4]
        
        L = 0.25  # ì•” ê¸¸ì´
        d = 0.01  # ë“œë˜ê·¸ ê³„ìˆ˜
        
        allocation_matrix = np.array([
            [1,  1,  1,  1],
            [0,  L,  0, -L],
            [-L, 0,  L,  0],
            [d, -d,  d, -d]
        ])
        
        # ëª©í‘œ ë²¡í„°
        target = np.array([total_thrust, 
                          desired_moments[0], 
                          desired_moments[1], 
                          desired_moments[2]])
        
        # ë¡œí„° ì¶”ë ¥ ê³„ì‚° (ì—­í–‰ë ¬)
        rotor_thrusts = np.linalg.inv(allocation_matrix) @ target
        
        # ë¬¼ë¦¬ì  ì œì•½ (ì–‘ìˆ˜, ìµœëŒ€ê°’)
        rotor_thrusts = np.clip(rotor_thrusts, 0, 15.0)  # ìµœëŒ€ 15N
        
        return rotor_thrusts
```

### 2. ê³ ì •ìµ ì œì–´

#### ìë™ì¡°ì¢…ì¥ì¹˜ (Autopilot)
```python
class FixedWingAutopilot:
    """ê³ ì •ìµ ìë™ì¡°ì¢…ì¥ì¹˜"""
    
    def __init__(self):
        # ì„¸ë¡œ ì•ˆì •ì„± ì¦ëŒ€ ì‹œìŠ¤í…œ (SAS)
        self.pitch_damper_gain = -0.5
        self.elevator_per_g = -0.02
        
        # í•­ë²• ì œì–´ê¸°
        self.heading_gain = 0.1
        self.altitude_gain = 0.05
        self.airspeed_gain = 0.1
    
    def lateral_autopilot(self, desired_heading, current_heading, current_roll):
        """íš¡ ë°©í–¥ ìë™ì¡°ì¢…"""
        
        # ë°©í–¥ ì˜¤ì°¨
        heading_error = self.normalize_angle(desired_heading - current_heading)
        
        # ì›í•˜ëŠ” ë¡¤ê° (ì„ íšŒë¥¼ ìœ„í•œ)
        desired_roll = self.heading_gain * heading_error
        desired_roll = np.clip(desired_roll, -np.pi/6, np.pi/6)  # Â±30ë„ ì œí•œ
        
        # ë¡¤ ì œì–´
        roll_error = desired_roll - current_roll
        aileron_command = 2.0 * roll_error  # ë¹„ë¡€ ì œì–´
        
        return aileron_command
    
    def longitudinal_autopilot(self, desired_altitude, current_altitude, 
                             desired_airspeed, current_airspeed):
        """ì¢… ë°©í–¥ ìë™ì¡°ì¢…"""
        
        # ê³ ë„ ì œì–´
        altitude_error = desired_altitude - current_altitude
        elevator_command_alt = self.altitude_gain * altitude_error
        
        # ì†ë„ ì œì–´ (ìŠ¤ë¡œí‹€)
        airspeed_error = desired_airspeed - current_airspeed
        throttle_command = 0.5 + self.airspeed_gain * airspeed_error
        throttle_command = np.clip(throttle_command, 0, 1)
        
        return elevator_command_alt, throttle_command
    
    def stability_augmentation(self, pitch_rate, normal_acceleration):
        """ì•ˆì •ì„± ì¦ëŒ€ ì‹œìŠ¤í…œ"""
        
        # í”¼ì¹˜ ëŒí¼
        elevator_pitch_damper = self.pitch_damper_gain * pitch_rate
        
        # í•˜ì¤‘ ì œí•œ
        elevator_g_limit = self.elevator_per_g * normal_acceleration
        
        total_elevator_command = elevator_pitch_damper + elevator_g_limit
        
        return total_elevator_command
```

### 3. ì ì‘ ì œì–´

#### ëª¨ë¸ ê¸°ì¤€ ì ì‘ ì œì–´ (MRAC)
```python
class AdaptiveController:
    """ëª¨ë¸ ê¸°ì¤€ ì ì‘ ì œì–´"""
    
    def __init__(self, reference_model):
        self.reference_model = reference_model
        self.adaptation_gain = 0.1
        self.adaptive_parameters = np.zeros(10)  # ì ì‘ ë§¤ê°œë³€ìˆ˜
    
    def adaptive_control_law(self, reference_input, plant_output, model_output):
        """ì ì‘ ì œì–´ ë²•ì¹™"""
        
        # ì¶”ì  ì˜¤ì°¨
        tracking_error = model_output - plant_output
        
        # ì ì‘ ë²•ì¹™ (gradient descent)
        regressor = self.compute_regressor(reference_input, plant_output)
        parameter_update = self.adaptation_gain * tracking_error * regressor
        
        # ë§¤ê°œë³€ìˆ˜ ì—…ë°ì´íŠ¸
        self.adaptive_parameters += parameter_update
        
        # ì œì–´ ì…ë ¥
        control_input = self.adaptive_parameters @ regressor
        
        return control_input, self.adaptive_parameters
```

## ğŸ—ºï¸ ê²½ë¡œ ê³„íš ë° í•­ë²•

### 1. ê²½ë¡œ ê³„íš

#### A* ì•Œê³ ë¦¬ì¦˜ (3ì°¨ì›)
```python
class Path3D:
    """3ì°¨ì› ê²½ë¡œ ê³„íš"""
    
    def __init__(self, grid_resolution, obstacles):
        self.resolution = grid_resolution
        self.obstacles = obstacles
    
    def a_star_3d(self, start, goal):
        """3ì°¨ì› A* ê²½ë¡œ ê³„íš"""
        
        open_set = [(0, start)]  # (f_score, node)
        closed_set = set()
        
        g_score = {start: 0}
        f_score = {start: self.heuristic(start, goal)}
        came_from = {}
        
        while open_set:
            current_f, current = heapq.heappop(open_set)
            
            if current == goal:
                return self.reconstruct_path(came_from, current)
            
            closed_set.add(current)
            
            # 26ê°œ ì´ì›ƒ (3ì°¨ì›)
            for neighbor in self.get_neighbors_3d(current):
                if neighbor in closed_set or self.is_obstacle(neighbor):
                    continue
                
                tentative_g = g_score[current] + self.distance(current, neighbor)
                
                if neighbor not in g_score or tentative_g < g_score[neighbor]:
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g
                    f_score[neighbor] = tentative_g + self.heuristic(neighbor, goal)
                    
                    heapq.heappush(open_set, (f_score[neighbor], neighbor))
        
        return None  # ê²½ë¡œ ì—†ìŒ
    
    def heuristic(self, node1, node2):
        """ìœ í´ë¦¬ë“œ ê±°ë¦¬ íœ´ë¦¬ìŠ¤í‹±"""
        return np.linalg.norm(np.array(node1) - np.array(node2))
```

#### RRT* (Rapidly-exploring Random Tree)
```python
class RRTStar3D:
    """3ì°¨ì› RRT* ê²½ë¡œ ê³„íš"""
    
    def __init__(self, start, goal, bounds, obstacle_check_fn):
        self.start = start
        self.goal = goal
        self.bounds = bounds
        self.is_collision_free = obstacle_check_fn
        self.step_size = 1.0
        self.goal_bias = 0.1
        
    def plan(self, max_iterations):
        """RRT* ê²½ë¡œ ê³„íš"""
        
        tree = {self.start: {'parent': None, 'cost': 0}}
        
        for i in range(max_iterations):
            # ëœë¤ ìƒ˜í”Œë§ (goal bias í¬í•¨)
            if np.random.random() < self.goal_bias:
                sample = self.goal
            else:
                sample = self.random_sample()
            
            # ê°€ì¥ ê°€ê¹Œìš´ ë…¸ë“œ
            nearest = self.find_nearest(tree, sample)
            
            # ìƒˆ ë…¸ë“œ ìƒì„±
            new_node = self.steer(nearest, sample)
            
            if self.is_collision_free(nearest, new_node):
                # ì£¼ë³€ ë…¸ë“œë“¤
                near_nodes = self.find_near_nodes(tree, new_node)
                
                # ìµœì†Œ ë¹„ìš© ë¶€ëª¨ ì„ íƒ
                min_cost = tree[nearest]['cost'] + self.distance(nearest, new_node)
                min_parent = nearest
                
                for near_node in near_nodes:
                    cost = tree[near_node]['cost'] + self.distance(near_node, new_node)
                    if cost < min_cost and self.is_collision_free(near_node, new_node):
                        min_cost = cost
                        min_parent = near_node
                
                # íŠ¸ë¦¬ì— ì¶”ê°€
                tree[new_node] = {'parent': min_parent, 'cost': min_cost}
                
                # ì¬ì—°ê²° (rewiring)
                for near_node in near_nodes:
                    new_cost = min_cost + self.distance(new_node, near_node)
                    if new_cost < tree[near_node]['cost']:
                        if self.is_collision_free(new_node, near_node):
                            tree[near_node]['parent'] = new_node
                            tree[near_node]['cost'] = new_cost
        
        # ëª©í‘œì ê¹Œì§€ì˜ ê²½ë¡œ ì¶”ì¶œ
        if self.goal in tree:
            return self.extract_path(tree, self.goal)
        else:
            return None
```

### 2. í•­ë²• ì‹œìŠ¤í…œ

#### ê´€ì„±í•­ë²•ì‹œìŠ¤í…œ (INS) + GPS ìœµí•©
```python
class INS_GPS_Navigation:
    """INS/GPS ìœµí•© í•­ë²•"""
    
    def __init__(self):
        self.state = np.zeros(15)  # [pos, vel, att, acc_bias, gyro_bias]
        self.covariance = np.eye(15) * 0.1
        self.ins_model = INSModel()
        
    def predict(self, imu_data, dt):
        """INS ì˜ˆì¸¡ ë‹¨ê³„"""
        
        # IMU ë°ì´í„°
        accel = imu_data['accelerometer']
        gyro = imu_data['gyroscope']
        
        # ë°”ì´ì–´ìŠ¤ ë³´ì •
        accel_corrected = accel - self.state[9:12]
        gyro_corrected = gyro - self.state[12:15]
        
        # INS ì—­í•™ ë°©ì •ì‹
        self.state = self.ins_model.propagate(
            self.state, accel_corrected, gyro_corrected, dt)
        
        # ê³µë¶„ì‚° ì „íŒŒ
        F = self.ins_model.state_transition_matrix(self.state, dt)
        Q = self.ins_model.process_noise_matrix(dt)
        self.covariance = F @ self.covariance @ F.T + Q
    
    def update_gps(self, gps_measurement):
        """GPS ì—…ë°ì´íŠ¸ ë‹¨ê³„"""
        
        # ê´€ì¸¡ í–‰ë ¬ (ìœ„ì¹˜ë§Œ ê´€ì¸¡)
        H = np.zeros((3, 15))
        H[0:3, 0:3] = np.eye(3)
        
        # ì¹¼ë§Œ ê²Œì¸
        R = np.eye(3) * 5.0  # GPS ì¸¡ì • ë…¸ì´ì¦ˆ
        S = H @ self.covariance @ H.T + R
        K = self.covariance @ H.T @ np.linalg.inv(S)
        
        # ìƒíƒœ ì—…ë°ì´íŠ¸
        innovation = gps_measurement - H @ self.state
        self.state += K @ innovation
        
        # ê³µë¶„ì‚° ì—…ë°ì´íŠ¸
        I = np.eye(15)
        self.covariance = (I - K @ H) @ self.covariance
```

## ğŸ¯ ì„¼ì„œ ì‹œìŠ¤í…œ

### 1. ê´€ì„±ì¸¡ì •ì¥ì¹˜ (IMU)

#### MEMS ì„¼ì„œ ëª¨ë¸ë§
```python
class IMU_Model:
    """IMU ì„¼ì„œ ëª¨ë¸"""
    
    def __init__(self):
        # ê°€ì†ë„ê³„ íŠ¹ì„±
        self.accel_noise_std = 0.01  # m/sÂ²
        self.accel_bias_std = 0.001
        self.accel_scale_factor_error = 0.001
        
        # ìì´ë¡œìŠ¤ì½”í”„ íŠ¹ì„±
        self.gyro_noise_std = 0.001  # rad/s
        self.gyro_bias_std = 0.0001
        self.gyro_scale_factor_error = 0.001
    
    def simulate_measurement(self, true_accel, true_gyro):
        """IMU ì¸¡ì •ê°’ ì‹œë®¬ë ˆì´ì…˜"""
        
        # ê°€ì†ë„ê³„ ì˜¤ì°¨ ëª¨ë¸
        accel_bias = np.random.normal(0, self.accel_bias_std, 3)
        accel_noise = np.random.normal(0, self.accel_noise_std, 3)
        accel_scale_error = np.random.normal(1, self.accel_scale_factor_error, 3)
        
        measured_accel = accel_scale_error * true_accel + accel_bias + accel_noise
        
        # ìì´ë¡œìŠ¤ì½”í”„ ì˜¤ì°¨ ëª¨ë¸
        gyro_bias = np.random.normal(0, self.gyro_bias_std, 3)
        gyro_noise = np.random.normal(0, self.gyro_noise_std, 3)
        gyro_scale_error = np.random.normal(1, self.gyro_scale_factor_error, 3)
        
        measured_gyro = gyro_scale_error * true_gyro + gyro_bias + gyro_noise
        
        return measured_accel, measured_gyro
```

### 2. ë¹„ì „ ì‹œìŠ¤í…œ

#### Visual SLAM
```python
class VisualSLAM:
    """ì‹œê° ê¸°ë°˜ ë™ì‹œ ìœ„ì¹˜ì¸ì‹ ë° ì§€ë„ ì‘ì„±"""
    
    def __init__(self, camera_params):
        self.camera = camera_params
        self.feature_detector = cv2.ORB_create()
        self.keyframes = []
        self.map_points = []
    
    def process_frame(self, image):
        """í”„ë ˆì„ ì²˜ë¦¬"""
        
        # íŠ¹ì§•ì  ì¶”ì¶œ
        keypoints, descriptors = self.feature_detector.detectAndCompute(image, None)
        
        if len(self.keyframes) == 0:
            # ì²« ë²ˆì§¸ í‚¤í”„ë ˆì„
            self.add_keyframe(image, keypoints, descriptors)
            return
        
        # íŠ¹ì§•ì  ë§¤ì¹­
        matches = self.match_features(descriptors, self.keyframes[-1]['descriptors'])
        
        # ëª¨ì…˜ ì¶”ì • (Essential Matrix)
        if len(matches) > 8:
            E, mask = cv2.findEssentialMat(
                matches[:, :2], matches[:, 2:], 
                self.camera.intrinsic_matrix, method=cv2.RANSAC)
            
            # ì¹´ë©”ë¼ í¬ì¦ˆ ë³µì›
            _, R, t, _ = cv2.recoverPose(E, matches[:, :2], matches[:, 2:],
                                        self.camera.intrinsic_matrix)
            
            # ì‚¼ê°ì¸¡ëŸ‰ìœ¼ë¡œ 3D ì  ìƒì„±
            points_3d = self.triangulate_points(matches, R, t)
            
            # ë§µ ì—…ë°ì´íŠ¸
            self.update_map(points_3d, keypoints, descriptors)
    
    def triangulate_points(self, matches, R, t):
        """ì‚¼ê°ì¸¡ëŸ‰ìœ¼ë¡œ 3D ì  ê³„ì‚°"""
        
        # íˆ¬ì˜ í–‰ë ¬
        P1 = self.camera.intrinsic_matrix @ np.hstack([np.eye(3), np.zeros((3, 1))])
        P2 = self.camera.intrinsic_matrix @ np.hstack([R, t])
        
        points_4d = cv2.triangulatePoints(P1, P2, 
                                         matches[:, :2].T, matches[:, 2:].T)
        
        # ë™ì°¨ì¢Œí‘œë¥¼ 3D ì¢Œí‘œë¡œ ë³€í™˜
        points_3d = points_4d[:3] / points_4d[3]
        
        return points_3d.T
```

### 3. LiDAR ì‹œìŠ¤í…œ

#### ì êµ° ì²˜ë¦¬
```python
class LiDAR_Processing:
    """LiDAR ì êµ° ì²˜ë¦¬"""
    
    def __init__(self):
        self.voxel_size = 0.1  # ë³µì…€ í¬ê¸°
    
    def process_point_cloud(self, points):
        """ì êµ° ì „ì²˜ë¦¬"""
        
        # 1. ë‹¤ìš´ìƒ˜í”Œë§ (ë³µì…€ ê·¸ë¦¬ë“œ)
        downsampled = self.voxel_grid_downsample(points)
        
        # 2. ë…¸ì´ì¦ˆ ì œê±° (í†µê³„ì  ì™¸ë¶€ê°’ ì œê±°)
        filtered = self.statistical_outlier_removal(downsampled)
        
        # 3. ì§€ë©´ ì œê±°
        ground_removed = self.remove_ground_plane(filtered)
        
        return ground_removed
    
    def voxel_grid_downsample(self, points):
        """ë³µì…€ ê·¸ë¦¬ë“œ ë‹¤ìš´ìƒ˜í”Œë§"""
        
        # ì ë“¤ì„ ë³µì…€ì— í• ë‹¹
        voxel_indices = np.floor(points / self.voxel_size).astype(int)
        
        # ê° ë³µì…€ì˜ ì¤‘ì‹¬ì  ê³„ì‚°
        unique_voxels, inverse_indices = np.unique(
            voxel_indices, axis=0, return_inverse=True)
        
        downsampled_points = []
        for i, voxel in enumerate(unique_voxels):
            voxel_points = points[inverse_indices == i]
            center_point = np.mean(voxel_points, axis=0)
            downsampled_points.append(center_point)
        
        return np.array(downsampled_points)
    
    def obstacle_detection(self, points):
        """ì¥ì• ë¬¼ ê²€ì¶œ"""
        
        # í´ëŸ¬ìŠ¤í„°ë§ (DBSCAN)
        clustering = DBSCAN(eps=0.5, min_samples=10)
        labels = clustering.fit_predict(points)
        
        obstacles = []
        for label in np.unique(labels):
            if label == -1:  # ë…¸ì´ì¦ˆ
                continue
            
            cluster_points = points[labels == label]
            
            # ë°”ìš´ë”© ë°•ìŠ¤ ê³„ì‚°
            min_coords = np.min(cluster_points, axis=0)
            max_coords = np.max(cluster_points, axis=0)
            
            obstacles.append({
                'points': cluster_points,
                'bbox': {'min': min_coords, 'max': max_coords},
                'center': np.mean(cluster_points, axis=0)
            })
        
        return obstacles
```

## ğŸ­ ì‘ìš© ë¶„ì•¼ ë° ì„±ëŠ¥

### 1. ë¯¼ê°„ ì‘ìš©
```
ë°°ì†¡ ì„œë¹„ìŠ¤:
- ì†Œí˜• íŒ¨í‚¤ì§€ ë°°ì†¡
- ì˜ë£Œìš©í’ˆ ê¸´ê¸‰ ìˆ˜ì†¡
- ìŒì‹ ë°°ë‹¬

ë†ì—…:
- ì‘ë¬¼ ëª¨ë‹ˆí„°ë§
- ì •ë°€ ë†ì•½ ì‚´í¬
- ê°€ì¶• ê´€ë¦¬

ì¸í”„ë¼ ì ê²€:
- ì†¡ì „ì„  ì ê²€
- êµëŸ‰ ì ê²€
- ê±´ë¬¼ ì™¸ë²½ ì ê²€

ì´¬ì˜/ì¸¡ëŸ‰:
- í•­ê³µ ì´¬ì˜
- ì§€í˜• ì¸¡ëŸ‰
- ê±´ì„¤ ëª¨ë‹ˆí„°ë§
```

### 2. ê³µê³µ ì•ˆì „
```
ì¬ë‚œ ëŒ€ì‘:
- ì‚°ë¶ˆ ê°ì‹œ
- í™ìˆ˜ ëª¨ë‹ˆí„°ë§
- ì§€ì§„ í”¼í•´ ì¡°ì‚¬

êµ¬ì¡° ì‘ì—…:
- ìˆ˜ìƒ‰ êµ¬ì¡°
- ì˜ë£Œì§„ ì ‘ê·¼ ë¶ˆê°€ ì§€ì—­
- ìœ„í—˜ë¬¼ì§ˆ íƒì§€

êµí†µ ê´€ë¦¬:
- êµí†µ ìƒí™© ëª¨ë‹ˆí„°ë§
- ì‚¬ê³  í˜„ì¥ ì¡°ì‚¬
- ë„ë¡œ ìƒíƒœ ì ê²€
```

### 3. ì„±ëŠ¥ ì§€í‘œ
```
ë¹„í–‰ ì„±ëŠ¥:
- ìµœëŒ€ ì†ë„: 15-300 km/h
- ë¹„í–‰ ê³ ë„: 0-500m (ë¯¼ê°„ìš©)
- í•­ì† ê±°ë¦¬: 10-100 km
- ë¹„í–‰ ì‹œê°„: 20-120ë¶„

í˜ì´ë¡œë“œ:
- ì†Œí˜•: 0.1-2 kg
- ì¤‘í˜•: 2-25 kg  
- ëŒ€í˜•: 25-100+ kg

ì •ë°€ë„:
- ìœ„ì¹˜ ì •í™•ë„: Â±1-10 cm (RTK GPS)
- ìì„¸ ì •í™•ë„: Â±0.1-1Â°
- í˜¸ë²„ë§ ì •í™•ë„: Â±5-50 cm
```

---

#ë¹„í–‰ë¡œë´‡ #AerialRobots #ì¿¼ë“œì½¥í„° #ê³ ì •ìµ #ë¬´ì¸í•­ê³µê¸° #ììœ¨ë¹„í–‰