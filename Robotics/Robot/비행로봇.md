# 비행로봇 (Aerial Robots)

## 📖 주요 참고문헌
> **핵심 교과서**: *Introduction to Autonomous Aerial Vehicles* (Beard & McLain), *Quadrotor Dynamics and Control* (Bouabdallah)
> **주요 연구기관**: ETH Zurich, MIT, University of Pennsylvania GRASP Lab
> **참고서적**: *Multirotor Aerial Vehicles* (Pounds), *Unmanned Aircraft Systems* (Austin)

## 🎯 정의 및 특징

**비행로봇**은 공중에서 자율적으로 비행하며 다양한 임무를 수행하는 무인항공기(UAV)로, 회전익과 고정익 형태로 구분됩니다.

### ✈️ 구조적 분류

#### 회전익 (Rotorcraft)
```
쿼드콥터 (Quadcopter):
- 4개 로터, X 또는 + 배치
- 가장 일반적인 형태
- 우수한 호버링 성능

헥사콥터/옥토콥터:
- 6개/8개 로터
- 높은 중복성과 안전성
- 대형 페이로드 가능

싱글 로터:
- 1개 메인 로터 + 테일 로터
- 전통적 헬리콥터 형태
- 높은 효율성
```

#### 고정익 (Fixed-Wing)
```
전통적 고정익:
- 동체 + 날개 + 꼬리날개
- 높은 속도와 항속거리
- 활주로 필요

틸트로터:
- 회전 가능한 로터
- 수직이착륙 + 고속순항
- 복잡한 제어 시스템
```

### ⚡ 장점
- **3차원 기동성**: 전 방향 이동 가능
- **접근성**: 지상 접근 불가 지역 도달
- **신속성**: 빠른 배치와 이동
- **안전성**: 인명 위험 최소화

### ⚠️ 제약 사항
- **에너지 제한**: 제한된 배터리 용량
- **페이로드 제한**: 중량 대비 낮은 탑재량
- **날씨 의존성**: 풍속, 강수량 영향
- **법적 제약**: 항공법, 비행금지구역

## 🔧 공기역학 기초

### 1. 로터 공기역학

#### 운동량 이론 (Momentum Theory)
```python
def rotor_thrust_momentum_theory(disk_area, air_density, induced_velocity):
    """운동량 이론을 이용한 로터 추력 계산"""
    
    # 추력 = 질량유량 × 속도 변화
    mass_flow_rate = air_density * disk_area * induced_velocity
    thrust = mass_flow_rate * induced_velocity
    
    # 이상적 유도속도
    # T = ρ * A * v² = 2 * ρ * A * v * v/2
    ideal_induced_velocity = np.sqrt(thrust / (2 * air_density * disk_area))
    
    return thrust, ideal_induced_velocity
```

#### 블레이드 요소 이론 (Blade Element Theory)
```python
class BladeElement:
    """블레이드 요소 해석"""
    
    def __init__(self, chord, twist_angle, airfoil_data):
        self.chord = chord
        self.twist = twist_angle
        self.airfoil = airfoil_data
    
    def compute_forces(self, radius, rpm, collective_pitch, air_density):
        """블레이드 요소 힘 계산"""
        
        # 회전 속도
        omega = rpm * 2 * np.pi / 60
        
        # 블레이드 속도
        blade_velocity = omega * radius
        
        # 유효 받음각
        effective_aoa = collective_pitch + self.twist
        
        # 양력 계수 (에어포일 데이터로부터)
        cl = self.airfoil.get_lift_coefficient(effective_aoa)
        cd = self.airfoil.get_drag_coefficient(effective_aoa)
        
        # 동적 압력
        dynamic_pressure = 0.5 * air_density * blade_velocity**2
        
        # 힘 계산
        lift = cl * dynamic_pressure * self.chord
        drag = cd * dynamic_pressure * self.chord
        
        return lift, drag
```

### 2. 고정익 공기역학

#### 양력 생성
```python
def wing_lift_calculation(wing_area, air_density, airspeed, angle_of_attack, cl_alpha):
    """고정익 양력 계산"""
    
    # 양력 계수
    cl = cl_alpha * angle_of_attack
    
    # 동적 압력
    dynamic_pressure = 0.5 * air_density * airspeed**2
    
    # 양력
    lift = cl * dynamic_pressure * wing_area
    
    return lift, cl
```

#### 항력 구성
```python
def total_drag_calculation(wing_area, air_density, airspeed, cd0, k, cl):
    """총 항력 계산"""
    
    # 동적 압력
    q = 0.5 * air_density * airspeed**2
    
    # 영점 양력 항력 (마찰 항력)
    parasite_drag = cd0 * q * wing_area
    
    # 유도 항력
    induced_drag = k * cl**2 * q * wing_area
    
    # 총 항력
    total_drag = parasite_drag + induced_drag
    
    return total_drag, parasite_drag, induced_drag
```

## ⚙️ 비행 동역학

### 1. 쿼드콥터 동역학

#### 운동 방정식
```python
class QuadcopterDynamics:
    """쿼드콥터 동역학 모델"""
    
    def __init__(self, mass, inertia_matrix, arm_length):
        self.m = mass
        self.I = inertia_matrix
        self.L = arm_length  # 암 길이
        self.g = 9.81
    
    def equations_of_motion(self, state, control_inputs):
        """6DOF 운동 방정식"""
        
        # 상태 변수 추출
        position = state[:3]  # [x, y, z]
        velocity = state[3:6]  # [vx, vy, vz]
        orientation = state[6:9]  # [phi, theta, psi] (roll, pitch, yaw)
        angular_velocity = state[9:12]  # [p, q, r]
        
        # 제어 입력 (로터 추력)
        T1, T2, T3, T4 = control_inputs
        
        # 총 추력
        total_thrust = T1 + T2 + T3 + T4
        
        # 모멘트 계산
        tau_x = self.L * (T2 - T4)  # 롤 모멘트
        tau_y = self.L * (T3 - T1)  # 피치 모멘트
        tau_z = 0.1 * (T1 - T2 + T3 - T4)  # 요 모멘트 (토크 차이)
        
        # 회전행렬 (body → inertial)
        phi, theta, psi = orientation
        R = self.rotation_matrix(phi, theta, psi)
        
        # 힘 방정식 (뉴턴 2법칙)
        thrust_body = np.array([0, 0, total_thrust])
        thrust_inertial = R @ thrust_body
        weight = np.array([0, 0, -self.m * self.g])
        
        acceleration = (thrust_inertial + weight) / self.m
        
        # 모멘트 방정식 (오일러 방정식)
        torque = np.array([tau_x, tau_y, tau_z])
        angular_acceleration = np.linalg.inv(self.I) @ (
            torque - np.cross(angular_velocity, self.I @ angular_velocity))
        
        # 자세 변화율 (오일러각 → 각속도 변환)
        euler_rate_matrix = self.euler_rate_matrix(phi, theta)
        euler_rates = euler_rate_matrix @ angular_velocity
        
        # 상태 미분
        state_dot = np.concatenate([
            velocity,           # 위치 변화율
            acceleration,       # 속도 변화율  
            euler_rates,        # 자세 변화율
            angular_acceleration # 각속도 변화율
        ])
        
        return state_dot
    
    def rotation_matrix(self, phi, theta, psi):
        """오일러각으로부터 회전행렬"""
        
        R_x = np.array([[1, 0, 0],
                       [0, np.cos(phi), -np.sin(phi)],
                       [0, np.sin(phi), np.cos(phi)]])
        
        R_y = np.array([[np.cos(theta), 0, np.sin(theta)],
                       [0, 1, 0],
                       [-np.sin(theta), 0, np.cos(theta)]])
        
        R_z = np.array([[np.cos(psi), -np.sin(psi), 0],
                       [np.sin(psi), np.cos(psi), 0],
                       [0, 0, 1]])
        
        return R_z @ R_y @ R_x
```

### 2. 고정익 동역학

#### 6DOF 항공기 동역학
```python
class FixedWingDynamics:
    """고정익 항공기 동역학"""
    
    def __init__(self, mass, inertia, aerodynamic_coeffs):
        self.m = mass
        self.I = inertia
        self.aero = aerodynamic_coeffs
    
    def aerodynamic_forces_moments(self, state, control_surfaces):
        """공기역학적 힘과 모멘트"""
        
        # 상태 변수
        V, alpha, beta = state['airspeed'], state['aoa'], state['sideslip']
        p, q, r = state['angular_rates']
        
        # 조종면 각도
        elevator, aileron, rudder = control_surfaces
        
        # 동적 압력
        q_bar = 0.5 * self.aero['rho'] * V**2
        
        # 힘 계수
        CL = self.aero['CL0'] + self.aero['CLalpha'] * alpha + self.aero['CLde'] * elevator
        CD = self.aero['CD0'] + self.aero['CDalpha'] * alpha**2
        CY = self.aero['CYbeta'] * beta + self.aero['CYdr'] * rudder
        
        # 모멘트 계수
        Cl = self.aero['Clbeta'] * beta + self.aero['Clda'] * aileron + self.aero['Clp'] * p
        Cm = self.aero['Cm0'] + self.aero['Cmalpha'] * alpha + self.aero['Cmde'] * elevator + self.aero['Cmq'] * q
        Cn = self.aero['Cnbeta'] * beta + self.aero['Cndr'] * rudder + self.aero['Cnr'] * r
        
        # 힘과 모멘트
        S = self.aero['wing_area']
        b = self.aero['wingspan']
        c = self.aero['chord']
        
        forces = q_bar * S * np.array([-CD, CY, -CL])
        moments = q_bar * S * np.array([Cl * b, Cm * c, Cn * b])
        
        return forces, moments
```

## 🎯 비행 제어 시스템

### 1. 쿼드콥터 제어

#### 계층적 제어 구조
```python
class QuadcopterController:
    """쿼드콥터 계층적 제어기"""
    
    def __init__(self):
        # 위치 제어기 게인
        self.kp_pos = np.diag([1.0, 1.0, 2.0])
        self.kd_pos = np.diag([0.5, 0.5, 1.0])
        
        # 자세 제어기 게인
        self.kp_att = np.diag([5.0, 5.0, 2.0])
        self.kd_att = np.diag([1.0, 1.0, 0.5])
    
    def position_controller(self, desired_pos, current_pos, desired_vel, current_vel):
        """외부 루프: 위치 제어"""
        
        # 위치 오차
        pos_error = desired_pos - current_pos
        vel_error = desired_vel - current_vel
        
        # PD 제어
        desired_acceleration = (self.kp_pos @ pos_error + 
                              self.kd_pos @ vel_error)
        
        # 중력 보상
        desired_acceleration[2] += 9.81
        
        # 원하는 추력 크기
        desired_thrust = np.linalg.norm(desired_acceleration)
        
        # 원하는 자세 (추력 방향으로부터 계산)
        thrust_direction = desired_acceleration / desired_thrust
        
        # 요 각은 별도 지정
        desired_yaw = 0.0
        
        # 추력 방향으로부터 롤, 피치 계산
        desired_pitch = np.arcsin(-thrust_direction[0])
        desired_roll = np.arctan2(thrust_direction[1], thrust_direction[2])
        
        desired_attitude = np.array([desired_roll, desired_pitch, desired_yaw])
        
        return desired_thrust, desired_attitude
    
    def attitude_controller(self, desired_att, current_att, desired_rates, current_rates):
        """내부 루프: 자세 제어"""
        
        # 자세 오차
        att_error = desired_att - current_att
        rate_error = desired_rates - current_rates
        
        # PD 제어로 원하는 각가속도
        desired_angular_acc = (self.kp_att @ att_error + 
                             self.kd_att @ rate_error)
        
        return desired_angular_acc
    
    def control_allocation(self, total_thrust, desired_moments):
        """제어 할당: 추력/모멘트 → 로터 추력"""
        
        # 할당 행렬
        # [T ]   [1  1  1  1 ] [T1]
        # [τx] = [0  L  0 -L ] [T2]  
        # [τy]   [-L 0  L  0 ] [T3]
        # [τz]   [d -d  d -d ] [T4]
        
        L = 0.25  # 암 길이
        d = 0.01  # 드래그 계수
        
        allocation_matrix = np.array([
            [1,  1,  1,  1],
            [0,  L,  0, -L],
            [-L, 0,  L,  0],
            [d, -d,  d, -d]
        ])
        
        # 목표 벡터
        target = np.array([total_thrust, 
                          desired_moments[0], 
                          desired_moments[1], 
                          desired_moments[2]])
        
        # 로터 추력 계산 (역행렬)
        rotor_thrusts = np.linalg.inv(allocation_matrix) @ target
        
        # 물리적 제약 (양수, 최대값)
        rotor_thrusts = np.clip(rotor_thrusts, 0, 15.0)  # 최대 15N
        
        return rotor_thrusts
```

### 2. 고정익 제어

#### 자동조종장치 (Autopilot)
```python
class FixedWingAutopilot:
    """고정익 자동조종장치"""
    
    def __init__(self):
        # 세로 안정성 증대 시스템 (SAS)
        self.pitch_damper_gain = -0.5
        self.elevator_per_g = -0.02
        
        # 항법 제어기
        self.heading_gain = 0.1
        self.altitude_gain = 0.05
        self.airspeed_gain = 0.1
    
    def lateral_autopilot(self, desired_heading, current_heading, current_roll):
        """횡 방향 자동조종"""
        
        # 방향 오차
        heading_error = self.normalize_angle(desired_heading - current_heading)
        
        # 원하는 롤각 (선회를 위한)
        desired_roll = self.heading_gain * heading_error
        desired_roll = np.clip(desired_roll, -np.pi/6, np.pi/6)  # ±30도 제한
        
        # 롤 제어
        roll_error = desired_roll - current_roll
        aileron_command = 2.0 * roll_error  # 비례 제어
        
        return aileron_command
    
    def longitudinal_autopilot(self, desired_altitude, current_altitude, 
                             desired_airspeed, current_airspeed):
        """종 방향 자동조종"""
        
        # 고도 제어
        altitude_error = desired_altitude - current_altitude
        elevator_command_alt = self.altitude_gain * altitude_error
        
        # 속도 제어 (스로틀)
        airspeed_error = desired_airspeed - current_airspeed
        throttle_command = 0.5 + self.airspeed_gain * airspeed_error
        throttle_command = np.clip(throttle_command, 0, 1)
        
        return elevator_command_alt, throttle_command
    
    def stability_augmentation(self, pitch_rate, normal_acceleration):
        """안정성 증대 시스템"""
        
        # 피치 댐퍼
        elevator_pitch_damper = self.pitch_damper_gain * pitch_rate
        
        # 하중 제한
        elevator_g_limit = self.elevator_per_g * normal_acceleration
        
        total_elevator_command = elevator_pitch_damper + elevator_g_limit
        
        return total_elevator_command
```

### 3. 적응 제어

#### 모델 기준 적응 제어 (MRAC)
```python
class AdaptiveController:
    """모델 기준 적응 제어"""
    
    def __init__(self, reference_model):
        self.reference_model = reference_model
        self.adaptation_gain = 0.1
        self.adaptive_parameters = np.zeros(10)  # 적응 매개변수
    
    def adaptive_control_law(self, reference_input, plant_output, model_output):
        """적응 제어 법칙"""
        
        # 추적 오차
        tracking_error = model_output - plant_output
        
        # 적응 법칙 (gradient descent)
        regressor = self.compute_regressor(reference_input, plant_output)
        parameter_update = self.adaptation_gain * tracking_error * regressor
        
        # 매개변수 업데이트
        self.adaptive_parameters += parameter_update
        
        # 제어 입력
        control_input = self.adaptive_parameters @ regressor
        
        return control_input, self.adaptive_parameters
```

## 🗺️ 경로 계획 및 항법

### 1. 경로 계획

#### A* 알고리즘 (3차원)
```python
class Path3D:
    """3차원 경로 계획"""
    
    def __init__(self, grid_resolution, obstacles):
        self.resolution = grid_resolution
        self.obstacles = obstacles
    
    def a_star_3d(self, start, goal):
        """3차원 A* 경로 계획"""
        
        open_set = [(0, start)]  # (f_score, node)
        closed_set = set()
        
        g_score = {start: 0}
        f_score = {start: self.heuristic(start, goal)}
        came_from = {}
        
        while open_set:
            current_f, current = heapq.heappop(open_set)
            
            if current == goal:
                return self.reconstruct_path(came_from, current)
            
            closed_set.add(current)
            
            # 26개 이웃 (3차원)
            for neighbor in self.get_neighbors_3d(current):
                if neighbor in closed_set or self.is_obstacle(neighbor):
                    continue
                
                tentative_g = g_score[current] + self.distance(current, neighbor)
                
                if neighbor not in g_score or tentative_g < g_score[neighbor]:
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g
                    f_score[neighbor] = tentative_g + self.heuristic(neighbor, goal)
                    
                    heapq.heappush(open_set, (f_score[neighbor], neighbor))
        
        return None  # 경로 없음
    
    def heuristic(self, node1, node2):
        """유클리드 거리 휴리스틱"""
        return np.linalg.norm(np.array(node1) - np.array(node2))
```

#### RRT* (Rapidly-exploring Random Tree)
```python
class RRTStar3D:
    """3차원 RRT* 경로 계획"""
    
    def __init__(self, start, goal, bounds, obstacle_check_fn):
        self.start = start
        self.goal = goal
        self.bounds = bounds
        self.is_collision_free = obstacle_check_fn
        self.step_size = 1.0
        self.goal_bias = 0.1
        
    def plan(self, max_iterations):
        """RRT* 경로 계획"""
        
        tree = {self.start: {'parent': None, 'cost': 0}}
        
        for i in range(max_iterations):
            # 랜덤 샘플링 (goal bias 포함)
            if np.random.random() < self.goal_bias:
                sample = self.goal
            else:
                sample = self.random_sample()
            
            # 가장 가까운 노드
            nearest = self.find_nearest(tree, sample)
            
            # 새 노드 생성
            new_node = self.steer(nearest, sample)
            
            if self.is_collision_free(nearest, new_node):
                # 주변 노드들
                near_nodes = self.find_near_nodes(tree, new_node)
                
                # 최소 비용 부모 선택
                min_cost = tree[nearest]['cost'] + self.distance(nearest, new_node)
                min_parent = nearest
                
                for near_node in near_nodes:
                    cost = tree[near_node]['cost'] + self.distance(near_node, new_node)
                    if cost < min_cost and self.is_collision_free(near_node, new_node):
                        min_cost = cost
                        min_parent = near_node
                
                # 트리에 추가
                tree[new_node] = {'parent': min_parent, 'cost': min_cost}
                
                # 재연결 (rewiring)
                for near_node in near_nodes:
                    new_cost = min_cost + self.distance(new_node, near_node)
                    if new_cost < tree[near_node]['cost']:
                        if self.is_collision_free(new_node, near_node):
                            tree[near_node]['parent'] = new_node
                            tree[near_node]['cost'] = new_cost
        
        # 목표점까지의 경로 추출
        if self.goal in tree:
            return self.extract_path(tree, self.goal)
        else:
            return None
```

### 2. 항법 시스템

#### 관성항법시스템 (INS) + GPS 융합
```python
class INS_GPS_Navigation:
    """INS/GPS 융합 항법"""
    
    def __init__(self):
        self.state = np.zeros(15)  # [pos, vel, att, acc_bias, gyro_bias]
        self.covariance = np.eye(15) * 0.1
        self.ins_model = INSModel()
        
    def predict(self, imu_data, dt):
        """INS 예측 단계"""
        
        # IMU 데이터
        accel = imu_data['accelerometer']
        gyro = imu_data['gyroscope']
        
        # 바이어스 보정
        accel_corrected = accel - self.state[9:12]
        gyro_corrected = gyro - self.state[12:15]
        
        # INS 역학 방정식
        self.state = self.ins_model.propagate(
            self.state, accel_corrected, gyro_corrected, dt)
        
        # 공분산 전파
        F = self.ins_model.state_transition_matrix(self.state, dt)
        Q = self.ins_model.process_noise_matrix(dt)
        self.covariance = F @ self.covariance @ F.T + Q
    
    def update_gps(self, gps_measurement):
        """GPS 업데이트 단계"""
        
        # 관측 행렬 (위치만 관측)
        H = np.zeros((3, 15))
        H[0:3, 0:3] = np.eye(3)
        
        # 칼만 게인
        R = np.eye(3) * 5.0  # GPS 측정 노이즈
        S = H @ self.covariance @ H.T + R
        K = self.covariance @ H.T @ np.linalg.inv(S)
        
        # 상태 업데이트
        innovation = gps_measurement - H @ self.state
        self.state += K @ innovation
        
        # 공분산 업데이트
        I = np.eye(15)
        self.covariance = (I - K @ H) @ self.covariance
```

## 🎯 센서 시스템

### 1. 관성측정장치 (IMU)

#### MEMS 센서 모델링
```python
class IMU_Model:
    """IMU 센서 모델"""
    
    def __init__(self):
        # 가속도계 특성
        self.accel_noise_std = 0.01  # m/s²
        self.accel_bias_std = 0.001
        self.accel_scale_factor_error = 0.001
        
        # 자이로스코프 특성
        self.gyro_noise_std = 0.001  # rad/s
        self.gyro_bias_std = 0.0001
        self.gyro_scale_factor_error = 0.001
    
    def simulate_measurement(self, true_accel, true_gyro):
        """IMU 측정값 시뮬레이션"""
        
        # 가속도계 오차 모델
        accel_bias = np.random.normal(0, self.accel_bias_std, 3)
        accel_noise = np.random.normal(0, self.accel_noise_std, 3)
        accel_scale_error = np.random.normal(1, self.accel_scale_factor_error, 3)
        
        measured_accel = accel_scale_error * true_accel + accel_bias + accel_noise
        
        # 자이로스코프 오차 모델
        gyro_bias = np.random.normal(0, self.gyro_bias_std, 3)
        gyro_noise = np.random.normal(0, self.gyro_noise_std, 3)
        gyro_scale_error = np.random.normal(1, self.gyro_scale_factor_error, 3)
        
        measured_gyro = gyro_scale_error * true_gyro + gyro_bias + gyro_noise
        
        return measured_accel, measured_gyro
```

### 2. 비전 시스템

#### Visual SLAM
```python
class VisualSLAM:
    """시각 기반 동시 위치인식 및 지도 작성"""
    
    def __init__(self, camera_params):
        self.camera = camera_params
        self.feature_detector = cv2.ORB_create()
        self.keyframes = []
        self.map_points = []
    
    def process_frame(self, image):
        """프레임 처리"""
        
        # 특징점 추출
        keypoints, descriptors = self.feature_detector.detectAndCompute(image, None)
        
        if len(self.keyframes) == 0:
            # 첫 번째 키프레임
            self.add_keyframe(image, keypoints, descriptors)
            return
        
        # 특징점 매칭
        matches = self.match_features(descriptors, self.keyframes[-1]['descriptors'])
        
        # 모션 추정 (Essential Matrix)
        if len(matches) > 8:
            E, mask = cv2.findEssentialMat(
                matches[:, :2], matches[:, 2:], 
                self.camera.intrinsic_matrix, method=cv2.RANSAC)
            
            # 카메라 포즈 복원
            _, R, t, _ = cv2.recoverPose(E, matches[:, :2], matches[:, 2:],
                                        self.camera.intrinsic_matrix)
            
            # 삼각측량으로 3D 점 생성
            points_3d = self.triangulate_points(matches, R, t)
            
            # 맵 업데이트
            self.update_map(points_3d, keypoints, descriptors)
    
    def triangulate_points(self, matches, R, t):
        """삼각측량으로 3D 점 계산"""
        
        # 투영 행렬
        P1 = self.camera.intrinsic_matrix @ np.hstack([np.eye(3), np.zeros((3, 1))])
        P2 = self.camera.intrinsic_matrix @ np.hstack([R, t])
        
        points_4d = cv2.triangulatePoints(P1, P2, 
                                         matches[:, :2].T, matches[:, 2:].T)
        
        # 동차좌표를 3D 좌표로 변환
        points_3d = points_4d[:3] / points_4d[3]
        
        return points_3d.T
```

### 3. LiDAR 시스템

#### 점군 처리
```python
class LiDAR_Processing:
    """LiDAR 점군 처리"""
    
    def __init__(self):
        self.voxel_size = 0.1  # 복셀 크기
    
    def process_point_cloud(self, points):
        """점군 전처리"""
        
        # 1. 다운샘플링 (복셀 그리드)
        downsampled = self.voxel_grid_downsample(points)
        
        # 2. 노이즈 제거 (통계적 외부값 제거)
        filtered = self.statistical_outlier_removal(downsampled)
        
        # 3. 지면 제거
        ground_removed = self.remove_ground_plane(filtered)
        
        return ground_removed
    
    def voxel_grid_downsample(self, points):
        """복셀 그리드 다운샘플링"""
        
        # 점들을 복셀에 할당
        voxel_indices = np.floor(points / self.voxel_size).astype(int)
        
        # 각 복셀의 중심점 계산
        unique_voxels, inverse_indices = np.unique(
            voxel_indices, axis=0, return_inverse=True)
        
        downsampled_points = []
        for i, voxel in enumerate(unique_voxels):
            voxel_points = points[inverse_indices == i]
            center_point = np.mean(voxel_points, axis=0)
            downsampled_points.append(center_point)
        
        return np.array(downsampled_points)
    
    def obstacle_detection(self, points):
        """장애물 검출"""
        
        # 클러스터링 (DBSCAN)
        clustering = DBSCAN(eps=0.5, min_samples=10)
        labels = clustering.fit_predict(points)
        
        obstacles = []
        for label in np.unique(labels):
            if label == -1:  # 노이즈
                continue
            
            cluster_points = points[labels == label]
            
            # 바운딩 박스 계산
            min_coords = np.min(cluster_points, axis=0)
            max_coords = np.max(cluster_points, axis=0)
            
            obstacles.append({
                'points': cluster_points,
                'bbox': {'min': min_coords, 'max': max_coords},
                'center': np.mean(cluster_points, axis=0)
            })
        
        return obstacles
```

## 🏭 응용 분야 및 성능

### 1. 민간 응용
```
배송 서비스:
- 소형 패키지 배송
- 의료용품 긴급 수송
- 음식 배달

농업:
- 작물 모니터링
- 정밀 농약 살포
- 가축 관리

인프라 점검:
- 송전선 점검
- 교량 점검
- 건물 외벽 점검

촬영/측량:
- 항공 촬영
- 지형 측량
- 건설 모니터링
```

### 2. 공공 안전
```
재난 대응:
- 산불 감시
- 홍수 모니터링
- 지진 피해 조사

구조 작업:
- 수색 구조
- 의료진 접근 불가 지역
- 위험물질 탐지

교통 관리:
- 교통 상황 모니터링
- 사고 현장 조사
- 도로 상태 점검
```

### 3. 성능 지표
```
비행 성능:
- 최대 속도: 15-300 km/h
- 비행 고도: 0-500m (민간용)
- 항속 거리: 10-100 km
- 비행 시간: 20-120분

페이로드:
- 소형: 0.1-2 kg
- 중형: 2-25 kg  
- 대형: 25-100+ kg

정밀도:
- 위치 정확도: ±1-10 cm (RTK GPS)
- 자세 정확도: ±0.1-1°
- 호버링 정확도: ±5-50 cm
```

---

#비행로봇 #AerialRobots #쿼드콥터 #고정익 #무인항공기 #자율비행