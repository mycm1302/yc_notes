# 인터럽트처리

> 상위: [[실시간제어]]

외부 이벤트나 하드웨어 신호에 대해 프로세서가 현재 실행 중인 작업을 중단하고 즉시 응답할 수 있게 하는 메커니즘입니다.

## ⚡ 인터럽트 기본 개념

### 인터럽트 vs 폴링
```
폴링 (Polling):
- 주기적으로 상태 확인
- CPU 자원 낭비
- 응답 지연 가능성
- 구현 단순

인터럽트 (Interrupt):
- 이벤트 발생 시 즉시 알림
- 효율적 자원 사용
- 빠른 응답 시간
- 복잡한 구현
```

### 인터럽트 처리 과정
```cpp
// ARM Cortex-M 인터럽트 처리 과정
class InterruptFlowDemonstration {
public:
    static void demonstrateInterruptFlow() {
        Serial.println("=== Interrupt Processing Flow ===");
        
        // 1. 현재 명령어 완료
        Serial.println("1. Current instruction completes");
        
        // 2. 컨텍스트 자동 저장 (Hardware)
        Serial.println("2. Hardware saves context (PSR, PC, LR, R0-R3, R12)");
        
        // 3. 벡터 테이블에서 ISR 주소 로드
        Serial.println("3. Load ISR address from vector table");
        
        // 4. ISR 실행
        Serial.println("4. Execute ISR");
        
        // 5. 컨텍스트 복원 (Hardware)
        Serial.println("5. Hardware restores context");
        
        // 6. 원래 프로그램으로 복귀
        Serial.println("6. Return to interrupted program");
    }
};

// 벡터 테이블 예시 (ARM Cortex-M)
extern "C" {
    // 벡터 테이블 정의
    void Reset_Handler(void);
    void NMI_Handler(void);
    void HardFault_Handler(void);
    void SysTick_Handler(void);
    void TIMER1_IRQHandler(void);
    
    // 벡터 테이블 배치 (링커 스크립트에서 정의)
    __attribute__((section(".isr_vector")))
    const uint32_t vector_table[] = {
        (uint32_t)&_estack,          // 0: 초기 스택 포인터
        (uint32_t)Reset_Handler,     // 1: Reset 핸들러
        (uint32_t)NMI_Handler,       // 2: NMI 핸들러
        (uint32_t)HardFault_Handler, // 3: Hard Fault 핸들러
        // ... 더 많은 벡터들
        (uint32_t)SysTick_Handler,   // 15: SysTick 핸들러
        (uint32_t)TIMER1_IRQHandler, // 16: Timer1 IRQ 핸들러
    };
}
```

## 🔧 인터럽트 서비스 루틴 (ISR)

### ISR 작성 원칙
```cpp
// 올바른 ISR 작성 예시
class OptimalISRDesign {
private:
    volatile bool timer_flag = false;
    volatile uint32_t timer_counter = 0;
    volatile uint8_t uart_rx_buffer[64];
    volatile int uart_rx_head = 0;
    volatile int uart_rx_tail = 0;
    
public:
    // 원칙 1: 짧고 빠르게 (Short and Fast)
    __attribute__((interrupt))
    static void TIMER1_IRQHandler() {
        // 최소한의 작업만 수행
        timer_flag = true;
        timer_counter++;
        
        // 인터럽트 플래그 클리어
        TIMER1->SR = 0;
        
        // 총 실행 시간: ~10 cycles
    }
    
    // 원칙 2: volatile 키워드 사용
    volatile uint32_t shared_variable;
    
    __attribute__((interrupt))
    static void ADC_IRQHandler() {
        // volatile 변수는 컴파일러 최적화 방지
        shared_variable = ADC1->DR;
        
        // 플래그 설정으로 메인 루프에 알림
        adc_conversion_complete = true;
        
        ADC1->SR = 0;  // 클리어
    }
    
    // 원칙 3: 함수 호출 금지 (No Function Calls)
    __attribute__((interrupt))
    static void UART_IRQHandler() {
        // 함수 호출 대신 인라인 코드 사용
        uint8_t received_byte = UART1->DR;
        
        // 순환 버퍼에 직접 저장
        int next_head = (uart_rx_head + 1) % 64;
        if(next_head != uart_rx_tail) {
            uart_rx_buffer[uart_rx_head] = received_byte;
            uart_rx_head = next_head;
        }
        
        UART1->SR = 0;
    }
    
    // 원칙 4: 최소한의 처리, 나머지는 메인에서
    static void processTimerEvent() {
        if(timer_flag) {
            timer_flag = false;  // 원자적 연산
            
            // 복잡한 처리는 여기서 수행
            performComplexTimerProcessing();
        }
    }
    
    static void processUARTData() {
        // ISR에서 버퍼링된 데이터 처리
        while(uart_rx_head != uart_rx_tail) {
            uint8_t data = uart_rx_buffer[uart_rx_tail];
            uart_rx_tail = (uart_rx_tail + 1) % 64;
            
            // 데이터 처리
            processReceivedByte(data);
        }
    }
    
private:
    static void performComplexTimerProcessing() {
        // 복잡한 연산은 ISR 밖에서
    }
    
    static void processReceivedByte(uint8_t data) {
        // UART 데이터 처리 로직
    }
};
```

### 인터럽트 우선순위 관리
```cpp
// NVIC 우선순위 관리 (ARM Cortex-M)
class InterruptPriorityManager {
private:
    enum IRQPriority {
        HIGHEST_PRIORITY = 0,
        HIGH_PRIORITY = 1,
        MEDIUM_PRIORITY = 2,
        LOW_PRIORITY = 3,
        LOWEST_PRIORITY = 4
    };
    
public:
    static void setupInterruptPriorities() {
        // NVIC 우선순위 그룹 설정 (4비트 preemption, 0비트 sub)
        NVIC_SetPriorityGrouping(3);
        
        // 시스템 크리티컬 인터럽트 (최고 우선순위)
        NVIC_SetPriority(SysTick_IRQn, HIGHEST_PRIORITY);
        NVIC_SetPriority(HardFault_IRQn, HIGHEST_PRIORITY);
        
        // 실시간 제어 관련 (높은 우선순위)
        NVIC_SetPriority(TIM1_IRQn, HIGH_PRIORITY);    // 모터 제어
        NVIC_SetPriority(ADC1_IRQn, HIGH_PRIORITY);    // 센서 읽기
        
        // 통신 관련 (중간 우선순위)
        NVIC_SetPriority(USART1_IRQn, MEDIUM_PRIORITY);
        NVIC_SetPriority(SPI1_IRQn, MEDIUM_PRIORITY);
        
        // 사용자 인터페이스 (낮은 우선순위)
        NVIC_SetPriority(EXTI0_IRQn, LOW_PRIORITY);    // 버튼
        NVIC_SetPriority(TIM2_IRQn, LOWEST_PRIORITY);  // LED 깜빡임
        
        Serial.println("Interrupt priorities configured");
    }
    
    // 크리티컬 섹션 구현
    static void enterCriticalSection() {
        __disable_irq();  // 모든 인터럽트 비활성화
    }
    
    static void exitCriticalSection() {
        __enable_irq();   // 인터럽트 재활성화
    }
    
    // 선택적 인터럽트 마스킹
    static void maskLowPriorityInterrupts() {
        // 우선순위 3 이하만 마스킹
        __set_BASEPRI(3 << (8 - __NVIC_PRIO_BITS));
    }
    
    static void unmaskAllInterrupts() {
        __set_BASEPRI(0);
    }
};
```

## ⏱️ 인터럽트 레이턴시 최적화

### 레이턴시 측정과 분석
```cpp
// 인터럽트 레이턴시 측정
class InterruptLatencyProfiler {
private:
    volatile uint32_t interrupt_timestamp = 0;
    volatile uint32_t handler_entry_time = 0;
    volatile uint32_t handler_exit_time = 0;
    
    struct LatencyStats {
        uint32_t min_latency;
        uint32_t max_latency;
        uint32_t total_latency;
        uint32_t sample_count;
    };
    
    static LatencyStats stats;
    
public:
    // GPIO를 이용한 하드웨어 레이턴시 측정
    static void setupLatencyMeasurement() {
        // 측정용 GPIO 핀 설정
        pinMode(TRIGGER_PIN, OUTPUT);
        pinMode(LATENCY_MEASURE_PIN, OUTPUT);
        
        // 외부 인터럽트 설정
        attachInterrupt(digitalPinToInterrupt(EXTERNAL_INT_PIN), 
                       latencyMeasureISR, RISING);
        
        // DWT 사이클 카운터 활성화 (ARM Cortex-M)
        CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
        DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
        DWT->CYCCNT = 0;
        
        Serial.println("Latency measurement setup complete");
    }
    
    // 레이턴시 측정용 ISR
    __attribute__((interrupt))
    static void latencyMeasureISR() {
        // ISR 진입 즉시 핀 토글 (오실로스코프 측정용)
        digitalWrite(LATENCY_MEASURE_PIN, HIGH);
        
        // 소프트웨어 타이밍 기록
        handler_entry_time = DWT->CYCCNT;
        
        // 실제 처리 작업 시뮬레이션
        volatile int dummy = 0;
        for(int i = 0; i < 10; i++) {
            dummy += i;
        }
        
        handler_exit_time = DWT->CYCCNT;
        
        // 통계 업데이트
        updateLatencyStats();
        
        digitalWrite(LATENCY_MEASURE_PIN, LOW);
    }
    
    static void triggerInterruptForMeasurement() {
        // 트리거 시점 기록
        interrupt_timestamp = DWT->CYCCNT;
        
        // 인터럽트 트리거
        digitalWrite(TRIGGER_PIN, HIGH);
        delayMicroseconds(1);
        digitalWrite(TRIGGER_PIN, LOW);
    }
    
    static void printLatencyReport() {
        Serial.println("=== Interrupt Latency Report ===");
        Serial.printf("Samples: %lu\n", stats.sample_count);
        
        float min_us = (float)stats.min_latency / (F_CPU / 1000000);
        float max_us = (float)stats.max_latency / (F_CPU / 1000000);
        float avg_us = (float)stats.total_latency / stats.sample_count / (F_CPU / 1000000);
        
        Serial.printf("Min latency: %.2f μs (%lu cycles)\n", min_us, stats.min_latency);
        Serial.printf("Max latency: %.2f μs (%lu cycles)\n", max_us, stats.max_latency);
        Serial.printf("Avg latency: %.2f μs\n", avg_us);
        
        // 지터 계산
        float jitter_us = max_us - min_us;
        Serial.printf("Jitter: %.2f μs\n", jitter_us);
    }
    
private:
    static void updateLatencyStats() {
        uint32_t latency = handler_entry_time - interrupt_timestamp;
        
        if(stats.sample_count == 0) {
            stats.min_latency = latency;
            stats.max_latency = latency;
        } else {
            if(latency < stats.min_latency) stats.min_latency = latency;
            if(latency > stats.max_latency) stats.max_latency = latency;
        }
        
        stats.total_latency += latency;
        stats.sample_count++;
    }
};

// 정적 변수 초기화
InterruptLatencyProfiler::LatencyStats InterruptLatencyProfiler::stats = {0, 0, 0, 0};
```

### 레이턴시 최소화 기법
```cpp
// 최적화된 인터럽트 핸들러
class OptimizedInterruptHandlers {
public:
    // 1. 인라인 어셈블리를 이용한 최적화
    __attribute__((interrupt, naked))
    static void fastISR() {
        asm volatile(
            "push {r0-r3, r12, lr}  \n"  // 필수 레지스터만 저장
            "ldr  r0, =0x40000000   \n"  // 직접 하드웨어 주소 접근
            "ldr  r1, [r0, #0x10]   \n"  // 상태 레지스터 읽기
            "str  r1, [r0, #0x14]   \n"  // 플래그 클리어
            "pop  {r0-r3, r12, lr}  \n"  // 레지스터 복원
            "bx   lr                \n"  // 리턴
        );
    }
    
    // 2. 컴파일러 최적화 힌트
    __attribute__((hot, optimize("O3")))
    static void criticalISR() {
        // 컴파일러에게 이 함수가 자주 호출되고 최적화가 중요함을 알림
        
        // 분기 예측 힌트
        if(__builtin_expect(status_flag, 1)) {
            // 일반적인 경우
            handleNormalCase();
        } else {
            // 예외적인 경우
            handleExceptionalCase();
        }
    }
    
    // 3. 메모리 접근 최적화
    static void optimizedMemoryAccess() {
        // 캐시 라인에 맞춘 데이터 구조
        struct __attribute__((aligned(32))) OptimizedData {
            volatile uint32_t counter;
            volatile uint32_t status;
            volatile uint32_t timestamp;
            volatile uint32_t reserved[5];  // 32바이트 정렬
        };
        
        static OptimizedData data;
        
        // 단일 캐시 라인 접근으로 성능 향상
        data.counter++;
        data.status = 1;
        data.timestamp = DWT->CYCCNT;
    }
    
    // 4. 하드웨어 특화 최적화
    static void setupHardwareOptimizations() {
        // 인터럽트 컨트롤러 최적화
        NVIC->ICER[0] = 0xFFFFFFFF;  // 모든 인터럽트 비활성화
        
        // 선택적 인터럽트만 활성화
        NVIC_EnableIRQ(TIMER1_IRQn);
        NVIC_EnableIRQ(USART1_IRQn);
        
        // 인터럽트 대기시간 최소화
        SCB->CCR |= SCB_CCR_STKALIGN_Msk;  // 스택 정렬 최적화
        
        // 프로세서 성능 최적화
        SCB->CPACR |= (0xF << 20);  // FPU 완전 접근 허용
    }
    
private:
    static void handleNormalCase() {
        // 빠른 경로 처리
    }
    
    static void handleExceptionalCase() {
        // 예외 처리
    }
};
```

## 🚦 실시간 인터럽트 관리

### 인터럽트 네스팅과 선점
```cpp
// 인터럽트 네스팅 관리
class InterruptNestingManager {
private:
    static int nesting_level;
    static uint32_t disabled_interrupts[8];  // 비활성화된 인터럽트 마스크
    
public:
    // 네스팅 상태 모니터링
    static void enterISR(IRQn_Type irq) {
        nesting_level++;
        
        if(nesting_level > MAX_NESTING_LEVEL) {
            // 네스팅 레벨 초과 경고
            Serial.printf("WARNING: Nesting level exceeded: %d\n", nesting_level);
        }
        
        Serial.printf("ISR entered: %d (level %d)\n", irq, nesting_level);
    }
    
    static void exitISR(IRQn_Type irq) {
        nesting_level--;
        Serial.printf("ISR exited: %d (level %d)\n", irq, nesting_level);
    }
    
    // 선택적 인터럽트 마스킹
    static void maskLowerPriorityInterrupts(int priority_threshold) {
        // 현재 우선순위보다 낮은 인터럽트들 마스킹
        for(int i = 0; i < 240; i++) {  // ARM Cortex-M 최대 240개 인터럽트
            if(NVIC_GetPriority((IRQn_Type)i) > priority_threshold) {
                NVIC_DisableIRQ((IRQn_Type)i);
            }
        }
    }
    
    // Priority Ceiling Protocol 구현
    static int raiseToHighestPriority(const int resource_id) {
        int original_priority = __get_BASEPRI();
        
        // 해당 자원의 천장 우선순위로 설정
        int ceiling_priority = getResourceCeilingPriority(resource_id);
        __set_BASEPRI(ceiling_priority << (8 - __NVIC_PRIO_BITS));
        
        return original_priority;
    }
    
    static void restorePriority(int original_priority) {
        __set_BASEPRI(original_priority);
    }
    
    // 인터럽트 통계 수집
    struct InterruptStats {
        uint32_t total_count;
        uint32_t max_execution_time;
        uint32_t total_execution_time;
        uint32_t missed_deadlines;
    };
    
    static InterruptStats stats[32];  // 주요 인터럽트들의 통계
    
    static void recordInterruptExecution(IRQn_Type irq, uint32_t execution_time) {
        if(irq >= 0 && irq < 32) {
            InterruptStats* stat = &stats[irq];
            
            stat->total_count++;
            stat->total_execution_time += execution_time;
            
            if(execution_time > stat->max_execution_time) {
                stat->max_execution_time = execution_time;
            }
            
            // 데드라인 체크 (예: 100μs)
            if(execution_time > 100 * (F_CPU / 1000000)) {
                stat->missed_deadlines++;
            }
        }
    }
    
private:
    static int getResourceCeilingPriority(int resource_id) {
        // 자원별 천장 우선순위 반환
        switch(resource_id) {
            case 0: return 1;  // 공유 버퍼
            case 1: return 2;  // UART 버퍼
            default: return 3;
        }
    }
};

int InterruptNestingManager::nesting_level = 0;
uint32_t InterruptNestingManager::disabled_interrupts[8] = {0};
InterruptNestingManager::InterruptStats InterruptNestingManager::stats[32] = {};
```

### 실시간 인터럽트 스케줄링
```cpp
// 실시간 이벤트 처리를 위한 인터럽트 기반 스케줄러
class RealTimeInterruptScheduler {
private:
    struct RTTask {
        void (*handler)();
        uint32_t period_us;
        uint32_t next_execution;
        int priority;
        bool enabled;
    };
    
    static const int MAX_RT_TASKS = 16;
    static RTTask rt_tasks[MAX_RT_TASKS];
    static int task_count;
    
public:
    // 실시간 주기 태스크 등록
    static int registerPeriodicTask(void (*handler)(), uint32_t period_us, int priority) {
        if(task_count >= MAX_RT_TASKS) return -1;
        
        rt_tasks[task_count] = {
            handler,
            period_us,
            micros() + period_us,
            priority,
            true
        };
        
        Serial.printf("RT Task %d registered: period=%lu μs, priority=%d\n",
                     task_count, period_us, priority);
        
        return task_count++;
    }
    
    // SysTick을 이용한 1ms 기본 타이머
    __attribute__((interrupt))
    static void SysTick_Handler() {
        static uint32_t ms_counter = 0;
        ms_counter++;
        
        // 1ms마다 실시간 태스크 체크
        checkRealTimeTasks();
    }
    
    // 실시간 태스크 스케줄링
    static void checkRealTimeTasks() {
        uint32_t current_time = micros();
        
        // 우선순위 순으로 정렬된 태스크들 확인
        for(int i = 0; i < task_count; i++) {
            RTTask* task = &rt_tasks[i];
            
            if(task->enabled && current_time >= task->next_execution) {
                
                // 데드라인 체크
                if(current_time > task->next_execution + task->period_us) {
                    Serial.printf("DEADLINE MISS: Task %d\n", i);
                }
                
                // 태스크 실행 (인터럽트 컨텍스트에서)
                uint32_t start_time = DWT->CYCCNT;
                task->handler();
                uint32_t execution_cycles = DWT->CYCCNT - start_time;
                
                // 다음 실행 시간 설정
                task->next_execution += task->period_us;
                
                // 실행 시간 모니터링
                float execution_time_us = (float)execution_cycles / (F_CPU / 1000000);
                if(execution_time_us > task->period_us * 0.1) {  // 10% 이상이면 경고
                    Serial.printf("WARN: Task %d took %.2f μs (%.1f%% of period)\n",
                                 i, execution_time_us, execution_time_us * 100 / task->period_us);
                }
            }
        }
    }
    
    // 태스크 활성화/비활성화
    static void enableTask(int task_id, bool enable) {
        if(task_id >= 0 && task_id < task_count) {
            rt_tasks[task_id].enabled = enable;
        }
    }
    
    // 시스템 부하 모니터링
    static float calculateSystemLoad() {
        uint32_t total_cpu_cycles = 0;
        uint32_t hyperperiod = 1000000;  // 1초
        
        for(int i = 0; i < task_count; i++) {
            if(rt_tasks[i].enabled) {
                // 각 태스크의 CPU 사용률 추정
                uint32_t executions_per_second = 1000000 / rt_tasks[i].period_us;
                // 실행 시간은 측정된 값 사용 (여기서는 추정)
                uint32_t estimated_cycles_per_execution = 1000;  // 추정값
                
                total_cpu_cycles += executions_per_second * estimated_cycles_per_execution;
            }
        }
        
        return (float)total_cpu_cycles * 100.0 / (F_CPU);
    }
};

// 정적 변수 초기화
RealTimeInterruptScheduler::RTTask RealTimeInterruptScheduler::rt_tasks[MAX_RT_TASKS];
int RealTimeInterruptScheduler::task_count = 0;
```

## 🛡️ 인터럽트 안전성

### 레이스 컨디션 방지
```cpp
// 원자적 연산과 동기화
class InterruptSafety {
private:
    volatile uint32_t shared_counter = 0;
    volatile bool data_ready = false;
    
public:
    // 1. 원자적 연산 사용
    static uint32_t atomicIncrement(volatile uint32_t* value) {
        uint32_t result;
        
        // ARM Cortex-M LDREX/STREX 사용
        do {
            result = __LDREXW(value);
            result++;
        } while (__STREXW(result, value) != 0);
        
        return result;
    }
    
    // 2. 크리티컬 섹션
    template<typename Func>
    static auto criticalSection(Func&& func) -> decltype(func()) {
        uint32_t primask = __get_PRIMASK();
        __disable_irq();
        
        auto result = func();
        
        __set_PRIMASK(primask);
        return result;
    }
    
    // 3. 메모리 배리어
    static void memoryBarrier() {
        __DMB();  // Data Memory Barrier
        __DSB();  // Data Synchronization Barrier
        __ISB();  // Instruction Synchronization Barrier
    }
    
    // 4. Lock-free 큐 구현
    template<typename T, size_t SIZE>
    class LockFreeQueue {
    private:
        volatile T buffer[SIZE];
        volatile uint32_t head = 0;
        volatile uint32_t tail = 0;
        
    public:
        bool enqueue(const T& item) {
            uint32_t current_tail = tail;
            uint32_t next_tail = (current_tail + 1) % SIZE;
            
            if(next_tail == head) {
                return false;  // 큐 가득참
            }
            
            buffer[current_tail] = item;
            __DMB();  // 메모리 배리어
            tail = next_tail;
            
            return true;
        }
        
        bool dequeue(T& item) {
            uint32_t current_head = head;
            
            if(current_head == tail) {
                return false;  // 큐 비어있음
            }
            
            item = buffer[current_head];
            __DMB();  // 메모리 배리어
            head = (current_head + 1) % SIZE;
            
            return true;
        }
        
        bool isEmpty() const {
            return head == tail;
        }
        
        bool isFull() const {
            return ((tail + 1) % SIZE) == head;
        }
    };
    
    // 5. 인터럽트 세이프 데이터 교환
    class SafeDataExchange {
    private:
        volatile uint32_t data[2];  // 더블 버퍼링
        volatile int active_buffer = 0;
        volatile bool buffer_ready[2] = {false, false};
        
    public:
        // ISR에서 데이터 쓰기
        void writeFromISR(uint32_t value) {
            int write_buffer = 1 - active_buffer;
            data[write_buffer] = value;
            buffer_ready[write_buffer] = true;
            
            // 원자적으로 버퍼 교체
            active_buffer = write_buffer;
        }
        
        // 메인 루프에서 데이터 읽기
        bool readFromMain(uint32_t& value) {
            int read_buffer = active_buffer;
            
            if(buffer_ready[read_buffer]) {
                value = data[read_buffer];
                buffer_ready[read_buffer] = false;
                return true;
            }
            
            return false;
        }
    };
};
```

### 인터럽트 베스트 프랙티스
```cpp
// 인터럽트 프로그래밍 베스트 프랙티스
class InterruptBestPractices {
public:
    // 베스트 프랙티스 1: 최소한의 ISR
    __attribute__((interrupt))
    static void goodISRExample() {
        // ✅ 좋은 예: 플래그 설정만
        gpio_interrupt_flag = true;
        error_count++;
        
        // ✅ 하드웨어 플래그 즉시 클리어
        EXTI->PR = EXTI_PR_PR0;
    }
    
    // 베스트 프랙티스 2: 잘못된 ISR 예시
    __attribute__((interrupt))
    static void badISRExample() {
        // ❌ 나쁜 예: 복잡한 처리
        /*
        for(int i = 0; i < 1000; i++) {
            complexCalculation();
        }
        
        // ❌ 블로킹 함수 호출
        delay(100);
        
        // ❌ printf 같은 무거운 함수
        printf("Interrupt occurred\n");
        
        // ❌ 동적 메모리 할당
        char* buffer = malloc(256);
        */
    }
    
    // 베스트 프랙티스 3: 메인 루프에서 처리
    static void mainLoopProcessing() {
        if(gpio_interrupt_flag) {
            gpio_interrupt_flag = false;
            
            // 복잡한 처리는 여기서
            processGPIOEvent();
            
            // 로깅도 여기서
            Serial.println("GPIO event processed");
        }
    }
    
    // 베스트 프랙티스 4: 타이밍 크리티컬한 경우
    __attribute__((interrupt))
    static void timingCriticalISR() {
        // 타이밍이 중요한 최소한의 작업만
        
        // 즉시 응답이 필요한 하드웨어 제어
        GPIOA->BSRR = GPIO_PIN_5;  // 핀 즉시 설정
        
        // 타임스탬프 기록
        critical_event_timestamp = DWT->CYCCNT;
        
        // 플래그 설정
        critical_event_occurred = true;
        
        // 하드웨어 상태 저장
        hardware_status_snapshot = DEVICE_STATUS_REG;
    }
    
    // 베스트 프랙티스 5: 인터럽트 통계 모니터링
    static void monitorInterruptPerformance() {
        static uint32_t last_check_time = 0;
        static uint32_t interrupt_count_last = 0;
        
        uint32_t current_time = millis();
        
        if(current_time - last_check_time >= 1000) {  // 1초마다
            uint32_t interrupts_per_second = interrupt_total_count - interrupt_count_last;
            
            Serial.printf("Interrupts/sec: %lu\n", interrupts_per_second);
            Serial.printf("Avg ISR time: %.2f μs\n", 
                         (float)total_isr_cycles / interrupt_total_count / (F_CPU / 1000000));
            
            if(interrupts_per_second > 10000) {
                Serial.println("WARNING: High interrupt rate detected");
            }
            
            last_check_time = current_time;
            interrupt_count_last = interrupt_total_count;
        }
    }
    
private:
    static volatile bool gpio_interrupt_flag;
    static volatile uint32_t error_count;
    static volatile bool critical_event_occurred;
    static volatile uint32_t critical_event_timestamp;
    static volatile uint32_t hardware_status_snapshot;
    static volatile uint32_t interrupt_total_count;
    static volatile uint32_t total_isr_cycles;
    
    static void processGPIOEvent() {
        // 복잡한 GPIO 이벤트 처리
    }
    
    static void complexCalculation() {
        // 복잡한 계산 (ISR에서 하면 안됨)
    }
};

// 정적 변수 초기화
volatile bool InterruptBestPractices::gpio_interrupt_flag = false;
volatile uint32_t InterruptBestPractices::error_count = 0;
volatile bool InterruptBestPractices::critical_event_occurred = false;
volatile uint32_t InterruptBestPractices::critical_event_timestamp = 0;
volatile uint32_t InterruptBestPractices::hardware_status_snapshot = 0;
volatile uint32_t InterruptBestPractices::interrupt_total_count = 0;
volatile uint32_t InterruptBestPractices::total_isr_cycles = 0;
```

---

## 🔗 연결 문서
- 상위: [[실시간제어]]
- 관련: [[데드라인]], [[지터]], [[레이턴시]]
- 스케줄링: [[우선순위스케줄링]], [[시분할스케줄링]]
- 하드웨어: [[마이크로컨트롤러]], [[센서인터페이스]]

## 📚 참고문헌
- [Embedded.com (2023). "Programming embedded systems: What are interrupts, and how they work"](https://www.embedded.com/programming-embedded-systems-what-are-interrupts-and-how-they-work/)
- [Embedded.com (2024). "5 best practices for writing interrupt service routines"](https://www.embedded.com/5-best-practices-for-writing-interrupt-service-routines/)
- [Bogotobogo (2024). "Embedded Systems Programming: Interrupt, Interrupt Latency, and IRQ"](https://www.bogotobogo.com/Embedded/hardware_interrupt_software_interrupt_latency_irq_vs_fiq.php)
- [Embien Technologies (2024). "Interrupt Handling in Embedded Software"](https://www.embien.com/blog/interrupt-handling-in-embedded-software)
- [TutorialsPoint (2024). "Understanding Interrupts in Embedded Systems"](https://www.tutorialspoint.com/embedded_systems/es_interrupts.htm)
