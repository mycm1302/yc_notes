# ì¸í„°ëŸ½íŠ¸ì²˜ë¦¬

> ìƒìœ„: [[ì‹¤ì‹œê°„ì œì–´]]

ì™¸ë¶€ ì´ë²¤íŠ¸ë‚˜ í•˜ë“œì›¨ì–´ ì‹ í˜¸ì— ëŒ€í•´ í”„ë¡œì„¸ì„œê°€ í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ ì‘ì—…ì„ ì¤‘ë‹¨í•˜ê³  ì¦‰ì‹œ ì‘ë‹µí•  ìˆ˜ ìˆê²Œ í•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜ì…ë‹ˆë‹¤.

## âš¡ ì¸í„°ëŸ½íŠ¸ ê¸°ë³¸ ê°œë…

### ì¸í„°ëŸ½íŠ¸ vs í´ë§
```
í´ë§ (Polling):
- ì£¼ê¸°ì ìœ¼ë¡œ ìƒíƒœ í™•ì¸
- CPU ìì› ë‚­ë¹„
- ì‘ë‹µ ì§€ì—° ê°€ëŠ¥ì„±
- êµ¬í˜„ ë‹¨ìˆœ

ì¸í„°ëŸ½íŠ¸ (Interrupt):
- ì´ë²¤íŠ¸ ë°œìƒ ì‹œ ì¦‰ì‹œ ì•Œë¦¼
- íš¨ìœ¨ì  ìì› ì‚¬ìš©
- ë¹ ë¥¸ ì‘ë‹µ ì‹œê°„
- ë³µì¡í•œ êµ¬í˜„
```

### ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬ ê³¼ì •
```cpp
// ARM Cortex-M ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬ ê³¼ì •
class InterruptFlowDemonstration {
public:
    static void demonstrateInterruptFlow() {
        Serial.println("=== Interrupt Processing Flow ===");
        
        // 1. í˜„ì¬ ëª…ë ¹ì–´ ì™„ë£Œ
        Serial.println("1. Current instruction completes");
        
        // 2. ì»¨í…ìŠ¤íŠ¸ ìë™ ì €ì¥ (Hardware)
        Serial.println("2. Hardware saves context (PSR, PC, LR, R0-R3, R12)");
        
        // 3. ë²¡í„° í…Œì´ë¸”ì—ì„œ ISR ì£¼ì†Œ ë¡œë“œ
        Serial.println("3. Load ISR address from vector table");
        
        // 4. ISR ì‹¤í–‰
        Serial.println("4. Execute ISR");
        
        // 5. ì»¨í…ìŠ¤íŠ¸ ë³µì› (Hardware)
        Serial.println("5. Hardware restores context");
        
        // 6. ì›ë˜ í”„ë¡œê·¸ë¨ìœ¼ë¡œ ë³µê·€
        Serial.println("6. Return to interrupted program");
    }
};

// ë²¡í„° í…Œì´ë¸” ì˜ˆì‹œ (ARM Cortex-M)
extern "C" {
    // ë²¡í„° í…Œì´ë¸” ì •ì˜
    void Reset_Handler(void);
    void NMI_Handler(void);
    void HardFault_Handler(void);
    void SysTick_Handler(void);
    void TIMER1_IRQHandler(void);
    
    // ë²¡í„° í…Œì´ë¸” ë°°ì¹˜ (ë§ì»¤ ìŠ¤í¬ë¦½íŠ¸ì—ì„œ ì •ì˜)
    __attribute__((section(".isr_vector")))
    const uint32_t vector_table[] = {
        (uint32_t)&_estack,          // 0: ì´ˆê¸° ìŠ¤íƒ í¬ì¸í„°
        (uint32_t)Reset_Handler,     // 1: Reset í•¸ë“¤ëŸ¬
        (uint32_t)NMI_Handler,       // 2: NMI í•¸ë“¤ëŸ¬
        (uint32_t)HardFault_Handler, // 3: Hard Fault í•¸ë“¤ëŸ¬
        // ... ë” ë§ì€ ë²¡í„°ë“¤
        (uint32_t)SysTick_Handler,   // 15: SysTick í•¸ë“¤ëŸ¬
        (uint32_t)TIMER1_IRQHandler, // 16: Timer1 IRQ í•¸ë“¤ëŸ¬
    };
}
```

## ğŸ”§ ì¸í„°ëŸ½íŠ¸ ì„œë¹„ìŠ¤ ë£¨í‹´ (ISR)

### ISR ì‘ì„± ì›ì¹™
```cpp
// ì˜¬ë°”ë¥¸ ISR ì‘ì„± ì˜ˆì‹œ
class OptimalISRDesign {
private:
    volatile bool timer_flag = false;
    volatile uint32_t timer_counter = 0;
    volatile uint8_t uart_rx_buffer[64];
    volatile int uart_rx_head = 0;
    volatile int uart_rx_tail = 0;
    
public:
    // ì›ì¹™ 1: ì§§ê³  ë¹ ë¥´ê²Œ (Short and Fast)
    __attribute__((interrupt))
    static void TIMER1_IRQHandler() {
        // ìµœì†Œí•œì˜ ì‘ì—…ë§Œ ìˆ˜í–‰
        timer_flag = true;
        timer_counter++;
        
        // ì¸í„°ëŸ½íŠ¸ í”Œë˜ê·¸ í´ë¦¬ì–´
        TIMER1->SR = 0;
        
        // ì´ ì‹¤í–‰ ì‹œê°„: ~10 cycles
    }
    
    // ì›ì¹™ 2: volatile í‚¤ì›Œë“œ ì‚¬ìš©
    volatile uint32_t shared_variable;
    
    __attribute__((interrupt))
    static void ADC_IRQHandler() {
        // volatile ë³€ìˆ˜ëŠ” ì»´íŒŒì¼ëŸ¬ ìµœì í™” ë°©ì§€
        shared_variable = ADC1->DR;
        
        // í”Œë˜ê·¸ ì„¤ì •ìœ¼ë¡œ ë©”ì¸ ë£¨í”„ì— ì•Œë¦¼
        adc_conversion_complete = true;
        
        ADC1->SR = 0;  // í´ë¦¬ì–´
    }
    
    // ì›ì¹™ 3: í•¨ìˆ˜ í˜¸ì¶œ ê¸ˆì§€ (No Function Calls)
    __attribute__((interrupt))
    static void UART_IRQHandler() {
        // í•¨ìˆ˜ í˜¸ì¶œ ëŒ€ì‹  ì¸ë¼ì¸ ì½”ë“œ ì‚¬ìš©
        uint8_t received_byte = UART1->DR;
        
        // ìˆœí™˜ ë²„í¼ì— ì§ì ‘ ì €ì¥
        int next_head = (uart_rx_head + 1) % 64;
        if(next_head != uart_rx_tail) {
            uart_rx_buffer[uart_rx_head] = received_byte;
            uart_rx_head = next_head;
        }
        
        UART1->SR = 0;
    }
    
    // ì›ì¹™ 4: ìµœì†Œí•œì˜ ì²˜ë¦¬, ë‚˜ë¨¸ì§€ëŠ” ë©”ì¸ì—ì„œ
    static void processTimerEvent() {
        if(timer_flag) {
            timer_flag = false;  // ì›ìì  ì—°ì‚°
            
            // ë³µì¡í•œ ì²˜ë¦¬ëŠ” ì—¬ê¸°ì„œ ìˆ˜í–‰
            performComplexTimerProcessing();
        }
    }
    
    static void processUARTData() {
        // ISRì—ì„œ ë²„í¼ë§ëœ ë°ì´í„° ì²˜ë¦¬
        while(uart_rx_head != uart_rx_tail) {
            uint8_t data = uart_rx_buffer[uart_rx_tail];
            uart_rx_tail = (uart_rx_tail + 1) % 64;
            
            // ë°ì´í„° ì²˜ë¦¬
            processReceivedByte(data);
        }
    }
    
private:
    static void performComplexTimerProcessing() {
        // ë³µì¡í•œ ì—°ì‚°ì€ ISR ë°–ì—ì„œ
    }
    
    static void processReceivedByte(uint8_t data) {
        // UART ë°ì´í„° ì²˜ë¦¬ ë¡œì§
    }
};
```

### ì¸í„°ëŸ½íŠ¸ ìš°ì„ ìˆœìœ„ ê´€ë¦¬
```cpp
// NVIC ìš°ì„ ìˆœìœ„ ê´€ë¦¬ (ARM Cortex-M)
class InterruptPriorityManager {
private:
    enum IRQPriority {
        HIGHEST_PRIORITY = 0,
        HIGH_PRIORITY = 1,
        MEDIUM_PRIORITY = 2,
        LOW_PRIORITY = 3,
        LOWEST_PRIORITY = 4
    };
    
public:
    static void setupInterruptPriorities() {
        // NVIC ìš°ì„ ìˆœìœ„ ê·¸ë£¹ ì„¤ì • (4ë¹„íŠ¸ preemption, 0ë¹„íŠ¸ sub)
        NVIC_SetPriorityGrouping(3);
        
        // ì‹œìŠ¤í…œ í¬ë¦¬í‹°ì»¬ ì¸í„°ëŸ½íŠ¸ (ìµœê³  ìš°ì„ ìˆœìœ„)
        NVIC_SetPriority(SysTick_IRQn, HIGHEST_PRIORITY);
        NVIC_SetPriority(HardFault_IRQn, HIGHEST_PRIORITY);
        
        // ì‹¤ì‹œê°„ ì œì–´ ê´€ë ¨ (ë†’ì€ ìš°ì„ ìˆœìœ„)
        NVIC_SetPriority(TIM1_IRQn, HIGH_PRIORITY);    // ëª¨í„° ì œì–´
        NVIC_SetPriority(ADC1_IRQn, HIGH_PRIORITY);    // ì„¼ì„œ ì½ê¸°
        
        // í†µì‹  ê´€ë ¨ (ì¤‘ê°„ ìš°ì„ ìˆœìœ„)
        NVIC_SetPriority(USART1_IRQn, MEDIUM_PRIORITY);
        NVIC_SetPriority(SPI1_IRQn, MEDIUM_PRIORITY);
        
        // ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤ (ë‚®ì€ ìš°ì„ ìˆœìœ„)
        NVIC_SetPriority(EXTI0_IRQn, LOW_PRIORITY);    // ë²„íŠ¼
        NVIC_SetPriority(TIM2_IRQn, LOWEST_PRIORITY);  // LED ê¹œë¹¡ì„
        
        Serial.println("Interrupt priorities configured");
    }
    
    // í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ êµ¬í˜„
    static void enterCriticalSection() {
        __disable_irq();  // ëª¨ë“  ì¸í„°ëŸ½íŠ¸ ë¹„í™œì„±í™”
    }
    
    static void exitCriticalSection() {
        __enable_irq();   // ì¸í„°ëŸ½íŠ¸ ì¬í™œì„±í™”
    }
    
    // ì„ íƒì  ì¸í„°ëŸ½íŠ¸ ë§ˆìŠ¤í‚¹
    static void maskLowPriorityInterrupts() {
        // ìš°ì„ ìˆœìœ„ 3 ì´í•˜ë§Œ ë§ˆìŠ¤í‚¹
        __set_BASEPRI(3 << (8 - __NVIC_PRIO_BITS));
    }
    
    static void unmaskAllInterrupts() {
        __set_BASEPRI(0);
    }
};
```

## â±ï¸ ì¸í„°ëŸ½íŠ¸ ë ˆì´í„´ì‹œ ìµœì í™”

### ë ˆì´í„´ì‹œ ì¸¡ì •ê³¼ ë¶„ì„
```cpp
// ì¸í„°ëŸ½íŠ¸ ë ˆì´í„´ì‹œ ì¸¡ì •
class InterruptLatencyProfiler {
private:
    volatile uint32_t interrupt_timestamp = 0;
    volatile uint32_t handler_entry_time = 0;
    volatile uint32_t handler_exit_time = 0;
    
    struct LatencyStats {
        uint32_t min_latency;
        uint32_t max_latency;
        uint32_t total_latency;
        uint32_t sample_count;
    };
    
    static LatencyStats stats;
    
public:
    // GPIOë¥¼ ì´ìš©í•œ í•˜ë“œì›¨ì–´ ë ˆì´í„´ì‹œ ì¸¡ì •
    static void setupLatencyMeasurement() {
        // ì¸¡ì •ìš© GPIO í•€ ì„¤ì •
        pinMode(TRIGGER_PIN, OUTPUT);
        pinMode(LATENCY_MEASURE_PIN, OUTPUT);
        
        // ì™¸ë¶€ ì¸í„°ëŸ½íŠ¸ ì„¤ì •
        attachInterrupt(digitalPinToInterrupt(EXTERNAL_INT_PIN), 
                       latencyMeasureISR, RISING);
        
        // DWT ì‚¬ì´í´ ì¹´ìš´í„° í™œì„±í™” (ARM Cortex-M)
        CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
        DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
        DWT->CYCCNT = 0;
        
        Serial.println("Latency measurement setup complete");
    }
    
    // ë ˆì´í„´ì‹œ ì¸¡ì •ìš© ISR
    __attribute__((interrupt))
    static void latencyMeasureISR() {
        // ISR ì§„ì… ì¦‰ì‹œ í•€ í† ê¸€ (ì˜¤ì‹¤ë¡œìŠ¤ì½”í”„ ì¸¡ì •ìš©)
        digitalWrite(LATENCY_MEASURE_PIN, HIGH);
        
        // ì†Œí”„íŠ¸ì›¨ì–´ íƒ€ì´ë° ê¸°ë¡
        handler_entry_time = DWT->CYCCNT;
        
        // ì‹¤ì œ ì²˜ë¦¬ ì‘ì—… ì‹œë®¬ë ˆì´ì…˜
        volatile int dummy = 0;
        for(int i = 0; i < 10; i++) {
            dummy += i;
        }
        
        handler_exit_time = DWT->CYCCNT;
        
        // í†µê³„ ì—…ë°ì´íŠ¸
        updateLatencyStats();
        
        digitalWrite(LATENCY_MEASURE_PIN, LOW);
    }
    
    static void triggerInterruptForMeasurement() {
        // íŠ¸ë¦¬ê±° ì‹œì  ê¸°ë¡
        interrupt_timestamp = DWT->CYCCNT;
        
        // ì¸í„°ëŸ½íŠ¸ íŠ¸ë¦¬ê±°
        digitalWrite(TRIGGER_PIN, HIGH);
        delayMicroseconds(1);
        digitalWrite(TRIGGER_PIN, LOW);
    }
    
    static void printLatencyReport() {
        Serial.println("=== Interrupt Latency Report ===");
        Serial.printf("Samples: %lu\n", stats.sample_count);
        
        float min_us = (float)stats.min_latency / (F_CPU / 1000000);
        float max_us = (float)stats.max_latency / (F_CPU / 1000000);
        float avg_us = (float)stats.total_latency / stats.sample_count / (F_CPU / 1000000);
        
        Serial.printf("Min latency: %.2f Î¼s (%lu cycles)\n", min_us, stats.min_latency);
        Serial.printf("Max latency: %.2f Î¼s (%lu cycles)\n", max_us, stats.max_latency);
        Serial.printf("Avg latency: %.2f Î¼s\n", avg_us);
        
        // ì§€í„° ê³„ì‚°
        float jitter_us = max_us - min_us;
        Serial.printf("Jitter: %.2f Î¼s\n", jitter_us);
    }
    
private:
    static void updateLatencyStats() {
        uint32_t latency = handler_entry_time - interrupt_timestamp;
        
        if(stats.sample_count == 0) {
            stats.min_latency = latency;
            stats.max_latency = latency;
        } else {
            if(latency < stats.min_latency) stats.min_latency = latency;
            if(latency > stats.max_latency) stats.max_latency = latency;
        }
        
        stats.total_latency += latency;
        stats.sample_count++;
    }
};

// ì •ì  ë³€ìˆ˜ ì´ˆê¸°í™”
InterruptLatencyProfiler::LatencyStats InterruptLatencyProfiler::stats = {0, 0, 0, 0};
```

### ë ˆì´í„´ì‹œ ìµœì†Œí™” ê¸°ë²•
```cpp
// ìµœì í™”ëœ ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬
class OptimizedInterruptHandlers {
public:
    // 1. ì¸ë¼ì¸ ì–´ì…ˆë¸”ë¦¬ë¥¼ ì´ìš©í•œ ìµœì í™”
    __attribute__((interrupt, naked))
    static void fastISR() {
        asm volatile(
            "push {r0-r3, r12, lr}  \n"  // í•„ìˆ˜ ë ˆì§€ìŠ¤í„°ë§Œ ì €ì¥
            "ldr  r0, =0x40000000   \n"  // ì§ì ‘ í•˜ë“œì›¨ì–´ ì£¼ì†Œ ì ‘ê·¼
            "ldr  r1, [r0, #0x10]   \n"  // ìƒíƒœ ë ˆì§€ìŠ¤í„° ì½ê¸°
            "str  r1, [r0, #0x14]   \n"  // í”Œë˜ê·¸ í´ë¦¬ì–´
            "pop  {r0-r3, r12, lr}  \n"  // ë ˆì§€ìŠ¤í„° ë³µì›
            "bx   lr                \n"  // ë¦¬í„´
        );
    }
    
    // 2. ì»´íŒŒì¼ëŸ¬ ìµœì í™” íŒíŠ¸
    __attribute__((hot, optimize("O3")))
    static void criticalISR() {
        // ì»´íŒŒì¼ëŸ¬ì—ê²Œ ì´ í•¨ìˆ˜ê°€ ìì£¼ í˜¸ì¶œë˜ê³  ìµœì í™”ê°€ ì¤‘ìš”í•¨ì„ ì•Œë¦¼
        
        // ë¶„ê¸° ì˜ˆì¸¡ íŒíŠ¸
        if(__builtin_expect(status_flag, 1)) {
            // ì¼ë°˜ì ì¸ ê²½ìš°
            handleNormalCase();
        } else {
            // ì˜ˆì™¸ì ì¸ ê²½ìš°
            handleExceptionalCase();
        }
    }
    
    // 3. ë©”ëª¨ë¦¬ ì ‘ê·¼ ìµœì í™”
    static void optimizedMemoryAccess() {
        // ìºì‹œ ë¼ì¸ì— ë§ì¶˜ ë°ì´í„° êµ¬ì¡°
        struct __attribute__((aligned(32))) OptimizedData {
            volatile uint32_t counter;
            volatile uint32_t status;
            volatile uint32_t timestamp;
            volatile uint32_t reserved[5];  // 32ë°”ì´íŠ¸ ì •ë ¬
        };
        
        static OptimizedData data;
        
        // ë‹¨ì¼ ìºì‹œ ë¼ì¸ ì ‘ê·¼ìœ¼ë¡œ ì„±ëŠ¥ í–¥ìƒ
        data.counter++;
        data.status = 1;
        data.timestamp = DWT->CYCCNT;
    }
    
    // 4. í•˜ë“œì›¨ì–´ íŠ¹í™” ìµœì í™”
    static void setupHardwareOptimizations() {
        // ì¸í„°ëŸ½íŠ¸ ì»¨íŠ¸ë¡¤ëŸ¬ ìµœì í™”
        NVIC->ICER[0] = 0xFFFFFFFF;  // ëª¨ë“  ì¸í„°ëŸ½íŠ¸ ë¹„í™œì„±í™”
        
        // ì„ íƒì  ì¸í„°ëŸ½íŠ¸ë§Œ í™œì„±í™”
        NVIC_EnableIRQ(TIMER1_IRQn);
        NVIC_EnableIRQ(USART1_IRQn);
        
        // ì¸í„°ëŸ½íŠ¸ ëŒ€ê¸°ì‹œê°„ ìµœì†Œí™”
        SCB->CCR |= SCB_CCR_STKALIGN_Msk;  // ìŠ¤íƒ ì •ë ¬ ìµœì í™”
        
        // í”„ë¡œì„¸ì„œ ì„±ëŠ¥ ìµœì í™”
        SCB->CPACR |= (0xF << 20);  // FPU ì™„ì „ ì ‘ê·¼ í—ˆìš©
    }
    
private:
    static void handleNormalCase() {
        // ë¹ ë¥¸ ê²½ë¡œ ì²˜ë¦¬
    }
    
    static void handleExceptionalCase() {
        // ì˜ˆì™¸ ì²˜ë¦¬
    }
};
```

## ğŸš¦ ì‹¤ì‹œê°„ ì¸í„°ëŸ½íŠ¸ ê´€ë¦¬

### ì¸í„°ëŸ½íŠ¸ ë„¤ìŠ¤íŒ…ê³¼ ì„ ì 
```cpp
// ì¸í„°ëŸ½íŠ¸ ë„¤ìŠ¤íŒ… ê´€ë¦¬
class InterruptNestingManager {
private:
    static int nesting_level;
    static uint32_t disabled_interrupts[8];  // ë¹„í™œì„±í™”ëœ ì¸í„°ëŸ½íŠ¸ ë§ˆìŠ¤í¬
    
public:
    // ë„¤ìŠ¤íŒ… ìƒíƒœ ëª¨ë‹ˆí„°ë§
    static void enterISR(IRQn_Type irq) {
        nesting_level++;
        
        if(nesting_level > MAX_NESTING_LEVEL) {
            // ë„¤ìŠ¤íŒ… ë ˆë²¨ ì´ˆê³¼ ê²½ê³ 
            Serial.printf("WARNING: Nesting level exceeded: %d\n", nesting_level);
        }
        
        Serial.printf("ISR entered: %d (level %d)\n", irq, nesting_level);
    }
    
    static void exitISR(IRQn_Type irq) {
        nesting_level--;
        Serial.printf("ISR exited: %d (level %d)\n", irq, nesting_level);
    }
    
    // ì„ íƒì  ì¸í„°ëŸ½íŠ¸ ë§ˆìŠ¤í‚¹
    static void maskLowerPriorityInterrupts(int priority_threshold) {
        // í˜„ì¬ ìš°ì„ ìˆœìœ„ë³´ë‹¤ ë‚®ì€ ì¸í„°ëŸ½íŠ¸ë“¤ ë§ˆìŠ¤í‚¹
        for(int i = 0; i < 240; i++) {  // ARM Cortex-M ìµœëŒ€ 240ê°œ ì¸í„°ëŸ½íŠ¸
            if(NVIC_GetPriority((IRQn_Type)i) > priority_threshold) {
                NVIC_DisableIRQ((IRQn_Type)i);
            }
        }
    }
    
    // Priority Ceiling Protocol êµ¬í˜„
    static int raiseToHighestPriority(const int resource_id) {
        int original_priority = __get_BASEPRI();
        
        // í•´ë‹¹ ìì›ì˜ ì²œì¥ ìš°ì„ ìˆœìœ„ë¡œ ì„¤ì •
        int ceiling_priority = getResourceCeilingPriority(resource_id);
        __set_BASEPRI(ceiling_priority << (8 - __NVIC_PRIO_BITS));
        
        return original_priority;
    }
    
    static void restorePriority(int original_priority) {
        __set_BASEPRI(original_priority);
    }
    
    // ì¸í„°ëŸ½íŠ¸ í†µê³„ ìˆ˜ì§‘
    struct InterruptStats {
        uint32_t total_count;
        uint32_t max_execution_time;
        uint32_t total_execution_time;
        uint32_t missed_deadlines;
    };
    
    static InterruptStats stats[32];  // ì£¼ìš” ì¸í„°ëŸ½íŠ¸ë“¤ì˜ í†µê³„
    
    static void recordInterruptExecution(IRQn_Type irq, uint32_t execution_time) {
        if(irq >= 0 && irq < 32) {
            InterruptStats* stat = &stats[irq];
            
            stat->total_count++;
            stat->total_execution_time += execution_time;
            
            if(execution_time > stat->max_execution_time) {
                stat->max_execution_time = execution_time;
            }
            
            // ë°ë“œë¼ì¸ ì²´í¬ (ì˜ˆ: 100Î¼s)
            if(execution_time > 100 * (F_CPU / 1000000)) {
                stat->missed_deadlines++;
            }
        }
    }
    
private:
    static int getResourceCeilingPriority(int resource_id) {
        // ìì›ë³„ ì²œì¥ ìš°ì„ ìˆœìœ„ ë°˜í™˜
        switch(resource_id) {
            case 0: return 1;  // ê³µìœ  ë²„í¼
            case 1: return 2;  // UART ë²„í¼
            default: return 3;
        }
    }
};

int InterruptNestingManager::nesting_level = 0;
uint32_t InterruptNestingManager::disabled_interrupts[8] = {0};
InterruptNestingManager::InterruptStats InterruptNestingManager::stats[32] = {};
```

### ì‹¤ì‹œê°„ ì¸í„°ëŸ½íŠ¸ ìŠ¤ì¼€ì¤„ë§
```cpp
// ì‹¤ì‹œê°„ ì´ë²¤íŠ¸ ì²˜ë¦¬ë¥¼ ìœ„í•œ ì¸í„°ëŸ½íŠ¸ ê¸°ë°˜ ìŠ¤ì¼€ì¤„ëŸ¬
class RealTimeInterruptScheduler {
private:
    struct RTTask {
        void (*handler)();
        uint32_t period_us;
        uint32_t next_execution;
        int priority;
        bool enabled;
    };
    
    static const int MAX_RT_TASKS = 16;
    static RTTask rt_tasks[MAX_RT_TASKS];
    static int task_count;
    
public:
    // ì‹¤ì‹œê°„ ì£¼ê¸° íƒœìŠ¤í¬ ë“±ë¡
    static int registerPeriodicTask(void (*handler)(), uint32_t period_us, int priority) {
        if(task_count >= MAX_RT_TASKS) return -1;
        
        rt_tasks[task_count] = {
            handler,
            period_us,
            micros() + period_us,
            priority,
            true
        };
        
        Serial.printf("RT Task %d registered: period=%lu Î¼s, priority=%d\n",
                     task_count, period_us, priority);
        
        return task_count++;
    }
    
    // SysTickì„ ì´ìš©í•œ 1ms ê¸°ë³¸ íƒ€ì´ë¨¸
    __attribute__((interrupt))
    static void SysTick_Handler() {
        static uint32_t ms_counter = 0;
        ms_counter++;
        
        // 1msë§ˆë‹¤ ì‹¤ì‹œê°„ íƒœìŠ¤í¬ ì²´í¬
        checkRealTimeTasks();
    }
    
    // ì‹¤ì‹œê°„ íƒœìŠ¤í¬ ìŠ¤ì¼€ì¤„ë§
    static void checkRealTimeTasks() {
        uint32_t current_time = micros();
        
        // ìš°ì„ ìˆœìœ„ ìˆœìœ¼ë¡œ ì •ë ¬ëœ íƒœìŠ¤í¬ë“¤ í™•ì¸
        for(int i = 0; i < task_count; i++) {
            RTTask* task = &rt_tasks[i];
            
            if(task->enabled && current_time >= task->next_execution) {
                
                // ë°ë“œë¼ì¸ ì²´í¬
                if(current_time > task->next_execution + task->period_us) {
                    Serial.printf("DEADLINE MISS: Task %d\n", i);
                }
                
                // íƒœìŠ¤í¬ ì‹¤í–‰ (ì¸í„°ëŸ½íŠ¸ ì»¨í…ìŠ¤íŠ¸ì—ì„œ)
                uint32_t start_time = DWT->CYCCNT;
                task->handler();
                uint32_t execution_cycles = DWT->CYCCNT - start_time;
                
                // ë‹¤ìŒ ì‹¤í–‰ ì‹œê°„ ì„¤ì •
                task->next_execution += task->period_us;
                
                // ì‹¤í–‰ ì‹œê°„ ëª¨ë‹ˆí„°ë§
                float execution_time_us = (float)execution_cycles / (F_CPU / 1000000);
                if(execution_time_us > task->period_us * 0.1) {  // 10% ì´ìƒì´ë©´ ê²½ê³ 
                    Serial.printf("WARN: Task %d took %.2f Î¼s (%.1f%% of period)\n",
                                 i, execution_time_us, execution_time_us * 100 / task->period_us);
                }
            }
        }
    }
    
    // íƒœìŠ¤í¬ í™œì„±í™”/ë¹„í™œì„±í™”
    static void enableTask(int task_id, bool enable) {
        if(task_id >= 0 && task_id < task_count) {
            rt_tasks[task_id].enabled = enable;
        }
    }
    
    // ì‹œìŠ¤í…œ ë¶€í•˜ ëª¨ë‹ˆí„°ë§
    static float calculateSystemLoad() {
        uint32_t total_cpu_cycles = 0;
        uint32_t hyperperiod = 1000000;  // 1ì´ˆ
        
        for(int i = 0; i < task_count; i++) {
            if(rt_tasks[i].enabled) {
                // ê° íƒœìŠ¤í¬ì˜ CPU ì‚¬ìš©ë¥  ì¶”ì •
                uint32_t executions_per_second = 1000000 / rt_tasks[i].period_us;
                // ì‹¤í–‰ ì‹œê°„ì€ ì¸¡ì •ëœ ê°’ ì‚¬ìš© (ì—¬ê¸°ì„œëŠ” ì¶”ì •)
                uint32_t estimated_cycles_per_execution = 1000;  // ì¶”ì •ê°’
                
                total_cpu_cycles += executions_per_second * estimated_cycles_per_execution;
            }
        }
        
        return (float)total_cpu_cycles * 100.0 / (F_CPU);
    }
};

// ì •ì  ë³€ìˆ˜ ì´ˆê¸°í™”
RealTimeInterruptScheduler::RTTask RealTimeInterruptScheduler::rt_tasks[MAX_RT_TASKS];
int RealTimeInterruptScheduler::task_count = 0;
```

## ğŸ›¡ï¸ ì¸í„°ëŸ½íŠ¸ ì•ˆì „ì„±

### ë ˆì´ìŠ¤ ì»¨ë””ì…˜ ë°©ì§€
```cpp
// ì›ìì  ì—°ì‚°ê³¼ ë™ê¸°í™”
class InterruptSafety {
private:
    volatile uint32_t shared_counter = 0;
    volatile bool data_ready = false;
    
public:
    // 1. ì›ìì  ì—°ì‚° ì‚¬ìš©
    static uint32_t atomicIncrement(volatile uint32_t* value) {
        uint32_t result;
        
        // ARM Cortex-M LDREX/STREX ì‚¬ìš©
        do {
            result = __LDREXW(value);
            result++;
        } while (__STREXW(result, value) != 0);
        
        return result;
    }
    
    // 2. í¬ë¦¬í‹°ì»¬ ì„¹ì…˜
    template<typename Func>
    static auto criticalSection(Func&& func) -> decltype(func()) {
        uint32_t primask = __get_PRIMASK();
        __disable_irq();
        
        auto result = func();
        
        __set_PRIMASK(primask);
        return result;
    }
    
    // 3. ë©”ëª¨ë¦¬ ë°°ë¦¬ì–´
    static void memoryBarrier() {
        __DMB();  // Data Memory Barrier
        __DSB();  // Data Synchronization Barrier
        __ISB();  // Instruction Synchronization Barrier
    }
    
    // 4. Lock-free í êµ¬í˜„
    template<typename T, size_t SIZE>
    class LockFreeQueue {
    private:
        volatile T buffer[SIZE];
        volatile uint32_t head = 0;
        volatile uint32_t tail = 0;
        
    public:
        bool enqueue(const T& item) {
            uint32_t current_tail = tail;
            uint32_t next_tail = (current_tail + 1) % SIZE;
            
            if(next_tail == head) {
                return false;  // í ê°€ë“ì°¸
            }
            
            buffer[current_tail] = item;
            __DMB();  // ë©”ëª¨ë¦¬ ë°°ë¦¬ì–´
            tail = next_tail;
            
            return true;
        }
        
        bool dequeue(T& item) {
            uint32_t current_head = head;
            
            if(current_head == tail) {
                return false;  // í ë¹„ì–´ìˆìŒ
            }
            
            item = buffer[current_head];
            __DMB();  // ë©”ëª¨ë¦¬ ë°°ë¦¬ì–´
            head = (current_head + 1) % SIZE;
            
            return true;
        }
        
        bool isEmpty() const {
            return head == tail;
        }
        
        bool isFull() const {
            return ((tail + 1) % SIZE) == head;
        }
    };
    
    // 5. ì¸í„°ëŸ½íŠ¸ ì„¸ì´í”„ ë°ì´í„° êµí™˜
    class SafeDataExchange {
    private:
        volatile uint32_t data[2];  // ë”ë¸” ë²„í¼ë§
        volatile int active_buffer = 0;
        volatile bool buffer_ready[2] = {false, false};
        
    public:
        // ISRì—ì„œ ë°ì´í„° ì“°ê¸°
        void writeFromISR(uint32_t value) {
            int write_buffer = 1 - active_buffer;
            data[write_buffer] = value;
            buffer_ready[write_buffer] = true;
            
            // ì›ìì ìœ¼ë¡œ ë²„í¼ êµì²´
            active_buffer = write_buffer;
        }
        
        // ë©”ì¸ ë£¨í”„ì—ì„œ ë°ì´í„° ì½ê¸°
        bool readFromMain(uint32_t& value) {
            int read_buffer = active_buffer;
            
            if(buffer_ready[read_buffer]) {
                value = data[read_buffer];
                buffer_ready[read_buffer] = false;
                return true;
            }
            
            return false;
        }
    };
};
```

### ì¸í„°ëŸ½íŠ¸ ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤
```cpp
// ì¸í„°ëŸ½íŠ¸ í”„ë¡œê·¸ë˜ë° ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤
class InterruptBestPractices {
public:
    // ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤ 1: ìµœì†Œí•œì˜ ISR
    __attribute__((interrupt))
    static void goodISRExample() {
        // âœ… ì¢‹ì€ ì˜ˆ: í”Œë˜ê·¸ ì„¤ì •ë§Œ
        gpio_interrupt_flag = true;
        error_count++;
        
        // âœ… í•˜ë“œì›¨ì–´ í”Œë˜ê·¸ ì¦‰ì‹œ í´ë¦¬ì–´
        EXTI->PR = EXTI_PR_PR0;
    }
    
    // ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤ 2: ì˜ëª»ëœ ISR ì˜ˆì‹œ
    __attribute__((interrupt))
    static void badISRExample() {
        // âŒ ë‚˜ìœ ì˜ˆ: ë³µì¡í•œ ì²˜ë¦¬
        /*
        for(int i = 0; i < 1000; i++) {
            complexCalculation();
        }
        
        // âŒ ë¸”ë¡œí‚¹ í•¨ìˆ˜ í˜¸ì¶œ
        delay(100);
        
        // âŒ printf ê°™ì€ ë¬´ê±°ìš´ í•¨ìˆ˜
        printf("Interrupt occurred\n");
        
        // âŒ ë™ì  ë©”ëª¨ë¦¬ í• ë‹¹
        char* buffer = malloc(256);
        */
    }
    
    // ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤ 3: ë©”ì¸ ë£¨í”„ì—ì„œ ì²˜ë¦¬
    static void mainLoopProcessing() {
        if(gpio_interrupt_flag) {
            gpio_interrupt_flag = false;
            
            // ë³µì¡í•œ ì²˜ë¦¬ëŠ” ì—¬ê¸°ì„œ
            processGPIOEvent();
            
            // ë¡œê¹…ë„ ì—¬ê¸°ì„œ
            Serial.println("GPIO event processed");
        }
    }
    
    // ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤ 4: íƒ€ì´ë° í¬ë¦¬í‹°ì»¬í•œ ê²½ìš°
    __attribute__((interrupt))
    static void timingCriticalISR() {
        // íƒ€ì´ë°ì´ ì¤‘ìš”í•œ ìµœì†Œí•œì˜ ì‘ì—…ë§Œ
        
        // ì¦‰ì‹œ ì‘ë‹µì´ í•„ìš”í•œ í•˜ë“œì›¨ì–´ ì œì–´
        GPIOA->BSRR = GPIO_PIN_5;  // í•€ ì¦‰ì‹œ ì„¤ì •
        
        // íƒ€ì„ìŠ¤íƒ¬í”„ ê¸°ë¡
        critical_event_timestamp = DWT->CYCCNT;
        
        // í”Œë˜ê·¸ ì„¤ì •
        critical_event_occurred = true;
        
        // í•˜ë“œì›¨ì–´ ìƒíƒœ ì €ì¥
        hardware_status_snapshot = DEVICE_STATUS_REG;
    }
    
    // ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤ 5: ì¸í„°ëŸ½íŠ¸ í†µê³„ ëª¨ë‹ˆí„°ë§
    static void monitorInterruptPerformance() {
        static uint32_t last_check_time = 0;
        static uint32_t interrupt_count_last = 0;
        
        uint32_t current_time = millis();
        
        if(current_time - last_check_time >= 1000) {  // 1ì´ˆë§ˆë‹¤
            uint32_t interrupts_per_second = interrupt_total_count - interrupt_count_last;
            
            Serial.printf("Interrupts/sec: %lu\n", interrupts_per_second);
            Serial.printf("Avg ISR time: %.2f Î¼s\n", 
                         (float)total_isr_cycles / interrupt_total_count / (F_CPU / 1000000));
            
            if(interrupts_per_second > 10000) {
                Serial.println("WARNING: High interrupt rate detected");
            }
            
            last_check_time = current_time;
            interrupt_count_last = interrupt_total_count;
        }
    }
    
private:
    static volatile bool gpio_interrupt_flag;
    static volatile uint32_t error_count;
    static volatile bool critical_event_occurred;
    static volatile uint32_t critical_event_timestamp;
    static volatile uint32_t hardware_status_snapshot;
    static volatile uint32_t interrupt_total_count;
    static volatile uint32_t total_isr_cycles;
    
    static void processGPIOEvent() {
        // ë³µì¡í•œ GPIO ì´ë²¤íŠ¸ ì²˜ë¦¬
    }
    
    static void complexCalculation() {
        // ë³µì¡í•œ ê³„ì‚° (ISRì—ì„œ í•˜ë©´ ì•ˆë¨)
    }
};

// ì •ì  ë³€ìˆ˜ ì´ˆê¸°í™”
volatile bool InterruptBestPractices::gpio_interrupt_flag = false;
volatile uint32_t InterruptBestPractices::error_count = 0;
volatile bool InterruptBestPractices::critical_event_occurred = false;
volatile uint32_t InterruptBestPractices::critical_event_timestamp = 0;
volatile uint32_t InterruptBestPractices::hardware_status_snapshot = 0;
volatile uint32_t InterruptBestPractices::interrupt_total_count = 0;
volatile uint32_t InterruptBestPractices::total_isr_cycles = 0;
```

---

## ğŸ”— ì—°ê²° ë¬¸ì„œ
- ìƒìœ„: [[ì‹¤ì‹œê°„ì œì–´]]
- ê´€ë ¨: [[ë°ë“œë¼ì¸]], [[ì§€í„°]], [[ë ˆì´í„´ì‹œ]]
- ìŠ¤ì¼€ì¤„ë§: [[ìš°ì„ ìˆœìœ„ìŠ¤ì¼€ì¤„ë§]], [[ì‹œë¶„í• ìŠ¤ì¼€ì¤„ë§]]
- í•˜ë“œì›¨ì–´: [[ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬]], [[ì„¼ì„œì¸í„°í˜ì´ìŠ¤]]

## ğŸ“š ì°¸ê³ ë¬¸í—Œ
- [Embedded.com (2023). "Programming embedded systems: What are interrupts, and how they work"](https://www.embedded.com/programming-embedded-systems-what-are-interrupts-and-how-they-work/)
- [Embedded.com (2024). "5 best practices for writing interrupt service routines"](https://www.embedded.com/5-best-practices-for-writing-interrupt-service-routines/)
- [Bogotobogo (2024). "Embedded Systems Programming: Interrupt, Interrupt Latency, and IRQ"](https://www.bogotobogo.com/Embedded/hardware_interrupt_software_interrupt_latency_irq_vs_fiq.php)
- [Embien Technologies (2024). "Interrupt Handling in Embedded Software"](https://www.embien.com/blog/interrupt-handling-in-embedded-software)
- [TutorialsPoint (2024). "Understanding Interrupts in Embedded Systems"](https://www.tutorialspoint.com/embedded_systems/es_interrupts.htm)
