# λ§μ΄ν¬λ΅μ»¨νΈλ΅¤λ¬

> μƒμ„: [[μ „μνλ΅μ„¤κ³„]]

ESP32λ¥Ό μ¤‘μ‹¬μΌλ΅ ν• λ΅λ΄‡ μ μ–΄ μ‹μ¤ν…μ λ§μ΄ν¬λ΅μ»¨νΈλ΅¤λ¬ μ„¤κ³„μ…λ‹λ‹¤.

## π― ESP32 μ„Όμ„ λ°μ΄ν„° κ΄€λ¦¬

### ESP32 μ„ νƒ μ΄μ   
- **λ“€μ–Ό μ½”μ–΄**: 240MHz Xtensa LX6
- **λ‚΄μ¥ WiFi/Bluetooth**: λ¬΄μ„  ν†µμ‹  μ§€μ›
- **ν’λ¶€ν• μΈν„°νμ΄μ¤**: GPIO, I2C, SPI, UART, ADC
- **κ°λ° μƒνƒκ³„**: Arduino IDE, ESP-IDF μ§€μ›

### ν•€ λ°°μΉ κ³„ν
```
μ„Όμ„ μΈν„°νμ΄μ¤:
- I2C: GPIO21(SDA), GPIO22(SCL) - IMU, μ••λ ¥μ„Όμ„
- SPI: GPIO18(SCK), GPIO19(MISO), GPIO23(MOSI)
- ADC: GPIO32-39 - μ•„λ‚ λ΅κ·Έ μ„Όμ„ (λ΅λ“μ…€)
- μΈν„°λ½νΈ: GPIO2, GPIO4 - μ—”μ½”λ”, λ¦¬λ―ΈνΈ μ¤μ„μΉ

λ¨ν„° μ μ–΄:
- PWM: GPIO12-15 - λ¨ν„° μ†λ„ μ μ–΄
- λ””μ§€ν„Έ μ¶λ ¥: GPIO25-27 - λ°©ν–¥ μ μ–΄

ν†µμ‹ :
- UART: GPIO16(RX), GPIO17(TX) - μ™Έλ¶€ ν†µμ‹   
- CAN: GPIO5(TX), GPIO35(RX) - CAN νΈλμ‹λ²„
```
## π” μ£Όλ³€ νλ΅ μ„¤κ³„

### μ „μ› κ³µκΈ‰ νλ΅
```
5V μ…λ ¥ β†’ AMS1117-3.3V β†’ ESP32 (3.3V)
                    β†“
            100ΞΌF + 100nF λ””μ»¤ν”λ§
```

### λ¦¬μ…‹ λ° λ¶€νΈ νλ΅
```
RESET: 10kΞ© Pull-up + λ²„νΌ + 100nF λ””λ°”μ΄μ¤
BOOT: 10kΞ© Pull-up + λ²„νΌ (ν”„λ΅κ·Έλλ°μ©)
EN: 10kΞ© Pull-up (ν™μ„±ν™”)
```

## π”§ μ„Όμ„ λ°μ΄ν„° κ΄€λ¦¬ κµ¬μ΅°

### μ‹¤μ‹κ°„ λ°μ΄ν„° μμ§‘
```cpp
// FreeRTOS νƒμ¤ν¬ κΈ°λ° κµ¬μ΅°
xTaskCreatePinnedToCore(
    sensorTask,     // μ„Όμ„ λ°μ΄ν„° μμ§‘
    "SensorTask", 
    4096,           // μ¤νƒ ν¬κΈ°
    NULL, 
    2,              // μ°μ„ μμ„
    NULL,
    0               // μ½”μ–΄ 0
);

xTaskCreatePinnedToCore(
    controlTask,    // μ μ–΄ λ΅μ§
    "ControlTask",
    8192,
    NULL,
    3,              // λ†’μ€ μ°μ„ μμ„  
    NULL,
    1               // μ½”μ–΄ 1
);
```
### λ°μ΄ν„° κµ¬μ΅°μ²΄
```cpp
typedef struct {
    float accel[3];     // κ°€μ†λ„ X, Y, Z
    float gyro[3];      // κ°μ†λ„ X, Y, Z  
    float angle;        // μ—”μ½”λ” κ°λ„
    float force;        // λ΅λ“μ…€ ν
    uint32_t timestamp; // νƒ€μ„μ¤νƒ¬ν”„
} SensorData_t;

QueueHandle_t sensorQueue;  // μ„Όμ„ λ°μ΄ν„° ν
```

### ν•„ν„°λ§ κµ¬ν„
```cpp
// μ΄λ™ν‰κ·  ν•„ν„°
class MovingAverage {
private:
    float buffer[FILTER_SIZE];
    int index = 0;
    float sum = 0;
    
public:
    float update(float value) {
        sum -= buffer[index];
        buffer[index] = value;
        sum += value;
        index = (index + 1) % FILTER_SIZE;
        return sum / FILTER_SIZE;
    }
};
```

## π¨ μ•μ „ λ° μμ™Έμ²λ¦¬

### μ„Όμ„ μ¤λ¥ μ²λ¦¬
```cpp
bool readSensorSafe(SensorData_t *data) {
    const int MAX_RETRIES = 3;
    
    for(int retry = 0; retry < MAX_RETRIES; retry++) {
        if(readSensor(data)) {
            return true;  // μ„±κ³µ
        }
        delay(10);  // μ¬μ‹λ„ λ€κΈ°
    }
    
    setSafeValues(data);  // μ•μ „ κ°’ μ„¤μ •
    return false;
}
```

---

## π”— μ—°κ²° λ¬Έμ„
- μƒμ„: [[μ „μνλ΅μ„¤κ³„]]
- κ΄€λ ¨: [[λ§μ΄ν¬λ΅ν”„λ΅μ„Έμ„]], [[μ„Όμ„μΈν„°νμ΄μ¤]]
- μ‘μ©: [[μ‹¤μ‹κ°„μ μ–΄]], [[ν†µμ‹ μΈν„°νμ΄μ¤]], [[λ¨ν„°λ“λΌμ΄λ²„]]