# ì§€í„°

> ìƒìœ„: [[ì‹¤ì‹œê°„ì œì–´]]

ì‹¤ì‹œê°„ ì‹œìŠ¤í…œì—ì„œ ì œì–´ ì£¼ê¸°ë‚˜ ì‹ í˜¸ íƒ€ì´ë°ì˜ ë³€ë™ì„±ìœ¼ë¡œ, ì´ìƒì ì¸ ì£¼ê¸°ì  ë™ì‘ì—ì„œ ë²—ì–´ë‚˜ëŠ” í˜„ìƒì…ë‹ˆë‹¤.

## ğŸ“Š ì§€í„° ì •ì˜ì™€ ë¶„ë¥˜

### ì£¼ê¸° ì§€í„° (Period Jitter)
```
ì •ì˜: ì‹¤ì œ ì£¼ê¸°ì™€ ì´ìƒì  ì£¼ê¸° ê°„ì˜ í¸ì°¨
ì¸¡ì •: Ïƒ = âˆš(Î£(Ti - T_avg)Â² / n)

ì—¬ê¸°ì„œ:
- Ti: ië²ˆì§¸ ì£¼ê¸°ì˜ ì‹¤ì œ ì‹œê°„
- T_avg: í‰ê·  ì£¼ê¸°
- Ïƒ: RMS ì§€í„° ê°’
```

### ì‚¬ì´í´ ê°„ ì§€í„° (Cycle-to-Cycle Jitter)
```
ì •ì˜: ì—°ì†ëœ ë‘ ì£¼ê¸° ê°„ì˜ ì°¨ì´
ê³„ì‚°: Jc2c = |Ti+1 - Ti|

íŠ¹ì§•:
- ì¸ì ‘í•œ ì£¼ê¸° ê°„ ë³€ë™ì„± ì¸¡ì •
- ì œì–´ ì•ˆì •ì„±ì— ì§ì ‘ì  ì˜í–¥
- ê³ ì£¼íŒŒ ë…¸ì´ì¦ˆ ì„±ë¶„ ë°˜ì˜
```

### ì‹œê°„ê°„ê²©ì˜¤ì°¨ (Time Interval Error, TIE)
```
ì •ì˜: ì´ìƒì ì¸ ê¸°ì¤€ ì‹ í˜¸ ëŒ€ë¹„ ì‹¤ì œ ì‹ í˜¸ì˜ ì‹œê°„ í¸ì°¨
ê³„ì‚°: TIE(t) = T_actual(t) - T_ideal(t)

ì‘ìš©:
- í†µì‹  ì‹œìŠ¤í…œ ë™ê¸°í™”
- í´ë¡ ë³µêµ¬ íšŒë¡œ
- ë°ì´í„° ìƒ˜í”Œë§ ì •í™•ë„
```

## âš¡ ì§€í„° ë°œìƒ ì›ì¸

### í•˜ë“œì›¨ì–´ ì§€í„°
```cpp
// í•˜ë“œì›¨ì–´ ìš”ì¸ë“¤
enum JitterSource {
    THERMAL_NOISE,      // ì—´ì¡ìŒ (Johnson noise)
    POWER_SUPPLY_NOISE, // ì „ì›ê³µê¸‰ì¥ì¹˜ ë…¸ì´ì¦ˆ  
    CLOCK_INSTABILITY,  // í´ë¡ ë¶ˆì•ˆì •ì„±
    EMI_INTERFERENCE,   // ì „ìê¸° ê°„ì„­
    COMPONENT_AGING     // ë¶€í’ˆ ë…¸í™”
};

// ì˜¨ë„ì— ë”°ë¥¸ í´ë¡ ì§€í„° ë³´ìƒ
class ThermalJitterCompensation {
private:
    float base_frequency = 16000000.0;  // 16MHz ê¸°ì¤€
    float temp_coefficient = -40e-6;    // ppm/Â°C
    
public:
    float compensateFrequency(float temperature) {
        float temp_drift = temp_coefficient * (temperature - 25.0);
        return base_frequency * (1.0 + temp_drift);
    }
    
    void adjustTimerPeriod(float temperature) {
        float compensated_freq = compensateFrequency(temperature);
        uint16_t timer_reload = (uint16_t)(F_CPU / compensated_freq);
        
        // íƒ€ì´ë¨¸ ë ˆì§€ìŠ¤í„° ì¡°ì •
        TIMER1_RELOAD = timer_reload;
    }
};
```

### ì†Œí”„íŠ¸ì›¨ì–´ ì§€í„°
```cpp
// ì†Œí”„íŠ¸ì›¨ì–´ ì§€í„° ìš”ì¸ë“¤
class SoftwareJitterAnalysis {
public:
    struct JitterFactors {
        int interrupt_latency;      // ì¸í„°ëŸ½íŠ¸ ì‘ë‹µ ì§€ì—°
        int context_switch_time;    // ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­ ì‹œê°„
        int cache_miss_penalty;     // ìºì‹œ ë¯¸ìŠ¤ íŒ¨ë„í‹°
        int memory_access_time;     // ë©”ëª¨ë¦¬ ì ‘ê·¼ ì‹œê°„
        int scheduler_overhead;     // ìŠ¤ì¼€ì¤„ëŸ¬ ì˜¤ë²„í—¤ë“œ
    };
    
    // ì§€í„° ì¸¡ì • í•¨ìˆ˜
    void measureExecutionJitter() {
        const int samples = 1000;
        unsigned long execution_times[samples];
        
        for(int i = 0; i < samples; i++) {
            unsigned long start = micros();
            
            // ì¸¡ì •í•  ì‘ì—… ì‹¤í–‰
            criticalTask();
            
            execution_times[i] = micros() - start;
        }
        
        // í†µê³„ ê³„ì‚°
        calculateJitterStatistics(execution_times, samples);
    }
    
private:
    void calculateJitterStatistics(unsigned long times[], int count) {
        // í‰ê·  ê³„ì‚°
        float mean = 0;
        for(int i = 0; i < count; i++) {
            mean += times[i];
        }
        mean /= count;
        
        // í‘œì¤€í¸ì°¨ ê³„ì‚° (RMS ì§€í„°)
        float variance = 0;
        for(int i = 0; i < count; i++) {
            variance += pow(times[i] - mean, 2);
        }
        float rms_jitter = sqrt(variance / count);
        
        // í”¼í¬íˆ¬í”¼í¬ ì§€í„°
        unsigned long min_time = times[0], max_time = times[0];
        for(int i = 1; i < count; i++) {
            if(times[i] < min_time) min_time = times[i];
            if(times[i] > max_time) max_time = times[i];
        }
        unsigned long pk2pk_jitter = max_time - min_time;
        
        Serial.printf("Mean execution time: %.2f Î¼s\n", mean);
        Serial.printf("RMS jitter: %.2f Î¼s\n", rms_jitter);
        Serial.printf("Peak-to-peak jitter: %lu Î¼s\n", pk2pk_jitter);
    }
};
```

## ğŸ¯ ì§€í„° ì¸¡ì • ê¸°ë²•

### í•˜ë“œì›¨ì–´ ê¸°ë°˜ ì¸¡ì •
```cpp
// ê³ ì •ë°€ íƒ€ì´ë¨¸ë¥¼ ì´ìš©í•œ ì§€í„° ì¸¡ì •
class PrecisionJitterMeter {
private:
    static const int BUFFER_SIZE = 1024;
    volatile unsigned long timestamps[BUFFER_SIZE];
    volatile int buffer_index = 0;
    
public:
    void initTimestamping() {
        // ê³ í•´ìƒë„ íƒ€ì´ë¨¸ ì„¤ì • (1MHz)
        TIMER2_PRESCALER = 16;  // 16MHz/16 = 1MHz
        TIMER2_MODE = TIMER_CTC_MODE;
        TIMER2_ENABLE_INTERRUPT();
    }
    
    // ì¸í„°ëŸ½íŠ¸ ì„œë¹„ìŠ¤ ë£¨í‹´ì—ì„œ í˜¸ì¶œ
    void recordTimestamp() {
        if(buffer_index < BUFFER_SIZE) {
            timestamps[buffer_index] = TIMER2_COUNTER;
            buffer_index++;
        }
    }
    
    void analyzeJitter() {
        if(buffer_index < 2) return;
        
        // ì£¼ê¸° ê³„ì‚°
        float periods[BUFFER_SIZE - 1];
        for(int i = 1; i < buffer_index; i++) {
            periods[i-1] = timestamps[i] - timestamps[i-1];
        }
        
        // ì§€í„° ë¶„ì„
        analyzePeriodicJitter(periods, buffer_index - 1);
        buffer_index = 0;  // ë²„í¼ ë¦¬ì…‹
    }
    
private:
    void analyzePeriodicJitter(float periods[], int count) {
        // í‰ê·  ì£¼ê¸°
        float mean_period = 0;
        for(int i = 0; i < count; i++) {
            mean_period += periods[i];
        }
        mean_period /= count;
        
        // ì£¼ê¸° ì§€í„° (í‘œì¤€í¸ì°¨)
        float period_jitter = 0;
        for(int i = 0; i < count; i++) {
            period_jitter += pow(periods[i] - mean_period, 2);
        }
        period_jitter = sqrt(period_jitter / count);
        
        // ì‚¬ì´í´ ê°„ ì§€í„°
        float c2c_jitter = 0;
        for(int i = 1; i < count; i++) {
            c2c_jitter += abs(periods[i] - periods[i-1]);
        }
        c2c_jitter /= (count - 1);
        
        Serial.printf("Mean period: %.2f Î¼s\n", mean_period);
        Serial.printf("Period jitter (RMS): %.2f Î¼s\n", period_jitter);
        Serial.printf("Cycle-to-cycle jitter: %.2f Î¼s\n", c2c_jitter);
    }
};
```

### ì†Œí”„íŠ¸ì›¨ì–´ í”„ë¡œíŒŒì¼ë§
```cpp
// ì½”ë“œ ì‹¤í–‰ ê²½ë¡œë³„ ì§€í„° ë¶„ì„
class ExecutionPathProfiler {
private:
    struct PathMetrics {
        const char* path_name;
        unsigned long min_time;
        unsigned long max_time;
        unsigned long total_time;
        int execution_count;
    };
    
    PathMetrics paths[10];
    int path_count = 0;
    
public:
    int registerPath(const char* name) {
        if(path_count < 10) {
            paths[path_count] = {name, ULONG_MAX, 0, 0, 0};
            return path_count++;
        }
        return -1;
    }
    
    void profilePath(int path_id, void (*function)()) {
        if(path_id < 0 || path_id >= path_count) return;
        
        unsigned long start = micros();
        function();
        unsigned long duration = micros() - start;
        
        // í†µê³„ ì—…ë°ì´íŠ¸
        PathMetrics* path = &paths[path_id];
        path->execution_count++;
        path->total_time += duration;
        
        if(duration < path->min_time) path->min_time = duration;
        if(duration > path->max_time) path->max_time = duration;
    }
    
    void printProfile() {
        for(int i = 0; i < path_count; i++) {
            PathMetrics* path = &paths[i];
            float avg_time = (float)path->total_time / path->execution_count;
            float jitter = path->max_time - path->min_time;
            
            Serial.printf("Path: %s\n", path->path_name);
            Serial.printf("  Average: %.2f Î¼s\n", avg_time);
            Serial.printf("  Min: %lu Î¼s, Max: %lu Î¼s\n", path->min_time, path->max_time);
            Serial.printf("  Jitter (P2P): %.0f Î¼s\n", jitter);
            Serial.printf("  Executions: %d\n\n", path->execution_count);
        }
    }
};
```

## ğŸ› ï¸ ì§€í„° ìµœì†Œí™” ê¸°ë²•

### í•˜ë“œì›¨ì–´ ìµœì í™”
```cpp
// ì¸í„°ëŸ½íŠ¸ ì§€ì—° ìµœì†Œí™”
class LowJitterInterruptHandler {
public:
    void setupLowLatencyTimer() {
        // ìµœê³  ìš°ì„ ìˆœìœ„ ì¸í„°ëŸ½íŠ¸ ì„¤ì •
        NVIC_SetPriority(TIMER1_IRQn, 0);
        
        // í”„ë¦¬ìŠ¤ì¼€ì¼ëŸ¬ ìµœì†Œí™” (ì •ë°€ë„ í–¥ìƒ)
        TIMER1_PRESCALER = 1;
        
        // í•˜ë“œì›¨ì–´ íŠ¸ë¦¬ê±° ì‚¬ìš©
        TIMER1_TRIGGER_SOURCE = HARDWARE_TRIGGER;
        
        // ì¸í„°ëŸ½íŠ¸ ì‘ë‹µ ìµœì í™”
        __enable_irq();
        TIMER1_ENABLE_INTERRUPT();
    }
    
    // ìµœì í™”ëœ ISR
    __attribute__((interrupt, used))
    void TIMER1_Handler() {
        // ìµœì†Œí•œì˜ ì²˜ë¦¬ë§Œ ìˆ˜í–‰
        static volatile bool toggle = false;
        
        // í¬ë¦¬í‹°ì»¬ íƒ€ì´ë° ì‘ì—…
        if(toggle) {
            GPIOA->BSRR = GPIO_PIN_1;  // í•€ ì„¤ì • (í•œ ì‚¬ì´í´)
        } else {
            GPIOA->BSRR = GPIO_PIN_1 << 16;  // í•€ ë¦¬ì…‹
        }
        toggle = !toggle;
        
        // í”Œë˜ê·¸ í´ë¦¬ì–´ (í•˜ë“œì›¨ì–´ ìë™ì²˜ë¦¬)
        TIMER1->SR = 0;
    }
};
```

### ì‹¤ì‹œê°„ ìŠ¤ì¼€ì¤„ë§ ìµœì í™”
```cpp
// ì§€í„° ìµœì†Œí™”ë¥¼ ìœ„í•œ ìŠ¤ì¼€ì¤„ë§ ê¸°ë²•
class JitterMinimizedScheduler {
private:
    struct PeriodicTask {
        void (*function)();
        unsigned long period_us;
        unsigned long next_execution;
        int priority;
        bool jitter_sensitive;
    };
    
    PeriodicTask tasks[MAX_TASKS];
    int task_count = 0;
    
public:
    void addTask(void (*func)(), unsigned long period, 
                int priority, bool jitter_sensitive = false) {
        if(task_count < MAX_TASKS) {
            tasks[task_count] = {func, period, micros() + period, 
                               priority, jitter_sensitive};
            task_count++;
            
            // ìš°ì„ ìˆœìœ„ë³„ ì •ë ¬
            sortTasksByPriority();
        }
    }
    
    void executeTasks() {
        unsigned long current_time = micros();
        
        // ì§€í„° ë¯¼ê° ì‘ì—… ìš°ì„  ì²˜ë¦¬
        for(int i = 0; i < task_count; i++) {
            if(tasks[i].jitter_sensitive && 
               current_time >= tasks[i].next_execution) {
                
                // ì •í™•í•œ íƒ€ì´ë°ì— ì‹¤í–‰
                while(micros() < tasks[i].next_execution) {
                    // ëŠ¥ë™ ëŒ€ê¸° (ìŠ¤í•€ë½)
                    __NOP();
                }
                
                tasks[i].function();
                tasks[i].next_execution += tasks[i].period_us;
            }
        }
        
        // ì¼ë°˜ ì‘ì—…ë“¤ ì²˜ë¦¬
        for(int i = 0; i < task_count; i++) {
            if(!tasks[i].jitter_sensitive && 
               current_time >= tasks[i].next_execution) {
                
                tasks[i].function();
                tasks[i].next_execution += tasks[i].period_us;
            }
        }
    }
    
private:
    void sortTasksByPriority() {
        // ë²„ë¸” ì •ë ¬ (ì‘ì€ ë°°ì—´ìš©)
        for(int i = 0; i < task_count - 1; i++) {
            for(int j = 0; j < task_count - i - 1; j++) {
                if(tasks[j].priority > tasks[j + 1].priority) {
                    PeriodicTask temp = tasks[j];
                    tasks[j] = tasks[j + 1];
                    tasks[j + 1] = temp;
                }
            }
        }
    }
};
```

## ğŸ”§ ì§€í„° ë³´ìƒ ê¸°ë²•

### ì ì‘ì  ì§€í„° ë³´ìƒ
```cpp
// ì‹¤ì‹œê°„ ì§€í„° ë³´ìƒ ì•Œê³ ë¦¬ì¦˜
class AdaptiveJitterCompensator {
private:
    float jitter_history[16];
    int history_index = 0;
    float predicted_jitter = 0;
    
public:
    void recordJitter(float measured_jitter) {
        jitter_history[history_index] = measured_jitter;
        history_index = (history_index + 1) % 16;
        
        // ì§€í„° ì˜ˆì¸¡ (ì´ë™í‰ê· )
        updateJitterPrediction();
    }
    
    unsigned long compensateNextExecution(unsigned long nominal_time) {
        // ì˜ˆì¸¡ëœ ì§€í„°ë¥¼ ê³ ë ¤í•œ ì‹œê°„ ì¡°ì •
        return nominal_time - (unsigned long)(predicted_jitter * 0.7);
    }
    
private:
    void updateJitterPrediction() {
        float sum = 0;
        for(int i = 0; i < 16; i++) {
            sum += jitter_history[i];
        }
        predicted_jitter = sum / 16.0;
    }
};

// í´ë§ ê¸°ë°˜ ì§€í„° ê°ì†Œ
class PollingJitterReduction {
private:
    unsigned long target_period_us;
    unsigned long last_execution;
    
public:
    PollingJitterReduction(unsigned long period) : target_period_us(period) {
        last_execution = micros();
    }
    
    void waitForNextPeriod() {
        unsigned long target_time = last_execution + target_period_us;
        
        // ëŠ¥ë™ ëŒ€ê¸°ë¡œ ì •í™•í•œ íƒ€ì´ë° ë³´ì¥
        while(micros() < target_time) {
            // CPU ì‚¬ìš©ë¥  ì¦ê°€í•˜ì§€ë§Œ ì§€í„° ìµœì†Œí™”
            __NOP();
        }
        
        last_execution = target_time;
    }
    
    // ì§€í„° ì¸¡ì •ê³¼ í•¨ê»˜ ì‹¤í–‰
    void executeWithJitterMeasurement(void (*task)()) {
        unsigned long actual_start = micros();
        float jitter = (float)((long)(actual_start - last_execution - target_period_us));
        
        task();
        
        Serial.printf("Execution jitter: %.2f Î¼s\n", jitter);
        last_execution = actual_start;
    }
};
```

---

## ğŸ”— ì—°ê²° ë¬¸ì„œ
- ìƒìœ„: [[ì‹¤ì‹œê°„ì œì–´]]
- ê´€ë ¨: [[ë°ë“œë¼ì¸]], [[ë ˆì´í„´ì‹œ]], [[ì²˜ë¦¬ëŸ‰]]
- í•˜ë“œì›¨ì–´: [[ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬]], [[ADC]], [[ì¸í„°ëŸ½íŠ¸ì²˜ë¦¬]]
- ì¸¡ì •: [[ì„¼ì„œì¸í„°í˜ì´ìŠ¤]], [[ì‹ í˜¸ì¡°ì ˆ]]

## ğŸ“š ì°¸ê³ ë¬¸í—Œ
- [NIST (2001). "Real-Time Operating System Timing Jitter and its Impact on Motor Control"](https://www.nist.gov/publications/real-time-operating-system-timing-jitter-and-its-impact-motor-control-0)
- [NI (2024). "Determinism and Jitter in a Real-Time System"](https://www.ni.com/docs/en-US/bundle/labview-nxg-rt-module-programming-with-rt-target/page/determinism-real-time.html)
- [SiTime (2024). "Jitter 101: What you need to know"](https://www.sitime.com/company/newsroom/blog/jitter-101-what-you-need-know)
- [IEEE (1995). "Jitter compensation for real-time control systems"](https://ieeexplore.ieee.org/abstract/document/990594/)
