# 지터

> 상위: [[실시간제어]]

실시간 시스템에서 제어 주기나 신호 타이밍의 변동성으로, 이상적인 주기적 동작에서 벗어나는 현상입니다.

## 📊 지터 정의와 분류

### 주기 지터 (Period Jitter)
```
정의: 실제 주기와 이상적 주기 간의 편차
측정: σ = √(Σ(Ti - T_avg)² / n)

여기서:
- Ti: i번째 주기의 실제 시간
- T_avg: 평균 주기
- σ: RMS 지터 값
```

### 사이클 간 지터 (Cycle-to-Cycle Jitter)
```
정의: 연속된 두 주기 간의 차이
계산: Jc2c = |Ti+1 - Ti|

특징:
- 인접한 주기 간 변동성 측정
- 제어 안정성에 직접적 영향
- 고주파 노이즈 성분 반영
```

### 시간간격오차 (Time Interval Error, TIE)
```
정의: 이상적인 기준 신호 대비 실제 신호의 시간 편차
계산: TIE(t) = T_actual(t) - T_ideal(t)

응용:
- 통신 시스템 동기화
- 클록 복구 회로
- 데이터 샘플링 정확도
```

## ⚡ 지터 발생 원인

### 하드웨어 지터
```cpp
// 하드웨어 요인들
enum JitterSource {
    THERMAL_NOISE,      // 열잡음 (Johnson noise)
    POWER_SUPPLY_NOISE, // 전원공급장치 노이즈  
    CLOCK_INSTABILITY,  // 클록 불안정성
    EMI_INTERFERENCE,   // 전자기 간섭
    COMPONENT_AGING     // 부품 노화
};

// 온도에 따른 클록 지터 보상
class ThermalJitterCompensation {
private:
    float base_frequency = 16000000.0;  // 16MHz 기준
    float temp_coefficient = -40e-6;    // ppm/°C
    
public:
    float compensateFrequency(float temperature) {
        float temp_drift = temp_coefficient * (temperature - 25.0);
        return base_frequency * (1.0 + temp_drift);
    }
    
    void adjustTimerPeriod(float temperature) {
        float compensated_freq = compensateFrequency(temperature);
        uint16_t timer_reload = (uint16_t)(F_CPU / compensated_freq);
        
        // 타이머 레지스터 조정
        TIMER1_RELOAD = timer_reload;
    }
};
```

### 소프트웨어 지터
```cpp
// 소프트웨어 지터 요인들
class SoftwareJitterAnalysis {
public:
    struct JitterFactors {
        int interrupt_latency;      // 인터럽트 응답 지연
        int context_switch_time;    // 컨텍스트 스위칭 시간
        int cache_miss_penalty;     // 캐시 미스 패널티
        int memory_access_time;     // 메모리 접근 시간
        int scheduler_overhead;     // 스케줄러 오버헤드
    };
    
    // 지터 측정 함수
    void measureExecutionJitter() {
        const int samples = 1000;
        unsigned long execution_times[samples];
        
        for(int i = 0; i < samples; i++) {
            unsigned long start = micros();
            
            // 측정할 작업 실행
            criticalTask();
            
            execution_times[i] = micros() - start;
        }
        
        // 통계 계산
        calculateJitterStatistics(execution_times, samples);
    }
    
private:
    void calculateJitterStatistics(unsigned long times[], int count) {
        // 평균 계산
        float mean = 0;
        for(int i = 0; i < count; i++) {
            mean += times[i];
        }
        mean /= count;
        
        // 표준편차 계산 (RMS 지터)
        float variance = 0;
        for(int i = 0; i < count; i++) {
            variance += pow(times[i] - mean, 2);
        }
        float rms_jitter = sqrt(variance / count);
        
        // 피크투피크 지터
        unsigned long min_time = times[0], max_time = times[0];
        for(int i = 1; i < count; i++) {
            if(times[i] < min_time) min_time = times[i];
            if(times[i] > max_time) max_time = times[i];
        }
        unsigned long pk2pk_jitter = max_time - min_time;
        
        Serial.printf("Mean execution time: %.2f μs\n", mean);
        Serial.printf("RMS jitter: %.2f μs\n", rms_jitter);
        Serial.printf("Peak-to-peak jitter: %lu μs\n", pk2pk_jitter);
    }
};
```

## 🎯 지터 측정 기법

### 하드웨어 기반 측정
```cpp
// 고정밀 타이머를 이용한 지터 측정
class PrecisionJitterMeter {
private:
    static const int BUFFER_SIZE = 1024;
    volatile unsigned long timestamps[BUFFER_SIZE];
    volatile int buffer_index = 0;
    
public:
    void initTimestamping() {
        // 고해상도 타이머 설정 (1MHz)
        TIMER2_PRESCALER = 16;  // 16MHz/16 = 1MHz
        TIMER2_MODE = TIMER_CTC_MODE;
        TIMER2_ENABLE_INTERRUPT();
    }
    
    // 인터럽트 서비스 루틴에서 호출
    void recordTimestamp() {
        if(buffer_index < BUFFER_SIZE) {
            timestamps[buffer_index] = TIMER2_COUNTER;
            buffer_index++;
        }
    }
    
    void analyzeJitter() {
        if(buffer_index < 2) return;
        
        // 주기 계산
        float periods[BUFFER_SIZE - 1];
        for(int i = 1; i < buffer_index; i++) {
            periods[i-1] = timestamps[i] - timestamps[i-1];
        }
        
        // 지터 분석
        analyzePeriodicJitter(periods, buffer_index - 1);
        buffer_index = 0;  // 버퍼 리셋
    }
    
private:
    void analyzePeriodicJitter(float periods[], int count) {
        // 평균 주기
        float mean_period = 0;
        for(int i = 0; i < count; i++) {
            mean_period += periods[i];
        }
        mean_period /= count;
        
        // 주기 지터 (표준편차)
        float period_jitter = 0;
        for(int i = 0; i < count; i++) {
            period_jitter += pow(periods[i] - mean_period, 2);
        }
        period_jitter = sqrt(period_jitter / count);
        
        // 사이클 간 지터
        float c2c_jitter = 0;
        for(int i = 1; i < count; i++) {
            c2c_jitter += abs(periods[i] - periods[i-1]);
        }
        c2c_jitter /= (count - 1);
        
        Serial.printf("Mean period: %.2f μs\n", mean_period);
        Serial.printf("Period jitter (RMS): %.2f μs\n", period_jitter);
        Serial.printf("Cycle-to-cycle jitter: %.2f μs\n", c2c_jitter);
    }
};
```

### 소프트웨어 프로파일링
```cpp
// 코드 실행 경로별 지터 분석
class ExecutionPathProfiler {
private:
    struct PathMetrics {
        const char* path_name;
        unsigned long min_time;
        unsigned long max_time;
        unsigned long total_time;
        int execution_count;
    };
    
    PathMetrics paths[10];
    int path_count = 0;
    
public:
    int registerPath(const char* name) {
        if(path_count < 10) {
            paths[path_count] = {name, ULONG_MAX, 0, 0, 0};
            return path_count++;
        }
        return -1;
    }
    
    void profilePath(int path_id, void (*function)()) {
        if(path_id < 0 || path_id >= path_count) return;
        
        unsigned long start = micros();
        function();
        unsigned long duration = micros() - start;
        
        // 통계 업데이트
        PathMetrics* path = &paths[path_id];
        path->execution_count++;
        path->total_time += duration;
        
        if(duration < path->min_time) path->min_time = duration;
        if(duration > path->max_time) path->max_time = duration;
    }
    
    void printProfile() {
        for(int i = 0; i < path_count; i++) {
            PathMetrics* path = &paths[i];
            float avg_time = (float)path->total_time / path->execution_count;
            float jitter = path->max_time - path->min_time;
            
            Serial.printf("Path: %s\n", path->path_name);
            Serial.printf("  Average: %.2f μs\n", avg_time);
            Serial.printf("  Min: %lu μs, Max: %lu μs\n", path->min_time, path->max_time);
            Serial.printf("  Jitter (P2P): %.0f μs\n", jitter);
            Serial.printf("  Executions: %d\n\n", path->execution_count);
        }
    }
};
```

## 🛠️ 지터 최소화 기법

### 하드웨어 최적화
```cpp
// 인터럽트 지연 최소화
class LowJitterInterruptHandler {
public:
    void setupLowLatencyTimer() {
        // 최고 우선순위 인터럽트 설정
        NVIC_SetPriority(TIMER1_IRQn, 0);
        
        // 프리스케일러 최소화 (정밀도 향상)
        TIMER1_PRESCALER = 1;
        
        // 하드웨어 트리거 사용
        TIMER1_TRIGGER_SOURCE = HARDWARE_TRIGGER;
        
        // 인터럽트 응답 최적화
        __enable_irq();
        TIMER1_ENABLE_INTERRUPT();
    }
    
    // 최적화된 ISR
    __attribute__((interrupt, used))
    void TIMER1_Handler() {
        // 최소한의 처리만 수행
        static volatile bool toggle = false;
        
        // 크리티컬 타이밍 작업
        if(toggle) {
            GPIOA->BSRR = GPIO_PIN_1;  // 핀 설정 (한 사이클)
        } else {
            GPIOA->BSRR = GPIO_PIN_1 << 16;  // 핀 리셋
        }
        toggle = !toggle;
        
        // 플래그 클리어 (하드웨어 자동처리)
        TIMER1->SR = 0;
    }
};
```

### 실시간 스케줄링 최적화
```cpp
// 지터 최소화를 위한 스케줄링 기법
class JitterMinimizedScheduler {
private:
    struct PeriodicTask {
        void (*function)();
        unsigned long period_us;
        unsigned long next_execution;
        int priority;
        bool jitter_sensitive;
    };
    
    PeriodicTask tasks[MAX_TASKS];
    int task_count = 0;
    
public:
    void addTask(void (*func)(), unsigned long period, 
                int priority, bool jitter_sensitive = false) {
        if(task_count < MAX_TASKS) {
            tasks[task_count] = {func, period, micros() + period, 
                               priority, jitter_sensitive};
            task_count++;
            
            // 우선순위별 정렬
            sortTasksByPriority();
        }
    }
    
    void executeTasks() {
        unsigned long current_time = micros();
        
        // 지터 민감 작업 우선 처리
        for(int i = 0; i < task_count; i++) {
            if(tasks[i].jitter_sensitive && 
               current_time >= tasks[i].next_execution) {
                
                // 정확한 타이밍에 실행
                while(micros() < tasks[i].next_execution) {
                    // 능동 대기 (스핀락)
                    __NOP();
                }
                
                tasks[i].function();
                tasks[i].next_execution += tasks[i].period_us;
            }
        }
        
        // 일반 작업들 처리
        for(int i = 0; i < task_count; i++) {
            if(!tasks[i].jitter_sensitive && 
               current_time >= tasks[i].next_execution) {
                
                tasks[i].function();
                tasks[i].next_execution += tasks[i].period_us;
            }
        }
    }
    
private:
    void sortTasksByPriority() {
        // 버블 정렬 (작은 배열용)
        for(int i = 0; i < task_count - 1; i++) {
            for(int j = 0; j < task_count - i - 1; j++) {
                if(tasks[j].priority > tasks[j + 1].priority) {
                    PeriodicTask temp = tasks[j];
                    tasks[j] = tasks[j + 1];
                    tasks[j + 1] = temp;
                }
            }
        }
    }
};
```

## 🔧 지터 보상 기법

### 적응적 지터 보상
```cpp
// 실시간 지터 보상 알고리즘
class AdaptiveJitterCompensator {
private:
    float jitter_history[16];
    int history_index = 0;
    float predicted_jitter = 0;
    
public:
    void recordJitter(float measured_jitter) {
        jitter_history[history_index] = measured_jitter;
        history_index = (history_index + 1) % 16;
        
        // 지터 예측 (이동평균)
        updateJitterPrediction();
    }
    
    unsigned long compensateNextExecution(unsigned long nominal_time) {
        // 예측된 지터를 고려한 시간 조정
        return nominal_time - (unsigned long)(predicted_jitter * 0.7);
    }
    
private:
    void updateJitterPrediction() {
        float sum = 0;
        for(int i = 0; i < 16; i++) {
            sum += jitter_history[i];
        }
        predicted_jitter = sum / 16.0;
    }
};

// 폴링 기반 지터 감소
class PollingJitterReduction {
private:
    unsigned long target_period_us;
    unsigned long last_execution;
    
public:
    PollingJitterReduction(unsigned long period) : target_period_us(period) {
        last_execution = micros();
    }
    
    void waitForNextPeriod() {
        unsigned long target_time = last_execution + target_period_us;
        
        // 능동 대기로 정확한 타이밍 보장
        while(micros() < target_time) {
            // CPU 사용률 증가하지만 지터 최소화
            __NOP();
        }
        
        last_execution = target_time;
    }
    
    // 지터 측정과 함께 실행
    void executeWithJitterMeasurement(void (*task)()) {
        unsigned long actual_start = micros();
        float jitter = (float)((long)(actual_start - last_execution - target_period_us));
        
        task();
        
        Serial.printf("Execution jitter: %.2f μs\n", jitter);
        last_execution = actual_start;
    }
};
```

---

## 🔗 연결 문서
- 상위: [[실시간제어]]
- 관련: [[데드라인]], [[레이턴시]], [[처리량]]
- 하드웨어: [[마이크로컨트롤러]], [[ADC]], [[인터럽트처리]]
- 측정: [[센서인터페이스]], [[신호조절]]

## 📚 참고문헌
- [NIST (2001). "Real-Time Operating System Timing Jitter and its Impact on Motor Control"](https://www.nist.gov/publications/real-time-operating-system-timing-jitter-and-its-impact-motor-control-0)
- [NI (2024). "Determinism and Jitter in a Real-Time System"](https://www.ni.com/docs/en-US/bundle/labview-nxg-rt-module-programming-with-rt-target/page/determinism-real-time.html)
- [SiTime (2024). "Jitter 101: What you need to know"](https://www.sitime.com/company/newsroom/blog/jitter-101-what-you-need-know)
- [IEEE (1995). "Jitter compensation for real-time control systems"](https://ieeexplore.ieee.org/abstract/document/990594/)
