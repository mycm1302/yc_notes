# 목적함수

> 상위: [[최적화설계]]

최적화 문제에서 최대화하거나 최소화하고자 하는 성능 지표를 수학적으로 표현한 함수입니다. 쉽게 말해 "무엇을 가장 좋게 만들고 싶은가?"를 수식으로 나타낸 것입니다.

## 🎯 기본 개념

### 목적함수란 무엇인가?

**일상적 비유:**
음식점을 운영한다고 생각해보세요.
- **최대화 목표**: 이익, 고객 만족도, 브랜드 가치
- **최소화 목표**: 비용, 대기시간, 식재료 낭비

**공학적 예시:**
```
자동차 설계:
- 최대화: 연비, 안전성, 성능
- 최소화: 중량, 비용, 배기가스

로봇 설계:
- 최대화: 정밀도, 작업공간, 속도
- 최소화: 에너지 소비, 진동, 가격
```

### 수학적 정의

**일반형:**
```
최적화 문제: min/max f(x)
여기서:
- f(x): 목적함수
- x = [x₁, x₂, ..., xₙ]ᵀ: 설계변수 벡터
```

**다목적 형태:**
```
최적화 문제: min/max F(x) = [f₁(x), f₂(x), ..., fₘ(x)]ᵀ
```

### 목적함수의 특성

**연속성 (Continuity):**
```matlab
% 연속 함수: 작은 변화 → 작은 결과 변화
f_continuous = @(x) x^2 + 2*x + 1;

% 불연속 함수: 작은 변화 → 급격한 결과 변화
f_discontinuous = @(x) floor(x);  % 계단 함수
```

**미분가능성 (Differentiability):**
```matlab
% 미분가능: 그래디언트 기반 최적화 가능
f_smooth = @(x) x^2;

% 미분불가능: 특수 알고리즘 필요
f_nonsmooth = @(x) abs(x);  % x=0에서 미분불가
```

**볼록성 (Convexity):**
```matlab
% 볼록함수: 전역 최적해 보장
f_convex = @(x) x(1)^2 + x(2)^2;

% 비볼록함수: 국소 최적해 위험
f_nonconvex = @(x) x(1)^4 - 2*x(1)^2 + x(2)^2;
```

---

## 📊 목적함수 유형

### 1. 성능 기반 목적함수

#### 질량 최소화 (Weight Minimization)
**가장 일반적인 구조 최적화 목표**

**수식:**
```
질량 = ∫ ρ(x) dV = ∑ ρᵢ Aᵢ Lᵢ
```

**구현 예시:**
```matlab
function mass = calculate_mass(areas, lengths, density)
    % 입력:
    %   areas: 각 부재의 단면적 벡터 [m²]
    %   lengths: 각 부재의 길이 벡터 [m]
    %   density: 재료 밀도 [kg/m³]
    
    mass = sum(density * areas .* lengths);
end

% 사용 예
areas = [0.001, 0.0015, 0.002];     % m²
lengths = [1.0, 1.5, 2.0];         % m
rho_steel = 7850;                   % kg/m³

total_mass = calculate_mass(areas, lengths, rho_steel);
```

#### 강성 최대화 (Stiffness Maximization)
**컴플라이언스 최소화와 동일**

**수식:**
```
컴플라이언스 c = uᵀF = uᵀKu
강성 최대화 ≡ 컴플라이언스 최소화
```

**물리적 의미:**
- 컴플라이언스 ↓ = 같은 힘에 대해 변형 ↓
- 구조물이 더 단단함을 의미

**구현:**
```matlab
function compliance = calculate_compliance(K, F)
    % 입력:
    %   K: 전역 강성행렬
    %   F: 하중 벡터
    
    % 변위 계산: Ku = F
    u = K \ F;
    
    % 컴플라이언스: c = u^T * F
    compliance = u' * F;
end
```

#### 고유진동수 최적화
**동적 성능 개선**

**1차 고유진동수 최대화:**
```matlab
function [freq, mode] = first_natural_frequency(K, M)
    % 일반 고유값 문제: K*phi = lambda*M*phi
    [eigenvectors, eigenvalues] = eig(K, M);
    
    % 고유진동수 계산 [Hz]
    frequencies = sqrt(diag(eigenvalues)) / (2*pi);
    
    % 1차 고유진동수와 모드형상
    [freq, idx] = min(frequencies);
    mode = eigenvectors(:, idx);
end
```

**특정 진동수 범위 회피:**
```matlab
function penalty = frequency_constraint(freq, avoid_range)
    % 회피해야 할 진동수 범위 [Hz]
    f_min = avoid_range(1);
    f_max = avoid_range(2);
    
    if freq >= f_min && freq <= f_max
        % 금지 범위 내: 큰 페널티
        penalty = 1000 * (1 - abs(freq - (f_min+f_max)/2) / ((f_max-f_min)/2));
    else
        % 금지 범위 외: 페널티 없음
        penalty = 0;
    end
end
```

### 2. 경제성 기반 목적함수

#### 제조비용 최소화

**재료비 + 가공비 + 조립비:**
```matlab
function total_cost = manufacturing_cost(design_vars)
    % 설계변수에서 형상 정보 추출
    volume = calculate_volume(design_vars);
    surface_area = calculate_surface_area(design_vars);
    complexity = calculate_complexity(design_vars);
    
    % 비용 구성요소
    material_cost = volume * material_cost_per_volume;
    machining_cost = surface_area * machining_cost_per_area;
    complexity_cost = complexity * complexity_penalty;
    
    total_cost = material_cost + machining_cost + complexity_cost;
end
```

**가공 시간 기반 비용:**
```matlab
function machining_time = estimate_machining_time(features)
    % 가공 특징별 시간 추정
    drilling_time = features.num_holes * 0.5;      % 0.5분/구멍
    milling_time = features.pocket_volume * 2.0;   % 2분/cm³
    turning_time = features.turned_length * 0.1;   % 0.1분/mm
    
    machining_time = drilling_time + milling_time + turning_time;
end
```

#### 생명주기비용 (Life Cycle Cost)

**초기비용 + 운영비용 + 폐기비용:**
```matlab
function lcc = life_cycle_cost(design, service_life)
    % 초기 투자비
    initial_cost = design.material_cost + design.manufacturing_cost;
    
    % 연간 운영비 (에너지, 유지보수)
    annual_operating_cost = design.energy_cost + design.maintenance_cost;
    
    % 현재가치로 할인
    discount_rate = 0.05;  % 5%
    pv_operating = 0;
    for year = 1:service_life
        pv_operating = pv_operating + annual_operating_cost / (1 + discount_rate)^year;
    end
    
    % 폐기비용 (현재가치)
    disposal_cost = design.disposal_cost / (1 + discount_rate)^service_life;
    
    lcc = initial_cost + pv_operating + disposal_cost;
end
```

### 3. 신뢰성 기반 목적함수

#### 파손확률 최소화

**응력 기반 신뢰성:**
```matlab
function prob_failure = stress_reliability(stress_mean, stress_std, material_strength)
    % 응력의 평균과 표준편차
    % 재료 강도 (결정적 값)
    
    % 안전여유의 평균과 표준편차
    safety_margin_mean = material_strength - stress_mean;
    safety_margin_std = stress_std;  % 재료강도는 결정적이라 가정
    
    % 표준화
    z = safety_margin_mean / safety_margin_std;
    
    % 파손확률 (정규분포 가정)
    prob_failure = 0.5 * (1 - erf(z / sqrt(2)));
end
```

#### 피로수명 최대화

**S-N 곡선 기반:**
```matlab
function fatigue_life = estimate_fatigue_life(stress_amplitude, material_params)
    % S-N 곡선: N = A * (S)^(-m)
    A = material_params.fatigue_strength_coefficient;
    m = material_params.fatigue_strength_exponent;
    
    % 피로수명 [cycles]
    fatigue_life = A * (stress_amplitude)^(-m);
    
    % 무한수명 체크
    endurance_limit = material_params.endurance_limit;
    if stress_amplitude < endurance_limit
        fatigue_life = Inf;
    end
end
```
---

## 🔧 함수 구성 방법

### 직접 정의 (Direct Definition)

**단일 성능 지표:**
```matlab
% 캔틸레버 보의 최대 처짐 최소화
function deflection = cantilever_deflection(width, height, length, load, E)
    % 2차 관성모멘트
    I = width * height^3 / 12;
    
    % 최대 처짐 (자유단)
    deflection = load * length^3 / (3 * E * I);
end

% 목적함수 정의
objective = @(x) cantilever_deflection(x(1), x(2), 1000, 1000, 200e9);
```

**명확한 물리적 의미:**
- 해석해 존재 시 활용
- 계산 속도 빠름
- 검증 용이

### 복합 함수 (Composite Function)

#### 가중합 형태
```matlab
function f_combined = weighted_combination(x)
    % 개별 목적함수 계산
    mass = calculate_mass(x);
    stress = calculate_max_stress(x);
    cost = calculate_cost(x);
    
    % 정규화 (기준값 대비)
    mass_norm = mass / mass_reference;
    stress_norm = stress / stress_limit;
    cost_norm = cost / cost_budget;
    
    % 가중합
    w1 = 0.4; w2 = 0.3; w3 = 0.3;
    f_combined = w1*mass_norm + w2*stress_norm + w3*cost_norm;
end
```

#### 곱셈 형태 (Product Form)
```matlab
function f_product = product_form(x)
    efficiency = calculate_efficiency(x);     % 최대화 목표
    reliability = calculate_reliability(x);   % 최대화 목표
    cost = calculate_cost(x);                % 최소화 목표
    
    % 곱셈 형태 (모든 항목을 최대화 문제로 변환)
    f_product = efficiency * reliability / cost;
end
```

### 정규화 목적함수

#### Z-Score 정규화
```matlab
function f_normalized = z_score_normalization(objectives, weights)
    % 목적함수 평균과 표준편차 계산 (과거 설계 데이터 기반)
    obj_mean = mean(objectives, 2);
    obj_std = std(objectives, 0, 2);
    
    % Z-score 정규화
    z_scores = (objectives - obj_mean) ./ obj_std;
    
    % 가중합
    f_normalized = weights' * z_scores;
end
```

#### Min-Max 정규화
```matlab
function f_scaled = minmax_scaling(objectives, obj_min, obj_max, weights)
    % [0,1] 범위로 스케일링
    scaled = (objectives - obj_min) ./ (obj_max - obj_min);
    
    % 가중합
    f_scaled = weights' * scaled;
end
```

---

## 📈 설계 분야별 적용

### 구조 최적화

#### 트러스 구조 설계
```matlab
function [mass, stress_ratio] = truss_objectives(areas, truss_data)
    % 입력:
    %   areas: 각 부재 단면적 [m²]
    %   truss_data: 노드좌표, 연결정보, 하중, 재료특성
    
    % 강성행렬 조립
    K = assemble_stiffness_matrix(areas, truss_data);
    
    % 변위 계산
    u = K \ truss_data.loads;
    
    % 부재력 계산
    member_forces = calculate_member_forces(u, areas, truss_data);
    
    % 목적함수 1: 질량
    lengths = truss_data.member_lengths;
    density = truss_data.material.density;
    mass = sum(density * areas .* lengths);
    
    % 목적함수 2: 최대 응력비
    stresses = abs(member_forces ./ areas);
    allowable_stress = truss_data.material.yield_strength / truss_data.safety_factor;
    stress_ratio = max(stresses / allowable_stress);
end

% 최적화 문제 정의
objective = @(A) truss_objectives(A, truss_data);
```

#### 연속체 구조 (토폴로지 최적화)
```matlab
function compliance = topology_objective(density_vector, fem_data)
    % 밀도 분포를 강성행렬에 반영
    K_modified = apply_simp_model(density_vector, fem_data.K_elements);
    
    % 전역 강성행렬 조립
    K_global = assemble_global_matrix(K_modified, fem_data.connectivity);
    
    % 컴플라이언스 계산
    u = K_global \ fem_data.loads;
    compliance = fem_data.loads' * u;
end
```

### 유체역학 최적화

#### 익형 설계 (항력 최소화)
```matlab
function [drag, lift] = airfoil_performance(control_points, flow_conditions)
    % 제어점으로부터 익형 형상 생성
    airfoil_coords = generate_airfoil_from_cst(control_points);
    
    % CFD 해석 또는 패널법
    [pressure_dist, velocity_dist] = panel_method(airfoil_coords, flow_conditions);
    
    % 힘 계산
    [drag, lift] = integrate_forces(pressure_dist, airfoil_coords);
end

% 다목적 최적화 (항력 최소화, 양력 최대화)
objectives = @(x) airfoil_performance(x, flow_conditions);
```

#### 덕트 설계 (압력손실 최소화)
```matlab
function pressure_loss = duct_optimization(duct_geometry, flow_rate)
    % 형상 파라미터로부터 덕트 메시 생성
    mesh = generate_duct_mesh(duct_geometry);
    
    % CFD 해석
    [pressure_field, velocity_field] = solve_navier_stokes(mesh, flow_rate);
    
    % 압력손실 계산
    pressure_in = mean(pressure_field(mesh.inlet_nodes));
    pressure_out = mean(pressure_field(mesh.outlet_nodes));
    pressure_loss = pressure_in - pressure_out;
end
```

### 제어 시스템 최적화

#### PID 제어기 튜닝
```matlab
function [ise, overshoot, settling_time] = pid_performance(pid_gains, plant_model)
    % PID 제어기 구성
    Kp = pid_gains(1);
    Ki = pid_gains(2);
    Kd = pid_gains(3);
    
    controller = pid(Kp, Ki, Kd);
    
    % 폐루프 시스템
    closed_loop = feedback(controller * plant_model, 1);
    
    % 단위계단응답
    [y, t] = step(closed_loop);
    
    % 성능지표 계산
    error = 1 - y;
    ise = trapz(t, error.^2);  % Integral Squared Error
    
    step_info = stepinfo(closed_loop);
    overshoot = step_info.Overshoot;
    settling_time = step_info.SettlingTime;
end

% 다목적 최적화
objective = @(gains) pid_performance(gains, plant);
```

---

## ⚙️ 구현 고려사항

### 수치적 안정성

#### 스케일링 (Scaling)
```matlab
function f_scaled = scale_objective(f_original, scale_factor)
    % 목적함수 값의 크기 조정
    f_scaled = f_original / scale_factor;
end

% 예시: 질량(kg)과 응력(Pa)을 같은 스케일로
mass_kg = 100;
stress_pa = 100e6;

mass_scaled = mass_kg / 1000;        % ton 단위
stress_scaled = stress_pa / 1e6;     % MPa 단위
```

#### 조건수 개선
```matlab
function f_conditioned = improve_conditioning(x)
    % 원래 목적함수
    f_original = expensive_analysis(x);
    
    % 로그 스케일링 (큰 값의 영향 완화)
    f_conditioned = log(1 + f_original);
end
```

### 계산 효율성

#### 근사 모델 (Surrogate Model)
```matlab
% 크리깅 모델 구축
function kriging_model = build_surrogate(sample_points, sample_values)
    % 실험계획법으로 얻은 샘플 데이터
    % 크리깅 모델 훈련
    kriging_model = fitrgp(sample_points, sample_values);
end

% 근사 목적함수
function f_approx = surrogate_objective(x, kriging_model)
    f_approx = predict(kriging_model, x);
end
```

#### 적응적 평가
```matlab
function f = adaptive_evaluation(x, tolerance)
    % 이전 평가 결과와 비교
    if is_close_to_previous(x, tolerance)
        % 보간으로 추정
        f = interpolate_from_history(x);
    else
        % 정확한 계산
        f = exact_evaluation(x);
        % 히스토리에 저장
        save_to_history(x, f);
    end
end
```

### 다중 목표 처리

#### 스칼라화 방법
```matlab
function f_scalar = scalarization(f_vector, method, parameters)
    switch method
        case 'weighted_sum'
            weights = parameters.weights;
            f_scalar = weights' * f_vector;
            
        case 'epsilon_constraint'
            primary_obj = f_vector(1);
            constraints = f_vector(2:end) - parameters.epsilon;
            if all(constraints <= 0)
                f_scalar = primary_obj;
            else
                f_scalar = Inf;  % 제약 위반
            end
            
        case 'compromise_programming'
            ideal_point = parameters.ideal;
            p_norm = parameters.p;
            f_scalar = norm(f_vector - ideal_point, p_norm);
    end
end
```

#### 파레토 프론트 근사
```matlab
function pareto_front = approximate_pareto_front(f_matrix)
    % f_matrix: 각 행이 하나의 해, 각 열이 하나의 목적함수
    
    n_solutions = size(f_matrix, 1);
    is_dominated = false(n_solutions, 1);
    
    for i = 1:n_solutions
        for j = 1:n_solutions
            if i ~= j && dominates(f_matrix(j,:), f_matrix(i,:))
                is_dominated(i) = true;
                break;
            end
        end
    end
    
    pareto_front = f_matrix(~is_dominated, :);
end

function result = dominates(a, b)
    % a가 b를 지배하는가? (최소화 문제)
    result = all(a <= b) && any(a < b);
end
```

---

## 💻 프로그래밍 구현

### MATLAB 목적함수 클래스

```matlab
classdef ObjectiveFunction < handle
    properties
        name            % 함수 이름
        type            % 'minimize' or 'maximize'
        scale_factor    % 스케일링 계수
        evaluation_count % 평가 횟수
        history         % 평가 히스토리
    end
    
    methods
        function obj = ObjectiveFunction(name, type, scale_factor)
            obj.name = name;
            obj.type = type;
            obj.scale_factor = scale_factor;
            obj.evaluation_count = 0;
            obj.history = [];
        end
        
        function f = evaluate(obj, x, varargin)
            % 실제 목적함수 계산
            f_raw = obj.compute_raw_value(x, varargin{:});
            
            % 스케일링 적용
            f = f_raw / obj.scale_factor;
            
            % 최대화 문제를 최소화로 변환
            if strcmp(obj.type, 'maximize')
                f = -f;
            end
            
            % 히스토리 저장
            obj.evaluation_count = obj.evaluation_count + 1;
            obj.history(end+1,:) = [x(:)', f];
        end
        
        function f = compute_raw_value(obj, x, varargin)
            % 실제 계산 (하위 클래스에서 구현)
            error('Subclass must implement compute_raw_value method');
        end
        
        function plot_history(obj)
            if size(obj.history, 1) < 2
                warning('Insufficient data for plotting');
                return;
            end
            
            figure;
            plot(1:obj.evaluation_count, obj.history(:,end), 'b-o');
            xlabel('Evaluation Number');
            ylabel(['Objective Value: ' obj.name]);
            title('Optimization History');
            grid on;
        end
    end
end

% 구체적인 목적함수 구현 예시
classdef MassObjective < ObjectiveFunction
    properties
        material_density
        element_data
    end
    
    methods
        function obj = MassObjective(density, elements)
            obj@ObjectiveFunction('Mass', 'minimize', 1000); % kg 단위
            obj.material_density = density;
            obj.element_data = elements;
        end
        
        function f = compute_raw_value(obj, areas)
            % areas: 각 요소의 단면적
            volumes = areas .* obj.element_data.lengths;
            f = obj.material_density * sum(volumes);
        end
    end
end
```

### Python 구현 (객체지향)

```python
import numpy as np
import matplotlib.pyplot as plt
from abc import ABC, abstractmethod

class ObjectiveFunction(ABC):
    def __init__(self, name, objective_type='minimize', scale_factor=1.0):
        self.name = name
        self.type = objective_type
        self.scale_factor = scale_factor
        self.evaluation_count = 0
        self.history = []
    
    def evaluate(self, x, *args, **kwargs):
        """목적함수 평가"""
        # 원시값 계산
        f_raw = self.compute_raw_value(x, *args, **kwargs)
        
        # 스케일링
        f = f_raw / self.scale_factor
        
        # 최대화를 최소화로 변환
        if self.type == 'maximize':
            f = -f
        
        # 히스토리 저장
        self.evaluation_count += 1
        self.history.append((x.copy(), f))
        
        return f
    
    @abstractmethod
    def compute_raw_value(self, x, *args, **kwargs):
        """실제 목적함수 계산 (하위 클래스에서 구현)"""
        pass
    
    def plot_history(self):
        """최적화 히스토리 플롯"""
        if len(self.history) < 2:
            print("Not enough data for plotting")
            return
        
        values = [item[1] for item in self.history]
        plt.figure(figsize=(10, 6))
        plt.plot(range(1, len(values)+1), values, 'b-o')
        plt.xlabel('Evaluation Number')
        plt.ylabel(f'Objective Value: {self.name}')
        plt.title('Optimization History')
        plt.grid(True)
        plt.show()

# 구체적인 구현 예시
class TrussWeight(ObjectiveFunction):
    def __init__(self, lengths, density=7850):
        super().__init__('Truss Weight', 'minimize', 1000)  # kg 단위
        self.lengths = np.array(lengths)
        self.density = density
    
    def compute_raw_value(self, areas):
        """트러스 질량 계산"""
        volumes = areas * self.lengths
        weight = self.density * np.sum(volumes)
        return weight

class ComplianceObjective(ObjectiveFunction):
    def __init__(self, stiffness_matrix, load_vector):
        super().__init__('Compliance', 'minimize', 1e-6)  # μm 단위
        self.K0 = stiffness_matrix
        self.F = load_vector
    
    def compute_raw_value(self, areas):
        """컴플라이언스 계산"""
        # 수정된 강성행렬 (단순화된 예시)
        K = self.K0 * np.mean(areas)
        
        # 변위 계산
        u = np.linalg.solve(K, self.F)
        
        # 컴플라이언스
        compliance = np.dot(self.F, u)
        return compliance

# 다목적 목적함수 클래스
class MultiObjectiveFunction:
    def __init__(self, objective_functions):
        self.objectives = objective_functions
        self.evaluation_count = 0
    
    def evaluate(self, x):
        """모든 목적함수 동시 평가"""
        f_vector = []
        for obj_func in self.objectives:
            f_i = obj_func.evaluate(x)
            f_vector.append(f_i)
        
        self.evaluation_count += 1
        return np.array(f_vector)
    
    def get_names(self):
        return [obj.name for obj in self.objectives]
```

---

## 🎓 학습 단계별 가이드

### 초급 (1-2개월)

**1주차: 단일 목적함수**
```matlab
% 간단한 수학함수로 시작
f1 = @(x) x^2 + 2*x + 1;              % 볼록함수
f2 = @(x) x^4 - 2*x^2 + 1;            % 비볼록함수  
f3 = @(x) abs(x);                     % 미분불가능

% 플롯으로 특성 관찰
x = -3:0.1:3;
subplot(1,3,1); plot(x, f1(x)); title('Convex');
subplot(1,3,2); plot(x, f2(x)); title('Non-convex');
subplot(1,3,3); plot(x, f3(x)); title('Non-smooth');
```

**2주차: 공학적 목적함수**
```matlab
% 캔틸레버 보 최적화
function deflection = beam_deflection(x)
    width = x(1);   % 10-100 mm
    height = x(2);  % 5-50 mm
    
    L = 1000;       % 길이 [mm]
    P = 1000;       % 하중 [N]  
    E = 200e9;      % 탄성계수 [Pa]
    
    I = width * height^3 / 12;  % 관성모멘트 [mm⁴]
    deflection = P * L^3 / (3 * E * I * 1e-12);  % [mm]
end

% 최적화 실행
x0 = [50, 25];
[x_opt, f_opt] = fminunc(@beam_deflection, x0);
```

### 중급 (3-4개월)

**3-4주차: 복합 목적함수**
```matlab
% 질량과 처짐을 동시 고려
function f_combined = beam_multiobjective(x, weights)
    % 개별 목적함수
    mass = beam_mass(x);
    deflection = beam_deflection(x);
    
    % 정규화 (기준값 대비)
    mass_norm = mass / 1.0;           % 1kg 기준
    deflection_norm = deflection / 1.0; % 1mm 기준
    
    % 가중합
    f_combined = weights(1)*mass_norm + weights(2)*deflection_norm;
end
```

**5-8주차: 확률적 목적함수**
```matlab
% 불확실성을 고려한 강건설계
function [f_mean, f_std] = robust_objective(x_nominal, uncertainty)
    n_samples = 1000;
    f_samples = zeros(n_samples, 1);
    
    for i = 1:n_samples
        % 불확실성 샘플링
        x_sample = x_nominal + uncertainty.std .* randn(size(x_nominal));
        
        % 목적함수 평가
        f_samples(i) = expensive_analysis(x_sample);
    end
    
    f_mean = mean(f_samples);
    f_std = std(f_samples);
end
```

### 고급 (6개월+)

**9-12주차: 대규모 문제**
- 위상최적화 목적함수
- 다분야 연성 문제
- 실시간 최적화

**13-16주차: 실무 프로젝트**
- 실제 산업 문제
- 상용 소프트웨어 연동
- 성능 최적화

---

**참고문헌:**
- Arora, J.S. (2016). *Introduction to Optimum Design*. Academic Press.
- Rao, S.S. (2019). *Engineering Optimization: Theory and Practice*. Wiley.
- Vanderplaats, G.N. (2007). *Multidiscipline Design Optimization*. Vanderplaats R&D.
- Martins, J.R.R.A. & Ning, A. (2021). *Engineering Design Optimization*. Cambridge University Press.