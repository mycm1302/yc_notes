# ëª©ì í•¨ìˆ˜

> ìƒìœ„: [[ìµœì í™”ì„¤ê³„]]

ìµœì í™” ë¬¸ì œì—ì„œ ìµœëŒ€í™”í•˜ê±°ë‚˜ ìµœì†Œí™”í•˜ê³ ìž í•˜ëŠ” ì„±ëŠ¥ ì§€í‘œë¥¼ ìˆ˜í•™ì ìœ¼ë¡œ í‘œí˜„í•œ í•¨ìˆ˜ìž…ë‹ˆë‹¤. ì‰½ê²Œ ë§í•´ "ë¬´ì—‡ì„ ê°€ìž¥ ì¢‹ê²Œ ë§Œë“¤ê³  ì‹¶ì€ê°€?"ë¥¼ ìˆ˜ì‹ìœ¼ë¡œ ë‚˜íƒ€ë‚¸ ê²ƒìž…ë‹ˆë‹¤.

## ðŸŽ¯ ê¸°ë³¸ ê°œë…

### ëª©ì í•¨ìˆ˜ëž€ ë¬´ì—‡ì¸ê°€?

**ì¼ìƒì  ë¹„ìœ :**
ìŒì‹ì ì„ ìš´ì˜í•œë‹¤ê³  ìƒê°í•´ë³´ì„¸ìš”.
- **ìµœëŒ€í™” ëª©í‘œ**: ì´ìµ, ê³ ê° ë§Œì¡±ë„, ë¸Œëžœë“œ ê°€ì¹˜
- **ìµœì†Œí™” ëª©í‘œ**: ë¹„ìš©, ëŒ€ê¸°ì‹œê°„, ì‹ìž¬ë£Œ ë‚­ë¹„

**ê³µí•™ì  ì˜ˆì‹œ:**
```
ìžë™ì°¨ ì„¤ê³„:
- ìµœëŒ€í™”: ì—°ë¹„, ì•ˆì „ì„±, ì„±ëŠ¥
- ìµœì†Œí™”: ì¤‘ëŸ‰, ë¹„ìš©, ë°°ê¸°ê°€ìŠ¤

ë¡œë´‡ ì„¤ê³„:
- ìµœëŒ€í™”: ì •ë°€ë„, ìž‘ì—…ê³µê°„, ì†ë„
- ìµœì†Œí™”: ì—ë„ˆì§€ ì†Œë¹„, ì§„ë™, ê°€ê²©
```

### ìˆ˜í•™ì  ì •ì˜

**ì¼ë°˜í˜•:**
```
ìµœì í™” ë¬¸ì œ: min/max f(x)
ì—¬ê¸°ì„œ:
- f(x): ëª©ì í•¨ìˆ˜
- x = [xâ‚, xâ‚‚, ..., xâ‚™]áµ€: ì„¤ê³„ë³€ìˆ˜ ë²¡í„°
```

**ë‹¤ëª©ì  í˜•íƒœ:**
```
ìµœì í™” ë¬¸ì œ: min/max F(x) = [fâ‚(x), fâ‚‚(x), ..., fâ‚˜(x)]áµ€
```

### ëª©ì í•¨ìˆ˜ì˜ íŠ¹ì„±

**ì—°ì†ì„± (Continuity):**
```matlab
% ì—°ì† í•¨ìˆ˜: ìž‘ì€ ë³€í™” â†’ ìž‘ì€ ê²°ê³¼ ë³€í™”
f_continuous = @(x) x^2 + 2*x + 1;

% ë¶ˆì—°ì† í•¨ìˆ˜: ìž‘ì€ ë³€í™” â†’ ê¸‰ê²©í•œ ê²°ê³¼ ë³€í™”
f_discontinuous = @(x) floor(x);  % ê³„ë‹¨ í•¨ìˆ˜
```

**ë¯¸ë¶„ê°€ëŠ¥ì„± (Differentiability):**
```matlab
% ë¯¸ë¶„ê°€ëŠ¥: ê·¸ëž˜ë””ì–¸íŠ¸ ê¸°ë°˜ ìµœì í™” ê°€ëŠ¥
f_smooth = @(x) x^2;

% ë¯¸ë¶„ë¶ˆê°€ëŠ¥: íŠ¹ìˆ˜ ì•Œê³ ë¦¬ì¦˜ í•„ìš”
f_nonsmooth = @(x) abs(x);  % x=0ì—ì„œ ë¯¸ë¶„ë¶ˆê°€
```

**ë³¼ë¡ì„± (Convexity):**
```matlab
% ë³¼ë¡í•¨ìˆ˜: ì „ì—­ ìµœì í•´ ë³´ìž¥
f_convex = @(x) x(1)^2 + x(2)^2;

% ë¹„ë³¼ë¡í•¨ìˆ˜: êµ­ì†Œ ìµœì í•´ ìœ„í—˜
f_nonconvex = @(x) x(1)^4 - 2*x(1)^2 + x(2)^2;
```

---

## ðŸ“Š ëª©ì í•¨ìˆ˜ ìœ í˜•

### 1. ì„±ëŠ¥ ê¸°ë°˜ ëª©ì í•¨ìˆ˜

#### ì§ˆëŸ‰ ìµœì†Œí™” (Weight Minimization)
**ê°€ìž¥ ì¼ë°˜ì ì¸ êµ¬ì¡° ìµœì í™” ëª©í‘œ**

**ìˆ˜ì‹:**
```
ì§ˆëŸ‰ = âˆ« Ï(x) dV = âˆ‘ Ïáµ¢ Aáµ¢ Láµ¢
```

**êµ¬í˜„ ì˜ˆì‹œ:**
```matlab
function mass = calculate_mass(areas, lengths, density)
    % ìž…ë ¥:
    %   areas: ê° ë¶€ìž¬ì˜ ë‹¨ë©´ì  ë²¡í„° [mÂ²]
    %   lengths: ê° ë¶€ìž¬ì˜ ê¸¸ì´ ë²¡í„° [m]
    %   density: ìž¬ë£Œ ë°€ë„ [kg/mÂ³]
    
    mass = sum(density * areas .* lengths);
end

% ì‚¬ìš© ì˜ˆ
areas = [0.001, 0.0015, 0.002];     % mÂ²
lengths = [1.0, 1.5, 2.0];         % m
rho_steel = 7850;                   % kg/mÂ³

total_mass = calculate_mass(areas, lengths, rho_steel);
```

#### ê°•ì„± ìµœëŒ€í™” (Stiffness Maximization)
**ì»´í”Œë¼ì´ì–¸ìŠ¤ ìµœì†Œí™”ì™€ ë™ì¼**

**ìˆ˜ì‹:**
```
ì»´í”Œë¼ì´ì–¸ìŠ¤ c = uáµ€F = uáµ€Ku
ê°•ì„± ìµœëŒ€í™” â‰¡ ì»´í”Œë¼ì´ì–¸ìŠ¤ ìµœì†Œí™”
```

**ë¬¼ë¦¬ì  ì˜ë¯¸:**
- ì»´í”Œë¼ì´ì–¸ìŠ¤ â†“ = ê°™ì€ íž˜ì— ëŒ€í•´ ë³€í˜• â†“
- êµ¬ì¡°ë¬¼ì´ ë” ë‹¨ë‹¨í•¨ì„ ì˜ë¯¸

**êµ¬í˜„:**
```matlab
function compliance = calculate_compliance(K, F)
    % ìž…ë ¥:
    %   K: ì „ì—­ ê°•ì„±í–‰ë ¬
    %   F: í•˜ì¤‘ ë²¡í„°
    
    % ë³€ìœ„ ê³„ì‚°: Ku = F
    u = K \ F;
    
    % ì»´í”Œë¼ì´ì–¸ìŠ¤: c = u^T * F
    compliance = u' * F;
end
```

#### ê³ ìœ ì§„ë™ìˆ˜ ìµœì í™”
**ë™ì  ì„±ëŠ¥ ê°œì„ **

**1ì°¨ ê³ ìœ ì§„ë™ìˆ˜ ìµœëŒ€í™”:**
```matlab
function [freq, mode] = first_natural_frequency(K, M)
    % ì¼ë°˜ ê³ ìœ ê°’ ë¬¸ì œ: K*phi = lambda*M*phi
    [eigenvectors, eigenvalues] = eig(K, M);
    
    % ê³ ìœ ì§„ë™ìˆ˜ ê³„ì‚° [Hz]
    frequencies = sqrt(diag(eigenvalues)) / (2*pi);
    
    % 1ì°¨ ê³ ìœ ì§„ë™ìˆ˜ì™€ ëª¨ë“œí˜•ìƒ
    [freq, idx] = min(frequencies);
    mode = eigenvectors(:, idx);
end
```

**íŠ¹ì • ì§„ë™ìˆ˜ ë²”ìœ„ íšŒí”¼:**
```matlab
function penalty = frequency_constraint(freq, avoid_range)
    % íšŒí”¼í•´ì•¼ í•  ì§„ë™ìˆ˜ ë²”ìœ„ [Hz]
    f_min = avoid_range(1);
    f_max = avoid_range(2);
    
    if freq >= f_min && freq <= f_max
        % ê¸ˆì§€ ë²”ìœ„ ë‚´: í° íŽ˜ë„í‹°
        penalty = 1000 * (1 - abs(freq - (f_min+f_max)/2) / ((f_max-f_min)/2));
    else
        % ê¸ˆì§€ ë²”ìœ„ ì™¸: íŽ˜ë„í‹° ì—†ìŒ
        penalty = 0;
    end
end
```

### 2. ê²½ì œì„± ê¸°ë°˜ ëª©ì í•¨ìˆ˜

#### ì œì¡°ë¹„ìš© ìµœì†Œí™”

**ìž¬ë£Œë¹„ + ê°€ê³µë¹„ + ì¡°ë¦½ë¹„:**
```matlab
function total_cost = manufacturing_cost(design_vars)
    % ì„¤ê³„ë³€ìˆ˜ì—ì„œ í˜•ìƒ ì •ë³´ ì¶”ì¶œ
    volume = calculate_volume(design_vars);
    surface_area = calculate_surface_area(design_vars);
    complexity = calculate_complexity(design_vars);
    
    % ë¹„ìš© êµ¬ì„±ìš”ì†Œ
    material_cost = volume * material_cost_per_volume;
    machining_cost = surface_area * machining_cost_per_area;
    complexity_cost = complexity * complexity_penalty;
    
    total_cost = material_cost + machining_cost + complexity_cost;
end
```

**ê°€ê³µ ì‹œê°„ ê¸°ë°˜ ë¹„ìš©:**
```matlab
function machining_time = estimate_machining_time(features)
    % ê°€ê³µ íŠ¹ì§•ë³„ ì‹œê°„ ì¶”ì •
    drilling_time = features.num_holes * 0.5;      % 0.5ë¶„/êµ¬ë©
    milling_time = features.pocket_volume * 2.0;   % 2ë¶„/cmÂ³
    turning_time = features.turned_length * 0.1;   % 0.1ë¶„/mm
    
    machining_time = drilling_time + milling_time + turning_time;
end
```

#### ìƒëª…ì£¼ê¸°ë¹„ìš© (Life Cycle Cost)

**ì´ˆê¸°ë¹„ìš© + ìš´ì˜ë¹„ìš© + íê¸°ë¹„ìš©:**
```matlab
function lcc = life_cycle_cost(design, service_life)
    % ì´ˆê¸° íˆ¬ìžë¹„
    initial_cost = design.material_cost + design.manufacturing_cost;
    
    % ì—°ê°„ ìš´ì˜ë¹„ (ì—ë„ˆì§€, ìœ ì§€ë³´ìˆ˜)
    annual_operating_cost = design.energy_cost + design.maintenance_cost;
    
    % í˜„ìž¬ê°€ì¹˜ë¡œ í• ì¸
    discount_rate = 0.05;  % 5%
    pv_operating = 0;
    for year = 1:service_life
        pv_operating = pv_operating + annual_operating_cost / (1 + discount_rate)^year;
    end
    
    % íê¸°ë¹„ìš© (í˜„ìž¬ê°€ì¹˜)
    disposal_cost = design.disposal_cost / (1 + discount_rate)^service_life;
    
    lcc = initial_cost + pv_operating + disposal_cost;
end
```

### 3. ì‹ ë¢°ì„± ê¸°ë°˜ ëª©ì í•¨ìˆ˜

#### íŒŒì†í™•ë¥  ìµœì†Œí™”

**ì‘ë ¥ ê¸°ë°˜ ì‹ ë¢°ì„±:**
```matlab
function prob_failure = stress_reliability(stress_mean, stress_std, material_strength)
    % ì‘ë ¥ì˜ í‰ê· ê³¼ í‘œì¤€íŽ¸ì°¨
    % ìž¬ë£Œ ê°•ë„ (ê²°ì •ì  ê°’)
    
    % ì•ˆì „ì—¬ìœ ì˜ í‰ê· ê³¼ í‘œì¤€íŽ¸ì°¨
    safety_margin_mean = material_strength - stress_mean;
    safety_margin_std = stress_std;  % ìž¬ë£Œê°•ë„ëŠ” ê²°ì •ì ì´ë¼ ê°€ì •
    
    % í‘œì¤€í™”
    z = safety_margin_mean / safety_margin_std;
    
    % íŒŒì†í™•ë¥  (ì •ê·œë¶„í¬ ê°€ì •)
    prob_failure = 0.5 * (1 - erf(z / sqrt(2)));
end
```

#### í”¼ë¡œìˆ˜ëª… ìµœëŒ€í™”

**S-N ê³¡ì„  ê¸°ë°˜:**
```matlab
function fatigue_life = estimate_fatigue_life(stress_amplitude, material_params)
    % S-N ê³¡ì„ : N = A * (S)^(-m)
    A = material_params.fatigue_strength_coefficient;
    m = material_params.fatigue_strength_exponent;
    
    % í”¼ë¡œìˆ˜ëª… [cycles]
    fatigue_life = A * (stress_amplitude)^(-m);
    
    % ë¬´í•œìˆ˜ëª… ì²´í¬
    endurance_limit = material_params.endurance_limit;
    if stress_amplitude < endurance_limit
        fatigue_life = Inf;
    end
end
```
---

## ðŸ”§ í•¨ìˆ˜ êµ¬ì„± ë°©ë²•

### ì§ì ‘ ì •ì˜ (Direct Definition)

**ë‹¨ì¼ ì„±ëŠ¥ ì§€í‘œ:**
```matlab
% ìº”í‹¸ë ˆë²„ ë³´ì˜ ìµœëŒ€ ì²˜ì§ ìµœì†Œí™”
function deflection = cantilever_deflection(width, height, length, load, E)
    % 2ì°¨ ê´€ì„±ëª¨ë©˜íŠ¸
    I = width * height^3 / 12;
    
    % ìµœëŒ€ ì²˜ì§ (ìžìœ ë‹¨)
    deflection = load * length^3 / (3 * E * I);
end

% ëª©ì í•¨ìˆ˜ ì •ì˜
objective = @(x) cantilever_deflection(x(1), x(2), 1000, 1000, 200e9);
```

**ëª…í™•í•œ ë¬¼ë¦¬ì  ì˜ë¯¸:**
- í•´ì„í•´ ì¡´ìž¬ ì‹œ í™œìš©
- ê³„ì‚° ì†ë„ ë¹ ë¦„
- ê²€ì¦ ìš©ì´

### ë³µí•© í•¨ìˆ˜ (Composite Function)

#### ê°€ì¤‘í•© í˜•íƒœ
```matlab
function f_combined = weighted_combination(x)
    % ê°œë³„ ëª©ì í•¨ìˆ˜ ê³„ì‚°
    mass = calculate_mass(x);
    stress = calculate_max_stress(x);
    cost = calculate_cost(x);
    
    % ì •ê·œí™” (ê¸°ì¤€ê°’ ëŒ€ë¹„)
    mass_norm = mass / mass_reference;
    stress_norm = stress / stress_limit;
    cost_norm = cost / cost_budget;
    
    % ê°€ì¤‘í•©
    w1 = 0.4; w2 = 0.3; w3 = 0.3;
    f_combined = w1*mass_norm + w2*stress_norm + w3*cost_norm;
end
```

#### ê³±ì…ˆ í˜•íƒœ (Product Form)
```matlab
function f_product = product_form(x)
    efficiency = calculate_efficiency(x);     % ìµœëŒ€í™” ëª©í‘œ
    reliability = calculate_reliability(x);   % ìµœëŒ€í™” ëª©í‘œ
    cost = calculate_cost(x);                % ìµœì†Œí™” ëª©í‘œ
    
    % ê³±ì…ˆ í˜•íƒœ (ëª¨ë“  í•­ëª©ì„ ìµœëŒ€í™” ë¬¸ì œë¡œ ë³€í™˜)
    f_product = efficiency * reliability / cost;
end
```

### ì •ê·œí™” ëª©ì í•¨ìˆ˜

#### Z-Score ì •ê·œí™”
```matlab
function f_normalized = z_score_normalization(objectives, weights)
    % ëª©ì í•¨ìˆ˜ í‰ê· ê³¼ í‘œì¤€íŽ¸ì°¨ ê³„ì‚° (ê³¼ê±° ì„¤ê³„ ë°ì´í„° ê¸°ë°˜)
    obj_mean = mean(objectives, 2);
    obj_std = std(objectives, 0, 2);
    
    % Z-score ì •ê·œí™”
    z_scores = (objectives - obj_mean) ./ obj_std;
    
    % ê°€ì¤‘í•©
    f_normalized = weights' * z_scores;
end
```

#### Min-Max ì •ê·œí™”
```matlab
function f_scaled = minmax_scaling(objectives, obj_min, obj_max, weights)
    % [0,1] ë²”ìœ„ë¡œ ìŠ¤ì¼€ì¼ë§
    scaled = (objectives - obj_min) ./ (obj_max - obj_min);
    
    % ê°€ì¤‘í•©
    f_scaled = weights' * scaled;
end
```

---

## ðŸ“ˆ ì„¤ê³„ ë¶„ì•¼ë³„ ì ìš©

### êµ¬ì¡° ìµœì í™”

#### íŠ¸ëŸ¬ìŠ¤ êµ¬ì¡° ì„¤ê³„
```matlab
function [mass, stress_ratio] = truss_objectives(areas, truss_data)
    % ìž…ë ¥:
    %   areas: ê° ë¶€ìž¬ ë‹¨ë©´ì  [mÂ²]
    %   truss_data: ë…¸ë“œì¢Œí‘œ, ì—°ê²°ì •ë³´, í•˜ì¤‘, ìž¬ë£ŒíŠ¹ì„±
    
    % ê°•ì„±í–‰ë ¬ ì¡°ë¦½
    K = assemble_stiffness_matrix(areas, truss_data);
    
    % ë³€ìœ„ ê³„ì‚°
    u = K \ truss_data.loads;
    
    % ë¶€ìž¬ë ¥ ê³„ì‚°
    member_forces = calculate_member_forces(u, areas, truss_data);
    
    % ëª©ì í•¨ìˆ˜ 1: ì§ˆëŸ‰
    lengths = truss_data.member_lengths;
    density = truss_data.material.density;
    mass = sum(density * areas .* lengths);
    
    % ëª©ì í•¨ìˆ˜ 2: ìµœëŒ€ ì‘ë ¥ë¹„
    stresses = abs(member_forces ./ areas);
    allowable_stress = truss_data.material.yield_strength / truss_data.safety_factor;
    stress_ratio = max(stresses / allowable_stress);
end

% ìµœì í™” ë¬¸ì œ ì •ì˜
objective = @(A) truss_objectives(A, truss_data);
```

#### ì—°ì†ì²´ êµ¬ì¡° (í† í´ë¡œì§€ ìµœì í™”)
```matlab
function compliance = topology_objective(density_vector, fem_data)
    % ë°€ë„ ë¶„í¬ë¥¼ ê°•ì„±í–‰ë ¬ì— ë°˜ì˜
    K_modified = apply_simp_model(density_vector, fem_data.K_elements);
    
    % ì „ì—­ ê°•ì„±í–‰ë ¬ ì¡°ë¦½
    K_global = assemble_global_matrix(K_modified, fem_data.connectivity);
    
    % ì»´í”Œë¼ì´ì–¸ìŠ¤ ê³„ì‚°
    u = K_global \ fem_data.loads;
    compliance = fem_data.loads' * u;
end
```

### ìœ ì²´ì—­í•™ ìµœì í™”

#### ìµí˜• ì„¤ê³„ (í•­ë ¥ ìµœì†Œí™”)
```matlab
function [drag, lift] = airfoil_performance(control_points, flow_conditions)
    % ì œì–´ì ìœ¼ë¡œë¶€í„° ìµí˜• í˜•ìƒ ìƒì„±
    airfoil_coords = generate_airfoil_from_cst(control_points);
    
    % CFD í•´ì„ ë˜ëŠ” íŒ¨ë„ë²•
    [pressure_dist, velocity_dist] = panel_method(airfoil_coords, flow_conditions);
    
    % íž˜ ê³„ì‚°
    [drag, lift] = integrate_forces(pressure_dist, airfoil_coords);
end

% ë‹¤ëª©ì  ìµœì í™” (í•­ë ¥ ìµœì†Œí™”, ì–‘ë ¥ ìµœëŒ€í™”)
objectives = @(x) airfoil_performance(x, flow_conditions);
```

#### ë•íŠ¸ ì„¤ê³„ (ì••ë ¥ì†ì‹¤ ìµœì†Œí™”)
```matlab
function pressure_loss = duct_optimization(duct_geometry, flow_rate)
    % í˜•ìƒ íŒŒë¼ë¯¸í„°ë¡œë¶€í„° ë•íŠ¸ ë©”ì‹œ ìƒì„±
    mesh = generate_duct_mesh(duct_geometry);
    
    % CFD í•´ì„
    [pressure_field, velocity_field] = solve_navier_stokes(mesh, flow_rate);
    
    % ì••ë ¥ì†ì‹¤ ê³„ì‚°
    pressure_in = mean(pressure_field(mesh.inlet_nodes));
    pressure_out = mean(pressure_field(mesh.outlet_nodes));
    pressure_loss = pressure_in - pressure_out;
end
```

### ì œì–´ ì‹œìŠ¤í…œ ìµœì í™”

#### PID ì œì–´ê¸° íŠœë‹
```matlab
function [ise, overshoot, settling_time] = pid_performance(pid_gains, plant_model)
    % PID ì œì–´ê¸° êµ¬ì„±
    Kp = pid_gains(1);
    Ki = pid_gains(2);
    Kd = pid_gains(3);
    
    controller = pid(Kp, Ki, Kd);
    
    % íë£¨í”„ ì‹œìŠ¤í…œ
    closed_loop = feedback(controller * plant_model, 1);
    
    % ë‹¨ìœ„ê³„ë‹¨ì‘ë‹µ
    [y, t] = step(closed_loop);
    
    % ì„±ëŠ¥ì§€í‘œ ê³„ì‚°
    error = 1 - y;
    ise = trapz(t, error.^2);  % Integral Squared Error
    
    step_info = stepinfo(closed_loop);
    overshoot = step_info.Overshoot;
    settling_time = step_info.SettlingTime;
end

% ë‹¤ëª©ì  ìµœì í™”
objective = @(gains) pid_performance(gains, plant);
```

---

## âš™ï¸ êµ¬í˜„ ê³ ë ¤ì‚¬í•­

### ìˆ˜ì¹˜ì  ì•ˆì •ì„±

#### ìŠ¤ì¼€ì¼ë§ (Scaling)
```matlab
function f_scaled = scale_objective(f_original, scale_factor)
    % ëª©ì í•¨ìˆ˜ ê°’ì˜ í¬ê¸° ì¡°ì •
    f_scaled = f_original / scale_factor;
end

% ì˜ˆì‹œ: ì§ˆëŸ‰(kg)ê³¼ ì‘ë ¥(Pa)ì„ ê°™ì€ ìŠ¤ì¼€ì¼ë¡œ
mass_kg = 100;
stress_pa = 100e6;

mass_scaled = mass_kg / 1000;        % ton ë‹¨ìœ„
stress_scaled = stress_pa / 1e6;     % MPa ë‹¨ìœ„
```

#### ì¡°ê±´ìˆ˜ ê°œì„ 
```matlab
function f_conditioned = improve_conditioning(x)
    % ì›ëž˜ ëª©ì í•¨ìˆ˜
    f_original = expensive_analysis(x);
    
    % ë¡œê·¸ ìŠ¤ì¼€ì¼ë§ (í° ê°’ì˜ ì˜í–¥ ì™„í™”)
    f_conditioned = log(1 + f_original);
end
```

### ê³„ì‚° íš¨ìœ¨ì„±

#### ê·¼ì‚¬ ëª¨ë¸ (Surrogate Model)
```matlab
% í¬ë¦¬ê¹… ëª¨ë¸ êµ¬ì¶•
function kriging_model = build_surrogate(sample_points, sample_values)
    % ì‹¤í—˜ê³„íšë²•ìœ¼ë¡œ ì–»ì€ ìƒ˜í”Œ ë°ì´í„°
    % í¬ë¦¬ê¹… ëª¨ë¸ í›ˆë ¨
    kriging_model = fitrgp(sample_points, sample_values);
end

% ê·¼ì‚¬ ëª©ì í•¨ìˆ˜
function f_approx = surrogate_objective(x, kriging_model)
    f_approx = predict(kriging_model, x);
end
```

#### ì ì‘ì  í‰ê°€
```matlab
function f = adaptive_evaluation(x, tolerance)
    % ì´ì „ í‰ê°€ ê²°ê³¼ì™€ ë¹„êµ
    if is_close_to_previous(x, tolerance)
        % ë³´ê°„ìœ¼ë¡œ ì¶”ì •
        f = interpolate_from_history(x);
    else
        % ì •í™•í•œ ê³„ì‚°
        f = exact_evaluation(x);
        % ížˆìŠ¤í† ë¦¬ì— ì €ìž¥
        save_to_history(x, f);
    end
end
```

### ë‹¤ì¤‘ ëª©í‘œ ì²˜ë¦¬

#### ìŠ¤ì¹¼ë¼í™” ë°©ë²•
```matlab
function f_scalar = scalarization(f_vector, method, parameters)
    switch method
        case 'weighted_sum'
            weights = parameters.weights;
            f_scalar = weights' * f_vector;
            
        case 'epsilon_constraint'
            primary_obj = f_vector(1);
            constraints = f_vector(2:end) - parameters.epsilon;
            if all(constraints <= 0)
                f_scalar = primary_obj;
            else
                f_scalar = Inf;  % ì œì•½ ìœ„ë°˜
            end
            
        case 'compromise_programming'
            ideal_point = parameters.ideal;
            p_norm = parameters.p;
            f_scalar = norm(f_vector - ideal_point, p_norm);
    end
end
```

#### íŒŒë ˆí†  í”„ë¡ íŠ¸ ê·¼ì‚¬
```matlab
function pareto_front = approximate_pareto_front(f_matrix)
    % f_matrix: ê° í–‰ì´ í•˜ë‚˜ì˜ í•´, ê° ì—´ì´ í•˜ë‚˜ì˜ ëª©ì í•¨ìˆ˜
    
    n_solutions = size(f_matrix, 1);
    is_dominated = false(n_solutions, 1);
    
    for i = 1:n_solutions
        for j = 1:n_solutions
            if i ~= j && dominates(f_matrix(j,:), f_matrix(i,:))
                is_dominated(i) = true;
                break;
            end
        end
    end
    
    pareto_front = f_matrix(~is_dominated, :);
end

function result = dominates(a, b)
    % aê°€ bë¥¼ ì§€ë°°í•˜ëŠ”ê°€? (ìµœì†Œí™” ë¬¸ì œ)
    result = all(a <= b) && any(a < b);
end
```

---

## ðŸ’» í”„ë¡œê·¸ëž˜ë° êµ¬í˜„

### MATLAB ëª©ì í•¨ìˆ˜ í´ëž˜ìŠ¤

```matlab
classdef ObjectiveFunction < handle
    properties
        name            % í•¨ìˆ˜ ì´ë¦„
        type            % 'minimize' or 'maximize'
        scale_factor    % ìŠ¤ì¼€ì¼ë§ ê³„ìˆ˜
        evaluation_count % í‰ê°€ íšŸìˆ˜
        history         % í‰ê°€ ížˆìŠ¤í† ë¦¬
    end
    
    methods
        function obj = ObjectiveFunction(name, type, scale_factor)
            obj.name = name;
            obj.type = type;
            obj.scale_factor = scale_factor;
            obj.evaluation_count = 0;
            obj.history = [];
        end
        
        function f = evaluate(obj, x, varargin)
            % ì‹¤ì œ ëª©ì í•¨ìˆ˜ ê³„ì‚°
            f_raw = obj.compute_raw_value(x, varargin{:});
            
            % ìŠ¤ì¼€ì¼ë§ ì ìš©
            f = f_raw / obj.scale_factor;
            
            % ìµœëŒ€í™” ë¬¸ì œë¥¼ ìµœì†Œí™”ë¡œ ë³€í™˜
            if strcmp(obj.type, 'maximize')
                f = -f;
            end
            
            % ížˆìŠ¤í† ë¦¬ ì €ìž¥
            obj.evaluation_count = obj.evaluation_count + 1;
            obj.history(end+1,:) = [x(:)', f];
        end
        
        function f = compute_raw_value(obj, x, varargin)
            % ì‹¤ì œ ê³„ì‚° (í•˜ìœ„ í´ëž˜ìŠ¤ì—ì„œ êµ¬í˜„)
            error('Subclass must implement compute_raw_value method');
        end
        
        function plot_history(obj)
            if size(obj.history, 1) < 2
                warning('Insufficient data for plotting');
                return;
            end
            
            figure;
            plot(1:obj.evaluation_count, obj.history(:,end), 'b-o');
            xlabel('Evaluation Number');
            ylabel(['Objective Value: ' obj.name]);
            title('Optimization History');
            grid on;
        end
    end
end

% êµ¬ì²´ì ì¸ ëª©ì í•¨ìˆ˜ êµ¬í˜„ ì˜ˆì‹œ
classdef MassObjective < ObjectiveFunction
    properties
        material_density
        element_data
    end
    
    methods
        function obj = MassObjective(density, elements)
            obj@ObjectiveFunction('Mass', 'minimize', 1000); % kg ë‹¨ìœ„
            obj.material_density = density;
            obj.element_data = elements;
        end
        
        function f = compute_raw_value(obj, areas)
            % areas: ê° ìš”ì†Œì˜ ë‹¨ë©´ì 
            volumes = areas .* obj.element_data.lengths;
            f = obj.material_density * sum(volumes);
        end
    end
end
```

### Python êµ¬í˜„ (ê°ì²´ì§€í–¥)

```python
import numpy as np
import matplotlib.pyplot as plt
from abc import ABC, abstractmethod

class ObjectiveFunction(ABC):
    def __init__(self, name, objective_type='minimize', scale_factor=1.0):
        self.name = name
        self.type = objective_type
        self.scale_factor = scale_factor
        self.evaluation_count = 0
        self.history = []
    
    def evaluate(self, x, *args, **kwargs):
        """ëª©ì í•¨ìˆ˜ í‰ê°€"""
        # ì›ì‹œê°’ ê³„ì‚°
        f_raw = self.compute_raw_value(x, *args, **kwargs)
        
        # ìŠ¤ì¼€ì¼ë§
        f = f_raw / self.scale_factor
        
        # ìµœëŒ€í™”ë¥¼ ìµœì†Œí™”ë¡œ ë³€í™˜
        if self.type == 'maximize':
            f = -f
        
        # ížˆìŠ¤í† ë¦¬ ì €ìž¥
        self.evaluation_count += 1
        self.history.append((x.copy(), f))
        
        return f
    
    @abstractmethod
    def compute_raw_value(self, x, *args, **kwargs):
        """ì‹¤ì œ ëª©ì í•¨ìˆ˜ ê³„ì‚° (í•˜ìœ„ í´ëž˜ìŠ¤ì—ì„œ êµ¬í˜„)"""
        pass
    
    def plot_history(self):
        """ìµœì í™” ížˆìŠ¤í† ë¦¬ í”Œë¡¯"""
        if len(self.history) < 2:
            print("Not enough data for plotting")
            return
        
        values = [item[1] for item in self.history]
        plt.figure(figsize=(10, 6))
        plt.plot(range(1, len(values)+1), values, 'b-o')
        plt.xlabel('Evaluation Number')
        plt.ylabel(f'Objective Value: {self.name}')
        plt.title('Optimization History')
        plt.grid(True)
        plt.show()

# êµ¬ì²´ì ì¸ êµ¬í˜„ ì˜ˆì‹œ
class TrussWeight(ObjectiveFunction):
    def __init__(self, lengths, density=7850):
        super().__init__('Truss Weight', 'minimize', 1000)  # kg ë‹¨ìœ„
        self.lengths = np.array(lengths)
        self.density = density
    
    def compute_raw_value(self, areas):
        """íŠ¸ëŸ¬ìŠ¤ ì§ˆëŸ‰ ê³„ì‚°"""
        volumes = areas * self.lengths
        weight = self.density * np.sum(volumes)
        return weight

class ComplianceObjective(ObjectiveFunction):
    def __init__(self, stiffness_matrix, load_vector):
        super().__init__('Compliance', 'minimize', 1e-6)  # Î¼m ë‹¨ìœ„
        self.K0 = stiffness_matrix
        self.F = load_vector
    
    def compute_raw_value(self, areas):
        """ì»´í”Œë¼ì´ì–¸ìŠ¤ ê³„ì‚°"""
        # ìˆ˜ì •ëœ ê°•ì„±í–‰ë ¬ (ë‹¨ìˆœí™”ëœ ì˜ˆì‹œ)
        K = self.K0 * np.mean(areas)
        
        # ë³€ìœ„ ê³„ì‚°
        u = np.linalg.solve(K, self.F)
        
        # ì»´í”Œë¼ì´ì–¸ìŠ¤
        compliance = np.dot(self.F, u)
        return compliance

# ë‹¤ëª©ì  ëª©ì í•¨ìˆ˜ í´ëž˜ìŠ¤
class MultiObjectiveFunction:
    def __init__(self, objective_functions):
        self.objectives = objective_functions
        self.evaluation_count = 0
    
    def evaluate(self, x):
        """ëª¨ë“  ëª©ì í•¨ìˆ˜ ë™ì‹œ í‰ê°€"""
        f_vector = []
        for obj_func in self.objectives:
            f_i = obj_func.evaluate(x)
            f_vector.append(f_i)
        
        self.evaluation_count += 1
        return np.array(f_vector)
    
    def get_names(self):
        return [obj.name for obj in self.objectives]
```

---

## ðŸŽ“ í•™ìŠµ ë‹¨ê³„ë³„ ê°€ì´ë“œ

### ì´ˆê¸‰ (1-2ê°œì›”)

**1ì£¼ì°¨: ë‹¨ì¼ ëª©ì í•¨ìˆ˜**
```matlab
% ê°„ë‹¨í•œ ìˆ˜í•™í•¨ìˆ˜ë¡œ ì‹œìž‘
f1 = @(x) x^2 + 2*x + 1;              % ë³¼ë¡í•¨ìˆ˜
f2 = @(x) x^4 - 2*x^2 + 1;            % ë¹„ë³¼ë¡í•¨ìˆ˜  
f3 = @(x) abs(x);                     % ë¯¸ë¶„ë¶ˆê°€ëŠ¥

% í”Œë¡¯ìœ¼ë¡œ íŠ¹ì„± ê´€ì°°
x = -3:0.1:3;
subplot(1,3,1); plot(x, f1(x)); title('Convex');
subplot(1,3,2); plot(x, f2(x)); title('Non-convex');
subplot(1,3,3); plot(x, f3(x)); title('Non-smooth');
```

**2ì£¼ì°¨: ê³µí•™ì  ëª©ì í•¨ìˆ˜**
```matlab
% ìº”í‹¸ë ˆë²„ ë³´ ìµœì í™”
function deflection = beam_deflection(x)
    width = x(1);   % 10-100 mm
    height = x(2);  % 5-50 mm
    
    L = 1000;       % ê¸¸ì´ [mm]
    P = 1000;       % í•˜ì¤‘ [N]  
    E = 200e9;      % íƒ„ì„±ê³„ìˆ˜ [Pa]
    
    I = width * height^3 / 12;  % ê´€ì„±ëª¨ë©˜íŠ¸ [mmâ´]
    deflection = P * L^3 / (3 * E * I * 1e-12);  % [mm]
end

% ìµœì í™” ì‹¤í–‰
x0 = [50, 25];
[x_opt, f_opt] = fminunc(@beam_deflection, x0);
```

### ì¤‘ê¸‰ (3-4ê°œì›”)

**3-4ì£¼ì°¨: ë³µí•© ëª©ì í•¨ìˆ˜**
```matlab
% ì§ˆëŸ‰ê³¼ ì²˜ì§ì„ ë™ì‹œ ê³ ë ¤
function f_combined = beam_multiobjective(x, weights)
    % ê°œë³„ ëª©ì í•¨ìˆ˜
    mass = beam_mass(x);
    deflection = beam_deflection(x);
    
    % ì •ê·œí™” (ê¸°ì¤€ê°’ ëŒ€ë¹„)
    mass_norm = mass / 1.0;           % 1kg ê¸°ì¤€
    deflection_norm = deflection / 1.0; % 1mm ê¸°ì¤€
    
    % ê°€ì¤‘í•©
    f_combined = weights(1)*mass_norm + weights(2)*deflection_norm;
end
```

**5-8ì£¼ì°¨: í™•ë¥ ì  ëª©ì í•¨ìˆ˜**
```matlab
% ë¶ˆí™•ì‹¤ì„±ì„ ê³ ë ¤í•œ ê°•ê±´ì„¤ê³„
function [f_mean, f_std] = robust_objective(x_nominal, uncertainty)
    n_samples = 1000;
    f_samples = zeros(n_samples, 1);
    
    for i = 1:n_samples
        % ë¶ˆí™•ì‹¤ì„± ìƒ˜í”Œë§
        x_sample = x_nominal + uncertainty.std .* randn(size(x_nominal));
        
        % ëª©ì í•¨ìˆ˜ í‰ê°€
        f_samples(i) = expensive_analysis(x_sample);
    end
    
    f_mean = mean(f_samples);
    f_std = std(f_samples);
end
```

### ê³ ê¸‰ (6ê°œì›”+)

**9-12ì£¼ì°¨: ëŒ€ê·œëª¨ ë¬¸ì œ**
- ìœ„ìƒìµœì í™” ëª©ì í•¨ìˆ˜
- ë‹¤ë¶„ì•¼ ì—°ì„± ë¬¸ì œ
- ì‹¤ì‹œê°„ ìµœì í™”

**13-16ì£¼ì°¨: ì‹¤ë¬´ í”„ë¡œì íŠ¸**
- ì‹¤ì œ ì‚°ì—… ë¬¸ì œ
- ìƒìš© ì†Œí”„íŠ¸ì›¨ì–´ ì—°ë™
- ì„±ëŠ¥ ìµœì í™”

---

**ì°¸ê³ ë¬¸í—Œ:**
- Arora, J.S. (2016). *Introduction to Optimum Design*. Academic Press.
- Rao, S.S. (2019). *Engineering Optimization: Theory and Practice*. Wiley.
- Vanderplaats, G.N. (2007). *Multidiscipline Design Optimization*. Vanderplaats R&D.
- Martins, J.R.R.A. & Ning, A. (2021). *Engineering Design Optimization*. Cambridge University Press.