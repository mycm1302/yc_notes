# 특수유클리드군

> 상위: [[선형대수및기하학]]  
> 관련: [[리군론]], [[특수직교군]]

강체의 위치와 방향을 동시에 다루는 특수유클리드군 SE(3)입니다. 로봇의 포즈 제어와 경로 계획의 핵심 수학적 도구입니다.

## 🎯 SE(3)의 정의

### 수학적 정의
```
SE(3) = {T = [R p] | R ∈ SO(3), p ∈ ℝ³}
              [0 1]

T ∈ ℝ⁴ˣ⁴: 동차변환행렬 (Homogeneous Transformation Matrix)
R ∈ SO(3): 회전 부분 (3×3)
p ∈ ℝ³: 평행이동 부분 (3×1)
```

### 물리적 의미
- 강체의 완전한 운동 (위치 + 방향)
- 좌표계 간의 변환 관계
- 로봇 말단장치의 포즈 (pose)

### 군 구조
```
곱셈: T₁T₂ (변환의 합성)
항등원: I₄ (4×4 단위행렬)
역원: T⁻¹ = [R^T  -R^T p]
              [0     1   ]
차원: 6 (회전 3 + 평행이동 3)
```

## 🔄 동차변환행렬

### 구조와 성질
```
T = [R p] = [r₁ r₂ r₃ p]
    [0 1]   [0  0  0  1]

r₁, r₂, r₃: 회전행렬의 열벡터 (단위 직교 벡터)
p: 원점의 위치벡터
```

### 변환의 해석
```
점 P의 변환: P' = TP = [R p][P] = [RP + p]
                        [0 1][1]   [  1   ]

회전 후 평행이동: P' = RP + p
```

### 합성 법칙
```
T₃ = T₁T₂ = [R₁R₂  R₁p₂ + p₁]
             [0     1        ]

회전 합성: R₃ = R₁R₂
위치 합성: p₃ = R₁p₂ + p₁
```

## 🎯 se(3) 리대수

### 트위스트 좌표
```
se(3) = {ξ̂ = [ω̂ v] | ω̂ ∈ so(3), v ∈ ℝ³}
             [0  0]

ξ = [v] ∈ ℝ⁶: 트위스트 벡터
    [ω]

v ∈ ℝ³: 선속도 (linear velocity)
ω ∈ ℝ³: 각속도 (angular velocity)
```

### 스크류 운동
트위스트는 스크류 운동을 나타냅니다:
- 순수 회전: ω ≠ 0, v = 0
- 순수 평행이동: ω = 0, v ≠ 0  
- 일반 스크류 운동: ω ≠ 0, v ≠ 0

### hat과 vee 연산자
```
∧: ℝ⁶ → se(3) (hat 연산자)
∨: se(3) → ℝ⁶ (vee 연산자)

ξ̂ = ξ∧ = [ω̂ v]
          [0  0]
```

## 🧮 지수 사상

### SE(3)에서의 지수 공식
```
exp(ξ̂) = [exp(ω̂)  Vv]
         [0       1 ]

여기서 V는 좌측 자코비안:
V = I + (1-cos(θ))/θ² ω̂ + (θ-sin(θ))/θ³ ω̂²
θ = ||ω||
```

### 특수 경우들
```
순수 평행이동 (ω = 0):
exp(ξ̂) = [I v]
         [0 1]

순수 회전 (v = 0):
exp(ξ̂) = [exp(ω̂) 0]
         [0       1]

작은 운동 (θ → 0):
exp(ξ̂) ≈ I + ξ̂
```

### 로그 사상
```
log: SE(3) → se(3)
ξ̂ = log(T)

복잡한 공식이지만 수치적으로 안정한 구현 가능
```

## 🔧 실용적 연산

### 1. 역변환
```
T⁻¹ = [R^T  -R^T p]
      [0     1    ]

기하학적 의미: 역방향 변환
```

### 2. 상대 변환
```
T_AB: A에서 B로의 변환
T_BC: B에서 C로의 변환
T_AC = T_AB T_BC: A에서 C로의 직접 변환
```

### 3. 보간 (SE(3)에서의 SLERP)
```
T(t) = T₁ exp(t log(T₁⁻¹T₂))
t ∈ [0,1]: T₁에서 T₂로의 최단 경로
```

### 4. 미분
```
속도 변환:
Ṫ = Tξ̂ (Body frame)
Ṫ = ξ̂T (Spatial frame)
```

## 🤖 로봇공학 응용

### 1. 순기구학
```
말단장치 포즈:
T₀ⁿ = T₀¹T₁²...T_{n-1}ⁿ

각 변환 T_i^{i+1}: i에서 i+1로의 관절 변환
```

### 2. 역기구학
```
목표 포즈 T_target 달성:
T_error = T_target T_current⁻¹
오차 트위스트: ξ_error = log(T_error)∨
```

### 3. 자코비안 관계
```
말단장치 속도: V = [v] = J(q)q̇
                    [ω]

Body Jacobian: V_b = J_b(q)q̇
Spatial Jacobian: V_s = J_s(q)q̇
```

### 4. 궤적 계획
```
직선 운동: T(t) = T_start exp(tξ̂)
원호 운동: 스크류 축 주변 회전
복합 운동: 구간별 스플라인 보간
```

## 📊 아드조인트 표현

### Adjoint 행렬
```
Ad_T: se(3) → se(3)
Ad_T = [R   p̂R] ∈ ℝ⁶ˣ⁶
       [0   R ]

p̂ = [0  -p₃  p₂]
    [p₃  0  -p₁]
    [-p₂ p₁  0 ]
```

### 물리적 의미
```
좌표계 변환: ξ'_body = Ad_T ξ_spatial
서로 다른 좌표계에서 표현된 같은 운동
```

### 활용 예시
```
Base frame 트위스트 → End-effector frame 트위스트
센서 데이터의 좌표계 변환
제어 명령의 좌표계 통일
```

## 🎯 특수한 SE(3) 요소들

### 1. 단위 스크류
```
단위 각속도: ||ω|| = 1
피치: h = ω^T v
모멘트: m = ω × v
```

### 2. 나선 운동
```
일정한 트위스트 ξ에 의한 운동:
T(t) = exp(tξ̂)
직선과 회전의 결합
```

### 3. 순간 나선축 (ISA)
```
순간적인 운동의 중심축
ω ≠ 0일 때 잘 정의됨
```

## 🔬 측정과 추정

### 1. 포즈 추정
```
시각적 SLAM: 카메라 포즈 T_camera
라이다 SLAM: 로봇 포즈 T_robot
IMU 적분: 상대 변화량 ΔT
```

### 2. 센서 융합
```
EKF on SE(3):
상태: T ∈ SE(3)
예측: T(t+dt) = T(t)exp(ξ(t)dt)
보정: 센서 측정값으로 업데이트
```

### 3. 캘리브레이션
```
Hand-Eye 캘리브레이션:
A_i X = X B_i (i = 1, ..., n)
SE(3)에서의 연립방정식 해결
```

## 🎯 수치적 고려사항

### 1. 직교성 유지
```
회전 부분의 직교성:
R ∈ SO(3) 유지를 위한 투영
SVD 또는 그람-슈미트 사용
```

### 2. 리 브라켓
```
[ξ̂₁, ξ̂₂] = ad_ξ₁(ξ₂)
ad_ξ = [ω̂  v̂]
       [0  ω̂]
```

### 3. 수치 적분
```
작은 각도에서의 근사:
V ≈ I + ½ω̂ + (1/12)ω̂²
더 정확한 근사식 존재
```

## 🚀 고급 주제

### 1. SE(3) 상에서의 최적화
```
포즈 그래프 SLAM:
min Σᵢⱼ ||log(T_i⁻¹T_ij T_j⁻¹)||²
매니폴드 최적화 기법 적용
```

### 2. 확률적 포즈
```
포즈 불확실성:
T̄ ± δT
δT는 se(3)의 분포로 표현
```

### 3. 시간변화 SE(3)
```
가속도: α = dV/dt + ad_V(V)
고차 미분과 동역학 연결
```

## 🔧 구현 예제

### MATLAB
```matlab
% DH 파라미터로부터 변환행렬
function T = dh_transform(a, alpha, d, theta)
    T = [cos(theta) -sin(theta)*cos(alpha)  sin(theta)*sin(alpha) a*cos(theta);
         sin(theta)  cos(theta)*cos(alpha) -cos(theta)*sin(alpha) a*sin(theta);
         0           sin(alpha)             cos(alpha)            d;
         0           0                      0                     1];
end

% 트위스트에서 변환행렬
function T = twist_to_transform(xi, theta)
    omega = xi(4:6);
    v = xi(1:3);
    omega_hat = skew(omega);
    
    if norm(omega) < 1e-6
        T = [eye(3) v*theta; 0 0 0 1];
    else
        T = [rodrigues(omega*theta) ...
             (eye(3)*theta + (1-cos(theta))*omega_hat + ...
              (theta-sin(theta))*omega_hat^2)*v; 
             0 0 0 1];
    end
end
```

### Python
```python
import numpy as np
from scipy.linalg import expm, logm

class SE3:
    def __init__(self, R=None, p=None, T=None):
        if T is not None:
            self.T = T
        else:
            if R is None:
                R = np.eye(3)
            if p is None:
                p = np.zeros(3)
            self.T = np.block([[R, p.reshape(-1,1)],
                              [0, 0, 0, 1]])
    
    @property
    def R(self):
        return self.T[:3, :3]
    
    @property 
    def p(self):
        return self.T[:3, 3]
    
    def __mul__(self, other):
        return SE3(T=self.T @ other.T)
    
    def inv(self):
        R_inv = self.R.T
        p_inv = -R_inv @ self.p
        return SE3(R_inv, p_inv)
    
    @staticmethod
    def exp(xi):
        """트위스트에서 SE(3) 원소 생성"""
        omega = xi[3:6]
        v = xi[0:3]
        theta = np.linalg.norm(omega)
        
        if theta < 1e-8:
            V = np.eye(3)
            R = np.eye(3)
        else:
            omega_hat = skew(omega)
            R = rodrigues(omega)
            V = (np.eye(3) + 
                 (1-np.cos(theta))/theta**2 * omega_hat +
                 (theta-np.sin(theta))/theta**3 * omega_hat @ omega_hat)
        
        return SE3(R, V @ v)
```

## 🎯 학습 로드맵

1. **기본 개념** (2-3주)
   - 동차변환행렬의 구조와 의미
   - 기본 변환 연산들

2. **리군 구조** (3-4주)
   - se(3)과 SE(3)의 관계
   - 트위스트와 스크류 이론

3. **로봇 응용** (4-5주)
   - 순/역 기구학에서의 활용
   - 궤적 계획과 제어

4. **고급 응용** (3-4주)
   - SLAM과 포즈 추정
   - 최적화와 확률적 방법

---
*참고: Modern Robotics (Lynch & Park), A Mathematical Introduction to Robotic Manipulation (Murray et al.), Robotics: Modelling, Planning and Control (Siciliano)*