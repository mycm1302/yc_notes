# 전원시스템

> 상위: [[전자회로설계]]

로봇의 안정적인 동작을 위한 전원 관리 및 분배 시스템입니다.

## ⚡ 전원 아키텍처

### 계층적 전원 분배
```
메인 배터리 (12V/24V)
├── DC-DC 컨버터 (12V) → 모터 드라이버
├── DC-DC 컨버터 (5V) → 센서, MCU, 통신
└── LDO 레귤레이터 (3.3V) → 아날로그 회로
```

## 🔋 배터리 관리

### 리튬 이온 배터리 선택
- **용량**: 로봇 동작 시간 고려 (2-10Ah)
- **전압**: 3.7V 셀 조합 (3S=11.1V, 4S=14.8V)
- **방전율**: 모터 순간 전류 고려 (10-30C)

### BMS (Battery Management System)
- 과충전/과방전 보호
- 셀 밸런싱
- 온도 모니터링  
- 전류 제한
## 🔌 전압 레귤레이터

### 스위칭 레귤레이터 (Buck)
- **장점**: 고효율 (85-95%), 발열 적음
- **용도**: 고전류 부하 (모터, 컨트롤러)
- **추천 IC**: LM2596, XL4015, TPS54560

### 선형 레귤레이터 (LDO)  
- **장점**: 낮은 노이즈, 간단한 회로
- **용도**: 민감한 아날로그 회로
- **추천 IC**: AMS1117, LP2985, TLV71533

## 📊 전원 분배

### 전원 도메인 분리
1. **디지털 전원**: 마이크로컨트롤러, 로직 IC
2. **아날로그 전원**: 센서, ADC, 기준 전압  
3. **모터 전원**: 고전류 드라이버
4. **통신 전원**: 무선 모듈, 인터페이스

### 전원 분배 회로
```
메인 전원 → 히트 퓨즈 → 전원 분배 보드
           ├── 모터 전원 (고전류)
           ├── 디지털 전원 (중간 전류)  
           ├── 아날로그 전원 (저노이즈)
           └── 스탠바이 전원 (항상 ON)
```
## 🛡️ 보호 회로

### 과전류 보호
- **히트 퓨즈**: 물리적 보호 (일회용)
- **전자 퓨즈**: 리셋 가능한 보호
- **전류 제한**: IC 내장 또는 외부 회로

### 과전압 보호
- **제너 다이오드**: 간단한 전압 제한
- **TVS 다이오드**: 빠른 과도전압 보호
- **전압 감시**: 마이크로컨트롤러 모니터링

## ⚡ 실제 설계 예시

### 로봇 전력 계산
```cpp
전력 계산 예시:
- 모터: 24V × 5A = 120W
- 센서: 5V × 0.5A = 2.5W  
- MCU: 3.3V × 0.3A = 1W
- 통신: 5V × 0.2A = 1W
총합: ~125W

배터리 런타임:
100Wh / 50W(평균) = 2시간
```

---

## 🔗 연결 문서
- 상위: [[전자회로설계]]
- 관련: [[전원회로]], [[배터리관리]]
- 응용: [[모터드라이버]], [[센서인터페이스]], [[마이크로컨트롤러]], [[통신인터페이스]]
- 통합: [[로봇구조]], [[기계설계]]
## 🔋 고급 배터리 관리 시스템

### 리튬 배터리 상태 추정
```cpp
// SOC (State of Charge) 추정 알고리즘
class BatterySOCEstimator {
private:
    float coulomb_counter = 0;  // 쿨롱 카운터 [Ah]
    float voltage_soc = 0;      // 전압 기반 SOC
    float combined_soc = 0;     // 융합 SOC
    
public:
    void updateSOC(float voltage, float current, float dt) {
        // 쿨롱 카운팅
        coulomb_counter += current * dt / 3600.0;  // mAh
        float coulomb_soc = (battery_capacity - coulomb_counter) / battery_capacity * 100;
        
        // 개방전압 기반 SOC (OCV-SOC 룩업테이블)
        voltage_soc = lookupOCVtoSOC(voltage);
        
        // 칼만 필터 융합
        combined_soc = kalmanFilter(coulomb_soc, voltage_soc);
    }
    
private:
    float lookupOCVtoSOC(float voltage) {
        // 리튬 배터리 OCV-SOC 특성 곡선
        if(voltage > 4.1) return 100;
        else if(voltage > 3.9) return 80 + (voltage - 3.9) * 100;
        else if(voltage > 3.7) return 40 + (voltage - 3.7) * 200;
        else if(voltage > 3.4) return 10 + (voltage - 3.4) * 100;
        else return 0;
    }
};
```

### 배터리 열 관리
```cpp
// 능동 열 관리 시스템
class ThermalManager {
private:
    float cell_temps[4];  // 4셀 배터리팩
    bool cooling_active = false;
    
public:
    void monitorTemperature() {
        float max_temp = 0, min_temp = 100;
        
        for(int i = 0; i < 4; i++) {
            cell_temps[i] = readThermistor(i);
            max_temp = max(max_temp, cell_temps[i]);
            min_temp = min(min_temp, cell_temps[i]);
        }
        
        // 온도 기반 제어
        if(max_temp > 45) {
            activeCooling(true);
            limitChargeCurrent(0.5);  // 충전전류 50% 제한
        } else if(max_temp < 35) {
            activeCooling(false);
            limitChargeCurrent(1.0);  // 정상 충전
        }
        
        // 셀 간 온도 불균형 경고
        if(max_temp - min_temp > 5) {
            Serial.println("셀 온도 불균형 경고");
        }
    }
    
private:
    void activeCooling(bool enable) {
        digitalWrite(FAN_PIN, enable);
        cooling_active = enable;
    }
};
```

### 고급 충전 알고리즘 (CC-CV)
```cpp
// 정전류-정전압 충전 제어
class SmartCharger {
private:
    enum ChargeStage { PRECHARGE, CC, CV, COMPLETE };
    ChargeStage stage = PRECHARGE;
    
public:
    void chargeControl(float voltage, float current, float target_current) {
        switch(stage) {
            case PRECHARGE:
                if(voltage < 3.0) {
                    setChargeCurrent(0.1 * target_current);  // 10% 전류로 예비충전
                } else {
                    stage = CC;
                }
                break;
                
            case CC:  // 정전류 단계
                setChargeCurrent(target_current);
                if(voltage >= 4.2) {
                    stage = CV;
                }
                break;
                
            case CV:  // 정전압 단계
                setChargeVoltage(4.2);
                if(current < 0.05 * target_current) {  // 5%까지 감소시 완료
                    stage = COMPLETE;
                }
                break;
                
            case COMPLETE:
                setChargeCurrent(0);
                break;
        }
    }
    
    float estimateChargeTime() {
        float remaining_capacity = (100 - current_soc) / 100.0 * battery_capacity;
        float avg_charge_rate = 0.8 * max_charge_current;  // 효율 고려
        return remaining_capacity / avg_charge_rate;  // 시간
    }
};
```

## ⚡ DC-DC 컨버터 고급 설계

### 동기식 Buck 컨버터 (고효율)
```cpp
// 동기식 Buck 컨버터 제어 (95% 효율 달성)
class SynchronousBuck {
private:
    float inductor_current = 0;
    float output_voltage = 0;
    bool ccm_mode = true;  // 연속 도통 모드
    
public:
    void controlLoop() {
        // 전류 측정 (홀센서 또는 션트저항)
        inductor_current = readInductorCurrent();
        output_voltage = readOutputVoltage();
        
        // 전압 모드 제어
        float error = voltage_reference - output_voltage;
        float duty = pi_controller.update(error);
        
        // 적응형 데드타임 제어
        float deadtime = calculateOptimalDeadtime(inductor_current);
        
        // PWM 생성 (상부/하부 MOSFET)
        setPWM_HighSide(duty, deadtime);
        setPWM_LowSide(duty, deadtime);
        
        // 경부하시 PFM 모드 전환
        if(inductor_current < 0.1) {
            switchToPFMMode();
        }
    }
    
private:
    void switchToPFMMode() {
        // Pulse Frequency Modulation (경부하 고효율)
        if(output_voltage < voltage_reference - 0.01) {
            generateSinglePulse();
        }
    }
};
```

### 다중 위상 컨버터 (고전류)
```cpp
// 4상 인터리브드 Buck (리플 전류 감소)
class MultiphaseConverter {
private:
    static const int PHASES = 4;
    float phase_currents[PHASES];
    float phase_shift = 360.0 / PHASES;  // 90도 위상차
    
public:
    void interleaveControl() {
        float total_current = 0;
        
        for(int i = 0; i < PHASES; i++) {
            phase_currents[i] = readPhaseCurrent(i);
            total_current += phase_currents[i];
        }
        
        // 전류 밸런싱
        float avg_current = total_current / PHASES;
        for(int i = 0; i < PHASES; i++) {
            float imbalance = phase_currents[i] - avg_current;
            adjustPhaseDuty(i, -imbalance * 0.1);  // 비례 보정
        }
        
        // 상별 PWM 생성 (90도 위상차)
        float base_duty = calculateBaseDuty();
        for(int i = 0; i < PHASES; i++) {
            float phase_angle = i * phase_shift;
            setPhasePWM(i, base_duty, phase_angle);
        }
    }
    
    float getRippleCurrent() {
        // 4상 인터리브드로 리플 전류 1/4 감소
        return calculateRipple() / PHASES;
    }
};
```

### 양방향 DC-DC 컨버터 (에너지 회생)
```cpp
// 모터 제동시 에너지 회생
class BidirectionalConverter {
private:
    enum Mode { MOTORING, BRAKING, STANDBY };
    Mode operating_mode = STANDBY;
    
public:
    void energyManagement(float motor_torque, float motor_speed) {
        float mechanical_power = motor_torque * motor_speed;
        
        if(mechanical_power > 0) {
            // 모터링 모드 (배터리 → 모터)
            operating_mode = MOTORING;
            buckOperation();
        } else if(mechanical_power < -100) {  // 100W 이상 회생
            // 제동 모드 (모터 → 배터리)
            operating_mode = BRAKING;
            boostOperation();
        } else {
            operating_mode = STANDBY;
        }
    }
    
private:
    void buckOperation() {
        // 스텝다운 동작 (배터리 → 모터)
        float duty = calculateBuckDuty();
        setMOSFET_Q1(duty);
        setMOSFET_Q2(0);
    }
    
    void boostOperation() {
        // 스텝업 동작 (모터 → 배터리)
        float duty = calculateBoostDuty();
        setMOSFET_Q1(0);
        setMOSFET_Q2(duty);
        
        // 배터리 과충전 보호
        if(battery_voltage > 4.2 * cell_count) {
            stopRegeneration();
        }
    }
};
```

## 🔌 스마트 전원 관리

### 동적 전력 할당
```cpp
// 시스템 우선순위에 따른 전력 분배
class PowerManager {
private:
    struct PowerDomain {
        String name;
        float current_power;
        float max_power;
        int priority;  // 1=최고 우선순위
        bool enabled;
    };
    
    PowerDomain domains[5] = {
        {"모터", 0, 200, 1, true},
        {"센서", 0, 10, 2, true},  
        {"통신", 0, 5, 3, true},
        {"조명", 0, 20, 4, true},
        {"기타", 0, 15, 5, true}
    };
    
public:
    void managePower(float available_power) {
        float total_demand = calculateTotalDemand();
        
        if(total_demand > available_power) {
            // 전력 부족시 우선순위 기반 할당
            priorityBasedAllocation(available_power);
        } else {
            // 정상 동작
            normalOperation();
        }
    }
    
private:
    void priorityBasedAllocation(float budget) {
        // 우선순위 순으로 정렬
        sortByPriority(domains, 5);
        
        float remaining = budget;
        for(int i = 0; i < 5; i++) {
            if(remaining >= domains[i].current_power) {
                domains[i].enabled = true;
                remaining -= domains[i].current_power;
            } else {
                domains[i].enabled = false;
                Serial.printf("%s 전원 차단\n", domains[i].name.c_str());
            }
        }
    }
};
```

### 예측 전력 관리
```cpp
// 미션 프로파일 기반 전력 계획
class PredictivePowerManager {
private:
    struct MissionSegment {
        float duration;     // 구간 시간 [s]
        float motor_power;  // 모터 소비전력 [W]
        float sensor_power; // 센서 소비전력 [W]
    };
    
    MissionSegment mission_profile[10];
    int profile_length = 0;
    
public:
    bool planMission(MissionSegment* profile, int length) {
        float total_energy = 0;
        
        // 총 에너지 요구량 계산
        for(int i = 0; i < length; i++) {
            total_energy += (profile[i].motor_power + profile[i].sensor_power) 
                           * profile[i].duration / 3600.0;  // Wh
        }
        
        float available_energy = battery_capacity * battery_voltage * soc / 100.0;
        
        if(total_energy * 1.2 > available_energy) {  // 20% 안전마진
            Serial.printf("에너지 부족: 필요=%0.1fWh, 가용=%0.1fWh\n", 
                         total_energy, available_energy);
            return false;
        }
        
        // 미션 프로파일 저장
        memcpy(mission_profile, profile, sizeof(MissionSegment) * length);
        profile_length = length;
        return true;
    }
    
    void adaptToReality(float actual_power) {
        static float predicted_power = 0;
        
        // 예측과 실제 차이 학습
        float error = actual_power - predicted_power;
        
        // 나머지 구간 전력 소비 보정
        for(int i = current_segment; i < profile_length; i++) {
            mission_profile[i].motor_power += error * 0.1;  // 10% 보정
        }
    }
};
```

## 🛡️ 전자기 호환성 (EMC) 설계

### 전원 필터 설계
```cpp
// 다단계 EMI 필터
class EMIFilter {
private:
    float common_mode_current = 0;
    float differential_mode_current = 0;
    
public:
    void measureEMI() {
        // 공통모드 전류 측정 (CT를 이용한 홀센서)
        common_mode_current = readCommonModeCurrent();
        
        // 차동모드 전류 측정
        differential_mode_current = readDifferentialCurrent();
        
        // EMI 기준 초과시 경고
        if(common_mode_current > 1.0) {  // 1A 기준
            Serial.println("공통모드 EMI 초과");
        }
    }
    
    void optimizeFilterDesign(float switching_freq) {
        // 스위칭 주파수의 10배에서 40dB 감쇠 목표
        float target_freq = switching_freq * 10;
        
        // LC 필터 설계
        float L_cm = 1e-3;  // 1mH 공통모드 초크
        float C_dm = calculateDifferentialCapacitor(target_freq, L_cm);
        
        Serial.printf("권장 차동모드 커패시터: %.1fuF\n", C_dm * 1e6);
    }
    
private:
    float calculateDifferentialCapacitor(float f, float L) {
        // fc = 1/(2π√LC)에서 C 계산
        return 1.0 / (4 * PI * PI * f * f * L);
    }
};
```