# ì „ì›ì‹œìŠ¤í…œ

> ìƒìœ„: [[ì „ìíšŒë¡œì„¤ê³„]]

ë¡œë´‡ì˜ ì•ˆì •ì ì¸ ë™ì‘ì„ ìœ„í•œ ì „ì› ê´€ë¦¬ ë° ë¶„ë°° ì‹œìŠ¤í…œì…ë‹ˆë‹¤.

## âš¡ ì „ì› ì•„í‚¤í…ì²˜

### ê³„ì¸µì  ì „ì› ë¶„ë°°
```
ë©”ì¸ ë°°í„°ë¦¬ (12V/24V)
â”œâ”€â”€ DC-DC ì»¨ë²„í„° (12V) â†’ ëª¨í„° ë“œë¼ì´ë²„
â”œâ”€â”€ DC-DC ì»¨ë²„í„° (5V) â†’ ì„¼ì„œ, MCU, í†µì‹ 
â””â”€â”€ LDO ë ˆê·¤ë ˆì´í„° (3.3V) â†’ ì•„ë‚ ë¡œê·¸ íšŒë¡œ
```

## ğŸ”‹ ë°°í„°ë¦¬ ê´€ë¦¬

### ë¦¬íŠ¬ ì´ì˜¨ ë°°í„°ë¦¬ ì„ íƒ
- **ìš©ëŸ‰**: ë¡œë´‡ ë™ì‘ ì‹œê°„ ê³ ë ¤ (2-10Ah)
- **ì „ì••**: 3.7V ì…€ ì¡°í•© (3S=11.1V, 4S=14.8V)
- **ë°©ì „ìœ¨**: ëª¨í„° ìˆœê°„ ì „ë¥˜ ê³ ë ¤ (10-30C)

### BMS (Battery Management System)
- ê³¼ì¶©ì „/ê³¼ë°©ì „ ë³´í˜¸
- ì…€ ë°¸ëŸ°ì‹±
- ì˜¨ë„ ëª¨ë‹ˆí„°ë§  
- ì „ë¥˜ ì œí•œ
## ğŸ”Œ ì „ì•• ë ˆê·¤ë ˆì´í„°

### ìŠ¤ìœ„ì¹­ ë ˆê·¤ë ˆì´í„° (Buck)
- **ì¥ì **: ê³ íš¨ìœ¨ (85-95%), ë°œì—´ ì ìŒ
- **ìš©ë„**: ê³ ì „ë¥˜ ë¶€í•˜ (ëª¨í„°, ì»¨íŠ¸ë¡¤ëŸ¬)
- **ì¶”ì²œ IC**: LM2596, XL4015, TPS54560

### ì„ í˜• ë ˆê·¤ë ˆì´í„° (LDO)  
- **ì¥ì **: ë‚®ì€ ë…¸ì´ì¦ˆ, ê°„ë‹¨í•œ íšŒë¡œ
- **ìš©ë„**: ë¯¼ê°í•œ ì•„ë‚ ë¡œê·¸ íšŒë¡œ
- **ì¶”ì²œ IC**: AMS1117, LP2985, TLV71533

## ğŸ“Š ì „ì› ë¶„ë°°

### ì „ì› ë„ë©”ì¸ ë¶„ë¦¬
1. **ë””ì§€í„¸ ì „ì›**: ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬, ë¡œì§ IC
2. **ì•„ë‚ ë¡œê·¸ ì „ì›**: ì„¼ì„œ, ADC, ê¸°ì¤€ ì „ì••  
3. **ëª¨í„° ì „ì›**: ê³ ì „ë¥˜ ë“œë¼ì´ë²„
4. **í†µì‹  ì „ì›**: ë¬´ì„  ëª¨ë“ˆ, ì¸í„°í˜ì´ìŠ¤

### ì „ì› ë¶„ë°° íšŒë¡œ
```
ë©”ì¸ ì „ì› â†’ íˆíŠ¸ í“¨ì¦ˆ â†’ ì „ì› ë¶„ë°° ë³´ë“œ
           â”œâ”€â”€ ëª¨í„° ì „ì› (ê³ ì „ë¥˜)
           â”œâ”€â”€ ë””ì§€í„¸ ì „ì› (ì¤‘ê°„ ì „ë¥˜)  
           â”œâ”€â”€ ì•„ë‚ ë¡œê·¸ ì „ì› (ì €ë…¸ì´ì¦ˆ)
           â””â”€â”€ ìŠ¤íƒ ë°”ì´ ì „ì› (í•­ìƒ ON)
```
## ğŸ›¡ï¸ ë³´í˜¸ íšŒë¡œ

### ê³¼ì „ë¥˜ ë³´í˜¸
- **íˆíŠ¸ í“¨ì¦ˆ**: ë¬¼ë¦¬ì  ë³´í˜¸ (ì¼íšŒìš©)
- **ì „ì í“¨ì¦ˆ**: ë¦¬ì…‹ ê°€ëŠ¥í•œ ë³´í˜¸
- **ì „ë¥˜ ì œí•œ**: IC ë‚´ì¥ ë˜ëŠ” ì™¸ë¶€ íšŒë¡œ

### ê³¼ì „ì•• ë³´í˜¸
- **ì œë„ˆ ë‹¤ì´ì˜¤ë“œ**: ê°„ë‹¨í•œ ì „ì•• ì œí•œ
- **TVS ë‹¤ì´ì˜¤ë“œ**: ë¹ ë¥¸ ê³¼ë„ì „ì•• ë³´í˜¸
- **ì „ì•• ê°ì‹œ**: ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ ëª¨ë‹ˆí„°ë§

## âš¡ ì‹¤ì œ ì„¤ê³„ ì˜ˆì‹œ

### ë¡œë´‡ ì „ë ¥ ê³„ì‚°
```cpp
ì „ë ¥ ê³„ì‚° ì˜ˆì‹œ:
- ëª¨í„°: 24V Ã— 5A = 120W
- ì„¼ì„œ: 5V Ã— 0.5A = 2.5W  
- MCU: 3.3V Ã— 0.3A = 1W
- í†µì‹ : 5V Ã— 0.2A = 1W
ì´í•©: ~125W

ë°°í„°ë¦¬ ëŸ°íƒ€ì„:
100Wh / 50W(í‰ê· ) = 2ì‹œê°„
```

---

## ğŸ”— ì—°ê²° ë¬¸ì„œ
- ìƒìœ„: [[ì „ìíšŒë¡œì„¤ê³„]]
- ê´€ë ¨: [[ì „ì›íšŒë¡œ]], [[ë°°í„°ë¦¬ê´€ë¦¬]]
- ì‘ìš©: [[ëª¨í„°ë“œë¼ì´ë²„]], [[ì„¼ì„œì¸í„°í˜ì´ìŠ¤]], [[ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬]], [[í†µì‹ ì¸í„°í˜ì´ìŠ¤]]
- í†µí•©: [[ë¡œë´‡êµ¬ì¡°]], [[ê¸°ê³„ì„¤ê³„]]
## ğŸ”‹ ê³ ê¸‰ ë°°í„°ë¦¬ ê´€ë¦¬ ì‹œìŠ¤í…œ

### ë¦¬íŠ¬ ë°°í„°ë¦¬ ìƒíƒœ ì¶”ì •
```cpp
// SOC (State of Charge) ì¶”ì • ì•Œê³ ë¦¬ì¦˜
class BatterySOCEstimator {
private:
    float coulomb_counter = 0;  // ì¿¨ë¡± ì¹´ìš´í„° [Ah]
    float voltage_soc = 0;      // ì „ì•• ê¸°ë°˜ SOC
    float combined_soc = 0;     // ìœµí•© SOC
    
public:
    void updateSOC(float voltage, float current, float dt) {
        // ì¿¨ë¡± ì¹´ìš´íŒ…
        coulomb_counter += current * dt / 3600.0;  // mAh
        float coulomb_soc = (battery_capacity - coulomb_counter) / battery_capacity * 100;
        
        // ê°œë°©ì „ì•• ê¸°ë°˜ SOC (OCV-SOC ë£©ì—…í…Œì´ë¸”)
        voltage_soc = lookupOCVtoSOC(voltage);
        
        // ì¹¼ë§Œ í•„í„° ìœµí•©
        combined_soc = kalmanFilter(coulomb_soc, voltage_soc);
    }
    
private:
    float lookupOCVtoSOC(float voltage) {
        // ë¦¬íŠ¬ ë°°í„°ë¦¬ OCV-SOC íŠ¹ì„± ê³¡ì„ 
        if(voltage > 4.1) return 100;
        else if(voltage > 3.9) return 80 + (voltage - 3.9) * 100;
        else if(voltage > 3.7) return 40 + (voltage - 3.7) * 200;
        else if(voltage > 3.4) return 10 + (voltage - 3.4) * 100;
        else return 0;
    }
};
```

### ë°°í„°ë¦¬ ì—´ ê´€ë¦¬
```cpp
// ëŠ¥ë™ ì—´ ê´€ë¦¬ ì‹œìŠ¤í…œ
class ThermalManager {
private:
    float cell_temps[4];  // 4ì…€ ë°°í„°ë¦¬íŒ©
    bool cooling_active = false;
    
public:
    void monitorTemperature() {
        float max_temp = 0, min_temp = 100;
        
        for(int i = 0; i < 4; i++) {
            cell_temps[i] = readThermistor(i);
            max_temp = max(max_temp, cell_temps[i]);
            min_temp = min(min_temp, cell_temps[i]);
        }
        
        // ì˜¨ë„ ê¸°ë°˜ ì œì–´
        if(max_temp > 45) {
            activeCooling(true);
            limitChargeCurrent(0.5);  // ì¶©ì „ì „ë¥˜ 50% ì œí•œ
        } else if(max_temp < 35) {
            activeCooling(false);
            limitChargeCurrent(1.0);  // ì •ìƒ ì¶©ì „
        }
        
        // ì…€ ê°„ ì˜¨ë„ ë¶ˆê· í˜• ê²½ê³ 
        if(max_temp - min_temp > 5) {
            Serial.println("ì…€ ì˜¨ë„ ë¶ˆê· í˜• ê²½ê³ ");
        }
    }
    
private:
    void activeCooling(bool enable) {
        digitalWrite(FAN_PIN, enable);
        cooling_active = enable;
    }
};
```

### ê³ ê¸‰ ì¶©ì „ ì•Œê³ ë¦¬ì¦˜ (CC-CV)
```cpp
// ì •ì „ë¥˜-ì •ì „ì•• ì¶©ì „ ì œì–´
class SmartCharger {
private:
    enum ChargeStage { PRECHARGE, CC, CV, COMPLETE };
    ChargeStage stage = PRECHARGE;
    
public:
    void chargeControl(float voltage, float current, float target_current) {
        switch(stage) {
            case PRECHARGE:
                if(voltage < 3.0) {
                    setChargeCurrent(0.1 * target_current);  // 10% ì „ë¥˜ë¡œ ì˜ˆë¹„ì¶©ì „
                } else {
                    stage = CC;
                }
                break;
                
            case CC:  // ì •ì „ë¥˜ ë‹¨ê³„
                setChargeCurrent(target_current);
                if(voltage >= 4.2) {
                    stage = CV;
                }
                break;
                
            case CV:  // ì •ì „ì•• ë‹¨ê³„
                setChargeVoltage(4.2);
                if(current < 0.05 * target_current) {  // 5%ê¹Œì§€ ê°ì†Œì‹œ ì™„ë£Œ
                    stage = COMPLETE;
                }
                break;
                
            case COMPLETE:
                setChargeCurrent(0);
                break;
        }
    }
    
    float estimateChargeTime() {
        float remaining_capacity = (100 - current_soc) / 100.0 * battery_capacity;
        float avg_charge_rate = 0.8 * max_charge_current;  // íš¨ìœ¨ ê³ ë ¤
        return remaining_capacity / avg_charge_rate;  // ì‹œê°„
    }
};
```

## âš¡ DC-DC ì»¨ë²„í„° ê³ ê¸‰ ì„¤ê³„

### ë™ê¸°ì‹ Buck ì»¨ë²„í„° (ê³ íš¨ìœ¨)
```cpp
// ë™ê¸°ì‹ Buck ì»¨ë²„í„° ì œì–´ (95% íš¨ìœ¨ ë‹¬ì„±)
class SynchronousBuck {
private:
    float inductor_current = 0;
    float output_voltage = 0;
    bool ccm_mode = true;  // ì—°ì† ë„í†µ ëª¨ë“œ
    
public:
    void controlLoop() {
        // ì „ë¥˜ ì¸¡ì • (í™€ì„¼ì„œ ë˜ëŠ” ì…˜íŠ¸ì €í•­)
        inductor_current = readInductorCurrent();
        output_voltage = readOutputVoltage();
        
        // ì „ì•• ëª¨ë“œ ì œì–´
        float error = voltage_reference - output_voltage;
        float duty = pi_controller.update(error);
        
        // ì ì‘í˜• ë°ë“œíƒ€ì„ ì œì–´
        float deadtime = calculateOptimalDeadtime(inductor_current);
        
        // PWM ìƒì„± (ìƒë¶€/í•˜ë¶€ MOSFET)
        setPWM_HighSide(duty, deadtime);
        setPWM_LowSide(duty, deadtime);
        
        // ê²½ë¶€í•˜ì‹œ PFM ëª¨ë“œ ì „í™˜
        if(inductor_current < 0.1) {
            switchToPFMMode();
        }
    }
    
private:
    void switchToPFMMode() {
        // Pulse Frequency Modulation (ê²½ë¶€í•˜ ê³ íš¨ìœ¨)
        if(output_voltage < voltage_reference - 0.01) {
            generateSinglePulse();
        }
    }
};
```

### ë‹¤ì¤‘ ìœ„ìƒ ì»¨ë²„í„° (ê³ ì „ë¥˜)
```cpp
// 4ìƒ ì¸í„°ë¦¬ë¸Œë“œ Buck (ë¦¬í”Œ ì „ë¥˜ ê°ì†Œ)
class MultiphaseConverter {
private:
    static const int PHASES = 4;
    float phase_currents[PHASES];
    float phase_shift = 360.0 / PHASES;  // 90ë„ ìœ„ìƒì°¨
    
public:
    void interleaveControl() {
        float total_current = 0;
        
        for(int i = 0; i < PHASES; i++) {
            phase_currents[i] = readPhaseCurrent(i);
            total_current += phase_currents[i];
        }
        
        // ì „ë¥˜ ë°¸ëŸ°ì‹±
        float avg_current = total_current / PHASES;
        for(int i = 0; i < PHASES; i++) {
            float imbalance = phase_currents[i] - avg_current;
            adjustPhaseDuty(i, -imbalance * 0.1);  // ë¹„ë¡€ ë³´ì •
        }
        
        // ìƒë³„ PWM ìƒì„± (90ë„ ìœ„ìƒì°¨)
        float base_duty = calculateBaseDuty();
        for(int i = 0; i < PHASES; i++) {
            float phase_angle = i * phase_shift;
            setPhasePWM(i, base_duty, phase_angle);
        }
    }
    
    float getRippleCurrent() {
        // 4ìƒ ì¸í„°ë¦¬ë¸Œë“œë¡œ ë¦¬í”Œ ì „ë¥˜ 1/4 ê°ì†Œ
        return calculateRipple() / PHASES;
    }
};
```

### ì–‘ë°©í–¥ DC-DC ì»¨ë²„í„° (ì—ë„ˆì§€ íšŒìƒ)
```cpp
// ëª¨í„° ì œë™ì‹œ ì—ë„ˆì§€ íšŒìƒ
class BidirectionalConverter {
private:
    enum Mode { MOTORING, BRAKING, STANDBY };
    Mode operating_mode = STANDBY;
    
public:
    void energyManagement(float motor_torque, float motor_speed) {
        float mechanical_power = motor_torque * motor_speed;
        
        if(mechanical_power > 0) {
            // ëª¨í„°ë§ ëª¨ë“œ (ë°°í„°ë¦¬ â†’ ëª¨í„°)
            operating_mode = MOTORING;
            buckOperation();
        } else if(mechanical_power < -100) {  // 100W ì´ìƒ íšŒìƒ
            // ì œë™ ëª¨ë“œ (ëª¨í„° â†’ ë°°í„°ë¦¬)
            operating_mode = BRAKING;
            boostOperation();
        } else {
            operating_mode = STANDBY;
        }
    }
    
private:
    void buckOperation() {
        // ìŠ¤í…ë‹¤ìš´ ë™ì‘ (ë°°í„°ë¦¬ â†’ ëª¨í„°)
        float duty = calculateBuckDuty();
        setMOSFET_Q1(duty);
        setMOSFET_Q2(0);
    }
    
    void boostOperation() {
        // ìŠ¤í…ì—… ë™ì‘ (ëª¨í„° â†’ ë°°í„°ë¦¬)
        float duty = calculateBoostDuty();
        setMOSFET_Q1(0);
        setMOSFET_Q2(duty);
        
        // ë°°í„°ë¦¬ ê³¼ì¶©ì „ ë³´í˜¸
        if(battery_voltage > 4.2 * cell_count) {
            stopRegeneration();
        }
    }
};
```

## ğŸ”Œ ìŠ¤ë§ˆíŠ¸ ì „ì› ê´€ë¦¬

### ë™ì  ì „ë ¥ í• ë‹¹
```cpp
// ì‹œìŠ¤í…œ ìš°ì„ ìˆœìœ„ì— ë”°ë¥¸ ì „ë ¥ ë¶„ë°°
class PowerManager {
private:
    struct PowerDomain {
        String name;
        float current_power;
        float max_power;
        int priority;  // 1=ìµœê³  ìš°ì„ ìˆœìœ„
        bool enabled;
    };
    
    PowerDomain domains[5] = {
        {"ëª¨í„°", 0, 200, 1, true},
        {"ì„¼ì„œ", 0, 10, 2, true},  
        {"í†µì‹ ", 0, 5, 3, true},
        {"ì¡°ëª…", 0, 20, 4, true},
        {"ê¸°íƒ€", 0, 15, 5, true}
    };
    
public:
    void managePower(float available_power) {
        float total_demand = calculateTotalDemand();
        
        if(total_demand > available_power) {
            // ì „ë ¥ ë¶€ì¡±ì‹œ ìš°ì„ ìˆœìœ„ ê¸°ë°˜ í• ë‹¹
            priorityBasedAllocation(available_power);
        } else {
            // ì •ìƒ ë™ì‘
            normalOperation();
        }
    }
    
private:
    void priorityBasedAllocation(float budget) {
        // ìš°ì„ ìˆœìœ„ ìˆœìœ¼ë¡œ ì •ë ¬
        sortByPriority(domains, 5);
        
        float remaining = budget;
        for(int i = 0; i < 5; i++) {
            if(remaining >= domains[i].current_power) {
                domains[i].enabled = true;
                remaining -= domains[i].current_power;
            } else {
                domains[i].enabled = false;
                Serial.printf("%s ì „ì› ì°¨ë‹¨\n", domains[i].name.c_str());
            }
        }
    }
};
```

### ì˜ˆì¸¡ ì „ë ¥ ê´€ë¦¬
```cpp
// ë¯¸ì…˜ í”„ë¡œíŒŒì¼ ê¸°ë°˜ ì „ë ¥ ê³„íš
class PredictivePowerManager {
private:
    struct MissionSegment {
        float duration;     // êµ¬ê°„ ì‹œê°„ [s]
        float motor_power;  // ëª¨í„° ì†Œë¹„ì „ë ¥ [W]
        float sensor_power; // ì„¼ì„œ ì†Œë¹„ì „ë ¥ [W]
    };
    
    MissionSegment mission_profile[10];
    int profile_length = 0;
    
public:
    bool planMission(MissionSegment* profile, int length) {
        float total_energy = 0;
        
        // ì´ ì—ë„ˆì§€ ìš”êµ¬ëŸ‰ ê³„ì‚°
        for(int i = 0; i < length; i++) {
            total_energy += (profile[i].motor_power + profile[i].sensor_power) 
                           * profile[i].duration / 3600.0;  // Wh
        }
        
        float available_energy = battery_capacity * battery_voltage * soc / 100.0;
        
        if(total_energy * 1.2 > available_energy) {  // 20% ì•ˆì „ë§ˆì§„
            Serial.printf("ì—ë„ˆì§€ ë¶€ì¡±: í•„ìš”=%0.1fWh, ê°€ìš©=%0.1fWh\n", 
                         total_energy, available_energy);
            return false;
        }
        
        // ë¯¸ì…˜ í”„ë¡œíŒŒì¼ ì €ì¥
        memcpy(mission_profile, profile, sizeof(MissionSegment) * length);
        profile_length = length;
        return true;
    }
    
    void adaptToReality(float actual_power) {
        static float predicted_power = 0;
        
        // ì˜ˆì¸¡ê³¼ ì‹¤ì œ ì°¨ì´ í•™ìŠµ
        float error = actual_power - predicted_power;
        
        // ë‚˜ë¨¸ì§€ êµ¬ê°„ ì „ë ¥ ì†Œë¹„ ë³´ì •
        for(int i = current_segment; i < profile_length; i++) {
            mission_profile[i].motor_power += error * 0.1;  // 10% ë³´ì •
        }
    }
};
```

## ğŸ›¡ï¸ ì „ìê¸° í˜¸í™˜ì„± (EMC) ì„¤ê³„

### ì „ì› í•„í„° ì„¤ê³„
```cpp
// ë‹¤ë‹¨ê³„ EMI í•„í„°
class EMIFilter {
private:
    float common_mode_current = 0;
    float differential_mode_current = 0;
    
public:
    void measureEMI() {
        // ê³µí†µëª¨ë“œ ì „ë¥˜ ì¸¡ì • (CTë¥¼ ì´ìš©í•œ í™€ì„¼ì„œ)
        common_mode_current = readCommonModeCurrent();
        
        // ì°¨ë™ëª¨ë“œ ì „ë¥˜ ì¸¡ì •
        differential_mode_current = readDifferentialCurrent();
        
        // EMI ê¸°ì¤€ ì´ˆê³¼ì‹œ ê²½ê³ 
        if(common_mode_current > 1.0) {  // 1A ê¸°ì¤€
            Serial.println("ê³µí†µëª¨ë“œ EMI ì´ˆê³¼");
        }
    }
    
    void optimizeFilterDesign(float switching_freq) {
        // ìŠ¤ìœ„ì¹­ ì£¼íŒŒìˆ˜ì˜ 10ë°°ì—ì„œ 40dB ê°ì‡  ëª©í‘œ
        float target_freq = switching_freq * 10;
        
        // LC í•„í„° ì„¤ê³„
        float L_cm = 1e-3;  // 1mH ê³µí†µëª¨ë“œ ì´ˆí¬
        float C_dm = calculateDifferentialCapacitor(target_freq, L_cm);
        
        Serial.printf("ê¶Œì¥ ì°¨ë™ëª¨ë“œ ì»¤íŒ¨ì‹œí„°: %.1fuF\n", C_dm * 1e6);
    }
    
private:
    float calculateDifferentialCapacitor(float f, float L) {
        // fc = 1/(2Ï€âˆšLC)ì—ì„œ C ê³„ì‚°
        return 1.0 / (4 * PI * PI * f * f * L);
    }
};
```