# 기하자코비안 (Geometric Jacobian)

> 상위: [[자코비안분석]] | 기본: [[자코비안]] | 대비: [[해석자코비안]]

기하학적 직관을 바탕으로 유도된 자코비안으로, 각 관절이 말단 장치의 속도에 미치는 기하학적 기여도를 직접적으로 나타냅니다.

## 🎯 기본 개념

### 정의
기하자코비안은 관절의 회전축과 위치 벡터를 이용하여 직접적으로 계산되는 자코비안입니다.

```
V = J_g(θ) θ̇
```

여기서:
- V = [v; ω]: 말단 장치의 트위스트 벡터
- J_g(θ): 기하자코비안 (6×n)
- θ̇: 관절 속도 벡터 (n×1)

### 물리적 의미
각 열은 해당 관절의 단위 각속도가 말단 장치에 미치는 순간적인 기하학적 효과를 나타냅니다.

## 📐 계산 방법

### 회전 관절 (Revolute Joint)
i번째 회전 관절에 대해:

```
J_vi = zi-1 × (pn - pi-1)
J_ωi = zi-1
```

여기서:
- zi-1: (i-1)번째 좌표계의 z축 방향 벡터
- pn: 말단 장치의 위치 벡터
- pi-1: (i-1)번째 관절의 위치 벡터

### 직진 관절 (Prismatic Joint)
i번째 직진 관절에 대해:

```
J_vi = zi-1
J_ωi = 0
```

### 전체 자코비안 구성
```
J_g = [J_v1  J_v2  ...  J_vn]
      [J_ω1  J_ω2  ...  J_ωn]
```

## 🔧 단계별 계산 과정

### 1단계: 좌표계 설정
DH 매개변수 또는 POE 방법으로 각 링크 좌표계 정의

### 2단계: 변환 행렬 계산
각 관절에 대한 변환 행렬 Ti 계산

### 3단계: z축 벡터 추출
```
zi = Ri+1 * [0; 0; 1]  (i번째 관절의 회전축)
```

### 4단계: 위치 벡터 계산
```
pi = Ti의 위치 부분
```

### 5단계: 자코비안 열 계산
각 관절 유형에 따라 위의 공식 적용

## 📊 계산 예제

### 2R 평면 매니퓰레이터
2개의 회전 관절을 가진 평면 로봇:

#### 좌표계 정의
- 관절 1: 기준점에서 회전
- 관절 2: L1 거리에서 회전

#### 기하자코비안
```
J_g = [(-L1*sin(θ1) - L2*sin(θ1+θ2))  (-L2*sin(θ1+θ2))]
      [(L1*cos(θ1) + L2*cos(θ1+θ2))   (L2*cos(θ1+θ2)) ]
      [0                               0               ]
      [0                               0               ]
      [0                               0               ]
      [1                               1               ]
```

### 3R 공간 매니퓰레이터
3개의 회전 관절을 가진 공간 로봇의 경우:

#### z축 벡터들
```
z0 = [0; 0; 1]
z1 = [sin(θ1); -cos(θ1); 0]
z2 = [sin(θ1); -cos(θ1)*cos(θ2); cos(θ1)*sin(θ2)]
```

#### 위치 벡터들
```
p0 = [0; 0; 0]
p1 = [L1*cos(θ1); L1*sin(θ1); 0]
p2 = [L1*cos(θ1) + L2*cos(θ1)*cos(θ2); ...]
```

## ⚙️ 계산 알고리즘

### MATLAB/Python 구현
```matlab
function J_g = geometric_jacobian(DH_params, theta)
    % DH_params: DH 매개변수 [a, alpha, d, theta]
    % theta: 현재 관절 각도
    
    n = size(DH_params, 1);
    J_g = zeros(6, n);
    
    % 변환 행렬들 계산
    T = eye(4);
    T_list = zeros(4, 4, n+1);
    T_list(:,:,1) = T;
    
    for i = 1:n
        T_i = dh_transform(DH_params(i,:), theta(i));
        T = T * T_i;
        T_list(:,:,i+1) = T;
    end
    
    % 말단 장치 위치
    p_n = T(1:3, 4);
    
    % 각 관절에 대해 자코비안 계산
    for i = 1:n
        % z축과 위치 벡터
        z_i = T_list(1:3, 3, i);
        p_i = T_list(1:3, 4, i);
        
        % 자코비안 열 계산
        if is_revolute(i)
            J_g(1:3, i) = cross(z_i, p_n - p_i);
            J_g(4:6, i) = z_i;
        else  % prismatic
            J_g(1:3, i) = z_i;
            J_g(4:6, i) = [0; 0; 0];
        end
    end
end
```

## 🎯 특성 및 장점

### 직관적 이해
- 기하학적 의미가 명확
- 시각적으로 이해하기 쉬움
- 디버깅이 용이함

### 계산 효율성
- 복잡한 미분 계산 불필요
- 실시간 계산에 적합
- 수치적으로 안정적

### 범용성
- 모든 유형의 관절에 적용 가능
- DH 매개변수와 직접 연결
- 기존 로봇 모델과 호환성 우수

## ⚠️ 주의사항

### 좌표계 의존성
계산 결과는 선택한 기준 좌표계에 의존합니다.

### 특이점에서의 문제
```
rank(J_g) < 6  (특이점에서)
```

### 수치적 정확도
부동소수점 연산에 의한 오차 누적 가능

## 🔍 검증 방법

### 미분을 통한 검증
순기구학 방정식의 시간 미분과 비교:
```
d/dt T(θ) = J_g(θ) θ̇
```

### 스크류 이론과의 비교
공간자코비안 또는 물체자코비안과의 일치성 확인

## 📚 참고 문헌

### 주요 교과서
1. **Craig, J. J. (2005)**. *Introduction to Robotics: Mechanics and Control* (4th ed.). Pearson.
   - Chapter 5: Velocities, Static Forces, and Jacobians
   - 기하학적 접근법의 전형적 예시

2. **Spong, M. W., Hutchinson, S., & Vidyasagar, M. (2020)**. *Robot Modeling and Control* (2nd ed.). Wiley.
   - Chapter 4: Velocity Kinematics - The Jacobian
   - 기하학적 해석과 응용

3. **Siciliano, B., Sciavicco, L., Villani, L., & Oriolo, G. (2010)**. *Robotics: Modelling, Planning and Control*. Springer.
   - Chapter 3: Differential Kinematics
   - 유럽식 접근법

### 비교 연구
- **Lynch, K. M., & Park, F. C. (2017)**. *Modern Robotics*에서 스크류 이론과의 비교
- **Paul, R. P. (1981)**. *Robot Manipulators*에서 전통적 접근법

### 소프트웨어 도구
- [Robotics Toolbox for MATLAB](https://petercorke.com/toolboxes/robotics-toolbox/)
- [RigidBodyDynamics.jl](https://github.com/JuliaRobotics/RigidBodyDynamics.jl)

---

## 🔗 연결 문서
- 상위: [[자코비안분석]]
- 기본: [[자코비안]]
- 비교: [[해석자코비안]], [[공간자코비안]], [[물체자코비안]]
- 기초: [[위치기구학]], [[회전표현]]
- 응용: [[속도기구학]], [[특이점분석]]